class Generator {
  static GenAutoIncrementId() {
    return Generator.auto_increment_id++;
  }
}
Generator.auto_increment_id = 0;

class ContainerModule {
  constructor(registry) {
    this.id = Generator.GenAutoIncrementId(), this.registry = registry;
  }
}

const NAMED_TAG = "named";
const INJECT_TAG = "inject";
const MULTI_INJECT_TAG = "multi_inject";
const TAGGED = "inversify:tagged";
const PARAM_TYPES = "inversify:paramtypes";

class Metadata {
  constructor(key, value) {
    this.key = key, this.value = value;
  }
  toString() {
    return this.key === NAMED_TAG ? `named: ${String(this.value).toString()} ` : `tagged: { key:${this.key.toString()}, value: ${String(this.value)} }`;
  }
}

var Reflect$1 = (function (Reflect) {
  var target;
  return function (exporter) {
    const supportsSymbol = "function" == typeof Symbol,
      toPrimitiveSymbol = supportsSymbol && void 0 !== Symbol.toPrimitive ? Symbol.toPrimitive : "@@toPrimitive",
      functionPrototype = (Object.getPrototypeOf(Function)),
      _Map = ("object" == typeof process && process.env && process.env.REFLECT_METADATA_USE_MAP_POLYFILL, Map),
      Metadata = (new WeakMap());
    function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
    }
    function hasMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasMetadata(metadataKey, target, propertyKey);
    }
    function hasOwnMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
    }
    function getMetadata(metadataKey, target, propertyKey) {
      if (!IsObject(target)) throw new TypeError();
      return IsUndefined(propertyKey) || (propertyKey = ToPropertyKey(propertyKey)), OrdinaryGetMetadata(metadataKey, target, propertyKey);
    }
    function GetOrCreateMetadataMap(O, P, Create) {
      let targetMetadata = Metadata.get(O);
      if (IsUndefined(targetMetadata)) {
        if (!Create) return;
        targetMetadata = new _Map(), Metadata.set(O, targetMetadata);
      }
      let metadataMap = targetMetadata.get(P);
      if (IsUndefined(metadataMap)) {
        if (!Create) return;
        metadataMap = new _Map(), targetMetadata.set(P, metadataMap);
      }
      return metadataMap;
    }
    function OrdinaryHasMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return !0;
      const parent = OrdinaryGetPrototypeOf(O);
      return !IsNull(parent) && OrdinaryHasMetadata(MetadataKey, parent, P);
    }
    function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, !1);
      return !IsUndefined(metadataMap) && ToBoolean(metadataMap.has(MetadataKey));
    }
    function OrdinaryGetMetadata(MetadataKey, O, P) {
      if (OrdinaryHasOwnMetadata(MetadataKey, O, P)) return OrdinaryGetOwnMetadata(MetadataKey, O, P);
      const parent = OrdinaryGetPrototypeOf(O);
      return IsNull(parent) ? void 0 : OrdinaryGetMetadata(MetadataKey, parent, P);
    }
    function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
      const metadataMap = GetOrCreateMetadataMap(O, P, !1);
      if (!IsUndefined(metadataMap)) return metadataMap.get(MetadataKey);
    }
    function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
      GetOrCreateMetadataMap(O, P, !0).set(MetadataKey, MetadataValue);
    }
    function Type(x) {
      if (null === x) return 1;
      switch (typeof x) {
        case "undefined":
          return 0;
        case "boolean":
          return 2;
        case "string":
          return 3;
        case "symbol":
          return 4;
        case "number":
          return 5;
        case "object":
          return null === x ? 1 : 6;
        default:
          return 6;
      }
    }
    function IsUndefined(x) {
      return void 0 === x;
    }
    function IsNull(x) {
      return null === x;
    }
    function IsSymbol(x) {
      return "symbol" == typeof x;
    }
    function IsObject(x) {
      return "object" == typeof x ? null !== x : "function" == typeof x;
    }
    function ToPrimitive(input, PreferredType) {
      switch (Type(input)) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          return input;
      }
      const hint = 3 === PreferredType ? "string" : 5 === PreferredType ? "number" : "default",
        exoticToPrim = GetMethod(input, toPrimitiveSymbol);
      if (void 0 !== exoticToPrim) {
        const result = exoticToPrim.call(input, hint);
        if (IsObject(result)) throw new TypeError();
        return result;
      }
      return OrdinaryToPrimitive(input, "default" === hint ? "number" : hint);
    }
    function OrdinaryToPrimitive(O, hint) {
      if ("string" === hint) {
        const toString_1 = O.toString;
        if (IsCallable(toString_1)) {
          const result = toString_1.call(O);
          if (!IsObject(result)) return result;
        }
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result = valueOf.call(O);
          if (!IsObject(result)) return result;
        }
      } else {
        const valueOf = O.valueOf;
        if (IsCallable(valueOf)) {
          const result = valueOf.call(O);
          if (!IsObject(result)) return result;
        }
        const toString_2 = O.toString;
        if (IsCallable(toString_2)) {
          const result = toString_2.call(O);
          if (!IsObject(result)) return result;
        }
      }
      throw new TypeError();
    }
    function ToBoolean(argument) {
      return !!argument;
    }
    function ToString(argument) {
      return "" + argument;
    }
    function ToPropertyKey(argument) {
      const key = ToPrimitive(argument, 3);
      return IsSymbol(key) ? key : ToString(key);
    }
    function IsCallable(argument) {
      return "function" == typeof argument;
    }
    function GetMethod(V, P) {
      const func = V[P];
      if (null != func) {
        if (!IsCallable(func)) throw new TypeError();
        return func;
      }
    }
    function OrdinaryGetPrototypeOf(O) {
      const proto = Object.getPrototypeOf(O);
      if ("function" != typeof O || O === functionPrototype) return proto;
      if (proto !== functionPrototype) return proto;
      const prototype = O.prototype,
        prototypeProto = prototype && Object.getPrototypeOf(prototype);
      if (null == prototypeProto || prototypeProto === Object.prototype) return proto;
      const constructor = prototypeProto.constructor;
      return "function" != typeof constructor || constructor === O ? proto : constructor;
    }
    exporter("defineMetadata", defineMetadata), exporter("hasMetadata", hasMetadata), exporter("hasOwnMetadata", hasOwnMetadata), exporter("getMetadata", getMetadata);
  }((target = Reflect, function (key, value) {
    "function" != typeof target[key] && Object.defineProperty(target, key, {
      configurable: !0,
      writable: !0,
      value: value
    });
  })), Reflect;
})({});

function _tagParameterOrProperty(metadataKey, annotationTarget, key, metadata) {
  const metadatas = [metadata];
  let paramsOrPropertiesMetadata = {};
  Reflect$1.hasOwnMetadata(metadataKey, annotationTarget) && (paramsOrPropertiesMetadata = Reflect$1.getMetadata(metadataKey, annotationTarget));
  let paramOrPropertyMetadata = paramsOrPropertiesMetadata[key];
  void 0 === paramOrPropertyMetadata && (paramOrPropertyMetadata = []), paramOrPropertyMetadata.push(...metadatas), paramsOrPropertiesMetadata[key] = paramOrPropertyMetadata, Reflect$1.defineMetadata(metadataKey, paramsOrPropertiesMetadata, annotationTarget);
}
function tagParameter(annotationTarget, parameterName, parameterIndex, metadata) {
  _tagParameterOrProperty(TAGGED, annotationTarget, parameterIndex.toString(), metadata);
}
function createTaggedDecorator(metadata) {
  return (target, targetKey, indexOrPropertyDescriptor) => {
    tagParameter(target, targetKey, indexOrPropertyDescriptor, metadata);
  };
}
function injectBase(metadataKey) {
  return serviceIdentifier => (target, targetKey, indexOrPropertyDescriptor) => createTaggedDecorator(new Metadata(metadataKey, serviceIdentifier))(target, targetKey, indexOrPropertyDescriptor);
}

const inject = injectBase(INJECT_TAG);

const multiInject = injectBase(MULTI_INJECT_TAG);

function injectable() {
  return function (target) {
    return Reflect$1.defineMetadata(PARAM_TYPES, null, target), target;
  };
}

function named(name) {
  return createTaggedDecorator(new Metadata(NAMED_TAG, name));
}

const BindingScopeEnum = {
    Singleton: "Singleton",
    Transient: "Transient"
  },
  BindingTypeEnum = {
    ConstantValue: "ConstantValue",
    Constructor: "Constructor",
    DynamicValue: "DynamicValue",
    Factory: "Factory",
    Function: "Function",
    Instance: "Instance",
    Invalid: "Invalid",
    Provider: "Provider"
  };

class Binding {
  constructor(serviceIdentifier, scope) {
    this.id = Generator.GenAutoIncrementId(), this.activated = !1, this.serviceIdentifier = serviceIdentifier, this.scope = scope, this.type = BindingTypeEnum.Invalid, this.constraint = request => !0, this.implementationType = null, this.cache = null, this.factory = null, this.provider = null, this.dynamicValue = null;
  }
  clone() {
    const clone = new Binding(this.serviceIdentifier, this.scope);
    return clone.activated = clone.scope === BindingScopeEnum.Singleton && this.activated, clone.implementationType = this.implementationType, clone.dynamicValue = this.dynamicValue, clone.scope = this.scope, clone.type = this.type, clone.provider = this.provider, clone.constraint = this.constraint, clone.cache = this.cache, clone;
  }
}

class MetadataReader {
  getConstructorMetadata(constructorFunc) {
    return {
      compilerGeneratedMetadata: Reflect$1.getMetadata(PARAM_TYPES, constructorFunc),
      userGeneratedMetadata: Reflect$1.getMetadata(TAGGED, constructorFunc) || {}
    };
  }
  getPropertiesMetadata(constructorFunc) {
    throw new Error("暂未实现");
  }
}

const taggedConstraint = key => value => {
  const constraint = request => {
    if (null == request) return !1;
    if (request.key === key && request.value === value) return !0;
    if (null == request.constructorArgsMetadata) return !1;
    const constructorArgsMetadata = request.constructorArgsMetadata;
    for (let i = 0; i < constructorArgsMetadata.length; i++) if (constructorArgsMetadata[i].key === key && constructorArgsMetadata[i].value === value) return !0;
    return !1;
  };
  return constraint.metaData = new Metadata(key, value), constraint;
};
const namedConstraint = taggedConstraint(NAMED_TAG);

class BindingInSyntax {
  constructor(binding) {
    this._binding = binding;
  }
  inRequestScope() {
    throw new Error("暂未实现");
  }
  inSingletonScope() {
    return this._binding.scope = BindingScopeEnum.Singleton, this;
  }
  inTransientScope() {
    return this._binding.scope = BindingScopeEnum.Transient, this;
  }
  whenTargetNamed(name) {
    return this._binding.constraint = namedConstraint(name), this;
  }
}

class BindingToSyntax {
  constructor(binding) {
    this._binding = binding;
  }
  to(constructor) {
    return this._binding.type = BindingTypeEnum.Instance, this._binding.implementationType = constructor, new BindingInSyntax(this._binding);
  }
  toSelf() {
    const self = this._binding.serviceIdentifier;
    return this.to(self);
  }
  toDynamicValue(func) {
    return this._binding.type = BindingTypeEnum.DynamicValue, this._binding.cache = null, this._binding.dynamicValue = func, this._binding.implementationType = null, new BindingInSyntax(this._binding);
  }
  toConstantValue(value) {
    return this._binding.type = BindingTypeEnum.ConstantValue, this._binding.cache = value, this._binding.dynamicValue = null, this._binding.implementationType = null, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toFactory(factory) {
    return this._binding.type = BindingTypeEnum.Factory, this._binding.factory = factory, this._binding.scope = BindingScopeEnum.Singleton, new BindingInSyntax(this._binding);
  }
  toService(service) {
    this.toDynamicValue(context => context.container.get(service));
  }
}

class Container {
  constructor(containerOptions) {
    const options = containerOptions || {};
    options.defaultScope = options.defaultScope || BindingScopeEnum.Transient, this.options = options, this.id = Generator.GenAutoIncrementId(), this._bindingDictionary = new Map(), this._metadataReader = new MetadataReader();
  }
  load(module) {
    const containerModuleHelpers = this._getContainerModuleHelpersFactory()(module.id);
    module.registry(containerModuleHelpers.bindFunction, containerModuleHelpers.unbindFunction, containerModuleHelpers.isboundFunction, containerModuleHelpers.rebindFunction);
  }
  get(serviceIdentifier) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, !1);
    return this._get(getArgs);
  }
  getAll(serviceIdentifier) {
    const getArgs = this._getAllArgs(serviceIdentifier);
    return this._get(getArgs);
  }
  getTagged(serviceIdentifier, key, value) {
    const getArgs = this._getNotAllArgs(serviceIdentifier, !1, key, value);
    return this._get(getArgs);
  }
  getNamed(serviceIdentifier, named) {
    return this.getTagged(serviceIdentifier, NAMED_TAG, named);
  }
  isBound(serviceIdentifier) {
    return this._bindingDictionary.has(serviceIdentifier);
  }
  bind(serviceIdentifier) {
    const scope = this.options.defaultScope,
      binding = new Binding(serviceIdentifier, scope),
      list = this._bindingDictionary.get(serviceIdentifier) || [];
    return list.push(binding), this._bindingDictionary.set(serviceIdentifier, list), new BindingToSyntax(binding);
  }
  unbind(serviceIdentifier) {
    this._bindingDictionary.delete(serviceIdentifier);
  }
  rebind(serviceIdentifier) {
    return this.unbind(serviceIdentifier), this.bind(serviceIdentifier);
  }
  _getContainerModuleHelpersFactory() {
    const setModuleId = (bindingToSyntax, moduleId) => {
        bindingToSyntax._binding.moduleId = moduleId;
      },
      getBindFunction = moduleId => serviceIdentifier => {
        const bindingToSyntax = this.bind(serviceIdentifier);
        return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
      },
      getUnbindFunction = () => serviceIdentifier => this.unbind(serviceIdentifier),
      getIsboundFunction = () => serviceIdentifier => this.isBound(serviceIdentifier),
      getRebindFunction = moduleId => serviceIdentifier => {
        const bindingToSyntax = this.rebind(serviceIdentifier);
        return setModuleId(bindingToSyntax, moduleId), bindingToSyntax;
      };
    return mId => ({
      bindFunction: getBindFunction(mId),
      isboundFunction: getIsboundFunction(),
      rebindFunction: getRebindFunction(mId),
      unbindFunction: getUnbindFunction(),
      unbindAsyncFunction: serviceIdentifier => null
    });
  }
  _getNotAllArgs(serviceIdentifier, isMultiInject, key, value) {
    return {
      avoidConstraints: !1,
      isMultiInject: isMultiInject,
      serviceIdentifier: serviceIdentifier,
      key: key,
      value: value
    };
  }
  _getAllArgs(serviceIdentifier) {
    return {
      avoidConstraints: !0,
      isMultiInject: !0,
      serviceIdentifier: serviceIdentifier
    };
  }
  _get(getArgs) {
    const result = [];
    return this._bindingDictionary.get(getArgs.serviceIdentifier).filter(b => b.constraint(getArgs)).forEach(binding => {
      result.push(this._resolveFromBinding(binding));
    }), getArgs.isMultiInject || 1 !== result.length ? result : result[0];
  }
  _getChildRequest(binding) {
    const constr = binding.implementationType,
      {
        userGeneratedMetadata: userGeneratedMetadata
      } = this._metadataReader.getConstructorMetadata(constr),
      keys = Object.keys(userGeneratedMetadata),
      arr = [];
    for (let i = 0; i < keys.length; i++) {
      const constructorArgsMetadata = userGeneratedMetadata[i],
        targetMetadataMap = {};
      constructorArgsMetadata.forEach(md => {
        targetMetadataMap[md.key] = md.value;
      });
      const metadata = {
          inject: targetMetadataMap[INJECT_TAG],
          multiInject: targetMetadataMap[MULTI_INJECT_TAG]
        },
        injectIdentifier = metadata.inject || metadata.multiInject,
        target = {
          serviceIdentifier: injectIdentifier,
          constructorArgsMetadata: constructorArgsMetadata
        },
        bindings = (this._bindingDictionary.get(injectIdentifier) || []).filter(b => b.constraint(target));
      if (bindings.length) {
        const request = {
          injectIdentifier: injectIdentifier,
          metadata: constructorArgsMetadata,
          bindings: bindings
        };
        arr.push(request);
      }
    }
    return arr;
  }
  _resolveFromBinding(binding) {
    const result = this._getResolvedFromBinding(binding);
    return this._saveToScope(binding, result), result;
  }
  _getResolvedFromBinding(binding) {
    let result;
    switch (binding.type) {
      case BindingTypeEnum.ConstantValue:
      case BindingTypeEnum.Function:
        result = binding.cache;
        break;
      case BindingTypeEnum.Instance:
        result = this._resolveInstance(binding, binding.implementationType);
        break;
      default:
        result = binding.dynamicValue({
          container: this
        });
    }
    return result;
  }
  _resolveInstance(binding, constr) {
    if (binding.activated) return binding.cache;
    const childRequests = this._getChildRequest(binding);
    return this._createInstance(constr, childRequests);
  }
  _createInstance(constr, childRequests) {
    if (childRequests.length) {
      return new constr(...this._resolveRequests(childRequests));
    }
    return new constr();
  }
  _resolveRequests(childRequests) {
    return childRequests.map(request => request.bindings.length > 1 ? request.bindings.map(binding => this._resolveFromBinding(binding)) : this._resolveFromBinding(request.bindings[0]));
  }
  _saveToScope(binding, result) {
    binding.scope === BindingScopeEnum.Singleton && (binding.cache = result, binding.activated = !0);
  }
}

const ContributionProvider = Symbol("ContributionProvider");
class ContributionProviderCache {
  constructor(serviceIdentifier, container) {
    this.serviceIdentifier = serviceIdentifier, this.container = container;
  }
  getContributions() {
    return this.caches || (this.caches = [], this.container && this.container.isBound(this.serviceIdentifier) && this.caches.push(...this.container.getAll(this.serviceIdentifier))), this.caches;
  }
}
function bindContributionProvider(bind, id) {
  bind(ContributionProvider).toDynamicValue(_ref => {
    let {
      container: container
    } = _ref;
    return new ContributionProviderCache(id, container);
  }).inSingletonScope().whenTargetNamed(id);
}
function bindContributionProviderNoSingletonScope(bind, id) {
  bind(ContributionProvider).toDynamicValue(_ref2 => {
    let {
      container: container
    } = _ref2;
    return new ContributionProviderCache(id, container);
  }).whenTargetNamed(id);
}

class Hook {
  constructor(args, name) {
    this._args = args, this.name = name, this.taps = [];
  }
  tap(options, fn) {
    this._tap("sync", options, fn);
  }
  unTap(options, fn) {
    const name = "string" == typeof options ? options.trim() : options.name;
    name && (this.taps = this.taps.filter(tap => !(tap.name === name && (!fn || tap.fn === fn))));
  }
  _parseOptions(type, options, fn) {
    let _options;
    if ("string" == typeof options) _options = {
      name: options.trim()
    };else if ("object" != typeof options || null === options) throw new Error("Invalid tap options");
    if ("string" != typeof _options.name || "" === _options.name) throw new Error("Missing name for tap");
    return _options = Object.assign({
      type: type,
      fn: fn
    }, _options), _options;
  }
  _tap(type, options, fn) {
    this._insert(this._parseOptions(type, options, fn));
  }
  _insert(item) {
    let before;
    "string" == typeof item.before ? before = new Set([item.before]) : Array.isArray(item.before) && (before = new Set(item.before));
    let stage = 0;
    "number" == typeof item.stage && (stage = item.stage);
    let i = this.taps.length;
    for (; i > 0;) {
      i--;
      const x = this.taps[i];
      this.taps[i + 1] = x;
      const xStage = x.stage || 0;
      if (before) {
        if (before.has(x.name)) {
          before.delete(x.name);
          continue;
        }
        if (before.size > 0) continue;
      }
      if (!(xStage > stage)) {
        i++;
        break;
      }
    }
    this.taps[i] = item;
  }
}

class SyncHook extends Hook {
  call() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this.taps.map(t => t.fn).forEach(cb => cb(...args));
  }
}

const EnvContribution = Symbol.for("EnvContribution");
const VGlobal = Symbol.for("VGlobal");
const DEFAULT_TEXT_FONT_FAMILY = "PingFang SC,Helvetica Neue,Microsoft Yahei,system-ui,-apple-system,segoe ui,Roboto,Helvetica,Arial,sans-serif,apple color emoji,segoe ui emoji,segoe ui symbol";

var __decorate$1L = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1k = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$W = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  },
  __awaiter$8 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
let DefaultGlobal = class {
  get env() {
    return this._env;
  }
  get isImageAnonymous() {
    return this._isImageAnonymous;
  }
  set isImageAnonymous(isImageAnonymous) {
    this._isImageAnonymous = isImageAnonymous;
  }
  get devicePixelRatio() {
    return this._env || this.setEnv("browser"), this.envContribution.getDevicePixelRatio();
  }
  get supportEvent() {
    return this._env || this.setEnv("browser"), this.envContribution.supportEvent;
  }
  set supportEvent(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportEvent = support;
  }
  get supportsTouchEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents;
  }
  set supportsTouchEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsTouchEvents = support;
  }
  get supportsPointerEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents;
  }
  set supportsPointerEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsPointerEvents = support;
  }
  get supportsMouseEvents() {
    return this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents;
  }
  set supportsMouseEvents(support) {
    this._env || this.setEnv("browser"), this.envContribution.supportsMouseEvents = support;
  }
  get applyStyles() {
    return this._env || this.setEnv("browser"), this.envContribution.applyStyles;
  }
  set applyStyles(support) {
    this._env || this.setEnv("browser"), this.envContribution.applyStyles = support;
  }
  constructor(contributions) {
    this.contributions = contributions, this._isImageAnonymous = !0, this.id = Generator.GenAutoIncrementId(), this.hooks = {
      onSetEnv: new SyncHook(["lastEnv", "env", "global"])
    }, this.measureTextMethod = "native", this.optimizeVisible = !1;
  }
  bindContribution(params) {
    const promiseArr = [];
    if (this.contributions.getContributions().forEach(contribution => {
      const data = contribution.configure(this, params);
      data && data.then && promiseArr.push(data);
    }), promiseArr.length) return Promise.all(promiseArr);
  }
  getDynamicCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getDynamicCanvasCount();
  }
  getStaticCanvasCount() {
    return this._env || this.setEnv("browser"), this.envContribution.getStaticCanvasCount();
  }
  setEnv(env, params) {
    if (params && !0 === params.force || this._env !== env) return this.deactiveCurrentEnv(), this.activeEnv(env, params);
  }
  deactiveCurrentEnv() {
    this.envContribution && this.envContribution.release();
  }
  activeEnv(env, params) {
    const lastEnv = this._env;
    this._env = env;
    const data = this.bindContribution(params);
    if (data && data.then) return data.then(() => {
      this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);
    });
    this.envParams = params, this.hooks.onSetEnv.call(lastEnv, env, this);
  }
  setActiveEnvContribution(contribution) {
    this.envContribution = contribution;
  }
  createCanvas(params) {
    return this._env || this.setEnv("browser"), this.envContribution.createCanvas(params);
  }
  createOffscreenCanvas(params) {
    return this._env || this.setEnv("browser"), this.envContribution.createOffscreenCanvas(params);
  }
  releaseCanvas(canvas) {
    return this._env || this.setEnv("browser"), this.envContribution.releaseCanvas(canvas);
  }
  addEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this._env || this.setEnv("browser"), this.envContribution.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._env || this.setEnv("browser"), this.envContribution.dispatchEvent(event);
  }
  getRequestAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getRequestAnimationFrame();
  }
  getCancelAnimationFrame() {
    return this._env || this.setEnv("browser"), this.envContribution.getCancelAnimationFrame();
  }
  getElementById(str) {
    return this._env || this.setEnv("browser"), this.envContribution.getElementById ? this.envContribution.getElementById(str) : null;
  }
  getRootElement() {
    return this._env || this.setEnv("browser"), this.envContribution.getRootElement ? this.envContribution.getRootElement() : null;
  }
  getDocument() {
    return this._env || this.setEnv("browser"), this.envContribution.getDocument ? this.envContribution.getDocument() : null;
  }
  mapToCanvasPoint(event, domElement) {
    return this._env || this.setEnv("browser"), this.envContribution.mapToCanvasPoint ? this.envContribution.mapToCanvasPoint(event, domElement) : null;
  }
  loadImage(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadImage(url);
  }
  loadSvg(str) {
    return this._env || this.setEnv("browser"), this.envContribution.loadSvg(str);
  }
  loadJson(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadJson(url);
  }
  loadArrayBuffer(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadArrayBuffer(url);
  }
  loadBlob(url) {
    return this._env || this.setEnv("browser"), this.envContribution.loadBlob(url);
  }
  loadFont(name, source, descriptors) {
    return __awaiter$8(this, void 0, void 0, function* () {
      return this._env || this.setEnv("browser"), this.envContribution.loadFont(name, source, descriptors);
    });
  }
  isChrome() {
    return null != this._isChrome || (this._env || this.setEnv("browser"), this._isChrome = "browser" === this._env && navigator.userAgent.indexOf("Chrome") > -1), this._isChrome;
  }
  isSafari() {
    return null != this._isSafari || (this._env || this.setEnv("browser"), this._isSafari = "browser" === this._env && /Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent)), this._isSafari;
  }
  getNativeAABBBounds(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.getNativeAABBBounds(dom);
  }
  removeDom(dom) {
    return this._env || this.setEnv("browser"), this.envContribution.removeDom(dom);
  }
  createDom(params) {
    return this._env || this.setEnv("browser"), this.envContribution.createDom(params);
  }
  updateDom(dom, params) {
    return this._env || this.setEnv("browser"), this.envContribution.updateDom(dom, params);
  }
  getElementTop(dom) {
    let baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return this._env || this.setEnv("browser"), this.envContribution.getElementTop(dom, baseWindow);
  }
  getElementLeft(dom) {
    let baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return this._env || this.setEnv("browser"), this.envContribution.getElementLeft(dom, baseWindow);
  }
  getElementTopLeft(dom) {
    let baseWindow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return this._env || this.setEnv("browser"), this.envContribution.getElementTopLeft(dom, baseWindow);
  }
  isMacOS() {
    return this._env || this.setEnv("browser"), this.envContribution.isMacOS();
  }
  copyToClipBoard(text) {
    return this._env || this.setEnv("browser"), this.envContribution.copyToClipBoard(text);
  }
};
DefaultGlobal = __decorate$1L([injectable(), __param$W(0, inject(ContributionProvider)), __param$W(0, named(EnvContribution)), __metadata$1k("design:paramtypes", [Object])], DefaultGlobal);

var MeasureModeEnum;
!function (MeasureModeEnum) {
  MeasureModeEnum[MeasureModeEnum.estimate = 0] = "estimate", MeasureModeEnum[MeasureModeEnum.actualBounding = 1] = "actualBounding", MeasureModeEnum[MeasureModeEnum.fontBounding = 2] = "fontBounding";
}(MeasureModeEnum || (MeasureModeEnum = {}));

const strCommandMap = ["arc", "arcTo", "bezierCurveTo", "closePath", "ellipse", "lineTo", "moveTo", "quadraticCurveTo", "rect"];

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var eventemitter3 = {exports: {}};

(function (module) {

  var has = Object.prototype.hasOwnProperty,
    prefix = '~';

  /**
   * Constructor to create a storage for our `EE` objects.
   * An `Events` instance is a plain object whose properties are event names.
   *
   * @constructor
   * @private
   */
  function Events() {}

  //
  // We try to not inherit from `Object.prototype`. In some engines creating an
  // instance in this way is faster than calling `Object.create(null)` directly.
  // If `Object.create(null)` is not supported we prefix the event names with a
  // character to make sure that the built-in object properties are not
  // overridden or used as an attack vector.
  //
  if (Object.create) {
    Events.prototype = Object.create(null);

    //
    // This hack is needed because the `__proto__` property is still inherited in
    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.
    //
    if (!new Events().__proto__) prefix = false;
  }

  /**
   * Representation of a single event listener.
   *
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} [once=false] Specify if the listener is a one-time listener.
   * @constructor
   * @private
   */
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }

  /**
   * Add a listener for a given event.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} context The context to invoke the listener with.
   * @param {Boolean} once Specify if the listener is a one-time listener.
   * @returns {EventEmitter}
   * @private
   */
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== 'function') {
      throw new TypeError('The listener must be a function');
    }
    var listener = new EE(fn, context || emitter, once),
      evt = prefix ? prefix + event : event;
    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);else emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }

  /**
   * Clear event by name.
   *
   * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.
   * @param {(String|Symbol)} evt The Event name.
   * @private
   */
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0) emitter._events = new Events();else delete emitter._events[evt];
  }

  /**
   * Minimal `EventEmitter` interface that is molded against the Node.js
   * `EventEmitter` interface.
   *
   * @constructor
   * @public
   */
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }

  /**
   * Return an array listing the events for which the emitter has registered
   * listeners.
   *
   * @returns {Array}
   * @public
   */
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [],
      events,
      name;
    if (this._eventsCount === 0) return names;
    for (name in events = this._events) {
      if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };

  /**
   * Return the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Array} The registered listeners.
   * @public
   */
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event,
      handlers = this._events[evt];
    if (!handlers) return [];
    if (handlers.fn) return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };

  /**
   * Return the number of listeners listening to a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Number} The number of listeners.
   * @public
   */
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event,
      listeners = this._events[evt];
    if (!listeners) return 0;
    if (listeners.fn) return 1;
    return listeners.length;
  };

  /**
   * Calls each of the listeners registered for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @returns {Boolean} `true` if the event had listeners, else `false`.
   * @public
   */
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return false;
    var listeners = this._events[evt],
      len = arguments.length,
      args,
      i;
    if (listeners.fn) {
      if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length,
        j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args) for (j = 1, args = new Array(len - 1); j < len; j++) {
              args[j - 1] = arguments[j];
            }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };

  /**
   * Add a listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };

  /**
   * Add a one-time listener for a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn The listener function.
   * @param {*} [context=this] The context to invoke the listener with.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };

  /**
   * Remove the listeners of a given event.
   *
   * @param {(String|Symbol)} event The event name.
   * @param {Function} fn Only remove the listeners that match this function.
   * @param {*} context Only remove the listeners that have this context.
   * @param {Boolean} once Only remove one-time listeners.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt]) return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }

      //
      // Reset the array, or remove it completely if we have no more listeners.
      //
      if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;else clearEvent(this, evt);
    }
    return this;
  };

  /**
   * Remove all listeners, or those of the specified event.
   *
   * @param {(String|Symbol)} [event] The event name.
   * @returns {EventEmitter} `this`.
   * @public
   */
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt]) clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };

  //
  // Alias methods names because people roll like that.
  //
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  //
  // Expose the prefix.
  //
  EventEmitter.prefixed = prefix;

  //
  // Allow `EventEmitter` to be imported as module namespace.
  //
  EventEmitter.EventEmitter = EventEmitter;

  //
  // Expose the module.
  //
  {
    module.exports = EventEmitter;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
var EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);

const isType = (value, type) => Object.prototype.toString.call(value) === `[object ${type}]`;
var isType$1 = isType;

const isBoolean = function (value) {
  let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  return fuzzy ? "boolean" == typeof value : !0 === value || !1 === value || isType$1(value, "Boolean");
};
var isBoolean$1 = isBoolean;

const isFunction = value => "function" == typeof value;
var isFunction$1 = isFunction;

const isNil = value => null == value;
var isNil$1 = isNil;

const isValid = value => null != value;
var isValid$1 = isValid;

const isObject = value => {
  const type = typeof value;
  return null !== value && "object" === type || "function" === type;
};
var isObject$1 = isObject;

const isObjectLike = value => "object" == typeof value && null !== value;
var isObjectLike$1 = isObjectLike;

const isPlainObject = function (value) {
  if (!isObjectLike$1(value) || !isType$1(value, "Object")) return !1;
  if (null === Object.getPrototypeOf(value)) return !0;
  let proto = value;
  for (; null !== Object.getPrototypeOf(proto);) proto = Object.getPrototypeOf(proto);
  return Object.getPrototypeOf(value) === proto;
};
var isPlainObject$1 = isPlainObject;

const isUndefined = value => void 0 === value;
var isUndefined$1 = isUndefined;

const isString = function (value) {
  let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  const type = typeof value;
  return fuzzy ? "string" === type : "string" === type || isType$1(value, "String");
};
var isString$1 = isString;

const isArray = value => Array.isArray ? Array.isArray(value) : isType$1(value, "Array");
var isArray$1 = isArray;

const isArrayLike = function (value) {
  return null !== value && "function" != typeof value && Number.isFinite(value.length);
};
var isArrayLike$1 = isArrayLike;

const isNumber = function (value) {
  let fuzzy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  const type = typeof value;
  return fuzzy ? "number" === type : "number" === type || isType$1(value, "Number");
};
var isNumber$1 = isNumber;

const isValidNumber = value => isNumber$1(value) && Number.isFinite(value);
var isValidNumber$1 = isValidNumber;

const isValidUrl = value => new RegExp(/^(http(s)?:\/\/)\w+[^\s]+(\.[^\s]+){1,}$/).test(value);
var isValidUrl$1 = isValidUrl;

const isBase64 = value => new RegExp(/^data:image\/(?:gif|png|jpeg|bmp|webp|svg\+xml)(?:;charset=utf-8)?;base64,(?:[A-Za-z0-9]|[+/])+={0,2}/g).test(value);
var isBase64$1 = isBase64;

const hasOwnProperty = Object.prototype.hasOwnProperty,
  has = (object, key) => null != object && hasOwnProperty.call(object, key);
var has$1 = has;

function baseMerge(target, source) {
  let shallowArray = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  let skipTargetArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  if (source) {
    if (target === source) return;
    if (isValid$1(source) && "object" == typeof source) {
      const iterable = Object(source),
        props = [];
      for (const key in iterable) props.push(key);
      let {
          length: length
        } = props,
        propIndex = -1;
      for (; length--;) {
        const key = props[++propIndex];
        !isValid$1(iterable[key]) || "object" != typeof iterable[key] || skipTargetArray && isArray$1(target[key]) ? assignMergeValue(target, key, iterable[key]) : baseMergeDeep(target, source, key, shallowArray, skipTargetArray);
      }
    }
  }
}
function baseMergeDeep(target, source, key) {
  let shallowArray = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  let skipTargetArray = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
  const objValue = target[key],
    srcValue = source[key];
  let newValue = source[key],
    isCommon = !0;
  if (isArray$1(srcValue)) {
    if (shallowArray) newValue = [];else if (isArray$1(objValue)) newValue = objValue;else if (isArrayLike$1(objValue)) {
      newValue = new Array(objValue.length);
      let index = -1;
      const length = objValue.length;
      for (; ++index < length;) newValue[index] = objValue[index];
    }
  } else isPlainObject$1(srcValue) ? (newValue = null != objValue ? objValue : {}, "function" != typeof objValue && "object" == typeof objValue || (newValue = {})) : isCommon = !1;
  isCommon && baseMerge(newValue, srcValue, shallowArray, skipTargetArray), assignMergeValue(target, key, newValue);
}
function assignMergeValue(target, key, value) {
  (void 0 !== value && !eq(target[key], value) || void 0 === value && !(key in target)) && (target[key] = value);
}
function eq(value, other) {
  return value === other || Number.isNaN(value) && Number.isNaN(other);
}
function merge(target) {
  let sourceIndex = -1;
  const length = arguments.length <= 1 ? 0 : arguments.length - 1;
  for (; ++sourceIndex < length;) {
    baseMerge(target, sourceIndex + 1 < 1 || arguments.length <= sourceIndex + 1 ? undefined : arguments[sourceIndex + 1], !0);
  }
  return target;
}

function arrayEqual(a, b) {
  if (!isArray$1(a) || !isArray$1(b)) return !1;
  if (a.length !== b.length) return !1;
  for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return !1;
  return !0;
}

const hasConsole = "undefined" != typeof console;
function log(method, level, input) {
  const args = [level].concat([].slice.call(input));
  hasConsole && console[method].apply(console, args);
}
var LoggerLevel;
!function (LoggerLevel) {
  LoggerLevel[LoggerLevel.None = 0] = "None", LoggerLevel[LoggerLevel.Error = 1] = "Error", LoggerLevel[LoggerLevel.Warn = 2] = "Warn", LoggerLevel[LoggerLevel.Info = 3] = "Info", LoggerLevel[LoggerLevel.Debug = 4] = "Debug";
}(LoggerLevel || (LoggerLevel = {}));
class Logger {
  static getInstance(level, method) {
    return Logger._instance && isNumber$1(level) ? Logger._instance.level(level) : Logger._instance || (Logger._instance = new Logger(level, method)), Logger._instance;
  }
  static setInstance(logger) {
    return Logger._instance = logger;
  }
  static setInstanceLevel(level) {
    Logger._instance ? Logger._instance.level(level) : Logger._instance = new Logger(level);
  }
  static clearInstance() {
    Logger._instance = null;
  }
  constructor() {
    let level = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : LoggerLevel.None;
    let method = arguments.length > 1 ? arguments[1] : undefined;
    this._onErrorHandler = [], this._level = level, this._method = method;
  }
  addErrorHandler(handler) {
    this._onErrorHandler.find(h => h === handler) || this._onErrorHandler.push(handler);
  }
  removeErrorHandler(handler) {
    const index = this._onErrorHandler.findIndex(h => h === handler);
    index < 0 || this._onErrorHandler.splice(index, 1);
  }
  callErrorHandler() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    this._onErrorHandler.forEach(h => h(...args));
  }
  canLogInfo() {
    return this._level >= LoggerLevel.Info;
  }
  canLogDebug() {
    return this._level >= LoggerLevel.Debug;
  }
  canLogError() {
    return this._level >= LoggerLevel.Error;
  }
  canLogWarn() {
    return this._level >= LoggerLevel.Warn;
  }
  level(levelValue) {
    return arguments.length ? (this._level = +levelValue, this) : this._level;
  }
  error() {
    var _a;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this._level >= LoggerLevel.Error && (this._onErrorHandler.length ? this.callErrorHandler(...args) : log(null !== (_a = this._method) && void 0 !== _a ? _a : "error", "ERROR", args)), this;
  }
  warn() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this._level >= LoggerLevel.Warn && log(this._method || "warn", "WARN", args), this;
  }
  info() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this._level >= LoggerLevel.Info && log(this._method || "log", "INFO", args), this;
  }
  debug() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return this._level >= LoggerLevel.Debug && log(this._method || "log", "DEBUG", args), this;
  }
}
Logger._instance = null;

const DEFAULT_ABSOLUTE_TOLERATE = 1e-10,
  DEFAULT_RELATIVE_TOLERATE = 1e-10;
function isNumberClose(a, b) {
  let relTol = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : DEFAULT_RELATIVE_TOLERATE;
  let absTol = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : DEFAULT_ABSOLUTE_TOLERATE;
  const abs = absTol,
    rel = relTol * Math.max(a, b);
  return Math.abs(a - b) <= Math.max(abs, rel);
}

const clamp = function (input, min, max) {
  return input < min ? min : input > max ? max : input;
};
var clamp$1 = clamp;

const epsilon = 1e-12;
const pi = Math.PI;
const halfPi$1 = pi / 2;
const tau = 2 * pi;
const pi2 = 2 * Math.PI;
const abs = Math.abs;
const atan2 = Math.atan2;
const cos = Math.cos;
const max = Math.max;
const min = Math.min;
const sin = Math.sin;
const sqrt = Math.sqrt;
const pow = Math.pow;
function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}
function asin(x) {
  return x >= 1 ? halfPi$1 : x <= -1 ? -halfPi$1 : Math.asin(x);
}
function pointAt(x1, y1, x2, y2, t) {
  let x = x2,
    y = y2;
  return "number" == typeof x1 && "number" == typeof x2 && (x = (1 - t) * x1 + t * x2), "number" == typeof y1 && "number" == typeof y2 && (y = (1 - t) * y1 + t * y2), {
    x: x,
    y: y
  };
}
function crossProduct$1(dir1, dir2) {
  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
function fuzzyEqualVec(a, b) {
  return abs(a[0] - b[0]) + abs(a[1] - b[1]) < 1e-12;
}
function getDecimalPlaces(n) {
  const dStr = n.toString().split(/[eE]/),
    s = (dStr[0].split(".")[1] || "").length - (+dStr[1] || 0);
  return s > 0 ? s : 0;
}

class Point {
  constructor() {
    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let x1 = arguments.length > 2 ? arguments[2] : undefined;
    let y1 = arguments.length > 3 ? arguments[3] : undefined;
    this.x = 0, this.y = 0, this.x = x, this.y = y, this.x1 = x1, this.y1 = y1;
  }
  clone() {
    return new Point(this.x, this.y);
  }
  copyFrom(p) {
    return this.x = p.x, this.y = p.y, this.x1 = p.x1, this.y1 = p.y1, this.defined = p.defined, this.context = p.context, this;
  }
  set(x, y) {
    return this.x = x, this.y = y, this;
  }
  add(point) {
    return isNumber$1(point) ? (this.x += point, void (this.y += point)) : (this.x += point.x, this.y += point.y, this);
  }
  sub(point) {
    return isNumber$1(point) ? (this.x -= point, void (this.y -= point)) : (this.x -= point.x, this.y -= point.y, this);
  }
  multi(point) {
    throw new Error("暂不支持");
  }
  div(point) {
    throw new Error("暂不支持");
  }
}
class PointService {
  static distancePP(p1, p2) {
    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));
  }
  static distanceNN(x, y, x1, y1) {
    return sqrt(pow(x - x1, 2) + pow(y - y1, 2));
  }
  static distancePN(point, x, y) {
    return sqrt(pow(x - point.x, 2) + pow(y - point.y, 2));
  }
  static pointAtPP(p1, p2, t) {
    return new Point((p2.x - p1.x) * t + p1.x, (p2.y - p1.y) * t + p1.y);
  }
}

function degreeToRadian(degree) {
  return degree * (Math.PI / 180);
}
function radianToDegree(radian) {
  return 180 * radian / Math.PI;
}
const clampRadian = function () {
  let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  if (angle < 0) for (; angle < -tau;) angle += tau;else if (angle > 0) for (; angle > tau;) angle -= tau;
  return angle;
};
const clampAngleByRadian = clampRadian;
function getAngleByPoint(center, point) {
  return Math.atan2(point.y - center.y, point.x - center.x);
}

function sub(out, v1, v2) {
  out[0] = v1[0] - v2[0], out[1] = v1[1] - v2[1];
}
function isIntersect(left1, right1, left2, right2) {
  let min1 = left1[0],
    max1 = right1[0],
    min2 = left2[0],
    max2 = right2[0];
  return max1 < min1 && ([min1, max1] = [max1, min1]), max2 < min2 && ([max2, min2] = [min2, max2]), !(max1 < min2 || max2 < min1) && (min1 = left1[1], max1 = right1[1], min2 = left2[1], max2 = right2[1], max1 < min1 && ([min1, max1] = [max1, min1]), max2 < min2 && ([max2, min2] = [min2, max2]), !(max1 < min2 || max2 < min1));
}
function getIntersectPoint(left1, right1, left2, right2) {
  if (!isIntersect(left1, right1, left2, right2)) return !1;
  const dir1 = [0, 0],
    dir2 = [0, 0],
    tempVec = [0, 0];
  if (sub(dir1, right1, left1), sub(dir2, right2, left2), fuzzyEqualVec(dir1, dir2)) return !0;
  sub(tempVec, left2, left1);
  const t = crossProduct$1(tempVec, dir2) / crossProduct$1(dir1, dir2);
  return t >= 0 && t <= 1 && [left1[0] + dir1[0] * t, left1[1] + dir1[1] * t];
}
function getRectIntersect(bbox1, bbox2, format) {
  if (null === bbox1) return bbox2;
  if (null === bbox2) return bbox1;
  const {
    x11: x11,
    x12: x12,
    y11: y11,
    y12: y12,
    x21: x21,
    x22: x22,
    y21: y21,
    y22: y22
  } = formatTwoBBox(bbox1, bbox2, format);
  return x11 >= x22 || x12 <= x21 || y11 >= y22 || y12 <= y21 ? {
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0
  } : {
    x1: Math.max(x11, x21),
    y1: Math.max(y11, y21),
    x2: Math.min(x12, x22),
    y2: Math.min(y12, y22)
  };
}
var InnerBBox;
!function (InnerBBox) {
  InnerBBox[InnerBBox.NONE = 0] = "NONE", InnerBBox[InnerBBox.BBOX1 = 1] = "BBOX1", InnerBBox[InnerBBox.BBOX2 = 2] = "BBOX2";
}(InnerBBox || (InnerBBox = {}));
const formatTwoBBox = (bbox1, bbox2, format) => {
  let x11 = bbox1.x1,
    x12 = bbox1.x2,
    y11 = bbox1.y1,
    y12 = bbox1.y2,
    x21 = bbox2.x1,
    x22 = bbox2.x2,
    y21 = bbox2.y1,
    y22 = bbox2.y2;
  return format && (x11 > x12 && ([x11, x12] = [x12, x11]), y11 > y12 && ([y11, y12] = [y12, y11]), x21 > x22 && ([x21, x22] = [x22, x21]), y21 > y22 && ([y21, y22] = [y22, y21])), {
    x11: x11,
    x12: x12,
    y11: y11,
    y12: y12,
    x21: x21,
    x22: x22,
    y21: y21,
    y22: y22
  };
};
function isRectIntersect(bbox1, bbox2, format) {
  if (bbox1 && bbox2) {
    if (!format) return !(bbox1.x1 > bbox2.x2 || bbox1.x2 < bbox2.x1 || bbox1.y1 > bbox2.y2 || bbox1.y2 < bbox2.y1);
    const {
      x11: x11,
      x12: x12,
      y11: y11,
      y12: y12,
      x21: x21,
      x22: x22,
      y21: y21,
      y22: y22
    } = formatTwoBBox(bbox1, bbox2, !0);
    return !(x11 > x22 || x12 < x21 || y11 > y22 || y12 < y21);
  }
  return !0;
}
function getProjectionRadius(checkAxis, axis) {
  return Math.abs(axis[0] * checkAxis[0] + axis[1] * checkAxis[1]);
}
function rotatePoint(_ref, rad) {
  let {
    x: x,
    y: y
  } = _ref;
  let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
    x: 0,
    y: 0
  };
  return {
    x: (x - origin.x) * Math.cos(rad) - (y - origin.y) * Math.sin(rad) + origin.x,
    y: (x - origin.x) * Math.sin(rad) + (y - origin.y) * Math.cos(rad) + origin.y
  };
}
function getCenterPoint(box) {
  return {
    x: (box.x1 + box.x2) / 2,
    y: (box.y1 + box.y2) / 2
  };
}
function toRect(box, isDeg) {
  const deg = isDeg ? degreeToRadian(box.angle) : box.angle,
    cp = getCenterPoint(box);
  return [rotatePoint({
    x: box.x1,
    y: box.y1
  }, deg, cp), rotatePoint({
    x: box.x2,
    y: box.y1
  }, deg, cp), rotatePoint({
    x: box.x2,
    y: box.y2
  }, deg, cp), rotatePoint({
    x: box.x1,
    y: box.y2
  }, deg, cp)];
}
function isRotateAABBIntersect(box1, box2) {
  let isDeg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  const rect1 = toRect(box1, isDeg),
    rect2 = toRect(box2, isDeg),
    vector = (start, end) => [end.x - start.x, end.y - start.y],
    vp1p2 = vector(getCenterPoint(box1), getCenterPoint(box2)),
    AB = vector(rect1[0], rect1[1]),
    BC = vector(rect1[1], rect1[2]),
    A1B1 = vector(rect2[0], rect2[1]),
    B1C1 = vector(rect2[1], rect2[2]),
    deg11 = isDeg ? degreeToRadian(box1.angle) : box1.angle;
  let deg12 = isDeg ? degreeToRadian(90 - box1.angle) : box1.angle + halfPi$1;
  const deg21 = isDeg ? degreeToRadian(box2.angle) : box2.angle;
  let deg22 = isDeg ? degreeToRadian(90 - box2.angle) : box2.angle + halfPi$1;
  deg12 > pi2 && (deg12 -= pi2), deg22 > pi2 && (deg22 -= pi2);
  const isCover = (checkAxisRadius, deg, targetAxis1, targetAxis2) => {
    const checkAxis = [Math.cos(deg), Math.sin(deg)];
    return checkAxisRadius + (getProjectionRadius(checkAxis, targetAxis1) + getProjectionRadius(checkAxis, targetAxis2)) / 2 > getProjectionRadius(checkAxis, vp1p2);
  };
  return isCover((box1.x2 - box1.x1) / 2, deg11, A1B1, B1C1) && isCover((box1.y2 - box1.y1) / 2, deg12, A1B1, B1C1) && isCover((box2.x2 - box2.x1) / 2, deg21, AB, BC) && isCover((box2.y2 - box2.y1) / 2, deg22, AB, BC);
}

function isPointInLine(x0, y0, x1, y1, x, y) {
  if (y > y0 && y > y1 || y < y0 && y < y1) return 0;
  if (y1 === y0) return 0;
  const t = (y - y0) / (y1 - y0);
  let dir = y1 < y0 ? 1 : -1;
  1 !== t && 0 !== t || (dir = y1 < y0 ? .5 : -.5);
  const x_ = t * (x1 - x0) + x0;
  return x_ === x ? 1 / 0 : x_ > x ? dir : 0;
}

const eastAsianCharacterInfo = character => {
  let x = character.charCodeAt(0),
    y = 2 === character.length ? character.charCodeAt(1) : 0,
    codePoint = x;
  return 55296 <= x && x <= 56319 && 56320 <= y && y <= 57343 && (x &= 1023, y &= 1023, codePoint = x << 10 | y, codePoint += 65536), 12288 === codePoint || 65281 <= codePoint && codePoint <= 65376 || 65504 <= codePoint && codePoint <= 65510 ? "F" : 8361 === codePoint || 65377 <= codePoint && codePoint <= 65470 || 65474 <= codePoint && codePoint <= 65479 || 65482 <= codePoint && codePoint <= 65487 || 65490 <= codePoint && codePoint <= 65495 || 65498 <= codePoint && codePoint <= 65500 || 65512 <= codePoint && codePoint <= 65518 ? "H" : 4352 <= codePoint && codePoint <= 4447 || 4515 <= codePoint && codePoint <= 4519 || 4602 <= codePoint && codePoint <= 4607 || 9001 <= codePoint && codePoint <= 9002 || 11904 <= codePoint && codePoint <= 11929 || 11931 <= codePoint && codePoint <= 12019 || 12032 <= codePoint && codePoint <= 12245 || 12272 <= codePoint && codePoint <= 12283 || 12289 <= codePoint && codePoint <= 12350 || 12353 <= codePoint && codePoint <= 12438 || 12441 <= codePoint && codePoint <= 12543 || 12549 <= codePoint && codePoint <= 12589 || 12593 <= codePoint && codePoint <= 12686 || 12688 <= codePoint && codePoint <= 12730 || 12736 <= codePoint && codePoint <= 12771 || 12784 <= codePoint && codePoint <= 12830 || 12832 <= codePoint && codePoint <= 12871 || 12880 <= codePoint && codePoint <= 13054 || 13056 <= codePoint && codePoint <= 19903 || 19968 <= codePoint && codePoint <= 42124 || 42128 <= codePoint && codePoint <= 42182 || 43360 <= codePoint && codePoint <= 43388 || 44032 <= codePoint && codePoint <= 55203 || 55216 <= codePoint && codePoint <= 55238 || 55243 <= codePoint && codePoint <= 55291 || 63744 <= codePoint && codePoint <= 64255 || 65040 <= codePoint && codePoint <= 65049 || 65072 <= codePoint && codePoint <= 65106 || 65108 <= codePoint && codePoint <= 65126 || 65128 <= codePoint && codePoint <= 65131 || 110592 <= codePoint && codePoint <= 110593 || 127488 <= codePoint && codePoint <= 127490 || 127504 <= codePoint && codePoint <= 127546 || 127552 <= codePoint && codePoint <= 127560 || 127568 <= codePoint && codePoint <= 127569 || 131072 <= codePoint && codePoint <= 194367 || 177984 <= codePoint && codePoint <= 196605 || 196608 <= codePoint && codePoint <= 262141 ? "W" : 32 <= codePoint && codePoint <= 126 || 162 <= codePoint && codePoint <= 163 || 165 <= codePoint && codePoint <= 166 || 172 === codePoint || 175 === codePoint || 10214 <= codePoint && codePoint <= 10221 || 10629 <= codePoint && codePoint <= 10630 ? "Na" : 161 === codePoint || 164 === codePoint || 167 <= codePoint && codePoint <= 168 || 170 === codePoint || 173 <= codePoint && codePoint <= 174 || 176 <= codePoint && codePoint <= 180 || 182 <= codePoint && codePoint <= 186 || 188 <= codePoint && codePoint <= 191 || 198 === codePoint || 208 === codePoint || 215 <= codePoint && codePoint <= 216 || 222 <= codePoint && codePoint <= 225 || 230 === codePoint || 232 <= codePoint && codePoint <= 234 || 236 <= codePoint && codePoint <= 237 || 240 === codePoint || 242 <= codePoint && codePoint <= 243 || 247 <= codePoint && codePoint <= 250 || 252 === codePoint || 254 === codePoint || 257 === codePoint || 273 === codePoint || 275 === codePoint || 283 === codePoint || 294 <= codePoint && codePoint <= 295 || 299 === codePoint || 305 <= codePoint && codePoint <= 307 || 312 === codePoint || 319 <= codePoint && codePoint <= 322 || 324 === codePoint || 328 <= codePoint && codePoint <= 331 || 333 === codePoint || 338 <= codePoint && codePoint <= 339 || 358 <= codePoint && codePoint <= 359 || 363 === codePoint || 462 === codePoint || 464 === codePoint || 466 === codePoint || 468 === codePoint || 470 === codePoint || 472 === codePoint || 474 === codePoint || 476 === codePoint || 593 === codePoint || 609 === codePoint || 708 === codePoint || 711 === codePoint || 713 <= codePoint && codePoint <= 715 || 717 === codePoint || 720 === codePoint || 728 <= codePoint && codePoint <= 731 || 733 === codePoint || 735 === codePoint || 768 <= codePoint && codePoint <= 879 || 913 <= codePoint && codePoint <= 929 || 931 <= codePoint && codePoint <= 937 || 945 <= codePoint && codePoint <= 961 || 963 <= codePoint && codePoint <= 969 || 1025 === codePoint || 1040 <= codePoint && codePoint <= 1103 || 1105 === codePoint || 8208 === codePoint || 8211 <= codePoint && codePoint <= 8214 || 8216 <= codePoint && codePoint <= 8217 || 8220 <= codePoint && codePoint <= 8221 || 8224 <= codePoint && codePoint <= 8226 || 8228 <= codePoint && codePoint <= 8231 || 8240 === codePoint || 8242 <= codePoint && codePoint <= 8243 || 8245 === codePoint || 8251 === codePoint || 8254 === codePoint || 8308 === codePoint || 8319 === codePoint || 8321 <= codePoint && codePoint <= 8324 || 8364 === codePoint || 8451 === codePoint || 8453 === codePoint || 8457 === codePoint || 8467 === codePoint || 8470 === codePoint || 8481 <= codePoint && codePoint <= 8482 || 8486 === codePoint || 8491 === codePoint || 8531 <= codePoint && codePoint <= 8532 || 8539 <= codePoint && codePoint <= 8542 || 8544 <= codePoint && codePoint <= 8555 || 8560 <= codePoint && codePoint <= 8569 || 8585 === codePoint || 8592 <= codePoint && codePoint <= 8601 || 8632 <= codePoint && codePoint <= 8633 || 8658 === codePoint || 8660 === codePoint || 8679 === codePoint || 8704 === codePoint || 8706 <= codePoint && codePoint <= 8707 || 8711 <= codePoint && codePoint <= 8712 || 8715 === codePoint || 8719 === codePoint || 8721 === codePoint || 8725 === codePoint || 8730 === codePoint || 8733 <= codePoint && codePoint <= 8736 || 8739 === codePoint || 8741 === codePoint || 8743 <= codePoint && codePoint <= 8748 || 8750 === codePoint || 8756 <= codePoint && codePoint <= 8759 || 8764 <= codePoint && codePoint <= 8765 || 8776 === codePoint || 8780 === codePoint || 8786 === codePoint || 8800 <= codePoint && codePoint <= 8801 || 8804 <= codePoint && codePoint <= 8807 || 8810 <= codePoint && codePoint <= 8811 || 8814 <= codePoint && codePoint <= 8815 || 8834 <= codePoint && codePoint <= 8835 || 8838 <= codePoint && codePoint <= 8839 || 8853 === codePoint || 8857 === codePoint || 8869 === codePoint || 8895 === codePoint || 8978 === codePoint || 9312 <= codePoint && codePoint <= 9449 || 9451 <= codePoint && codePoint <= 9547 || 9552 <= codePoint && codePoint <= 9587 || 9600 <= codePoint && codePoint <= 9615 || 9618 <= codePoint && codePoint <= 9621 || 9632 <= codePoint && codePoint <= 9633 || 9635 <= codePoint && codePoint <= 9641 || 9650 <= codePoint && codePoint <= 9651 || 9654 <= codePoint && codePoint <= 9655 || 9660 <= codePoint && codePoint <= 9661 || 9664 <= codePoint && codePoint <= 9665 || 9670 <= codePoint && codePoint <= 9672 || 9675 === codePoint || 9678 <= codePoint && codePoint <= 9681 || 9698 <= codePoint && codePoint <= 9701 || 9711 === codePoint || 9733 <= codePoint && codePoint <= 9734 || 9737 === codePoint || 9742 <= codePoint && codePoint <= 9743 || 9748 <= codePoint && codePoint <= 9749 || 9756 === codePoint || 9758 === codePoint || 9792 === codePoint || 9794 === codePoint || 9824 <= codePoint && codePoint <= 9825 || 9827 <= codePoint && codePoint <= 9829 || 9831 <= codePoint && codePoint <= 9834 || 9836 <= codePoint && codePoint <= 9837 || 9839 === codePoint || 9886 <= codePoint && codePoint <= 9887 || 9918 <= codePoint && codePoint <= 9919 || 9924 <= codePoint && codePoint <= 9933 || 9935 <= codePoint && codePoint <= 9953 || 9955 === codePoint || 9960 <= codePoint && codePoint <= 9983 || 10045 === codePoint || 10071 === codePoint || 10102 <= codePoint && codePoint <= 10111 || 11093 <= codePoint && codePoint <= 11097 || 12872 <= codePoint && codePoint <= 12879 || 57344 <= codePoint && codePoint <= 63743 || 65024 <= codePoint && codePoint <= 65039 || 65533 === codePoint || 127232 <= codePoint && codePoint <= 127242 || 127248 <= codePoint && codePoint <= 127277 || 127280 <= codePoint && codePoint <= 127337 || 127344 <= codePoint && codePoint <= 127386 || 917760 <= codePoint && codePoint <= 917999 || 983040 <= codePoint && codePoint <= 1048573 || 1048576 <= codePoint && codePoint <= 1114109 ? "A" : "N";
};

function getContextFont(text) {
  let defaultAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  let fontSizeScale = arguments.length > 2 ? arguments[2] : undefined;
  fontSizeScale || (fontSizeScale = 1);
  const {
    fontStyle = defaultAttr.fontStyle,
    fontVariant = defaultAttr.fontVariant,
    fontWeight = defaultAttr.fontWeight,
    fontSize = defaultAttr.fontSize,
    fontFamily = defaultAttr.fontFamily
  } = text;
  return (fontStyle ? fontStyle + " " : "") + (fontVariant ? fontVariant + " " : "") + (fontWeight ? fontWeight + " " : "") + fontSize * fontSizeScale + "px " + (fontFamily || "sans-serif");
}

class TextMeasure {
  constructor(option, textSpec) {
    this._numberCharSize = null, this._fullCharSize = null, this._letterCharSize = null, this._specialCharSizeMap = {}, this._canvas = null, this._context = null, this._contextSaved = !1, this._notSupportCanvas = !1, this._notSupportVRender = !1, this._userSpec = {}, this.specialCharSet = "-/: .,@%'\"~", this._option = option, this._userSpec = null != textSpec ? textSpec : {}, this.textSpec = this._initSpec(), isValid$1(option.specialCharSet) && (this.specialCharSet = option.specialCharSet), this._standardMethod = isValid$1(option.getTextBounds) ? this.fullMeasure.bind(this) : this.measureWithNaiveCanvas.bind(this);
  }
  initContext() {
    if (this._notSupportCanvas) return !1;
    if (isNil$1(this._canvas) && (isValid$1(this._option.getCanvasForMeasure) && (this._canvas = this._option.getCanvasForMeasure()), isNil$1(this._canvas) && "undefined" != typeof window && void 0 !== window.document && globalThis && isValid$1(globalThis.document) && (this._canvas = globalThis.document.createElement("canvas"))), isNil$1(this._context) && isValid$1(this._canvas)) {
      const context = this._canvas.getContext("2d");
      isValid$1(context) && (context.save(), context.font = getContextFont(this.textSpec), this._contextSaved = !0, this._context = context);
    }
    return !isNil$1(this._context) || (this._notSupportCanvas = !0, !1);
  }
  _initSpec() {
    var _a, _b, _c;
    const {
        defaultFontParams = {}
      } = this._option,
      {
        fontStyle = defaultFontParams.fontStyle,
        fontVariant = defaultFontParams.fontVariant,
        fontWeight = null !== (_a = defaultFontParams.fontWeight) && void 0 !== _a ? _a : "normal",
        fontSize = null !== (_b = defaultFontParams.fontSize) && void 0 !== _b ? _b : 12,
        fontFamily = null !== (_c = defaultFontParams.fontFamily) && void 0 !== _c ? _c : "sans-serif",
        align: align,
        textAlign = null != align ? align : "center",
        baseline: baseline,
        textBaseline = null != baseline ? baseline : "middle",
        ellipsis: ellipsis,
        limit: limit
      } = this._userSpec;
    let {
      lineHeight = fontSize
    } = this._userSpec;
    if (isString$1(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
      const scale = Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100;
      lineHeight = fontSize * scale;
    }
    return {
      fontStyle: fontStyle,
      fontVariant: fontVariant,
      fontFamily: fontFamily,
      fontSize: fontSize,
      fontWeight: fontWeight,
      textAlign: textAlign,
      textBaseline: textBaseline,
      ellipsis: ellipsis,
      limit: limit,
      lineHeight: lineHeight
    };
  }
  measure(text, method) {
    switch (method) {
      case "vrender":
      case "canopus":
        return this.fullMeasure(text);
      case "canvas":
        return this.measureWithNaiveCanvas(text);
      case "simple":
        return this.quickMeasureWithoutCanvas(text);
      default:
        return this.quickMeasure(text);
    }
  }
  fullMeasure(text) {
    if (isNil$1(text)) return {
      width: 0,
      height: 0
    };
    if (isNil$1(this._option.getTextBounds) || !this._notSupportVRender) return this.measureWithNaiveCanvas(text);
    const {
      fontFamily: fontFamily,
      fontSize: fontSize,
      fontWeight: fontWeight,
      textAlign: textAlign,
      textBaseline: textBaseline,
      ellipsis: ellipsis,
      limit: limit,
      lineHeight: lineHeight
    } = this.textSpec;
    let size;
    try {
      const bounds = this._option.getTextBounds({
        text: text,
        fontFamily: fontFamily,
        fontSize: fontSize,
        fontWeight: fontWeight,
        textAlign: textAlign,
        textBaseline: textBaseline,
        ellipsis: !!ellipsis,
        maxLineWidth: limit || 1 / 0,
        lineHeight: lineHeight
      });
      size = {
        width: bounds.width(),
        height: bounds.height()
      };
    } catch (e) {
      this._notSupportVRender = !0, size = this.measureWithNaiveCanvas(text);
    }
    return size;
  }
  measureWithNaiveCanvas(text) {
    return this._measureReduce(text, this._measureWithNaiveCanvas.bind(this));
  }
  _measureWithNaiveCanvas(text) {
    var _a;
    if (!this.initContext()) return this._quickMeasureWithoutCanvas(text);
    const metrics = this._context.measureText(text),
      {
        fontSize: fontSize,
        lineHeight: lineHeight
      } = this.textSpec;
    return {
      width: metrics.width,
      height: null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize,
      fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
      fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
    };
  }
  quickMeasure(text) {
    return this._measureReduce(text, this._quickMeasure.bind(this));
  }
  _quickMeasure(text) {
    const totalSize = {
      width: 0,
      height: 0
    };
    for (let i = 0; i < text.length; i++) {
      const char = text[i];
      let size = this._measureSpecialChar(char);
      isNil$1(size) && TextMeasure.NUMBERS_CHAR_SET.includes(char) && (size = this._measureNumberChar()), isNil$1(size) && ["F", "W"].includes(eastAsianCharacterInfo(char)) && (size = this._measureFullSizeChar()), isNil$1(size) && (size = this._measureLetterChar()), totalSize.width += size.width, totalSize.height = Math.max(totalSize.height, size.height), !isNil$1(size.fontBoundingBoxAscent) && (totalSize.fontBoundingBoxAscent = size.fontBoundingBoxAscent), !isNil$1(size.fontBoundingBoxDescent) && (totalSize.fontBoundingBoxDescent = size.fontBoundingBoxDescent);
    }
    return totalSize;
  }
  quickMeasureWithoutCanvas(text) {
    return this._measureReduce(text, this._quickMeasureWithoutCanvas.bind(this));
  }
  _quickMeasureWithoutCanvas(text) {
    var _a;
    const totalSize = {
        width: 0,
        height: 0
      },
      {
        fontSize: fontSize,
        lineHeight: lineHeight
      } = this.textSpec;
    for (let i = 0; i < text.length; i++) {
      const char = text[i],
        size = ["F", "W"].includes(eastAsianCharacterInfo(char)) ? 1 : .53;
      totalSize.width += size * fontSize;
    }
    return totalSize.height = null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize, totalSize;
  }
  _measureReduce(text, processor) {
    var _a;
    const {
        fontSize: fontSize,
        lineHeight: lineHeight
      } = this.textSpec,
      defaultResult = {
        width: 0,
        height: 0
      };
    if (isNil$1(text)) return defaultResult;
    if (isArray$1(text)) {
      const textArr = text.filter(isValid$1).map(s => s.toString());
      return 0 === textArr.length ? defaultResult : 1 === textArr.length ? processor(textArr[0]) : {
        width: textArr.reduce((maxWidth, cur) => Math.max(maxWidth, processor(cur).width), 0),
        height: textArr.length * ((null !== (_a = lineHeight) && void 0 !== _a ? _a : fontSize) + 1) + 1
      };
    }
    return processor(text.toString());
  }
  _measureNumberChar() {
    if (isNil$1(this._numberCharSize)) {
      const numberBounds = this._standardMethod(TextMeasure.NUMBERS_CHAR_SET);
      this._numberCharSize = {
        width: numberBounds.width / TextMeasure.NUMBERS_CHAR_SET.length,
        height: numberBounds.height,
        fontBoundingBoxAscent: numberBounds.fontBoundingBoxAscent,
        fontBoundingBoxDescent: numberBounds.fontBoundingBoxDescent
      };
    }
    return this._numberCharSize;
  }
  _measureFullSizeChar() {
    return isNil$1(this._fullCharSize) && (this._fullCharSize = this._standardMethod(TextMeasure.FULL_SIZE_CHAR)), this._fullCharSize;
  }
  _measureLetterChar() {
    if (isNil$1(this._letterCharSize)) {
      const alphabetBounds = this._standardMethod(TextMeasure.ALPHABET_CHAR_SET);
      this._letterCharSize = {
        width: alphabetBounds.width / TextMeasure.ALPHABET_CHAR_SET.length,
        height: alphabetBounds.height,
        fontBoundingBoxAscent: alphabetBounds.fontBoundingBoxAscent,
        fontBoundingBoxDescent: alphabetBounds.fontBoundingBoxDescent
      };
    }
    return this._letterCharSize;
  }
  _measureSpecialChar(char) {
    return isValid$1(this._specialCharSizeMap[char]) ? this._specialCharSizeMap[char] : this.specialCharSet.includes(char) ? (this._specialCharSizeMap[char] = this._standardMethod(char), this._specialCharSizeMap[char]) : null;
  }
  release() {
    isValid$1(this._canvas) && (this._canvas = null), isValid$1(this._context) && (this._contextSaved && (this._context.restore(), this._contextSaved = !1), this._context = null);
  }
}
TextMeasure.ALPHABET_CHAR_SET = "abcdefghijklmnopqrstuvwxyz", TextMeasure.NUMBERS_CHAR_SET = "0123456789", TextMeasure.FULL_SIZE_CHAR = "字";

const calculateAnchorOfBounds = (bounds, anchorType) => {
  const {
      x1: x1,
      x2: x2,
      y1: y1,
      y2: y2
    } = bounds,
    rectWidth = Math.abs(x2 - x1),
    rectHeight = Math.abs(y2 - y1);
  let anchorX = (x1 + x2) / 2,
    anchorY = (y1 + y2) / 2,
    sx = 0,
    sy = 0;
  switch (anchorType) {
    case "top":
    case "inside-top":
      sy = -.5;
      break;
    case "bottom":
    case "inside-bottom":
      sy = .5;
      break;
    case "left":
    case "inside-left":
      sx = -.5;
      break;
    case "right":
    case "inside-right":
      sx = .5;
      break;
    case "top-right":
      sx = .5, sy = -.5;
      break;
    case "top-left":
      sx = -.5, sy = -.5;
      break;
    case "bottom-right":
      sx = .5, sy = .5;
      break;
    case "bottom-left":
      sx = -.5, sy = .5;
  }
  return anchorX += sx * rectWidth, anchorY += sy * rectHeight, {
    x: anchorX,
    y: anchorY
  };
};

function transformBoundsWithMatrix(out, bounds, matrix) {
  const {
    x1: x1,
    y1: y1,
    x2: x2,
    y2: y2
  } = bounds;
  return matrix.onlyTranslate() ? (out !== bounds && out.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), out.translate(matrix.e, matrix.f), bounds) : (out.clear(), out.add(matrix.a * x1 + matrix.c * y1 + matrix.e, matrix.b * x1 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y1 + matrix.e, matrix.b * x2 + matrix.d * y1 + matrix.f), out.add(matrix.a * x2 + matrix.c * y2 + matrix.e, matrix.b * x2 + matrix.d * y2 + matrix.f), out.add(matrix.a * x1 + matrix.c * y2 + matrix.e, matrix.b * x1 + matrix.d * y2 + matrix.f), bounds);
}
class Bounds {
  constructor(bounds) {
    bounds ? this.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2) : this.clear();
  }
  clone() {
    return new Bounds(this);
  }
  clear() {
    return this.x1 = +Number.MAX_VALUE, this.y1 = +Number.MAX_VALUE, this.x2 = -Number.MAX_VALUE, this.y2 = -Number.MAX_VALUE, this;
  }
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  }
  equals(b) {
    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
  }
  setValue() {
    let x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return this.x1 = x1, this.y1 = y1, this.x2 = x2, this.y2 = y2, this;
  }
  set() {
    let x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return x2 < x1 ? (this.x2 = x1, this.x1 = x2) : (this.x1 = x1, this.x2 = x2), y2 < y1 ? (this.y2 = y1, this.y1 = y2) : (this.y1 = y1, this.y2 = y2), this;
  }
  add() {
    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return x < this.x1 && (this.x1 = x), y < this.y1 && (this.y1 = y), x > this.x2 && (this.x2 = x), y > this.y2 && (this.y2 = y), this;
  }
  expand() {
    let d = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return isArray$1(d) ? (this.y1 -= d[0], this.x2 += d[1], this.y2 += d[2], this.x1 -= d[3]) : (this.x1 -= d, this.y1 -= d, this.x2 += d, this.y2 += d), this;
  }
  round() {
    return this.x1 = Math.floor(this.x1), this.y1 = Math.floor(this.y1), this.x2 = Math.ceil(this.x2), this.y2 = Math.ceil(this.y2), this;
  }
  translate() {
    let dx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let dy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return this.x1 += dx, this.x2 += dx, this.y1 += dy, this.y2 += dy, this;
  }
  rotate() {
    let angle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let x = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    const p = this.rotatedPoints(angle, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  }
  scale() {
    let sx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let sy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    const p = this.scalePoints(sx, sy, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]);
  }
  union(b) {
    return b.x1 < this.x1 && (this.x1 = b.x1), b.y1 < this.y1 && (this.y1 = b.y1), b.x2 > this.x2 && (this.x2 = b.x2), b.y2 > this.y2 && (this.y2 = b.y2), this;
  }
  intersect(b) {
    return b.x1 > this.x1 && (this.x1 = b.x1), b.y1 > this.y1 && (this.y1 = b.y1), b.x2 < this.x2 && (this.x2 = b.x2), b.y2 < this.y2 && (this.y2 = b.y2), this;
  }
  encloses(b) {
    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
  }
  alignsWith(b) {
    return b && (this.x1 === b.x1 || this.x2 === b.x2 || this.y1 === b.y1 || this.y2 === b.y2);
  }
  intersects(b) {
    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
  }
  contains() {
    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
  }
  containsPoint(p) {
    return !(p.x < this.x1 || p.x > this.x2 || p.y < this.y1 || p.y > this.y2);
  }
  width() {
    return this.empty() ? 0 : this.x2 - this.x1;
  }
  height() {
    return this.empty() ? 0 : this.y2 - this.y1;
  }
  scaleX() {
    let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return this.x1 *= s, this.x2 *= s, this;
  }
  scaleY() {
    let s = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return this.y1 *= s, this.y2 *= s, this;
  }
  transformWithMatrix(matrix) {
    return transformBoundsWithMatrix(this, this, matrix), this;
  }
  copy(b) {
    return this.x1 = b.x1, this.y1 = b.y1, this.x2 = b.x2, this.y2 = b.y2, this;
  }
  rotatedPoints(angle, x, y) {
    const {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      } = this,
      cos = Math.cos(angle),
      sin = Math.sin(angle),
      cx = x - x * cos + y * sin,
      cy = y - x * sin - y * cos;
    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
  }
  scalePoints(sx, sy, x, y) {
    const {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2
    } = this;
    return [sx * x1 + (1 - sx) * x, sy * y1 + (1 - sy) * y, sx * x2 + (1 - sx) * x, sy * y2 + (1 - sy) * y];
  }
}
class AABBBounds extends Bounds {}
class OBBBounds extends Bounds {
  constructor(bounds) {
    let angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var _a;
    super(bounds), bounds && (this.angle = null !== (_a = bounds.angle) && void 0 !== _a ? _a : angle);
  }
  intersects(b) {
    return isRotateAABBIntersect(this, b);
  }
  setValue() {
    let x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    let angle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    return super.setValue(x1, y1, x2, y2), this.angle = angle, this;
  }
  clone() {
    return new OBBBounds(this);
  }
}

class Matrix {
  constructor() {
    let a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let d = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    let e = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
    let f = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
    this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f;
  }
  equalToMatrix(m2) {
    return !(this.e !== m2.e || this.f !== m2.f || this.a !== m2.a || this.d !== m2.d || this.b !== m2.b || this.c !== m2.c);
  }
  equalTo(a, b, c, d, e, f) {
    return !(this.e !== e || this.f !== f || this.a !== a || this.d !== d || this.b !== b || this.c !== c);
  }
  setValue(a, b, c, d, e, f) {
    return this.a = a, this.b = b, this.c = c, this.d = d, this.e = e, this.f = f, this;
  }
  reset() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  getInverse() {
    const a = this.a,
      b = this.b,
      c = this.c,
      d = this.d,
      e = this.e,
      f = this.f,
      m = new Matrix(),
      dt = a * d - b * c;
    return m.a = d / dt, m.b = -b / dt, m.c = -c / dt, m.d = a / dt, m.e = (c * f - d * e) / dt, m.f = -(a * f - b * e) / dt, m;
  }
  rotate(rad) {
    const c = Math.cos(rad),
      s = Math.sin(rad),
      m11 = this.a * c + this.c * s,
      m12 = this.b * c + this.d * s,
      m21 = this.a * -s + this.c * c,
      m22 = this.b * -s + this.d * c;
    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this;
  }
  rotateByCenter(rad, cx, cy) {
    const cos = Math.cos(rad),
      sin = Math.sin(rad),
      rotateM13 = (1 - cos) * cx + sin * cy,
      rotateM23 = (1 - cos) * cy - sin * cx,
      m11 = cos * this.a - sin * this.b,
      m21 = sin * this.a + cos * this.b,
      m12 = cos * this.c - sin * this.d,
      m22 = sin * this.c + cos * this.d,
      m13 = cos * this.e - sin * this.f + rotateM13,
      m23 = sin * this.e + cos * this.f + rotateM23;
    return this.a = m11, this.b = m21, this.c = m12, this.d = m22, this.e = m13, this.f = m23, this;
  }
  scale(sx, sy) {
    return this.a *= sx, this.b *= sx, this.c *= sy, this.d *= sy, this;
  }
  setScale(sx, sy) {
    return this.b = this.b / this.a * sx, this.c = this.c / this.d * sy, this.a = sx, this.d = sy, this;
  }
  transform(a, b, c, d, e, f) {
    return this.multiply(a, b, c, d, e, f), this;
  }
  translate(x, y) {
    return this.e += this.a * x + this.c * y, this.f += this.b * x + this.d * y, this;
  }
  transpose() {
    const {
      a: a,
      b: b,
      c: c,
      d: d,
      e: e,
      f: f
    } = this;
    return this.a = b, this.b = a, this.c = d, this.d = c, this.e = f, this.f = e, this;
  }
  multiply(a2, b2, c2, d2, e2, f2) {
    const a1 = this.a,
      b1 = this.b,
      c1 = this.c,
      d1 = this.d,
      m11 = a1 * a2 + c1 * b2,
      m12 = b1 * a2 + d1 * b2,
      m21 = a1 * c2 + c1 * d2,
      m22 = b1 * c2 + d1 * d2,
      dx = a1 * e2 + c1 * f2 + this.e,
      dy = b1 * e2 + d1 * f2 + this.f;
    return this.a = m11, this.b = m12, this.c = m21, this.d = m22, this.e = dx, this.f = dy, this;
  }
  interpolate(m2, t) {
    const m = new Matrix();
    return m.a = this.a + (m2.a - this.a) * t, m.b = this.b + (m2.b - this.b) * t, m.c = this.c + (m2.c - this.c) * t, m.d = this.d + (m2.d - this.d) * t, m.e = this.e + (m2.e - this.e) * t, m.f = this.f + (m2.f - this.f) * t, m;
  }
  transformPoint(source, target) {
    const {
        a: a,
        b: b,
        c: c,
        d: d,
        e: e,
        f: f
      } = this,
      dt = a * d - b * c,
      nextA = d / dt,
      nextB = -b / dt,
      nextC = -c / dt,
      nextD = a / dt,
      nextE = (c * f - d * e) / dt,
      nextF = -(a * f - b * e) / dt,
      {
        x: x,
        y: y
      } = source;
    target.x = x * nextA + y * nextC + nextE, target.y = x * nextB + y * nextD + nextF;
  }
  onlyTranslate() {
    let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return this.a === scale && 0 === this.b && 0 === this.c && this.d === scale;
  }
  clone() {
    return new Matrix(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  toTransformAttrs() {
    const a = this.a,
      b = this.b,
      c = this.c,
      d = this.d,
      delta = a * d - b * c,
      result = {
        x: this.e,
        y: this.f,
        rotateDeg: 0,
        scaleX: 0,
        scaleY: 0,
        skewX: 0,
        skewY: 0
      };
    if (0 !== a || 0 !== b) {
      const r = Math.sqrt(a * a + b * b);
      result.rotateDeg = b > 0 ? Math.acos(a / r) : -Math.acos(a / r), result.scaleX = r, result.scaleY = delta / r, result.skewX = (a * c + b * d) / delta, result.skewY = 0;
    } else if (0 !== c || 0 !== d) {
      const s = Math.sqrt(c * c + d * d);
      result.rotateDeg = Math.PI / 2 - (d > 0 ? Math.acos(-c / s) : -Math.acos(c / s)), result.scaleX = delta / s, result.scaleY = s, result.skewX = 0, result.skewY = (a * c + b * d) / delta;
    }
    return result.rotateDeg = radianToDegree(result.rotateDeg), result;
  }
}
function normalTransform(out, origin, x, y, scaleX, scaleY, angle, rotateCenter) {
  const oa = origin.a,
    ob = origin.b,
    oc = origin.c,
    od = origin.d,
    oe = origin.e,
    of = origin.f,
    cosTheta = cos(angle),
    sinTheta = sin(angle);
  let rotateCenterX, rotateCenterY;
  rotateCenter ? (rotateCenterX = rotateCenter[0], rotateCenterY = rotateCenter[1]) : (rotateCenterX = x, rotateCenterY = y);
  const offsetX = rotateCenterX - x,
    offsetY = rotateCenterY - y,
    a1 = oa * cosTheta + oc * sinTheta,
    b1 = ob * cosTheta + od * sinTheta,
    c1 = oc * cosTheta - oa * sinTheta,
    d1 = od * cosTheta - ob * sinTheta;
  out.a = scaleX * a1, out.b = scaleX * b1, out.c = scaleY * c1, out.d = scaleY * d1, out.e = oe + oa * rotateCenterX + oc * rotateCenterY - a1 * offsetX - c1 * offsetY, out.f = of + ob * rotateCenterX + od * rotateCenterY - b1 * offsetX - d1 * offsetY;
}

class LRU {
  constructor() {
    this.CLEAN_THRESHOLD = 1e3, this.L_TIME = 1e3, this.R_COUNT = 1, this.R_TIMESTAMP_MAX_SIZE = 20;
  }
  clearCache(cache, params) {
    const {
      CLEAN_THRESHOLD = this.CLEAN_THRESHOLD,
      L_TIME = this.L_TIME,
      R_COUNT = this.R_COUNT
    } = params;
    if (cache.size < CLEAN_THRESHOLD) return 0;
    let clearNum = 0;
    const clear = key => {
        clearNum++, cache.delete(key);
      },
      now = Date.now();
    return cache.forEach((item, key) => {
      if (item.timestamp.length < R_COUNT) return clear(key);
      let useCount = 0;
      for (; now - item.timestamp[item.timestamp.length - 1 - useCount] < L_TIME && (useCount++, !(useCount >= R_COUNT)););
      if (useCount < R_COUNT) return clear(key);
      for (; now - item.timestamp[0] > L_TIME;) item.timestamp.shift();
    }), clearNum;
  }
  addLimitedTimestamp(cacheItem, t, params) {
    const {
      R_TIMESTAMP_MAX_SIZE = this.R_TIMESTAMP_MAX_SIZE
    } = params;
    cacheItem.timestamp.length > R_TIMESTAMP_MAX_SIZE && cacheItem.timestamp.shift(), cacheItem.timestamp.push(t);
  }
  clearTimeStamp(cache, params) {
    const {
        L_TIME = this.L_TIME
      } = params,
      now = Date.now();
    cache.forEach(item => {
      for (; now - item.timestamp[0] > L_TIME;) item.timestamp.shift();
    });
  }
  clearItemTimestamp(cacheItem, params) {
    const {
        L_TIME = this.L_TIME
      } = params,
      now = Date.now();
    for (; now - cacheItem.timestamp[0] > L_TIME;) cacheItem.timestamp.shift();
  }
}

function hslToRgb(h, s, l) {
  s /= 100, l /= 100;
  const c = (1 - Math.abs(2 * l - 1)) * s,
    x = c * (1 - Math.abs(h / 60 % 2 - 1)),
    m = l - c / 2;
  let r = 0,
    g = 0,
    b = 0;
  return 0 <= h && h < 60 ? (r = c, g = x, b = 0) : 60 <= h && h < 120 ? (r = x, g = c, b = 0) : 120 <= h && h < 180 ? (r = 0, g = c, b = x) : 180 <= h && h < 240 ? (r = 0, g = x, b = c) : 240 <= h && h < 300 ? (r = x, g = 0, b = c) : 300 <= h && h < 360 && (r = c, g = 0, b = x), r = Math.round(255 * (r + m)), g = Math.round(255 * (g + m)), b = Math.round(255 * (b + m)), {
    r: r,
    g: g,
    b: b
  };
}

function rgbToHsl(r, g, b) {
  r /= 255, g /= 255, b /= 255;
  const cMin = Math.min(r, g, b),
    cMax = Math.max(r, g, b),
    delta = cMax - cMin;
  let h = 0,
    s = 0,
    l = 0;
  return h = 0 === delta ? 0 : cMax === r ? (g - b) / delta % 6 : cMax === g ? (b - r) / delta + 2 : (r - g) / delta + 4, h = Math.round(60 * h), h < 0 && (h += 360), l = (cMax + cMin) / 2, s = 0 === delta ? 0 : delta / (1 - Math.abs(2 * l - 1)), s = +(100 * s).toFixed(1), l = +(100 * l).toFixed(1), {
    h: h,
    s: s,
    l: l
  };
}

const REG_HEX = /^#([0-9a-f]{3,8})$/,
  DEFAULT_COLORS_OPACITY = {
    transparent: 4294967040
  };
const DEFAULT_COLORS = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
function hex(value) {
  return ((value = Math.max(0, Math.min(255, Math.round(value) || 0))) < 16 ? "0" : "") + value.toString(16);
}
function rgb(value) {
  return isNumber$1(value) ? new RGB(value >> 16, value >> 8 & 255, 255 & value, 1) : isArray$1(value) ? new RGB(value[0], value[1], value[2]) : new RGB(255, 255, 255);
}
function rgba(value) {
  return isNumber$1(value) ? new RGB(value >>> 24, value >>> 16 & 255, value >>> 8 & 255, 255 & value) : isArray$1(value) ? new RGB(value[0], value[1], value[2], value[3]) : new RGB(255, 255, 255, 1);
}
function SRGBToLinear(c) {
  return c < .04045 ? .0773993808 * c : Math.pow(.9478672986 * c + .0521327014, 2.4);
}
function LinearToSRGB(c) {
  return c < .0031308 ? 12.92 * c : 1.055 * Math.pow(c, .41666) - .055;
}
const setHex = (formatValue, forceHex) => {
  const isHex = REG_HEX.exec(formatValue);
  if (forceHex || isHex) {
    const hex = parseInt(isHex[1], 16),
      hexLength = isHex[1].length;
    return 3 === hexLength ? new RGB((hex >> 8 & 15) + ((hex >> 8 & 15) << 4), (hex >> 4 & 15) + ((hex >> 4 & 15) << 4), (15 & hex) + ((15 & hex) << 4), 1) : 6 === hexLength ? rgb(hex) : 8 === hexLength ? new RGB(hex >> 24 & 255, hex >> 16 & 255, hex >> 8 & 255, (255 & hex) / 255) : null;
  }
};
class Color {
  static Brighter(source) {
    let b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return 1 === b ? source : new Color(source).brighter(b).toRGBA();
  }
  static SetOpacity(source) {
    let o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return 1 === o ? source : new Color(source).setOpacity(o).toRGBA();
  }
  static getColorBrightness(source) {
    let model = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "hsl";
    const color = source instanceof Color ? source : new Color(source);
    switch (model) {
      case "hsv":
      default:
        return color.getHSVBrightness();
      case "hsl":
        return color.getHSLBrightness();
      case "lum":
        return color.getLuminance();
      case "lum2":
        return color.getLuminance2();
      case "lum3":
        return color.getLuminance3();
      case "wcag":
        return color.getLuminanceWCAG();
    }
  }
  static parseColorString(value) {
    if (isValid$1(DEFAULT_COLORS_OPACITY[value])) return rgba(DEFAULT_COLORS_OPACITY[value]);
    if (isValid$1(DEFAULT_COLORS[value])) return rgb(DEFAULT_COLORS[value]);
    const formatValue = `${value}`.trim().toLowerCase(),
      hexRes = setHex(formatValue);
    if (void 0 !== hexRes) return hexRes;
    if (/^(rgb|RGB|rgba|RGBA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|rgba|RGBA|rgb|RGB)*/g, "").split(",");
      return new RGB(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10), parseFloat(aColor[3]));
    }
    if (/^(hsl|HSL|hsla|HSLA)/.test(formatValue)) {
      const aColor = formatValue.replace(/(?:\(|\)|hsla|HSLA|hsl|HSL)*/g, "").split(","),
        rgb = hslToRgb(parseInt(aColor[0], 10), parseInt(aColor[1], 10), parseInt(aColor[2], 10));
      return new RGB(rgb.r, rgb.g, rgb.b, parseFloat(aColor[3]));
    }
  }
  constructor(value) {
    const color = Color.parseColorString(value);
    color ? this.color = color : (console.warn(`Warn: 传入${value}无法解析为Color`), this.color = new RGB(255, 255, 255));
  }
  toRGBA() {
    return this.color.formatRgb();
  }
  toString() {
    return this.color.formatRgb();
  }
  toHex() {
    return this.color.formatHex();
  }
  toHsl() {
    return this.color.formatHsl();
  }
  brighter(k) {
    const {
      r: r,
      g: g,
      b: b
    } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r * k))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * k))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * k))), this;
  }
  add(color) {
    const {
      r: r,
      g: g,
      b: b
    } = this.color;
    return this.color.r += Math.min(255, r + color.color.r), this.color.g += Math.min(255, g + color.color.g), this.color.b += Math.min(255, b + color.color.b), this;
  }
  sub(color) {
    return this.color.r = Math.max(0, this.color.r - color.color.r), this.color.g = Math.max(0, this.color.g - color.color.g), this.color.b = Math.max(0, this.color.b - color.color.b), this;
  }
  multiply(color) {
    const {
      r: r,
      g: g,
      b: b
    } = this.color;
    return this.color.r = Math.max(0, Math.min(255, Math.floor(r * color.color.r))), this.color.g = Math.max(0, Math.min(255, Math.floor(g * color.color.g))), this.color.b = Math.max(0, Math.min(255, Math.floor(b * color.color.b))), this;
  }
  getHSVBrightness() {
    return Math.max(this.color.r, this.color.g, this.color.b) / 255;
  }
  getHSLBrightness() {
    return .5 * (Math.max(this.color.r, this.color.g, this.color.b) / 255 + Math.min(this.color.r, this.color.g, this.color.b) / 255);
  }
  setHsl(h, s, l) {
    const opacity = this.color.opacity,
      hsl = rgbToHsl(this.color.r, this.color.g, this.color.b),
      rgb = hslToRgb(isNil$1(h) ? hsl.h : clamp$1(h, 0, 360), isNil$1(s) ? hsl.s : s >= 0 && s <= 1 ? 100 * s : s, isNil$1(l) ? hsl.l : l <= 1 && l >= 0 ? 100 * l : l);
    return this.color = new RGB(rgb.r, rgb.g, rgb.b, opacity), this;
  }
  setRGB(r, g, b) {
    return !isNil$1(r) && (this.color.r = r), !isNil$1(g) && (this.color.g = g), !isNil$1(b) && (this.color.b = b), this;
  }
  setHex(value) {
    const formatValue = `${value}`.trim().toLowerCase(),
      res = setHex(formatValue, !0);
    return null != res ? res : this;
  }
  setColorName(name) {
    const hex = DEFAULT_COLORS[name.toLowerCase()];
    return void 0 !== hex ? this.setHex(hex) : console.warn("THREE.Color: Unknown color " + name), this;
  }
  setScalar(scalar) {
    return this.color.r = scalar, this.color.g = scalar, this.color.b = scalar, this;
  }
  setOpacity() {
    let o = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    return this.color.opacity = o, this;
  }
  getLuminance() {
    return (.2126 * this.color.r + .7152 * this.color.g + .0722 * this.color.b) / 255;
  }
  getLuminance2() {
    return (.2627 * this.color.r + .678 * this.color.g + .0593 * this.color.b) / 255;
  }
  getLuminance3() {
    return (.299 * this.color.r + .587 * this.color.g + .114 * this.color.b) / 255;
  }
  getLuminanceWCAG() {
    const RsRGB = this.color.r / 255,
      GsRGB = this.color.g / 255,
      BsRGB = this.color.b / 255;
    let R, G, B;
    R = RsRGB <= .03928 ? RsRGB / 12.92 : Math.pow((RsRGB + .055) / 1.055, 2.4), G = GsRGB <= .03928 ? GsRGB / 12.92 : Math.pow((GsRGB + .055) / 1.055, 2.4), B = BsRGB <= .03928 ? BsRGB / 12.92 : Math.pow((BsRGB + .055) / 1.055, 2.4);
    return .2126 * R + .7152 * G + .0722 * B;
  }
  clone() {
    return new Color(this.color.toString());
  }
  copyGammaToLinear(color) {
    let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    return this.color.r = Math.pow(color.color.r, gammaFactor), this.color.g = Math.pow(color.color.g, gammaFactor), this.color.b = Math.pow(color.color.b, gammaFactor), this;
  }
  copyLinearToGamma(color) {
    let gammaFactor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    const safeInverse = gammaFactor > 0 ? 1 / gammaFactor : 1;
    return this.color.r = Math.pow(color.color.r, safeInverse), this.color.g = Math.pow(color.color.g, safeInverse), this.color.b = Math.pow(color.color.b, safeInverse), this;
  }
  convertGammaToLinear(gammaFactor) {
    return this.copyGammaToLinear(this, gammaFactor), this;
  }
  convertLinearToGamma(gammaFactor) {
    return this.copyLinearToGamma(this, gammaFactor), this;
  }
  copySRGBToLinear(color) {
    return this.color.r = SRGBToLinear(color.color.r), this.color.g = SRGBToLinear(color.color.g), this.color.b = SRGBToLinear(color.color.b), this;
  }
  copyLinearToSRGB(color) {
    return this.color.r = LinearToSRGB(color.color.r), this.color.g = LinearToSRGB(color.color.g), this.color.b = LinearToSRGB(color.color.b), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
}
class RGB {
  constructor(r, g, b, opacity) {
    this.r = isNaN(+r) ? 255 : Math.max(0, Math.min(255, +r)), this.g = isNaN(+g) ? 255 : Math.max(0, Math.min(255, +g)), this.b = isNaN(+b) ? 255 : Math.max(0, Math.min(255, +b)), isValid$1(opacity) ? this.opacity = isNaN(+opacity) ? 1 : Math.max(0, Math.min(1, +opacity)) : this.opacity = 1;
  }
  formatHex() {
    return `#${hex(this.r) + hex(this.g) + hex(this.b) + (1 === this.opacity ? "" : hex(255 * this.opacity))}`;
  }
  formatRgb() {
    const opacity = this.opacity;
    return `${1 === opacity ? "rgb(" : "rgba("}${this.r},${this.g},${this.b}${1 === opacity ? ")" : `,${opacity})`}`;
  }
  formatHsl() {
    const opacity = this.opacity,
      {
        h: h,
        s: s,
        l: l
      } = rgbToHsl(this.r, this.g, this.b);
    return `${1 === opacity ? "hsl(" : "hsla("}${h},${s}%,${l}%${1 === opacity ? ")" : `,${opacity})`}`;
  }
  toString() {
    return this.formatHex();
  }
}

const styleStringToObject = function () {
  let styleStr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
  const res = {};
  return styleStr.split(";").forEach(item => {
    if (item) {
      const arr = item.split(":");
      if (2 === arr.length) {
        const key = arr[0].trim(),
          value = arr[1].trim();
        key && value && (res[key] = value);
      }
    }
  }), res;
};
const lowerCamelCaseToMiddle = str => str.replace(/([A-Z])/g, "-$1").toLowerCase();

const circleThreshold = tau - 1e-8;
class BoundsContext {
  constructor(bounds) {
    this.init(bounds);
  }
  init(bounds) {
    this.bounds = bounds;
  }
  arc(cx, cy, r, sa, ea, ccw) {
    if (Math.abs(ea - sa) > circleThreshold) return this.bounds.add(cx - r, cy - r), void this.bounds.add(cx + r, cy + r);
    let s,
      i,
      x,
      y,
      xmin = 1 / 0,
      xmax = -1 / 0,
      ymin = 1 / 0,
      ymax = -1 / 0;
    function update(a) {
      x = r * Math.cos(a), y = r * Math.sin(a), x < xmin && (xmin = x), x > xmax && (xmax = x), y < ymin && (ymin = y), y > ymax && (ymax = y);
    }
    if (update(sa), update(ea), ea !== sa) if ((sa %= tau) < 0 && (sa += tau), (ea %= tau) < 0 && (ea += tau), ea < sa && (ccw = !ccw, s = sa, sa = ea, ea = s), ccw) for (ea -= tau, s = sa - sa % halfPi$1, i = 0; i < 4 && s > ea; ++i, s -= halfPi$1) update(s);else for (s = sa - sa % halfPi$1 + halfPi$1, i = 0; i < 4 && s < ea; ++i, s += halfPi$1) update(s);
    this.bounds.add(cx + xmin, cy + ymin), this.bounds.add(cx + xmax, cy + ymax);
  }
  arcTo(x1, y1, x2, y2, radius) {
    this.bounds.add(x1, y1);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.bounds.add(cp1x, cp1y), this.bounds.add(cp2x, cp2y), this.bounds.add(x, y);
  }
  closePath() {}
  ellipse() {
    throw new Error("不支持ellipse");
  }
  lineTo(x, y) {
    this.bounds.add(x, y);
  }
  moveTo(x, y) {
    this.bounds.add(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.bounds.add(cpx, cpy), this.bounds.add(x, y);
  }
  rect(x, y, w, h) {
    this.bounds.add(x, y), this.bounds.add(x + w, y + h);
  }
  clear() {
    this.bounds.clear();
  }
  release() {}
}

class CurvePath {
  constructor() {
    this._curves = [], this.bounds = new AABBBounds();
  }
  get curves() {
    return this._curves;
  }
  getCurveLengths() {
    return this._curves.map(curve => curve.getLength());
  }
  getPointAt(t) {
    return {
      x: 0,
      y: 0
    };
  }
  getLength() {
    return 0;
  }
  getBounds() {
    return this.bounds;
  }
}

const rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/gi,
  commandLengths = {
    m: 2,
    l: 2,
    h: 1,
    v: 1,
    c: 6,
    s: 4,
    q: 4,
    t: 2,
    a: 7,
    M: 2,
    L: 2,
    H: 1,
    V: 1,
    C: 6,
    S: 4,
    Q: 4,
    T: 2,
    A: 7
  };
const enumCommandMap = {
  A: 0,
  AT: 1,
  C: 2,
  Z: 3,
  E: 4,
  L: 5,
  M: 6,
  Q: 7,
  R: 8
};
let currPath, coordsStr, commandChar, coordStr, coordNumber, standardCommandLen;
function parseSvgPath(str) {
  if (!str) return [];
  const paths = str.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
  if (null === paths) return [];
  let currCommandData, coordsStrArr;
  const result = [];
  for (let i = 0, len = paths.length; i < len; i++) if (currPath = paths[i], coordsStr = currPath.slice(1), commandChar = currPath[0], currCommandData = [commandChar], coordsStrArr = coordsStr.match(rePathCommand), null !== coordsStrArr) {
    for (let i = 0, len = coordsStrArr.length; i < len; i++) coordStr = coordsStrArr[i], coordNumber = parseFloat(coordStr), Number.isNaN(coordNumber) || currCommandData.push(coordNumber);
    if (standardCommandLen = commandLengths[commandChar], currCommandData.length - 1 > standardCommandLen) {
      let subCommand,
        bestCommandChar = commandChar;
      for (let i = 1, len = currCommandData.length; i < len; i += standardCommandLen) {
        subCommand = [bestCommandChar];
        for (let j = i, subLen = i + standardCommandLen; j < subLen; j++) subCommand.push(currCommandData[j]);
        result.push(subCommand), "m" === bestCommandChar ? bestCommandChar = "l" : "M" === bestCommandChar && (bestCommandChar = "L");
      }
    } else result.push(currCommandData);
  } else result.push(currCommandData);
  return result;
}

var UpdateTag;
!function (UpdateTag) {
  UpdateTag[UpdateTag.NONE = 0] = "NONE", UpdateTag[UpdateTag.UPDATE_BOUNDS = 1] = "UPDATE_BOUNDS", UpdateTag[UpdateTag.UPDATE_SHAPE = 2] = "UPDATE_SHAPE", UpdateTag[UpdateTag.CLEAR_SHAPE = 253] = "CLEAR_SHAPE", UpdateTag[UpdateTag.UPDATE_SHAPE_AND_BOUNDS = 3] = "UPDATE_SHAPE_AND_BOUNDS", UpdateTag[UpdateTag.INIT = 179] = "INIT", UpdateTag[UpdateTag.CLEAR_BOUNDS = 254] = "CLEAR_BOUNDS", UpdateTag[UpdateTag.UPDATE_GLOBAL_MATRIX = 32] = "UPDATE_GLOBAL_MATRIX", UpdateTag[UpdateTag.CLEAR_GLOBAL_MATRIX = 223] = "CLEAR_GLOBAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LOCAL_MATRIX = 16] = "UPDATE_LOCAL_MATRIX", UpdateTag[UpdateTag.CLEAR_LOCAL_MATRIX = 239] = "CLEAR_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX = 48] = "UPDATE_GLOBAL_LOCAL_MATRIX", UpdateTag[UpdateTag.UPDATE_LAYOUT = 128] = "UPDATE_LAYOUT", UpdateTag[UpdateTag.CLEAR_LAYOUT = 127] = "CLEAR_LAYOUT";
}(UpdateTag || (UpdateTag = {}));
var IContainPointMode;
!function (IContainPointMode) {
  IContainPointMode[IContainPointMode.GLOBAL = 1] = "GLOBAL", IContainPointMode[IContainPointMode.LOCAL = 16] = "LOCAL", IContainPointMode[IContainPointMode.GLOBAL_ACCURATE = 3] = "GLOBAL_ACCURATE", IContainPointMode[IContainPointMode.LOCAL_ACCURATE = 48] = "LOCAL_ACCURATE";
}(IContainPointMode || (IContainPointMode = {}));
var AttributeUpdateType;
!function (AttributeUpdateType) {
  AttributeUpdateType[AttributeUpdateType.INIT = 0] = "INIT", AttributeUpdateType[AttributeUpdateType.DEFAULT = 1] = "DEFAULT", AttributeUpdateType[AttributeUpdateType.STATE = 2] = "STATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_BIND = 10] = "ANIMATE_BIND", AttributeUpdateType[AttributeUpdateType.ANIMATE_PLAY = 11] = "ANIMATE_PLAY", AttributeUpdateType[AttributeUpdateType.ANIMATE_START = 12] = "ANIMATE_START", AttributeUpdateType[AttributeUpdateType.ANIMATE_UPDATE = 13] = "ANIMATE_UPDATE", AttributeUpdateType[AttributeUpdateType.ANIMATE_END = 14] = "ANIMATE_END", AttributeUpdateType[AttributeUpdateType.TRANSLATE = 20] = "TRANSLATE", AttributeUpdateType[AttributeUpdateType.TRANSLATE_TO = 21] = "TRANSLATE_TO", AttributeUpdateType[AttributeUpdateType.SCALE = 22] = "SCALE", AttributeUpdateType[AttributeUpdateType.SCALE_TO = 23] = "SCALE_TO", AttributeUpdateType[AttributeUpdateType.ROTATE = 24] = "ROTATE", AttributeUpdateType[AttributeUpdateType.ROTATE_TO = 25] = "ROTATE_TO";
}(AttributeUpdateType || (AttributeUpdateType = {}));
var AnimateStatus;
!function (AnimateStatus) {
  AnimateStatus[AnimateStatus.INITIAL = 0] = "INITIAL", AnimateStatus[AnimateStatus.RUNNING = 1] = "RUNNING", AnimateStatus[AnimateStatus.PAUSED = 2] = "PAUSED", AnimateStatus[AnimateStatus.END = 3] = "END";
}(AnimateStatus || (AnimateStatus = {}));
var AnimateMode;
!function (AnimateMode) {
  AnimateMode[AnimateMode.NORMAL = 0] = "NORMAL", AnimateMode[AnimateMode.SET_ATTR_IMMEDIATELY = 1] = "SET_ATTR_IMMEDIATELY";
}(AnimateMode || (AnimateMode = {}));
var AnimateStepType;
!function (AnimateStepType) {
  AnimateStepType.wait = "wait", AnimateStepType.from = "from", AnimateStepType.to = "to", AnimateStepType.customAnimate = "customAnimate";
}(AnimateStepType || (AnimateStepType = {}));
var Direction$1;
!function (Direction) {
  Direction[Direction.ROW = 1] = "ROW", Direction[Direction.COLUMN = 2] = "COLUMN";
}(Direction$1 || (Direction$1 = {}));
var CurveTypeEnum;
!function (CurveTypeEnum) {
  CurveTypeEnum[CurveTypeEnum.CubicBezierCurve = 0] = "CubicBezierCurve", CurveTypeEnum[CurveTypeEnum.QuadraticBezierCurve = 1] = "QuadraticBezierCurve", CurveTypeEnum[CurveTypeEnum.ArcCurve = 2] = "ArcCurve", CurveTypeEnum[CurveTypeEnum.LineCurve = 3] = "LineCurve", CurveTypeEnum[CurveTypeEnum.EllipseCurve = 4] = "EllipseCurve", CurveTypeEnum[CurveTypeEnum.MoveCurve = 5] = "MoveCurve";
}(CurveTypeEnum || (CurveTypeEnum = {}));
var BaseRenderContributionTime;
!function (BaseRenderContributionTime) {
  BaseRenderContributionTime[BaseRenderContributionTime.beforeFillStroke = 0] = "beforeFillStroke", BaseRenderContributionTime[BaseRenderContributionTime.afterFillStroke = 1] = "afterFillStroke";
}(BaseRenderContributionTime || (BaseRenderContributionTime = {}));

function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  const th = degreeToRadian(rotateX),
    sin_th = Math.sin(th),
    cos_th = Math.cos(th),
    px = cos_th * (ox - x) * .5 + sin_th * (oy - y) * .5,
    py = cos_th * (oy - y) * .5 - sin_th * (ox - x) * .5;
  let pl = px * px / ((rx = Math.abs(rx)) * rx) + py * py / ((ry = Math.abs(ry)) * ry);
  pl > 1 && (pl = Math.sqrt(pl), rx *= pl, ry *= pl);
  const a00 = cos_th / rx,
    a01 = sin_th / rx,
    a10 = -sin_th / ry,
    a11 = cos_th / ry,
    x0 = a00 * ox + a01 * oy,
    y0 = a10 * ox + a11 * oy,
    x1 = a00 * x + a01 * y,
    y1 = a10 * x + a11 * y;
  let sfactor_sq = 1 / ((x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0)) - .25;
  sfactor_sq < 0 && (sfactor_sq = 0);
  let sfactor = Math.sqrt(sfactor_sq);
  sweep === large && (sfactor = -sfactor);
  const xc = .5 * (x0 + x1) - sfactor * (y1 - y0),
    yc = .5 * (y0 + y1) + sfactor * (x1 - x0),
    th0 = Math.atan2(y0 - yc, x0 - xc);
  let th_arc = Math.atan2(y1 - yc, x1 - xc) - th0;
  th_arc < 0 && 1 === sweep ? th_arc += tau : th_arc > 0 && 0 === sweep && (th_arc -= tau);
  const segs = Math.ceil(Math.abs(th_arc / (halfPi$1 + .001))),
    result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs,
      th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return result;
}
function bezier(params) {
  const cx = params[0],
    cy = params[1],
    th0 = params[2],
    th1 = params[3],
    rx = params[4],
    ry = params[5],
    sin_th = params[6],
    cos_th = params[7],
    a00 = cos_th * rx,
    a01 = -sin_th * ry,
    a10 = sin_th * rx,
    a11 = cos_th * ry,
    cos_th0 = Math.cos(th0),
    sin_th0 = Math.sin(th0),
    cos_th1 = Math.cos(th1),
    sin_th1 = Math.sin(th1),
    th_half = .5 * (th1 - th0),
    sin_th_h2 = Math.sin(.5 * th_half),
    t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half),
    x1 = cx + cos_th0 - t * sin_th0,
    y1 = cy + sin_th0 + t * cos_th0,
    x3 = cx + cos_th1,
    y3 = cy + sin_th1,
    x2 = x3 + t * sin_th1,
    y2 = y3 - t * cos_th1;
  return [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}
function drawArc(context, x, y, coords) {
  const seg = segments(coords[5], coords[6], coords[0], coords[1], coords[3], coords[4], coords[2], x, y);
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}
const addArcToBezierPath$1 = (bezierPath, startAngle, endAngle, cx, cy, rx, ry) => {
  const delta = Math.abs(endAngle - startAngle),
    count = delta > .5 * Math.PI ? Math.ceil(2 * delta / Math.PI) : 1,
    stepAngle = (endAngle - startAngle) / count;
  for (let i = 0; i < count; i++) {
    const sa = startAngle + stepAngle * i,
      ea = startAngle + stepAngle * (i + 1),
      len = 4 * Math.tan(Math.abs(stepAngle) / 4) / 3,
      dir = ea < sa ? -1 : 1,
      c1 = Math.cos(sa),
      s1 = Math.sin(sa),
      c2 = Math.cos(ea),
      s2 = Math.sin(ea),
      x1 = c1 * rx + cx,
      y1 = s1 * ry + cy,
      x4 = c2 * rx + cx,
      y4 = s2 * ry + cy,
      hx = rx * len * dir,
      hy = ry * len * dir;
    bezierPath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);
  }
};

const commandFuncs = [(command, context, x, y, sx, sy, z) => context.arc(command[1] * sx + x, command[2] * sy + y, command[3] * (sx + sy) / 2, command[4], command[5], command[6], z), (command, context, x, y, sx, sy, z) => context.arcTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * (sx + sy) / 2, z), (command, context, x, y, sx, sy, z) => context.bezierCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, command[5] * sx + x, command[6] * sy + y, z), (command, context, x, y) => context.closePath(), (command, context, x, y, sx, sy) => context.ellipse(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, command[5], command[6], command[7], command[8]), (command, context, x, y, sx, sy, z) => context.lineTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.moveTo(command[1] * sx + x, command[2] * sy + y, z), (command, context, x, y, sx, sy, z) => context.quadraticCurveTo(command[1] * sx + x, command[2] * sy + y, command[3] * sx + x, command[4] * sy + y, z), (command, context, x, y, sx, sy, z) => context.rect(command[1] * sx + x, command[2] * sy + y, command[3] * sx, command[4] * sy, z)];
function renderCommandList(commandList, context) {
  let x = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  let y = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  let sx = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
  let sy = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
  let z = arguments.length > 6 ? arguments[6] : undefined;
  for (let i = 0; i < commandList.length; i++) {
    const command = commandList[i];
    commandFuncs[command[0]](command, context, x, y, sx, sy, z);
  }
}

class Curve {
  getLength(direction) {
    return null != direction ? this.calcProjLength(direction) : (Number.isFinite(this.length) || (this.length = this.calcLength()), this.length);
  }
}

function snapLength(xArr, yArr) {
  let totalLength = 0;
  const count = xArr.length;
  for (let i = 0; i < count; i++) {
    const x = xArr[i],
      y = yArr[i],
      nextX = xArr[(i + 1) % count],
      nextY = yArr[(i + 1) % count];
    totalLength += PointService.distanceNN(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function cubicLength(p0, p1, p2, p3, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x, p3.x], [p0.y, p1.y, p2.y, p3.y]);
}
function cubicCalc(p0, p1, p2, p3, t) {
  const one = 1 - t;
  return one * one * one * p0 + 3 * p1 * t * one * one + 3 * p2 * t * t * one + p3 * t * t * t;
}
function cubicPointAt(p0, p1, p2, p3, t) {
  const x = cubicCalc(p0.x, p1.x, p2.x, p3.x, t),
    y = cubicCalc(p0.y, p1.y, p2.y, p3.y, t);
  return new Point(x, y);
}
function quadCalc(p0, p1, p2, t) {
  const one = 1 - t;
  return one * one * p0 + 2 * one * t * p1 + t * t * p2;
}
function quadPointAt(p0, p1, p2, t) {
  const x = quadCalc(p0.x, p1.x, p2.x, t),
    y = quadCalc(p0.y, p1.y, p2.y, t);
  return new Point(x, y);
}
function quadLength(p0, p1, p2, iterationCount) {
  return snapLength([p0.x, p1.x, p2.x], [p0.y, p1.y, p2.y]);
}

class QuadraticBezierCurve extends Curve {
  constructor(p0, p1, p2) {
    super(), this.type = CurveTypeEnum.QuadraticBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y);
  }
  getPointAt(t) {
    if (!1 !== this.defined) return quadPointAt(this.p0, this.p1, this.p2, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? quadLength(this.p0, this.p1, this.p2) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction$1.ROW ? abs(this.p0.x - this.p2.x) : direction === Direction$1.COLUMN ? abs(this.p0.y - this.p2.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - .01, 0),
      maxT = min(t + .01, 1),
      minP = this.getPointAt(minT),
      maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.quadraticCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y);else if (percent > 0) {
      const [curve1] = divideQuad(this, percent);
      path.quadraticCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y);
    }
  }
  getYAt(x) {
    throw new Error("QuadraticBezierCurve暂不支持getYAt");
  }
  includeX(x) {
    throw new Error("QuadraticBezierCurve暂不支持includeX");
  }
}

function divideCubic(curve, t) {
  const {
      p0: p0,
      p1: p1,
      p2: p2,
      p3: p3
    } = curve,
    pt = cubicPointAt(p0, p1, p2, p3, t),
    c1 = PointService.pointAtPP(p0, p1, t),
    c2 = PointService.pointAtPP(p1, p2, t),
    c3 = PointService.pointAtPP(p2, p3, t),
    c12 = PointService.pointAtPP(c1, c2, t),
    c23 = PointService.pointAtPP(c2, c3, t);
  return [new CubicBezierCurve(p0, c1, c12, pt), new CubicBezierCurve(pt, c23, c3, p3)];
}
function divideQuad(curve, t) {
  const {
      p0: p0,
      p1: p1,
      p2: p2
    } = curve,
    pt = quadPointAt(p0, p1, p2, t),
    c1 = PointService.pointAtPP(p0, p1, t),
    c2 = PointService.pointAtPP(p1, p2, t);
  return [new QuadraticBezierCurve(p0, c1, pt), new QuadraticBezierCurve(pt, c2, p2)];
}
class CubicBezierCurve extends Curve {
  constructor(p0, p1, p2, p3) {
    super(), this.type = CurveTypeEnum.CubicBezierCurve, this.p0 = p0, this.p1 = p1, this.p2 = p2, this.p3 = p3;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y + this.p2.x + this.p2.y + this.p3.x + this.p3.y);
  }
  getPointAt(t) {
    if (!1 !== this.defined) return cubicPointAt(this.p0, this.p1, this.p2, this.p3, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  calcLength() {
    return this._validPoint() ? cubicLength(this.p0, this.p1, this.p2, this.p3) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction$1.ROW ? abs(this.p0.x - this.p3.x) : direction === Direction$1.COLUMN ? abs(this.p0.y - this.p3.y) : 0;
  }
  getAngleAt(t) {
    const minT = max(t - .01, 0),
      maxT = min(t + .01, 1),
      minP = this.getPointAt(minT),
      maxP = this.getPointAt(maxT);
    return atan2(maxP.y - minP.y, maxP.x - minP.x);
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.bezierCurveTo(this.p1.x * sx + x, this.p1.y * sy + y, this.p2.x * sx + x, this.p2.y * sy + y, this.p3.x * sx + x, this.p3.y * sy + y);else if (percent > 0) {
      const [curve1] = divideCubic(this, percent);
      path.bezierCurveTo(curve1.p1.x * sx + x, curve1.p1.y * sy + y, curve1.p2.x * sx + x, curve1.p2.y * sy + y, curve1.p3.x * sx + x, curve1.p3.y * sy + y);
    }
  }
  includeX(x) {
    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x),
      maxX = max(this.p0.x, this.p1.x, this.p2.x, this.p3.x);
    return x >= minX && x <= maxX;
  }
  getYAt(x) {
    const minX = min(this.p0.x, this.p1.x, this.p2.x, this.p3.x),
      t = (x - minX) / (max(this.p0.x, this.p1.x, this.p2.x, this.p3.x) - minX);
    return this.getPointAt(t).y;
  }
}

function divideLinear(curve, t) {
  const {
      p0: p0,
      p1: p1
    } = curve,
    c1 = PointService.pointAtPP(p0, p1, t);
  return [new LineCurve(p0, c1), new LineCurve(c1, p1)];
}
class LineCurve extends Curve {
  constructor(p0, p1) {
    super(), this.type = CurveTypeEnum.LineCurve, this.p0 = p0, this.p1 = p1;
  }
  getPointAt(t) {
    if (!1 !== this.defined) return PointService.pointAtPP(this.p0, this.p1, t);
    throw new Error("defined为false的点不能getPointAt");
  }
  getAngleAt(t) {
    return null == this.angle && (this.angle = atan2(this.p1.y - this.p0.y, this.p1.x - this.p0.x)), this.angle;
  }
  _validPoint() {
    return Number.isFinite(this.p0.x + this.p0.y + this.p1.x + this.p1.y);
  }
  calcLength() {
    return this._validPoint() ? PointService.distancePP(this.p0, this.p1) : 60;
  }
  calcProjLength(direction) {
    return direction === Direction$1.ROW ? abs(this.p0.x - this.p1.x) : direction === Direction$1.COLUMN ? abs(this.p0.y - this.p1.y) : 0;
  }
  draw(path, x, y, sx, sy, percent) {
    if (path.moveTo(this.p0.x * sx + x, this.p0.y * sy + y), percent >= 1) path.lineTo(this.p1.x * sx + x, this.p1.y * sy + y);else if (percent > 0) {
      const p = this.getPointAt(percent);
      path.lineTo(p.x * sx + x, p.y * sy + y);
    }
  }
  includeX(x) {
    return x >= this.p0.x && x <= this.p1.x || x >= this.p1.x && x <= this.p0.x;
  }
  getYAt(x) {
    if (this.includeX(x)) {
      let minP = this.p0,
        maxP = this.p1;
      this.p0.x > this.p1.x && (minP = this.p1, maxP = this.p0);
      const percent = (x - minP.x) / (maxP.x - minP.x);
      return minP.y + percent * (maxP.y - minP.y);
    }
    return 1 / 0;
  }
}

class SegContext {
  get endX() {
    return this._lastX;
  }
  get endY() {
    return this._lastY;
  }
  constructor(curveType, direction) {
    this.init(curveType, direction);
  }
  init(curveType, direction) {
    this._lastX = this._lastY = this._startX = this._startY = 0, this.curveType = curveType, this.direction = direction, this.curves = [];
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    curve.originP1 = this._lastOriginP, curve.originP2 = p, curve.defined = defined, this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  closePath() {
    if (this.curves.length < 2) return;
    const lastCurve = this.curves[this.curves.length - 1];
    this.lineTo(this._startX, this._startY, lastCurve.defined, this._startOriginP);
  }
  ellipse() {
    throw new Error("SegContext不支持调用ellipse");
  }
  lineTo(x, y, defined, p) {
    const curve = this.addLinearCurve(x, y, defined, this._lastOriginP, p);
    this.curves.push(curve), this._lastX = x, this._lastY = y, this._lastOriginP = p;
  }
  moveTo(x, y, p) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this._lastOriginP = p, this._startOriginP = p, this;
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    throw new Error("SegContext不支持调用quadraticCurveTo");
  }
  clear() {
    this.curves = [], this.length = NaN;
  }
  tryUpdateLength(direction) {
    return this.getLength(direction);
  }
  addLinearCurve(x, y, defined, p1, p2) {
    const curve = new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
    return curve.originP1 = p1, curve.originP2 = p2, curve.defined = defined, curve;
  }
  getPointAt(t) {
    throw new Error("暂未实现");
  }
  getCurveLengths() {
    return [];
  }
  getLength(direction) {
    var _a, _b;
    if (direction === Direction$1.COLUMN) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0],
        ec = this.curves[this.curves.length - 1],
        endP = null !== (_a = ec.p3) && void 0 !== _a ? _a : ec.p1;
      return abs(sc.p0.y - endP.y);
    }
    if (direction === Direction$1.ROW) {
      if (!this.curves.length) return 0;
      const sc = this.curves[0],
        ec = this.curves[this.curves.length - 1],
        endP = null !== (_b = ec.p3) && void 0 !== _b ? _b : ec.p1;
      return abs(sc.p0.x - endP.x);
    }
    return Number.isFinite(this.length) || (this.length = this.curves.reduce((l, c) => l + c.getLength(), 0)), this.length;
  }
}
class ReflectSegContext extends SegContext {
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, defined, p) {
    return super.bezierCurveTo(cp1y, cp1x, cp2y, cp2x, y, x, defined, p);
  }
  lineTo(x, y, defined, p) {
    return super.lineTo(y, x, defined, p);
  }
  moveTo(x, y, p) {
    return super.moveTo(y, x, p);
  }
  clear() {
    return super.clear();
  }
}

function genCurveSegments(path, points) {
  let defined0 = !1;
  for (let i = 0, n = points.length; i <= n; i++) i >= n === defined0 && ((defined0 = !defined0) ? path.lineStart() : path.lineEnd()), defined0 && path.point(points[i]);
}
function genSegContext(curveType, direction, points) {
  const curveDirection = null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction$1.ROW : Direction$1.COLUMN;
  return "monotoneY" === curveType ? new ReflectSegContext(curveType, curveDirection) : new SegContext(curveType, curveDirection);
}

class Linear {
  constructor(context, startPoint) {
    this.context = context, startPoint && (this.startPoint = startPoint);
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x,
      y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);
    }
    this._lastDefined = p.defined;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genLinearSegments(points) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction, points);
  return genLinearTypeSegments(new Linear(segContext, startPoint), points), segContext;
}
function genLinearTypeSegments(path, points) {
  return genCurveSegments(path, points);
}

function point$3(curveClass, x, y, defined, p) {
  curveClass.context.bezierCurveTo((2 * curveClass._x0 + curveClass._x1) / 3, (2 * curveClass._y0 + curveClass._y1) / 3, (curveClass._x0 + 2 * curveClass._x1) / 3, (curveClass._y0 + 2 * curveClass._y1) / 3, (curveClass._x0 + 4 * curveClass._x1 + x) / 6, (curveClass._y0 + 4 * curveClass._y1 + y) / 6, defined, curveClass.lastPoint1);
}
class Basis {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    if (2 === this._point) point$3(this, 6 * this._x1 - (this._x0 + 4 * this._x1), 6 * this._y1 - (this._y0 + 4 * this._y1), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const x = p.x,
      y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      default:
        point$3(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function genBasisTypeSegments(path, points) {
  return genCurveSegments(path, points);
}
function genBasisSegments(points) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
  const segContext = genSegContext("basis", direction, points);
  return genBasisTypeSegments(new Basis(segContext, startPoint), points), segContext;
}

function sign(x) {
  return x < 0 ? -1 : 1;
}
function slope3(curveClass, x2, y2) {
  const h0 = curveClass._x1 - curveClass._x0,
    h1 = x2 - curveClass._x1,
    s0 = (curveClass._y1 - curveClass._y0) / (h0 || Number(h1 < 0 && -0)),
    s1 = (y2 - curveClass._y1) / (h1 || Number(h0 < 0 && -0)),
    p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), .5 * Math.abs(p)) || 0;
}
function slope2(curveClass, t) {
  const h = curveClass._x1 - curveClass._x0;
  return h ? (3 * (curveClass._y1 - curveClass._y0) / h - t) / 2 : t;
}
function point$2(curveClass, t0, t1, defined, p) {
  const x0 = curveClass._x0,
    y0 = curveClass._y0,
    x1 = curveClass._x1,
    y1 = curveClass._y1,
    dx = (x1 - x0) / 3;
  curveClass.context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1, defined, curveClass.lastPoint1);
}
class MonotoneX {
  constructor(context, startPoint) {
    this.context = context, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x1, this._y1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        point$2(this, this._t0, slope2(this, this._t0), !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    let t1 = NaN;
    const x = p.x,
      y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3, point$2(this, slope2(this, t1 = slope3(this, x, y)), t1, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
        break;
      default:
        point$2(this, this._t0, t1 = slope3(this, x, y), !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
    }
    this._x0 = this._x1, this._x1 = x, this._y0 = this._y1, this._y1 = y, this._t0 = t1, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = !1 !== p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
class MonotoneY extends MonotoneX {
  constructor(context, startPoint) {
    super(context, startPoint);
  }
  point(p) {
    return super.point({
      y: p.x,
      x: p.y,
      defined: p.defined
    });
  }
}
function genMonotoneXTypeSegments(path, points) {
  return genCurveSegments(path, points);
}
function genMonotoneXSegments(points) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
  const segContext = genSegContext("monotoneX", direction, points);
  return genMonotoneXTypeSegments(new MonotoneX(segContext, startPoint), points), segContext;
}
function genMonotoneYTypeSegments(path, points) {
  return genCurveSegments(path, points);
}
function genMonotoneYSegments(points) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
  const segContext = genSegContext("monotoneY", direction, points);
  return genMonotoneYTypeSegments(new MonotoneY(segContext, startPoint), points), segContext;
}

let Step$1 = class Step {
  constructor(context) {
    let t = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;
    let startPoint = arguments.length > 2 ? arguments[2] : undefined;
    this.context = context, this._t = t, this.startPoint = startPoint;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x = this._y = NaN, this._point = 0, this.startPoint && this.point(this.startPoint);
  }
  lineEnd() {
    0 < this._t && this._t < 1 && 2 === this._point && this.context.lineTo(this._x, this._y, !1 !== this._lastDefined, this.lastPoint), (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line >= 0 && (this._t = 1 - this._t, this._line = 1 - this._line);
  }
  point(p) {
    const x = p.x,
      y = p.y;
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p) : this.context.moveTo(x, y, p);
        break;
      case 1:
        this._point = 2;
      default:
        if (this._t <= 0) this.context.lineTo(this._x, y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x, y, !1 !== this._lastDefined && !1 !== p.defined, p);else {
          const x1 = this._x * (1 - this._t) + x * this._t;
          .5 === this._t ? this.context.lineTo(x1, this._y, !1 !== this._lastDefined, this.lastPoint) : this.context.lineTo(x1, this._y, !1 !== this._lastDefined && !1 !== p.defined, this.lastPoint), this.context.lineTo(x1, y, !1 !== this._lastDefined && !1 !== p.defined, p);
        }
    }
    this._lastDefined = p.defined, this._x = x, this._y = y, this.lastPoint = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
};
function genStepSegments(points, t) {
  let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = new SegContext("step", null != direction ? direction : abs(points[points.length - 1].x - points[0].x) > abs(points[points.length - 1].y - points[0].y) ? Direction$1.ROW : Direction$1.COLUMN);
  return genStepTypeSegments(new Step$1(segContext, t, startPoint), points), segContext;
}
function genStepTypeSegments(path, points) {
  return genCurveSegments(path, points);
}

class LinearClosed extends Linear {
  lineEnd() {
    this.context.closePath();
  }
}
function genLinearClosedSegments(points) {
  let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const {
    direction: direction,
    startPoint: startPoint
  } = params;
  if (points.length < 2 - Number(!!startPoint)) return null;
  const segContext = genSegContext("linear", direction, points);
  return genLinearClosedTypeSegments(new LinearClosed(segContext, startPoint), points), segContext;
}
function genLinearClosedTypeSegments(path, points) {
  return genCurveSegments(path, points);
}

function point$1(curveClass, x, y, defined, p) {
  let x1 = curveClass._x1,
    y1 = curveClass._y1,
    x2 = curveClass._x2,
    y2 = curveClass._y2;
  if (curveClass._l01_a > epsilon) {
    const a = 2 * curveClass._l01_2a + 3 * curveClass._l01_a * curveClass._l12_a + curveClass._l12_2a,
      n = 3 * curveClass._l01_a * (curveClass._l01_a + curveClass._l12_a);
    x1 = (x1 * a - curveClass._x0 * curveClass._l12_2a + curveClass._x2 * curveClass._l01_2a) / n, y1 = (y1 * a - curveClass._y0 * curveClass._l12_2a + curveClass._y2 * curveClass._l01_2a) / n;
  }
  if (curveClass._l23_a > epsilon) {
    const b = 2 * curveClass._l23_2a + 3 * curveClass._l23_a * curveClass._l12_a + curveClass._l12_2a,
      m = 3 * curveClass._l23_a * (curveClass._l23_a + curveClass._l12_a);
    x2 = (x2 * b + curveClass._x1 * curveClass._l23_2a - x * curveClass._l12_2a) / m, y2 = (y2 * b + curveClass._y1 * curveClass._l23_2a - y * curveClass._l12_2a) / m;
  }
  curveClass.context.bezierCurveTo(x1, y1, x2, y2, curveClass._x2, curveClass._y2, defined, curveClass.lastPoint1);
}
class CatmullRom {
  constructor(context) {
    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;
    let startPoint = arguments.length > 2 ? arguments[2] : undefined;
    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 2:
        this.context.lineTo(this._x2, this._y2, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1);
        break;
      case 3:
        this.point({
          x: this._x2,
          y: this._y2
        });
    }
    (this._line || 0 !== this._line && 1 === this._point) && this.context.closePath(), this._line = 1 - this._line;
  }
  point(p) {
    const {
      x: x,
      y: y
    } = p;
    if (this._point) {
      const x23 = this._x2 - x,
        y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._line ? this.context.lineTo(x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2) : this.context.moveTo(x, y);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
      default:
        point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
function commonGenCatmullRomSegments(type, cons) {
  return function (points, alpha) {
    let params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const {
      direction: direction,
      startPoint: startPoint
    } = params;
    if (points.length < 2 - Number(!!startPoint)) return null;
    if (points.length < 3 - Number(!!startPoint)) return genLinearSegments(points, params);
    const segContext = genSegContext(type, direction, points),
      gatmullRom = new cons(segContext, alpha, startPoint);
    return genCurveSegments(gatmullRom, points), segContext;
  };
}
const genCatmullRomSegments = commonGenCatmullRomSegments("catmullRom", CatmullRom);

class CatmullRomClosed {
  constructor(context) {
    let alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .5;
    let startPoint = arguments.length > 2 ? arguments[2] : undefined;
    this.context = context, this.startPoint = startPoint, this._alpha = alpha;
  }
  areaStart() {
    this._line = 0;
  }
  areaEnd() {
    this._line = NaN;
  }
  lineStart() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN, this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  }
  lineEnd() {
    switch (this._point) {
      case 1:
        this.context.moveTo(this._x3, this._y3, this.lastPoint1), this.context.closePath();
        break;
      case 2:
        this.context.lineTo(this._x3, this._y3, !1 !== this._lastDefined1 && !1 !== this._lastDefined2, this.lastPoint1), this.context.closePath();
        break;
      case 3:
        this.point({
          x: this._x3,
          y: this._y3
        }), this.point({
          x: this._x4,
          y: this._y4
        }), this.point({
          x: this._x5,
          y: this._y5
        });
    }
  }
  point(p) {
    const {
      x: x,
      y: y
    } = p;
    if (this._point) {
      const x23 = this._x2 - x,
        y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }
    switch (this._point) {
      case 0:
        this._point = 1, this._x3 = x, this._y3 = y;
        break;
      case 1:
        this._point = 2, this.context.moveTo(this._x4 = x, this._y4 = y, p);
        break;
      case 2:
        this._point = 3, this._x5 = x, this._y5 = y;
        break;
      default:
        point$1(this, x, y, !1 !== this._lastDefined1 && !1 !== this._lastDefined2);
    }
    this._l01_a = this._l12_a, this._l12_a = this._l23_a, this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a, this._x0 = this._x1, this._x1 = this._x2, this._x2 = x, this._y0 = this._y1, this._y1 = this._y2, this._y2 = y, this._lastDefined1 = this._lastDefined2, this._lastDefined2 = p.defined, this.lastPoint0 = this.lastPoint1, this.lastPoint1 = p;
  }
  tryUpdateLength() {
    return this.context.tryUpdateLength();
  }
}
const genCatmullRomClosedSegments = commonGenCatmullRomSegments("catmullRomClosed", CatmullRomClosed);

class CurveContext {
  constructor(path) {
    this.path = path, this._lastX = this._lastY = this._startX = this._startY = 0;
  }
  moveTo(x, y) {
    return this._lastX = this._startX = x, this._lastY = this._startY = y, this;
  }
  lineTo(x, y) {
    const curve = this.addLinearCurve(x, y);
    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
  }
  addLinearCurve(x, y) {
    return new LineCurve(new Point(this._lastX, this._lastY), new Point(x, y));
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(new Point(this._lastX, this._lastY), new Point(aCPx, aCPy), new Point(aX, aY));
    this.path.addCurve(curve), this._lastX = aX, this._lastY = aY;
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    const curve = new CubicBezierCurve(new Point(this._lastX, this._lastY), new Point(cp1x, cp1y), new Point(cp2x, cp2y), new Point(x, y));
    this.path.addCurve(curve), this._lastX = x, this._lastY = y;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    throw new Error("CurveContext不支持调用arcTo");
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    throw new Error("CurveContext不支持调用ellipse");
  }
  rect(x, y, w, h) {
    throw new Error("CurveContext不支持调用rect");
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    throw new Error("CurveContext不支持调用arc");
  }
  closePath() {
    this.path.curves.length < 2 || this.lineTo(this._startX, this._startY);
  }
}

function calcLineCache(points, curveType, params) {
  var _a, _b;
  switch (curveType) {
    case "linear":
    default:
      return genLinearSegments(points, params);
    case "basis":
      return genBasisSegments(points, params);
    case "monotoneX":
      return genMonotoneXSegments(points, params);
    case "monotoneY":
      return genMonotoneYSegments(points, params);
    case "step":
      return genStepSegments(points, .5, params);
    case "stepBefore":
      return genStepSegments(points, 0, params);
    case "stepAfter":
      return genStepSegments(points, 1, params);
    case "catmullRom":
      return genCatmullRomSegments(points, null !== (_a = null == params ? void 0 : params.curveTension) && void 0 !== _a ? _a : .5, params);
    case "catmullRomClosed":
      return genCatmullRomClosedSegments(points, null !== (_b = null == params ? void 0 : params.curveTension) && void 0 !== _b ? _b : .5, params);
    case "linearClosed":
      return genLinearClosedSegments(points, params);
  }
}

class CustomPath2D extends CurvePath {
  constructor(ctx) {
    super(), this.commandList = [], ctx && (this._ctx = ctx), this._boundsContext = new BoundsContext(this.bounds);
  }
  get curves() {
    return this.tryBuildCurves();
  }
  setCtx(ctx) {
    this._ctx = ctx;
  }
  moveTo(x, y) {
    return this.commandList.push([enumCommandMap.M, x, y]), this._ctx && this._ctx.moveTo(x, y), this;
  }
  lineTo(x, y) {
    return this.commandList.push([enumCommandMap.L, x, y]), this._ctx && this._ctx.lineTo(x, y), this;
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    return this.commandList.push([enumCommandMap.Q, aCPx, aCPy, aX, aY]), this._ctx && this._ctx.quadraticCurveTo(aCPx, aCPy, aX, aY), this;
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    return this.commandList.push([enumCommandMap.C, aCP1x, aCP1y, aCP2x, aCP2y, aX, aY]), this._ctx && this._ctx.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY), this;
  }
  arcTo(aX1, aY1, aX2, aY2, aRadius) {
    return this.commandList.push([enumCommandMap.AT, aX1, aY1, aX2, aY2, aRadius]), this._ctx && this._ctx.arcTo(aX1, aY1, aX2, aY2, aRadius), this;
  }
  ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise) {
    return this.commandList.push([enumCommandMap.E, aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise]), this._ctx && this._ctx.ellipse(aX, aY, xRadius, yRadius, aRotation, aStartAngle, aEndAngle, aClockwise), this;
  }
  rect(x, y, w, h) {
    return this.commandList.push([enumCommandMap.R, x, y, w, h]), this._ctx && this._ctx.rect(x, y, w, h), this;
  }
  arc(x, y, radius, startAngle, endAngle, counterclockwise) {
    return this.commandList.push([enumCommandMap.A, x, y, radius, startAngle, endAngle, counterclockwise]), this._ctx && this._ctx.arc(x, y, radius, startAngle, endAngle, counterclockwise), this;
  }
  closePath() {
    return this.commandList.push([enumCommandMap.Z]), this._ctx && this._ctx.closePath(), this;
  }
  addCurve(curve) {
    this._curves.push(curve);
  }
  clear() {
    this.transformCbList = null, this.commandList.length = 0, this._curves.length = 0;
  }
  beginPath() {
    this.clear();
  }
  tryBuildCurves() {
    if (!this._curves || !this._curves.length) {
      const curveContext = new CurveContext(this);
      renderCommandList(this.commandList, curveContext, 0, 0, 1, 1);
    }
    return this._curves;
  }
  toString() {
    if (!this.toStringCbList) {
      const list = [];
      list[enumCommandMap.M] = cmd => `M${cmd[1]} ${cmd[2]}`, list[enumCommandMap.L] = cmd => `L${cmd[1]} ${cmd[2]}`, list[enumCommandMap.Q] = cmd => `Q${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]}`, list[enumCommandMap.C] = cmd => `C${cmd[1]} ${cmd[2]} ${cmd[3]} ${cmd[4]} ${cmd[5]} ${cmd[6]}`, list[enumCommandMap.A] = cmd => {
        const bezierPathList = [];
        addArcToBezierPath$1(bezierPathList, cmd[4], cmd[5], cmd[1], cmd[2], cmd[3], cmd[3]);
        let path = "";
        for (let i = 0; i < bezierPathList.length; i += 6) path += `C${bezierPathList[i]} ${bezierPathList[i + 1]} ${bezierPathList[i + 2]} ${bezierPathList[i + 3]} ${bezierPathList[i + 4]} ${bezierPathList[i + 5]}`;
        return path;
      }, list[enumCommandMap.R] = cmd => `M${cmd[1]} ${cmd[2]} h${cmd[3]} v${cmd[4]} H${cmd[1]}Z`, list[enumCommandMap.Z] = cmd => "Z", this.toStringCbList = list;
    }
    const list = this.toStringCbList;
    let path = "";
    return this.commandList.forEach(c => {
      path += list[c[0]](c);
    }), path;
  }
  fromString(str, x, y, sX, sY) {
    this.clear();
    const commandStrList = parseSvgPath(str);
    return this._runCommandStrList(commandStrList, x, y, sX, sY), this._updateBounds(), this;
  }
  fromLine(line) {
    const {
      points: points,
      curveType: curveType,
      clipRangeByDimension: clipRangeByDimension
    } = line.attribute;
    if (!points) return;
    const cache = calcLineCache(points, curveType);
    "x" === clipRangeByDimension ? this.direction = Direction$1.ROW : "y" === clipRangeByDimension ? this.direction = Direction$1.COLUMN : "auto" === clipRangeByDimension && (this.direction = cache.direction), this._curves = cache.curves;
  }
  fromCustomPath2D(path, x, y, sX, sY) {
    return this.clear(), this._runCommandList(path.commandList, x, y, sX, sY), this._updateBounds(), this;
  }
  transform(x, y, sx, sy) {
    const commandList = this.commandList;
    if (!this.transformCbList) {
      const list = [];
      list[enumCommandMap.M] = this.moveToTransform, list[enumCommandMap.L] = this.lineToTransform, list[enumCommandMap.Q] = this.quadraticCurveToTransform, list[enumCommandMap.C] = this.bezierCurveToTransform, list[enumCommandMap.AT] = this.arcToTransform, list[enumCommandMap.E] = this.ellipseTransform, list[enumCommandMap.R] = this.rectTransform, list[enumCommandMap.A] = this.arcTransform, list[enumCommandMap.Z] = this.closePathTransform, this.transformCbList = list;
    }
    commandList.forEach(cmd => {
      this.transformCbList[cmd[0]](cmd, x, y, sx, sy);
    }), this._updateBounds();
  }
  moveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  lineToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y;
  }
  quadraticCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y;
  }
  bezierCurveToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * sx + x, cmd[6] = cmd[6] * sy + y;
  }
  arcToTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx + x, cmd[4] = cmd[4] * sy + y, cmd[5] = cmd[5] * (sx + sy) / 2;
  }
  ellipseTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  rectTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * sx, cmd[4] = cmd[4] * sy;
  }
  arcTransform(cmd, x, y, sx, sy) {
    cmd[1] = cmd[1] * sx + x, cmd[2] = cmd[2] * sy + y, cmd[3] = cmd[3] * (sx + sy) / 2;
  }
  closePathTransform() {}
  _runCommandStrList(commandStrList) {
    let l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let sX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    let sY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    let current,
      tempX,
      tempY,
      tempControlX,
      tempControlY,
      previous = null,
      x = 0,
      y = 0,
      controlX = 0,
      controlY = 0;
    for (let i = 0, len = commandStrList.length; i < len; ++i) {
      switch (current = commandStrList[i], 1 === sX && 1 === sY || (current = scale(current, sX, sY)), current[0]) {
        case "l":
          x += current[1], y += current[2], this.lineTo(x + l, y + t);
          break;
        case "L":
          x = current[1], y = current[2], this.lineTo(x + l, y + t);
          break;
        case "h":
          x += current[1], this.lineTo(x + l, y + t);
          break;
        case "H":
          x = current[1], this.lineTo(x + l, y + t);
          break;
        case "v":
          y += current[1], this.lineTo(x + l, y + t);
          break;
        case "V":
          y = current[1], this.lineTo(x + l, y + t);
          break;
        case "m":
          x += current[1], y += current[2], this.moveTo(x + l, y + t);
          break;
        case "M":
          x = current[1], y = current[2], this.moveTo(x + l, y + t);
          break;
        case "c":
          tempX = x + current[5], tempY = y + current[6], controlX = x + current[3], controlY = y + current[4], this.bezierCurveTo(x + current[1] + l, y + current[2] + t, controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "C":
          x = current[5], y = current[6], controlX = current[3], controlY = current[4], this.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
          break;
        case "s":
          tempX = x + current[3], tempY = y + current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = x + current[1], tempControlY = y + current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
          break;
        case "S":
          tempX = current[3], tempY = current[4], null === previous[0].match(/[CcSs]/) ? (controlX = x, controlY = y) : (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = current[1], tempControlY = current[2], this.bezierCurveTo(controlX + l, controlY + t, tempControlX + l, tempControlY + t, tempX + l, tempY + t), controlX = tempControlX, controlY = tempControlY, x = tempX, y = tempY;
          break;
        case "q":
          tempX = x + current[3], tempY = y + current[4], controlX = x + current[1], controlY = y + current[2], this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "Q":
          tempX = current[3], tempY = current[4], this.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = current[1], controlY = current[2];
          break;
        case "t":
          tempX = x + current[1], tempY = y + current[2], null === previous[0].match(/[QqTt]/) ? (controlX = x, controlY = y) : "t" === previous[0] ? (controlX = 2 * x - tempControlX, controlY = 2 * y - tempControlY) : "q" === previous[0] && (controlX = 2 * x - controlX, controlY = 2 * y - controlY), tempControlX = controlX, tempControlY = controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY, controlX = x + current[1], controlY = y + current[2];
          break;
        case "T":
          tempX = current[1], tempY = current[2], controlX = 2 * x - controlX, controlY = 2 * y - controlY, this.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t), x = tempX, y = tempY;
          break;
        case "a":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]), x += current[6], y += current[7];
          break;
        case "A":
          drawArc(this, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]), x = current[6], y = current[7];
          break;
        case "z":
        case "Z":
          this.closePath();
      }
      previous = current;
    }
  }
  _runCommandList(commandList) {
    let l = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let t = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    let sX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    let sY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    if (0 !== l || 0 !== t || 1 !== sX || 1 !== sY) for (let i = 0, len = commandList.length; i < len; ++i) {
      const current = commandList[i].slice();
      switch (current[0]) {
        case enumCommandMap.L:
          this.lineToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.M:
          this.moveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.C:
          this.bezierCurveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.Q:
          this.quadraticCurveToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.A:
          this.arcToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.E:
          this.ellipseTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.R:
          this.rectTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.AT:
          this.arcToTransform(current, l, t, sX, sY);
          break;
        case enumCommandMap.Z:
          this.closePath();
      }
    } else this.commandList = commandList.map(entry => entry.slice());
  }
  _updateBounds() {
    this.bounds.clear(), renderCommandList(this.commandList, this._boundsContext);
  }
  release() {
    this.commandList = [], this._boundsContext = null, this._ctx = null;
  }
  getLength() {
    if (this.direction === Direction$1.COLUMN) {
      if (!this._curves.length) return 0;
      const sc = this._curves[0],
        ec = this._curves[this._curves.length - 1];
      return abs(sc.p0.y - ec.p1.y);
    }
    if (this.direction === Direction$1.ROW) {
      if (!this._curves.length) return 0;
      const sc = this._curves[0],
        ec = this._curves[this._curves.length - 1];
      return abs(sc.p0.x - ec.p1.x);
    }
    return this._curves.reduce((l, c) => l + c.getLength(), 0);
  }
  getYAt(x) {
    if (!this.curves) return 1 / 0;
    for (let i = 0; i < this.curves.length; i++) {
      const curve = this.curves[i];
      if (curve.includeX(x)) return curve.getYAt(x);
    }
    return 1 / 0;
  }
  getAttrAt(distance) {
    if (!this._curves) return {
      pos: {
        x: 0,
        y: 0
      },
      angle: 0
    };
    let curve,
      _dis = 0;
    for (let i = 0; i < this._curves.length; i++) {
      curve = this._curves[i];
      const cl = curve.getLength(this.direction);
      if (_dis + cl >= distance) break;
      _dis += cl;
    }
    const t = (distance - _dis) / curve.getLength(this.direction);
    return {
      pos: curve.getPointAt(t),
      angle: curve.getAngleAt(t)
    };
  }
  drawWithClipRange(ctx, size, x, y, clipRange) {
    this.tryBuildCurves();
    const totalLen = this.getLength() * clipRange;
    let currLen = 0;
    for (let i = 0; i < this._curves.length; i++) {
      const curve = this._curves[i],
        cl = curve.getLength(this.direction);
      if (!(currLen + cl <= totalLen)) {
        const percent = 1 - (currLen + cl - totalLen) / cl;
        curve.draw(ctx, x, y, size, size, percent);
        break;
      }
      curve.draw(ctx, x, y, size, size, 1), currLen += cl;
    }
  }
}
const temp = ["l", 0, 0, 0, 0, 0, 0, 0];
function scale(current, sX, sY) {
  const c = temp[0] = current[0];
  if ("a" === c || "A" === c) temp[1] = sX * current[1], temp[2] = sY * current[2], temp[3] = current[3], temp[4] = current[4], temp[5] = current[5], temp[6] = sX * current[6], temp[7] = sY * current[7];else if ("h" === c || "H" === c) temp[1] = sX * current[1];else if ("v" === c || "V" === c) temp[1] = sY * current[1];else for (let i = 1, n = current.length; i < n; ++i) temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
  return temp;
}

const DefaultLayout = {
  alignSelf: "auto"
};
const DefaultTransform = {
  x: 0,
  y: 0,
  z: 0,
  dx: 0,
  dy: 0,
  dz: 0,
  scrollX: 0,
  scrollY: 0,
  scaleX: 1,
  scaleY: 1,
  scaleZ: 1,
  angle: 0,
  alpha: 0,
  beta: 0,
  scaleCenter: [0, 0],
  anchor: [0, 0],
  anchor3d: [0, 0],
  postMatrix: new Matrix()
};
const DefaultFillStyle = {
  fillOpacity: 1,
  fill: !1,
  shadowBlur: 0,
  shadowColor: "black",
  shadowOffsetX: 0,
  shadowOffsetY: 0
};
const commonStroke = {
  strokeOpacity: 1,
  lineDash: [],
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  lineJoin: "miter",
  miterLimit: 10,
  strokeBoundsBuffer: 2,
  stroke: !1
};
const DefaultStrokeStyle = Object.assign({
  outerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  }),
  innerBorder: Object.assign(Object.assign({}, commonStroke), {
    distance: 0
  })
}, commonStroke);
const DefaultTextStyle = {
  text: "",
  maxLineWidth: 1 / 0,
  maxWidth: 1 / 0,
  textAlign: "left",
  textBaseline: "alphabetic",
  fontSize: 16,
  fontFamily: "PingFang SC,Microsoft Yahei,system-ui,-apple-system,segoe ui,\n    Roboto,Helvetica,Arial,sans-serif, apple color emoji,segoe ui emoji,segoe ui symbol",
  fontWeight: "",
  ellipsis: "…",
  fontVariant: "",
  fontStyle: "",
  lineHeight: void 0,
  underline: 0,
  lineThrough: 0,
  scaleIn3d: !1,
  direction: "horizontal",
  wordBreak: "break-all",
  ignoreBuf: !1,
  verticalMode: 0,
  wrap: !1,
  whiteSpace: "no-wrap",
  heightLimit: 1 / 0,
  lineClamp: 1 / 0,
  suffixPosition: "end",
  underlineDash: [],
  underlineOffset: 0,
  disableAutoClipedPoptip: void 0,
  measureMode: MeasureModeEnum.fontBounding,
  keepCenterInLine: !1
};
const DefaultPickStyle = {
  pickStrokeBuffer: 0
};
const DefaultStyle = Object.assign(Object.assign(Object.assign(Object.assign({
  forceBoundsWidth: void 0,
  forceBoundsHeight: void 0,
  opacity: 1,
  background: null,
  autoAnimateTexture: !1,
  textureRatio: 1,
  textureOptions: null,
  backgroundOpacity: 1,
  backgroundCornerRadius: 0,
  texture: null,
  textureColor: "black",
  textureSize: 10,
  texturePadding: 2,
  backgroundMode: "no-repeat",
  backgroundFit: !0,
  backgroundKeepAspectRatio: !1,
  backgroundClip: !0,
  backgroundScale: 1,
  backgroundOffsetX: 0,
  backgroundOffsetY: 0,
  blur: 0,
  filter: "",
  cursor: null,
  html: null,
  react: null
}, DefaultFillStyle), DefaultStrokeStyle), DefaultLayout), DefaultPickStyle);
const DefaultConnectAttribute = {
  connectedType: "none",
  connectedStyle: {},
  connectedX: NaN,
  connectedY: NaN
};
const DefaultDebugAttribute = {
  _debug_bounds: !1
};
const DefaultAttribute = Object.assign(Object.assign(Object.assign({
  strokeSeg: null,
  renderable: !0,
  pickable: !0,
  shadowGraphic: void 0,
  childrenPickable: !0,
  fillPickable: !0,
  strokePickable: !0,
  visible: !0,
  zIndex: 0,
  layout: null,
  boundsPadding: 0,
  fillStrokeOrder: 0,
  renderStyle: "default",
  pickMode: "accurate",
  customPickShape: null,
  boundsMode: "accurate",
  keepDirIn3d: !0,
  shadowRootIdx: 1,
  globalZIndex: 1,
  globalCompositeOperation: "",
  overflow: "hidden",
  shadowPickMode: "graphic",
  keepStrokeScale: !1,
  clipConfig: null
}, DefaultDebugAttribute), DefaultStyle), DefaultTransform);
function addAttributeToPrototype(obj, c, keys) {
  keys.forEach(key => {
    c.prototype[key] = obj[key];
  });
}
function rewriteProto(obj, c) {
  Object.setPrototypeOf(obj, c);
}
const DefaultArcAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  startAngle: 0,
  endAngle: pi2,
  innerRadius: 0,
  outerRadius: 1,
  innerPadding: 0,
  outerPadding: 0,
  cornerRadius: 0,
  padRadius: 0,
  padAngle: 0,
  cap: !1,
  forceShowCap: !1
});
const DefaultAreaAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  closePath: !1,
  curveTension: 1
});
const DefaultCircleAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  radius: 1,
  startAngle: 0,
  endAngle: pi2
});
const DefaultGroupAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  cornerRadius: 0,
  path: [],
  clip: !1,
  visibleAll: !0,
  display: "relative",
  flexDirection: "row",
  flexWrap: "wrap",
  justifyContent: "flex-start",
  alignItems: "flex-start",
  alignContent: "flex-start",
  baseOpacity: 1,
  cornerType: "round"
});
const DefaultGlyphAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: "",
  width: 0,
  height: 0,
  cornerRadius: 0,
  clip: !1
});
const DefaultLineAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultConnectAttribute), {
  points: [],
  segments: [],
  curveType: "linear",
  clipRange: 1,
  clipRangeByDimension: "default",
  closePath: !1,
  curveTension: 1
});
const DefaultPathAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  path: new CustomPath2D(),
  fillStrokeOrder: 1,
  clipRange: 1,
  customPath: () => {
    Logger.getInstance().warn("空函数");
  }
});
const DefaultPolygonAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  points: [],
  cornerRadius: 0,
  closePath: !0
});
const DefaultRectAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  strokeBoundsBuffer: 0,
  cornerRadius: 0,
  cornerType: "round"
});
const DefaultRect3dAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  width: 0,
  height: 0,
  x1: 0,
  y1: 0,
  cornerRadius: 0,
  length: 0,
  cornerType: "round"
});
const DefaultSymbolAttribute = Object.assign(Object.assign({}, DefaultAttribute), {
  symbolType: "circle",
  size: 10,
  keepDirIn3d: !0,
  clipRange: 1
});
const DefaultTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  strokeBoundsBuffer: 0,
  keepDirIn3d: !0
});
const DefaultRichTextAttribute = Object.assign(Object.assign(Object.assign({}, DefaultAttribute), DefaultTextStyle), {
  upgradeAttrs: null,
  editable: !1,
  editOptions: null,
  ascentDescentMode: "actual",
  width: 300,
  height: 300,
  ellipsis: !0,
  wordBreak: "break-word",
  verticalDirection: "top",
  textAlign: "left",
  textBaseline: "top",
  layoutDirection: "horizontal",
  textConfig: [],
  disableAutoWrapLine: !1,
  maxHeight: void 0,
  maxWidth: void 0,
  singleLine: !1
});
const DefaultImageAttribute = Object.assign(Object.assign({
  repeatX: "no-repeat",
  repeatY: "no-repeat",
  image: "",
  width: 0,
  height: 0,
  maxWidth: 500,
  maxHeight: 500
}, DefaultAttribute), {
  fill: !0,
  cornerRadius: 0,
  cornerType: "round"
});
const DefaultRichTextIconAttribute = Object.assign(Object.assign({}, DefaultImageAttribute), {
  backgroundShowMode: "never",
  backgroundWidth: 0,
  backgroundHeight: 0,
  textAlign: "left",
  textBaseline: "middle",
  direction: "horizontal",
  margin: 0,
  id: "",
  width: 20,
  height: 20,
  backgroundFill: "rgba(101, 117, 168, 0.1)",
  backgroundFillOpacity: 1,
  backgroundStroke: !1,
  backgroundStrokeOpacity: 1,
  backgroundRadius: 4,
  opacity: 1
});

class Application {}
const application = new Application();

const parse$1 = function () {
  const tokens = {
    linearGradient: /^(linear\-gradient)/i,
    radialGradient: /^(radial\-gradient)/i,
    conicGradient: /^(conic\-gradient)/i,
    sideOrCorner: /^to (left (top|bottom)|right (top|bottom)|top (left|right)|bottom (left|right)|left|right|top|bottom)/i,
    extentKeywords: /^(closest\-side|closest\-corner|farthest\-side|farthest\-corner|contain|cover)/,
    positionKeywords: /^(left|center|right|top|bottom)/i,
    pixelValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))px/,
    percentageValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))\%/,
    emValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))em/,
    angleValue: /^(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    fromAngleValue: /^from\s*(-?(([0-9]*\.[0-9]+)|([0-9]+\.?)))deg/,
    startCall: /^\(/,
    endCall: /^\)/,
    comma: /^,/,
    hexColor: /(^\#[0-9a-fA-F]+)/,
    literalColor: /^([a-zA-Z]+)/,
    rgbColor: /^(rgb\(\d{1,3},\s*\d{1,3},\s*\d{1,3}\))/i,
    rgbaColor: /^(rgba\(\d{1,3},\s*\d{1,3},\s*\d{1,3},\s*((\d\.\d+)|\d{1,3})\))/i,
    number: /^(([0-9]*\.[0-9]+)|([0-9]+\.?))/
  };
  let input = "";
  function error(msg) {
    const err = new Error(input + ": " + msg);
    throw err.source = input, err;
  }
  function getAST() {
    const ast = matchListing(matchDefinition);
    return input.length > 0 && error("Invalid input not EOF"), ast;
  }
  function matchDefinition() {
    return matchGradient("linear", tokens.linearGradient, matchLinearOrientation) || matchGradient("radial", tokens.radialGradient, matchListRadialOrientations) || matchGradient("conic", tokens.conicGradient, matchConicalOrientation);
  }
  function matchGradient(gradientType, pattern, orientationMatcher) {
    return function (pattern, callback) {
      const captures = scan(pattern);
      if (captures) {
        scan(tokens.startCall) || error("Missing (");
        const result = callback(captures);
        return scan(tokens.endCall) || error("Missing )"), result;
      }
    }(pattern, function (captures) {
      const orientation = orientationMatcher();
      return orientation && (scan(tokens.comma) || error("Missing comma before color stops")), {
        type: gradientType,
        orientation: orientation,
        colorStops: matchListing(matchColorStop)
      };
    });
  }
  function matchLinearOrientation() {
    return match("directional", tokens.sideOrCorner, 1) || match("angular", tokens.angleValue, 1);
  }
  function matchConicalOrientation() {
    return match("angular", tokens.fromAngleValue, 1);
  }
  function matchListRadialOrientations() {
    let radialOrientations,
      lookaheadCache,
      radialOrientation = matchRadialOrientation();
    return radialOrientation && (radialOrientations = [], radialOrientations.push(radialOrientation), lookaheadCache = input, scan(tokens.comma) && (radialOrientation = matchRadialOrientation(), radialOrientation ? radialOrientations.push(radialOrientation) : input = lookaheadCache)), radialOrientations;
  }
  function matchRadialOrientation() {
    let radialType = function () {
      const circle = match("shape", /^(circle)/i, 0);
      circle && (circle.style = matchLength() || matchExtentKeyword());
      return circle;
    }() || function () {
      const ellipse = match("shape", /^(ellipse)/i, 0);
      ellipse && (ellipse.style = matchDistance() || matchExtentKeyword());
      return ellipse;
    }();
    if (radialType) radialType.at = matchAtPosition();else {
      const extent = matchExtentKeyword();
      if (extent) {
        radialType = extent;
        const positionAt = matchAtPosition();
        positionAt && (radialType.at = positionAt);
      } else {
        const defaultPosition = matchPositioning();
        defaultPosition && (radialType = {
          type: "default-radial",
          at: defaultPosition
        });
      }
    }
    return radialType;
  }
  function matchExtentKeyword() {
    return match("extent-keyword", tokens.extentKeywords, 1);
  }
  function matchAtPosition() {
    if (match("position", /^at/, 0)) {
      const positioning = matchPositioning();
      return positioning || error("Missing positioning value"), positioning;
    }
  }
  function matchPositioning() {
    const location = {
      x: matchDistance(),
      y: matchDistance()
    };
    if (location.x || location.y) return {
      type: "position",
      value: location
    };
  }
  function matchListing(matcher) {
    let captures = matcher();
    const result = [];
    if (captures) for (result.push(captures); scan(tokens.comma);) captures = matcher(), captures ? result.push(captures) : error("One extra comma");
    return result;
  }
  function matchColorStop() {
    const color = match("hex", tokens.hexColor, 1) || match("rgba", tokens.rgbaColor, 1) || match("rgb", tokens.rgbColor, 1) || match("literal", tokens.literalColor, 0);
    return color || error("Expected color definition"), color.length = matchDistance(), color;
  }
  function matchDistance() {
    return match("%", tokens.percentageValue, 1) || match("position-keyword", tokens.positionKeywords, 1) || matchLength();
  }
  function matchLength() {
    return match("px", tokens.pixelValue, 1) || match("em", tokens.emValue, 1);
  }
  function match(type, pattern, captureIndex) {
    const captures = scan(pattern);
    if (captures) return {
      type: type,
      value: captures[captureIndex]
    };
  }
  function scan(regexp) {
    const blankCaptures = /^[\n\r\t\s]+/.exec(input);
    blankCaptures && consume(blankCaptures[0].length);
    const captures = regexp.exec(input);
    return captures && consume(captures[0].length), captures;
  }
  function consume(size) {
    input = input.substr(size);
  }
  return function (code) {
    return input = code.toString(), getAST();
  };
}();
class GradientParser {
  static IsGradient(c) {
    return !("string" == typeof c && !c.includes("gradient"));
  }
  static IsGradientStr(c) {
    return "string" == typeof c && c.includes("gradient");
  }
  static Parse(c) {
    if (GradientParser.IsGradientStr(c)) try {
      const datum = parse$1(c)[0];
      if (datum) {
        if ("linear" === datum.type) return GradientParser.ParseLinear(datum);
        if ("radial" === datum.type) return GradientParser.ParseRadial(datum);
        if ("conic" === datum.type) return GradientParser.ParseConic(datum);
      }
    } catch (err) {
      return c;
    }
    return c;
  }
  static ParseConic(datum) {
    const {
        orientation: orientation,
        colorStops = []
      } = datum,
      halfPi = pi / 2,
      sa = parseFloat(orientation.value) / 180 * pi - halfPi;
    return {
      gradient: "conical",
      x: .5,
      y: .5,
      startAngle: sa,
      endAngle: sa + pi2,
      stops: colorStops.map(item => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseRadial(datum) {
    const {
      colorStops = []
    } = datum;
    return {
      gradient: "radial",
      x0: .5,
      y0: .5,
      x1: .5,
      y1: .5,
      r0: 0,
      r1: 1,
      stops: colorStops.map(item => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
  static ParseLinear(datum) {
    const {
        orientation: orientation,
        colorStops = []
      } = datum,
      halfPi = pi / 2;
    let angle = "angular" === orientation.type ? parseFloat(orientation.value) / 180 * pi : 0;
    for (; angle < 0;) angle += pi2;
    for (; angle >= pi2;) angle -= pi2;
    let x0 = 0,
      y0 = 0,
      x1 = 0,
      y1 = 0;
    return angle < halfPi ? (x0 = 0, y0 = 1, x1 = Math.sin(angle), y1 = y0 - Math.cos(angle)) : angle < pi ? (x0 = 0, y0 = 0, x1 = Math.cos(angle - halfPi), y1 = Math.sin(angle - halfPi)) : angle < pi + halfPi ? (x0 = 1, y0 = 0, x1 = x0 - Math.sin(angle - pi), y1 = Math.cos(angle - pi)) : (x0 = 1, x1 = x0 - Math.cos(angle - halfPi - pi), y1 -= Math.sin(angle - halfPi - pi)), {
      gradient: "linear",
      x0: x0,
      y0: y0,
      x1: x1,
      y1: y1,
      stops: colorStops.map(item => ({
        color: item.value,
        offset: parseFloat(item.length.value) / 100
      }))
    };
  }
}

function getScaledStroke(context, width, dpr) {
  let strokeWidth = width;
  const {
      a: a,
      b: b,
      c: c,
      d: d
    } = context.currentMatrix,
    scaleX = Math.sign(a) * Math.sqrt(a * a + b * b),
    scaleY = Math.sign(d) * Math.sqrt(c * c + d * d);
  return scaleX + scaleY === 0 ? 0 : (strokeWidth = strokeWidth / Math.abs(scaleX + scaleY) * 2 * dpr, strokeWidth);
}
function createColor(context, c, params) {
  let offsetX = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  let offsetY = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  if (!c || !0 === c) return "black";
  let result, color;
  if (isArray$1(c)) for (let i = 0; i < c.length && (color = c[i], !color); i++);else color = c;
  if (color = GradientParser.Parse(color), "string" == typeof color) return color;
  if (params.AABBBounds && (!params.attribute || 0 !== params.attribute.scaleX || 0 !== params.attribute.scaleY)) {
    const bounds = params.AABBBounds;
    let w = bounds.x2 - bounds.x1,
      h = bounds.y2 - bounds.y1,
      x = bounds.x1 - offsetX,
      y = bounds.y1 - offsetY;
    if (params.attribute) {
      const {
        scaleX = 1,
        scaleY = 1
      } = params.attribute;
      w /= scaleX, h /= scaleY, x /= scaleX, y /= scaleY;
    }
    "linear" === color.gradient ? result = createLinearGradient(context, color, x, y, w, h) : "conical" === color.gradient ? result = createConicGradient(context, color, x, y, w, h) : "radial" === color.gradient && (result = createRadialGradient(context, color, x, y, w, h));
  }
  return result || "orange";
}
function createLinearGradient(context, color, x, y, w, h) {
  var _a, _b, _c, _d;
  const canvasGradient = context.createLinearGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : 0) * h, x + (null !== (_c = color.x1) && void 0 !== _c ? _c : 1) * w, y + (null !== (_d = color.y1) && void 0 !== _d ? _d : 0) * h);
  return color.stops.forEach(stop => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createRadialGradient(context, color, x, y, w, h) {
  var _a, _b, _c, _d, _e, _f;
  const canvasGradient = context.createRadialGradient(x + (null !== (_a = color.x0) && void 0 !== _a ? _a : .5) * w, y + (null !== (_b = color.y0) && void 0 !== _b ? _b : .5) * h, Math.max(w, h) * (null !== (_c = color.r0) && void 0 !== _c ? _c : 0), x + (null !== (_d = color.x1) && void 0 !== _d ? _d : .5) * w, y + (null !== (_e = color.y1) && void 0 !== _e ? _e : .5) * h, Math.max(w, h) * (null !== (_f = color.r1) && void 0 !== _f ? _f : .5));
  return color.stops.forEach(stop => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient;
}
function createConicGradient(context, color, x, y, w, h) {
  var _a, _b;
  const canvasGradient = context.createConicGradient(x + (null !== (_a = color.x) && void 0 !== _a ? _a : 0) * w, y + (null !== (_b = color.y) && void 0 !== _b ? _b : 0) * h, color.startAngle, color.endAngle);
  return color.stops.forEach(stop => {
    canvasGradient.addColorStop(stop.offset, stop.color);
  }), canvasGradient.GetPattern(w + x, h + y, undefined);
}

const DIRECTION_KEY = {
  horizontal: {
    width: "width",
    height: "height",
    left: "left",
    top: "top",
    x: "x",
    y: "y",
    bottom: "bottom"
  },
  vertical: {
    width: "height",
    height: "width",
    left: "top",
    top: "left",
    x: "y",
    y: "x",
    bottom: "right"
  }
};
const defaultFormatting = {
    fontSize: 16,
    fontFamily: DEFAULT_TEXT_FONT_FAMILY,
    fill: !0,
    stroke: !1,
    fontWeight: "normal",
    lineHeight: "normal",
    fontStyle: "normal",
    textDecoration: "none",
    textAlign: "left",
    script: "normal"
  };
const regLetter = /\w|\(|\)|-/;
const regPunctuation = /[.?!,;:/，。？！、；：]/;
const regFirstSpace = /\S/;
const setTextStyle = (ctx, character) => {
  let fontSize = character.fontSize || 16;
  switch (character.script) {
    case "super":
    case "sub":
      fontSize *= .8;
  }
  ctx.setTextStyle({
    textAlign: "left",
    textBaseline: character.textBaseline || "alphabetic",
    fontStyle: character.fontStyle || "",
    fontWeight: character.fontWeight || "",
    fontSize: fontSize,
    fontFamily: character.fontFamily
  });
};
function applyFillStyle(ctx, character, b) {
  const fillStyle = character && character.fill || defaultFormatting.fill;
  if (!fillStyle) return void (ctx.globalAlpha = 0);
  const {
    fillOpacity = 1,
    opacity = 1
  } = character;
  ctx.globalAlpha = fillOpacity * opacity, ctx.fillStyle = b ? createColor(ctx, fillStyle, {
    AABBBounds: b
  }) : fillStyle, setTextStyle(ctx, character);
}
function applyStrokeStyle(ctx, character) {
  const strokeStyle = character && character.stroke || defaultFormatting.stroke;
  if (!strokeStyle) return void (ctx.globalAlpha = 0);
  const {
    strokeOpacity = 1,
    opacity = 1
  } = character;
  ctx.globalAlpha = strokeOpacity * opacity, ctx.lineWidth = character && "number" == typeof character.lineWidth ? character.lineWidth : 1, ctx.strokeStyle = strokeStyle, setTextStyle(ctx, character);
}
function getStrByWithCanvas(desc, width, character, guessIndex, needTestLetter) {
  if (!width || width <= 0) return 0;
  const textMeasure = application.graphicUtil.textMeasure;
  let index = guessIndex,
    temp = desc.slice(0, index),
    tempWidth = Math.floor(textMeasure.measureText(temp, character).width),
    tempNext = desc.slice(0, index + 1),
    tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  for (; tempWidth > width || tempWidthNext <= width;) {
    if (tempWidth > width ? index-- : index++, index > desc.length) {
      index = desc.length;
      break;
    }
    if (index < 0) {
      index = 0;
      break;
    }
    temp = desc.slice(0, index), tempWidth = Math.floor(textMeasure.measureText(temp, character).width), tempNext = desc.slice(0, index + 1), tempWidthNext = Math.floor(textMeasure.measureText(tempNext, character).width);
  }
  return needTestLetter && (index = testLetter(desc, index)), index;
}
function getWordStartEndIdx(string, index) {
  let startIdx = index;
  for (; (regLetter.test(string[startIdx - 1]) && regLetter.test(string[startIdx]) || regPunctuation.test(string[startIdx])) && (startIdx--, !(startIdx <= 0)););
  let endIdx = index;
  for (; (regLetter.test(string[endIdx + 1]) && regLetter.test(string[endIdx]) || regPunctuation.test(string[endIdx])) && (endIdx++, !(endIdx >= string.length)););
  return endIdx = Math.min(endIdx + 1, string.length), {
    startIdx: startIdx,
    endIdx: endIdx
  };
}
function testLetter(string, index) {
  let negativeWrongMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
  let i = index;
  for (; regLetter.test(string[i - 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i--, i <= 0) return negativeWrongMatch ? testLetter2(string, index) : index;
  return i;
}
function testLetter2(string, index) {
  let i = index;
  for (; regLetter.test(string[i + 1]) && regLetter.test(string[i]) || regPunctuation.test(string[i]);) if (i++, i >= string.length) return i;
  return i + 1;
}
function measureTextCanvas(text, character) {
  let mode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "actual";
  const measurement = application.graphicUtil.textMeasure.measureText(text, character),
    result = {
      ascent: 0,
      height: 0,
      descent: 0,
      width: 0
    },
    ascent = "actual" === mode ? measurement.actualBoundingBoxAscent : measurement.fontBoundingBoxAscent,
    descent = "actual" === mode ? measurement.actualBoundingBoxDescent : measurement.fontBoundingBoxDescent;
  return "number" != typeof ascent || "number" != typeof descent ? (result.width = Math.floor(measurement.width), result.height = character.fontSize || 0, result.ascent = result.height, result.descent = 0) : (result.width = Math.floor(measurement.width), result.height = Math.floor(ascent + descent), result.ascent = Math.floor(ascent), result.descent = result.height - result.ascent), result;
}

var __decorate$1K = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ATextMeasure = class {
  configure(service, env) {
    this.canvas = service.canvas, this.context = service.context, service.bindTextMeasure(this);
  }
  _measureTextWithoutAlignBaseline(text, options, compatible) {
    this.context.setTextStyleWithoutAlignBaseline(options);
    const metrics = this.context.measureText(text);
    return compatible ? this.compatibleMetrics(metrics, options) : metrics;
  }
  _measureTextWithAlignBaseline(text, options, compatible) {
    this.context.setTextStyle(options);
    const metrics = this.context.measureText(text);
    return compatible ? this.compatibleMetrics(metrics, options) : metrics;
  }
  compatibleMetrics(metrics, options) {
    if (null == metrics.actualBoundingBoxAscent || null == metrics.actualBoundingBoxDescent || null == metrics.fontBoundingBoxAscent || null == metrics.fontBoundingBoxDescent) {
      metrics = {
        width: metrics.width
      };
      const {
        ascent: ascent,
        descent: descent
      } = this.measureTextBoundADscentEstimate(options);
      metrics.actualBoundingBoxAscent = ascent, metrics.actualBoundingBoxDescent = descent, metrics.fontBoundingBoxAscent = ascent, metrics.fontBoundingBoxDescent = descent;
    }
    if (null == metrics.actualBoundingBoxLeft || null == metrics.actualBoundingBoxRight) {
      metrics = {
        width: metrics.width,
        actualBoundingBoxAscent: metrics.actualBoundingBoxAscent,
        actualBoundingBoxDescent: metrics.actualBoundingBoxDescent,
        fontBoundingBoxAscent: metrics.fontBoundingBoxAscent,
        fontBoundingBoxDescent: metrics.fontBoundingBoxDescent
      };
      const {
        left: left,
        right: right
      } = this.measureTextBoundLeftRightEstimate(options);
      metrics.actualBoundingBoxLeft = left, metrics.actualBoundingBoxRight = right;
    }
    return metrics;
  }
  estimate(text, _ref) {
    let {
      fontSize = DefaultTextAttribute.fontSize
    } = _ref;
    let eCharLen = 0,
      cCharLen = 0;
    for (let i = 0; i < text.length; i++) text.charCodeAt(i) < 128 ? eCharLen++ : cCharLen++;
    return {
      width: ~~(.8 * eCharLen * fontSize + cCharLen * fontSize),
      height: fontSize
    };
  }
  measureTextWidth(text, options, textMeasure) {
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options)).width : this.estimate(text, options).width;
  }
  measureTextBoundsWidth(text, options, textMeasure) {
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options)).width : this.estimate(text, options).width;
  }
  measureTextBoundsLeftRight(text, options, textMeasure) {
    return this.context ? {
      left: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).actualBoundingBoxLeft,
      right: textMeasure.actualBoundingBoxRight
    } : this.measureTextBoundLeftRightEstimate(options);
  }
  measureTextPixelHeight(text, options, textMeasure) {
    var _a;
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options, !0), Math.abs(textMeasure.actualBoundingBoxAscent - textMeasure.actualBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
  }
  measureTextPixelADscent(text, options, textMeasure) {
    return this.context ? {
      ascent: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).actualBoundingBoxAscent,
      descent: textMeasure.actualBoundingBoxDescent
    } : this.measureTextBoundADscentEstimate(options);
  }
  measureTextBoundHieght(text, options, textMeasure) {
    var _a;
    return this.context ? (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithoutAlignBaseline(text, options, !0), Math.abs(textMeasure.fontBoundingBoxAscent - textMeasure.fontBoundingBoxDescent)) : null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
  }
  measureTextBoundADscent(text, options, textMeasure) {
    return this.context ? {
      ascent: (textMeasure = null != textMeasure ? textMeasure : this._measureTextWithAlignBaseline(text, options, !0)).fontBoundingBoxAscent,
      descent: textMeasure.fontBoundingBoxDescent
    } : this.measureTextBoundADscentEstimate(options);
  }
  measureTextBoundADscentEstimate(options) {
    var _a;
    const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize;
    return {
      ascent: .79 * fontSize,
      descent: .21 * fontSize
    };
  }
  measureTextBoundLeftRightEstimate(options) {
    var _a;
    const fontSize = null !== (_a = options.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize,
      {
        textAlign: textAlign
      } = options;
    return "center" === textAlign ? {
      left: fontSize / 2,
      right: fontSize / 2
    } : "right" === textAlign || "end" === textAlign ? {
      left: fontSize,
      right: 0
    } : {
      left: 0,
      right: fontSize
    };
  }
  measureTextPixelADscentAndWidth(text, options, mode) {
    if (!this.context) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
      width: this.estimate(text, options).width
    });
    const out = this._measureTextWithoutAlignBaseline(text, options, !0);
    if (mode === MeasureModeEnum.actualBounding) return {
      ascent: out.actualBoundingBoxAscent,
      descent: out.actualBoundingBoxDescent,
      width: out.width
    };
    if (mode === MeasureModeEnum.estimate) return Object.assign(Object.assign({}, this.measureTextBoundADscentEstimate(options)), {
      width: out.width
    });
    if (mode === MeasureModeEnum.fontBounding) {
      let ascent = out.fontBoundingBoxAscent,
        descent = out.fontBoundingBoxDescent;
      if (out.actualBoundingBoxDescent && descent < out.actualBoundingBoxDescent) {
        const delta = out.actualBoundingBoxDescent - descent;
        descent += delta, ascent -= delta;
      } else if (out.actualBoundingBoxAscent && ascent < out.actualBoundingBoxAscent) {
        const delta = out.actualBoundingBoxAscent - ascent;
        ascent += delta, descent -= delta;
      }
      return {
        ascent: ascent,
        descent: descent,
        width: out.width
      };
    }
    return {
      ascent: out.actualBoundingBoxAscent,
      descent: out.actualBoundingBoxDescent,
      width: out.width
    };
  }
  measureText(text, options) {
    return this.context ? (this.context.setTextStyleWithoutAlignBaseline(options), this.context.measureText(text)) : this.estimate(text, options);
  }
  clipTextVertical(verticalList, options, width, wordBreak) {
    if (0 === verticalList.length) return {
      verticalList: verticalList,
      width: 0
    };
    const {
      fontSize = 12
    } = options;
    verticalList.forEach(item => {
      item.width = 0 === item.direction ? fontSize : this.measureTextWidth(item.text, options);
    });
    const out = [];
    let length = 0,
      i = 0;
    for (; i < verticalList.length && length + verticalList[i].width < width; i++) length += verticalList[i].width, out.push(verticalList[i]);
    if (verticalList[i] && verticalList[i].text.length > 1) {
      const clipedData = this._clipText(verticalList[i].text, options, width - length, 0, verticalList[i].text.length - 1, "end", !1);
      if (wordBreak && clipedData.str !== verticalList[i].text) {
        let text = "",
          length = 0;
        for (let j = 0; j < i; j++) {
          const item = verticalList[j];
          text += item.text, length += item.text.length;
        }
        text += verticalList[i].text;
        const totalLength = length + clipedData.str.length;
        let index = testLetter(text, totalLength);
        index -= length, index !== clipedData.str.length - 1 && (clipedData.str = clipedData.str.substring(0, index), clipedData.width = this.measureTextWidth(clipedData.str, options));
      }
      out.push(Object.assign(Object.assign({}, verticalList[i]), {
        text: clipedData.str,
        width: clipedData.width
      })), length += clipedData.width;
    }
    return {
      verticalList: out,
      width: length
    };
  }
  clipText(text, options, width, wordBreak, keepAllBreak) {
    if (0 === text.length) return {
      str: "",
      width: 0
    };
    let length = this.measureTextWidth(text, options);
    if (length <= width) return {
      str: text,
      width: length
    };
    if (length = this.measureTextWidth(text[0], options), length > width) return {
      str: "",
      width: 0
    };
    const data = this._clipText(text, options, width, 0, text.length - 1, "end", !1);
    if (wordBreak && data.str !== text) {
      let index = testLetter(text, data.str.length, keepAllBreak);
      index !== data.str.length && (index > data.str.length && (data.wordBreaked = index, index = data.str.length), data.str = text.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    }
    return data;
  }
  _clipText(text, options, width, leftIdx, rightIdx, position, suffix) {
    let data;
    if ("start" === position) data = this._clipTextStart(text, options, width, leftIdx, rightIdx), suffix && (data.result = suffix + data.str);else if ("middle" === position) {
      const d = this._clipTextMiddle(text, options, width, "", "", 0, 0, 1);
      data = {
        str: "none",
        width: d.width,
        result: d.left + suffix + d.right
      };
    } else data = this._clipTextEnd(text, options, width, leftIdx, rightIdx), suffix && (data.result = data.str + suffix);
    return data;
  }
  _clipTextEnd(text, options, width, leftIdx, rightIdx) {
    if (leftIdx === rightIdx) {
      Logger.getInstance().warn(`【_clipTextEnd】不应该走到这里${text}, ${leftIdx}, ${rightIdx}`);
      const subText = text.substring(0, rightIdx + 1);
      return {
        str: subText,
        width: this.measureTextWidth(subText, options)
      };
    }
    const middleIdx = Math.floor((leftIdx + rightIdx) / 2),
      subText = text.substring(0, middleIdx + 1),
      strWidth = this.measureTextWidth(subText, options);
    let length;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str = text.substring(0, middleIdx);
      return length = this.measureTextWidth(str, options), length <= width ? {
        str: str,
        width: length
      } : this._clipTextEnd(text, options, width, leftIdx, middleIdx);
    }
    if (strWidth < width) {
      if (middleIdx >= text.length - 1) return {
        str: text,
        width: this.measureTextWidth(text, options)
      };
      const str = text.substring(0, middleIdx + 2);
      return length = this.measureTextWidth(str, options), length >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextEnd(text, options, width, middleIdx, rightIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextStart(text, options, width, leftIdx, rightIdx) {
    const middleIdx = Math.ceil((leftIdx + rightIdx) / 2),
      subText = text.substring(middleIdx - 1, text.length),
      strWidth = this.measureTextWidth(subText, options);
    let length;
    if (strWidth > width) {
      if (subText.length <= 1) return {
        str: "",
        width: 0
      };
      const str = text.substring(middleIdx, text.length);
      return length = this.measureTextWidth(str, options), length <= width ? {
        str: str,
        width: length
      } : this._clipTextStart(text, options, width, middleIdx, text.length);
    }
    if (strWidth < width) {
      if (middleIdx <= 0) return {
        str: text,
        width: this.measureTextWidth(text, options)
      };
      const str = text.substring(middleIdx - 2, text.length);
      return length = this.measureTextWidth(str, options), length >= width ? {
        str: subText,
        width: strWidth
      } : this._clipTextStart(text, options, width, leftIdx, middleIdx);
    }
    return {
      str: subText,
      width: strWidth
    };
  }
  _clipTextMiddle(text, options, width, left, right, leftW, rightW, buffer) {
    const subLeftText = text.substring(0, buffer),
      strLeftWidth = this.measureTextWidth(subLeftText, options);
    if (strLeftWidth + rightW > width) return {
      left: left,
      right: right,
      width: leftW + rightW
    };
    const subRightText = text.substring(text.length - buffer, text.length),
      strRightWidth = this.measureTextWidth(subRightText, options);
    return strLeftWidth + strRightWidth > width ? {
      left: subLeftText,
      right: right,
      width: strLeftWidth + rightW
    } : this._clipTextMiddle(text, options, width, subLeftText, subRightText, strLeftWidth, strRightWidth, buffer + 1);
  }
  clipTextWithSuffixVertical(verticalList, options, width, suffix, wordBreak, suffixPosition) {
    if ("" === suffix) return this.clipTextVertical(verticalList, options, width, wordBreak);
    if (0 === verticalList.length) return {
      verticalList: verticalList,
      width: 0
    };
    const output = this.clipTextVertical(verticalList, options, width, wordBreak);
    if (output.verticalList.length === verticalList.length && output.verticalList[output.verticalList.length - 1].width === verticalList[verticalList.length - 1].width) return output;
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return output;
    let out;
    if (width -= suffixWidth, "start" === suffixPosition) {
      const nextVerticalList = this.revertVerticalList(verticalList);
      out = this.clipTextVertical(nextVerticalList, options, width, wordBreak);
      const v = this.revertVerticalList(out.verticalList);
      v.unshift({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), out.verticalList = v;
    } else if ("middle" === suffixPosition) {
      const leftOut = this.clipTextVertical(verticalList, options, width / 2, wordBreak),
        nextVerticalList = this.revertVerticalList(verticalList),
        rightOut = this.clipTextVertical(nextVerticalList, options, width / 2, wordBreak);
      leftOut.verticalList.push({
        text: suffix,
        direction: 1,
        width: suffixWidth
      }), this.revertVerticalList(rightOut.verticalList).forEach(v => leftOut.verticalList.push(v)), out = {
        verticalList: leftOut.verticalList,
        width: leftOut.width + rightOut.width
      };
    } else out = this.clipTextVertical(verticalList, options, width, wordBreak), out.verticalList.push({
      text: suffix,
      direction: 1,
      width: suffixWidth
    });
    return out.width += suffixWidth, out;
  }
  revertVerticalList(verticalList) {
    return verticalList.reverse().map(l => {
      const t = l.text.split("").reverse().join("");
      return Object.assign(Object.assign({}, l), {
        text: t
      });
    });
  }
  clipTextWithSuffix(text, options, width, suffix, wordBreak, position) {
    let forceSuffix = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
    if ("" === suffix) return this.clipText(text, options, width, wordBreak);
    if (0 === text.length) return {
      str: "",
      width: 0
    };
    const length = this.measureTextWidth(text, options);
    if (!forceSuffix && length <= width) return {
      str: text,
      width: length
    };
    const suffixWidth = this.measureTextWidth(suffix, options);
    if (suffixWidth > width) return {
      str: "",
      width: 0
    };
    if (forceSuffix && length + suffixWidth <= width) return {
      str: text + suffix,
      width: length + suffixWidth
    };
    width -= suffixWidth;
    const data = this._clipText(text, options, width, 0, text.length - 1, position, suffix);
    if (wordBreak && data.str !== text) {
      const index = testLetter(text, data.str.length);
      index !== data.str.length && (data.result = text.substring(0, index), data.width = this.measureTextWidth(data.str, options));
    } else forceSuffix && data.str === text && (data.result = text + suffix);
    return data.str = data.result, data.width += suffixWidth, data;
  }
};
ATextMeasure = __decorate$1K([injectable()], ATextMeasure);

var __decorate$1J = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
const TextMeasureContribution = Symbol.for("TextMeasureContribution");
let DefaultTextMeasureContribution = class extends ATextMeasure {};
DefaultTextMeasureContribution = __decorate$1J([injectable()], DefaultTextMeasureContribution);

const container = new Container();

const CanvasFactory = Symbol.for("CanvasFactory");
const Context2dFactory = Symbol.for("Context2dFactory");

function wrapCanvas(params) {
  return container.getNamed(CanvasFactory, application.global.env)(params);
}
function wrapContext(canvas, dpr) {
  return container.getNamed(Context2dFactory, application.global.env)(canvas, dpr);
}
const EPSILON_NUMERIC = 1e-4,
  THREE_SQRT = Math.sqrt(3),
  ONE_THIRD = 1 / 3;
function isAroundZero(val) {
  return val > -EPSILON && val < EPSILON;
}
function isNotAroundZero(val) {
  return val > EPSILON || val < -EPSILON;
}
const _v0 = [0, 0],
  _v1 = [0, 0],
  _v2 = [0, 0];
function distanceSquare(v1, v2) {
  return (v1[0] - v2[0]) * (v1[0] - v2[0]) + (v1[1] - v2[1]) * (v1[1] - v2[1]);
}
function quadraticAt(p0, p1, p2, t) {
  const onet = 1 - t;
  return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
}
function cubicAt(p0, p1, p2, p3, t) {
  const onet = 1 - t;
  return onet * onet * (onet * p0 + 3 * t * p1) + t * t * (t * p3 + 3 * onet * p2);
}
function quadraticRootAt(p0, p1, p2, val, roots) {
  const a = p0 - 2 * p1 + p2,
    b = 2 * (p1 - p0),
    c = p0 - val;
  let n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      const t1 = -c / b;
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) {
      const t1 = -b / (2 * a);
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc),
        t1 = (-b + discSqrt) / (2 * a),
        t2 = (-b - discSqrt) / (2 * a);
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
    }
  }
  return n;
}
function quadraticExtremum(p0, p1, p2) {
  const divider = p0 + p2 - 2 * p1;
  return 0 === divider ? .5 : (p0 - p1) / divider;
}
function quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, out) {
  let t = 0,
    interval = .005,
    d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += .05) {
    _v1[0] = quadraticAt(x0, x1, x2, _t), _v1[1] = quadraticAt(y0, y1, y2, _t);
    const d1 = distanceSquare(_v0, _v1);
    d1 < d && (t = _t, d = d1);
  }
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) {
    const prev = t - interval,
      next = t + interval;
    _v1[0] = quadraticAt(x0, x1, x2, prev), _v1[1] = quadraticAt(y0, y1, y2, prev);
    const d1 = distanceSquare(_v1, _v0);
    if (prev >= 0 && d1 < d) t = prev, d = d1;else {
      _v2[0] = quadraticAt(x0, x1, x2, next), _v2[1] = quadraticAt(y0, y1, y2, next);
      const d2 = distanceSquare(_v2, _v0);
      next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5;
    }
  }
  return out && (out[0] = quadraticAt(x0, x1, x2, t), out[1] = quadraticAt(y0, y1, y2, t)), Math.sqrt(d);
}
function cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
  let prev,
    next,
    d1,
    d2,
    t = 0,
    interval = .005,
    d = 1 / 0;
  _v0[0] = x, _v0[1] = y;
  for (let _t = 0; _t < 1; _t += .05) _v1[0] = cubicAt(x0, x1, x2, x3, _t), _v1[1] = cubicAt(y0, y1, y2, y3, _t), d1 = distanceSquare(_v0, _v1), d1 < d && (t = _t, d = d1);
  d = 1 / 0;
  for (let i = 0; i < 32 && !(interval < EPSILON_NUMERIC); i++) prev = t - interval, next = t + interval, _v1[0] = cubicAt(x0, x1, x2, x3, prev), _v1[1] = cubicAt(y0, y1, y2, y3, prev), d1 = distanceSquare(_v1, _v0), prev >= 0 && d1 < d ? (t = prev, d = d1) : (_v2[0] = cubicAt(x0, x1, x2, x3, next), _v2[1] = cubicAt(y0, y1, y2, y3, next), d2 = distanceSquare(_v2, _v0), next <= 1 && d2 < d ? (t = next, d = d2) : interval *= .5);
  return out && (out[0] = cubicAt(x0, x1, x2, x3, t), out[1] = cubicAt(y0, y1, y2, y3, t)), Math.sqrt(d);
}
function normalizeRadian(angle) {
  return (angle %= pi2) < 0 && (angle += pi2), angle;
}
function containQuadStroke(x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
  if (0 === lineWidth) return !1;
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l) return !1;
  return quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null) <= _l / 2;
}
function containCubicStroke(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
  if (0 === lineWidth) return !1;
  const _l = lineWidth;
  if (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l || y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l || x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l || x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l) return !1;
  return cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null) <= _l / 2;
}
function containArcStroke(cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
  if (0 === lineWidth) return !1;
  const _l = lineWidth;
  x -= cx, y -= cy;
  const d = Math.sqrt(x * x + y * y);
  if (d - _l > r || d + _l < r) return !1;
  if (Math.abs(startAngle - endAngle) % pi2 < 1e-4) return !0;
  if (anticlockwise) {
    const tmp = startAngle;
    startAngle = normalizeRadian(endAngle), endAngle = normalizeRadian(tmp);
  } else startAngle = normalizeRadian(startAngle), endAngle = normalizeRadian(endAngle);
  startAngle > endAngle && (endAngle += pi2);
  let angle = Math.atan2(y, x);
  return angle < 0 && (angle += pi2), angle >= startAngle && angle <= endAngle || angle + pi2 >= startAngle && angle + pi2 <= endAngle;
}
function containLineStroke(x0, y0, x1, y1, lineWidth, x, y) {
  if (0 === lineWidth) return !1;
  const _l = lineWidth,
    _halfL = lineWidth / 2;
  let _a = 0,
    _b = x0;
  if (y > y0 + _halfL && y > y1 + _halfL || y < y0 - _halfL && y < y1 - _halfL || x > x0 + _halfL && x > x1 + _halfL || x < x0 - _halfL && x < x1 - _halfL) return !1;
  if (x0 === x1) return Math.abs(x - x0) <= _l / 2;
  _a = (y0 - y1) / (x0 - x1), _b = (x0 * y1 - x1 * y0) / (x0 - x1);
  const tmp = _a * x - y + _b;
  return tmp * tmp / (_a * _a + 1) <= _l / 2 * _l / 2;
}
const EPSILON = 1e-4;
function cubicRootAt(p0, p1, p2, p3, val, roots) {
  const a = p3 + 3 * (p1 - p2) - p0,
    b = 3 * (p2 - 2 * p1 + p0),
    c = 3 * (p1 - p0),
    d = p0 - val,
    A = b * b - 3 * a * c,
    B = b * c - 9 * a * d,
    C = c * c - 3 * b * d;
  let n = 0;
  if (isAroundZero(A) && isAroundZero(B)) {
    if (isAroundZero(b)) roots[0] = 0;else {
      const t1 = -c / b;
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    }
  } else {
    const disc = B * B - 4 * A * C;
    if (isAroundZero(disc)) {
      const K = B / A,
        t1 = -b / a + K,
        t2 = -K / 2;
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2);
    } else if (disc > 0) {
      const discSqrt = Math.sqrt(disc);
      let Y1 = A * b + 1.5 * a * (-B + discSqrt),
        Y2 = A * b + 1.5 * a * (-B - discSqrt);
      Y1 = Y1 < 0 ? -Math.pow(-Y1, ONE_THIRD) : Math.pow(Y1, ONE_THIRD), Y2 = Y2 < 0 ? -Math.pow(-Y2, ONE_THIRD) : Math.pow(Y2, ONE_THIRD);
      const t1 = (-b - (Y1 + Y2)) / (3 * a);
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1);
    } else {
      const T = (2 * A * b - 3 * a * B) / (2 * Math.sqrt(A * A * A)),
        theta = Math.acos(T) / 3,
        ASqrt = Math.sqrt(A),
        tmp = Math.cos(theta),
        t1 = (-b - 2 * ASqrt * tmp) / (3 * a),
        t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a),
        t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
      t1 >= 0 && t1 <= 1 && (roots[n++] = t1), t2 >= 0 && t2 <= 1 && (roots[n++] = t2), t3 >= 0 && t3 <= 1 && (roots[n++] = t3);
    }
  }
  return n;
}
function cubicExtrema(p0, p1, p2, p3, extrema) {
  const b = 6 * p2 - 12 * p1 + 6 * p0,
    a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2,
    c = 3 * p1 - 3 * p0;
  let n = 0;
  if (isAroundZero(a)) {
    if (isNotAroundZero(b)) {
      const t1 = -c / b;
      t1 >= 0 && t1 <= 1 && (extrema[n++] = t1);
    }
  } else {
    const disc = b * b - 4 * a * c;
    if (isAroundZero(disc)) extrema[0] = -b / (2 * a);else if (disc > 0) {
      const discSqrt = Math.sqrt(disc),
        t1 = (-b + discSqrt) / (2 * a),
        t2 = (-b - discSqrt) / (2 * a);
      t1 >= 0 && t1 <= 1 && (extrema[n++] = t1), t2 >= 0 && t2 <= 1 && (extrema[n++] = t2);
    }
  }
  return n;
}
function isAroundEqual(a, b) {
  return Math.abs(a - b) < EPSILON;
}
const roots = [-1, -1, -1],
  extrema = [-1, -1];
function swapExtrema() {
  const tmp = extrema[0];
  extrema[0] = extrema[1], extrema[1] = tmp;
}
function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
  if (y > y0 && y > y1 && y > y2 && y > y3 || y < y0 && y < y1 && y < y2 && y < y3) return 0;
  const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots);
  if (0 === nRoots) return 0;
  let w = 0,
    nExtrema = -1,
    y0_ = 0,
    y1_ = 0;
  for (let i = 0; i < nRoots; i++) {
    const t = roots[i],
      unit = 0 === t || 1 === t ? .5 : 1;
    cubicAt(x0, x1, x2, x3, t) < x || (nExtrema < 0 && (nExtrema = cubicExtrema(y0, y1, y2, y3, extrema), extrema[1] < extrema[0] && nExtrema > 1 && swapExtrema(), y0_ = cubicAt(y0, y1, y2, y3, extrema[0]), nExtrema > 1 && (y1_ = cubicAt(y0, y1, y2, y3, extrema[1]))), 2 === nExtrema ? t < extrema[0] ? w += y0_ < y0 ? unit : -unit : t < extrema[1] ? w += y1_ < y0_ ? unit : -unit : w += y3 < y1_ ? unit : -unit : t < extrema[0] ? w += y0_ < y0 ? unit : -unit : w += y3 < y0_ ? unit : -unit);
  }
  return w;
}
function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
  if (y > y0 && y > y1 && y > y2 || y < y0 && y < y1 && y < y2) return 0;
  const nRoots = quadraticRootAt(y0, y1, y2, y, roots);
  if (0 === nRoots) return 0;
  const t = quadraticExtremum(y0, y1, y2);
  if (t >= 0 && t <= 1) {
    let w = 0;
    const y_ = quadraticAt(y0, y1, y2, t);
    for (let i = 0; i < nRoots; i++) {
      const unit = 0 === roots[i] || 1 === roots[i] ? .5 : 1;
      quadraticAt(x0, x1, x2, roots[i]) < x || (roots[i] < t ? w += y_ < y0 ? unit : -unit : w += y2 < y_ ? unit : -unit);
    }
    return w;
  }
  const unit = 0 === roots[0] || 1 === roots[0] ? .5 : 1;
  return quadraticAt(x0, x1, x2, roots[0]) < x ? 0 : y2 < y0 ? unit : -unit;
}
function windingArc(cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
  if ((y -= cy) > r || y < -r) return 0;
  const tmp = Math.sqrt(r * r - y * y);
  roots[0] = -tmp, roots[1] = tmp;
  const dTheta = Math.abs(startAngle - endAngle);
  if (dTheta < 1e-4) return 0;
  if (dTheta >= pi2 - 1e-4) {
    startAngle = 0, endAngle = pi2;
    const dir = anticlockwise ? 1 : -1;
    return x >= roots[0] + cx && x <= roots[1] + cx ? dir : 0;
  }
  if (startAngle > endAngle) {
    const tmp = startAngle;
    startAngle = endAngle, endAngle = tmp;
  }
  startAngle < 0 && (startAngle += pi2, endAngle += pi2);
  let w = 0;
  for (let i = 0; i < 2; i++) {
    const x_ = roots[i];
    if (x_ + cx > x) {
      let angle = Math.atan2(y, x_),
        dir = anticlockwise ? 1 : -1;
      angle < 0 && (angle = pi2 + angle), (angle >= startAngle && angle <= endAngle || angle + pi2 >= startAngle && angle + pi2 <= endAngle) && (angle > pi / 2 && angle < 1.5 * pi && (dir = -dir), w += dir);
    }
  }
  return w;
}
function modpi2(radian) {
  return Math.round(radian / pi * 1e8) / 1e8 % 2 * pi;
}
function normalizeArcAngles(angles, anticlockwise) {
  let newStartAngle = modpi2(angles[0]);
  newStartAngle < 0 && (newStartAngle += pi2);
  const delta = newStartAngle - angles[0];
  let newEndAngle = angles[1];
  newEndAngle += delta, !anticlockwise && newEndAngle - newStartAngle >= pi2 ? newEndAngle = newStartAngle + pi2 : anticlockwise && newStartAngle - newEndAngle >= pi2 ? newEndAngle = newStartAngle - pi2 : !anticlockwise && newStartAngle > newEndAngle ? newEndAngle = newStartAngle + (pi2 - modpi2(newStartAngle - newEndAngle)) : anticlockwise && newStartAngle < newEndAngle && (newEndAngle = newStartAngle - (pi2 - modpi2(newEndAngle - newStartAngle))), angles[0] = newStartAngle, angles[1] = newEndAngle;
}
const tmpAngles = [0, 0];
function containPath(commands, lineWidth, isStroke, x, y) {
  const data = commands,
    len = commands.length;
  let x1,
    y1,
    w = 0,
    xi = 0,
    yi = 0,
    x0 = 0,
    y0 = 0;
  for (let i = 0; i < len; i++) {
    const command = data[i],
      isFirst = 0 === i;
    command[0] === enumCommandMap.M && i > 1 && (isStroke || (w += isPointInLine(xi, yi, x0, y0, x, y))), isFirst && (xi = command[1], yi = command[2], x0 = xi, y0 = yi);
    const c0 = command[0],
      c1 = command[1],
      c2 = command[2],
      c3 = command[3],
      c4 = command[4],
      c5 = command[5],
      c6 = command[6];
    let startAngle = c4,
      endAngle = c5;
    tmpAngles[0] = startAngle, tmpAngles[1] = endAngle, normalizeArcAngles(tmpAngles, Boolean(command[6])), startAngle = tmpAngles[0], endAngle = tmpAngles[1];
    const theta = startAngle,
      dTheta = endAngle - startAngle,
      anticlockwise = !!(1 - (command[6] ? 0 : 1)),
      _x = (x - c1) * c3 / c3 + c1;
    switch (c0) {
      case enumCommandMap.M:
        x0 = c1, y0 = c2, xi = x0, yi = y0;
        break;
      case enumCommandMap.L:
        if (isStroke) {
          if (containLineStroke(xi, yi, c1, c2, lineWidth, x, y)) return !0;
        } else w += isPointInLine(xi, yi, c1, c2, x, y) || 0;
        xi = c1, yi = c2;
        break;
      case enumCommandMap.C:
        if (isStroke) {
          if (containCubicStroke(xi, yi, c1, c2, c3, c4, c5, c6, lineWidth, x, y)) return !0;
        } else w += windingCubic(xi, yi, c1, c2, c3, c4, c5, c6, x, y) || 0;
        xi = c5, yi = c6;
        break;
      case enumCommandMap.Q:
        if (isStroke) {
          if (containQuadStroke(xi, yi, c1, c2, c3, c4, lineWidth, x, y)) return !0;
        } else w += windingQuadratic(xi, yi, c1, c2, c3, c4, x, y) || 0;
        xi = c3, yi = c4;
        break;
      case enumCommandMap.A:
        if (x1 = Math.cos(theta) * c3 + c1, y1 = Math.sin(theta) * c3 + c2, isFirst ? (x0 = x1, y0 = y1) : w += isPointInLine(xi, yi, x1, y1, x, y), isStroke) {
          if (containArcStroke(c1, c2, c3, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) return !0;
        } else w += windingArc(c1, c2, c3, theta, theta + dTheta, anticlockwise, _x, y);
        xi = Math.cos(theta + dTheta) * c3 + c1, yi = Math.sin(theta + dTheta) * c3 + c2;
        break;
      case enumCommandMap.R:
        if (x0 = xi = c1, y0 = yi = c2, x1 = x0 + c3, y1 = y0 + c4, isStroke) {
          if (containLineStroke(x0, y0, x1, y0, lineWidth, x, y) || containLineStroke(x1, y0, x1, y1, lineWidth, x, y) || containLineStroke(x1, y1, x0, y1, lineWidth, x, y) || containLineStroke(x0, y1, x0, y0, lineWidth, x, y)) return !0;
        } else w += isPointInLine(x1, y0, x1, y1, x, y), w += isPointInLine(x0, y1, x0, y0, x, y);
        break;
      case enumCommandMap.Z:
        if (isStroke) {
          if (containLineStroke(xi, yi, x0, y0, lineWidth, x, y)) return !0;
        } else w += isPointInLine(xi, yi, x0, y0, x, y);
        xi = x0, yi = y0;
    }
  }
  return isStroke || isAroundEqual(yi, y0) || (w += isPointInLine(xi, yi, x0, y0, x, y) || 0), 0 !== w;
}
function contain(commands, x, y) {
  return containPath(commands, 0, !1, x, y);
}
function containStroke(commands, lineWidth, x, y) {
  return containPath(commands, lineWidth, !0, x, y);
}

class DefaultCanvasAllocate {
  constructor() {
    this.pools = [], this.allocatedCanvas = [];
  }
  shareCanvas() {
    return this.allocatedCanvas.length ? this.allocatedCanvas[0] : this.getCommonCanvas();
  }
  getCommonCanvas() {
    return this._commonCanvas || (this._commonCanvas = this.allocate({
      width: 100,
      height: 100,
      dpr: 2
    })), this._commonCanvas;
  }
  allocate(data) {
    if (!this.pools.length) {
      const c = wrapCanvas(Object.assign({
        nativeCanvas: application.global.createCanvas(data)
      }, data));
      return this.allocatedCanvas.push(c), c;
    }
    const m = this.pools.pop();
    return m.resize(data.width, data.height), m.dpr = data.dpr, m;
  }
  allocateByObj(canvas) {
    if (!this.pools.length) {
      const data = {
          width: canvas.width / canvas.dpr,
          height: canvas.height / canvas.dpr,
          dpr: canvas.dpr
        },
        c = wrapCanvas(Object.assign({
          nativeCanvas: application.global.createCanvas(data)
        }, data));
      return this.allocatedCanvas.push(c), c;
    }
    const m = this.pools.pop();
    return m.width = canvas.width, m.height = canvas.height, m;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release() {
    this.pools = [];
  }
}
const canvasAllocate = new DefaultCanvasAllocate();

var __decorate$1I = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1j = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
const VWindow = Symbol.for("VWindow");
const WindowHandlerContribution = Symbol.for("WindowHandlerContribution");
let DefaultWindow = class {
  get width() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._width = wh.width;
    }
    return this._width;
  }
  get height() {
    if (this._handler) {
      const wh = this._handler.getWH();
      return this._height = wh.height;
    }
    return this._height;
  }
  get dpr() {
    return this._handler.getDpr();
  }
  constructor() {
    this.hooks = {
      onChange: new SyncHook(["x", "y", "width", "height"])
    }, this.active = () => {
      const global = this.global;
      if (!global.env || this.actived) return;
      container.getNamed(WindowHandlerContribution, global.env).configure(this, global), this.actived = !0;
    }, this._uid = Generator.GenAutoIncrementId(), this.global = application.global, this.postInit();
  }
  postInit() {
    this.global.hooks.onSetEnv.tap("window", this.active), this.active();
  }
  get style() {
    var _a;
    return null !== (_a = this._handler.getStyle()) && void 0 !== _a ? _a : {};
  }
  set style(style) {
    this._handler.setStyle(style);
  }
  create(params) {
    var _a, _b;
    this._handler.createWindow(params);
    const windowWH = this._handler.getWH();
    this._width = windowWH.width, this._height = windowWH.height, params.viewBox ? this.setViewBox(params.viewBox) : !1 !== params.canvasControled ? this.setViewBox({
      x1: 0,
      y1: 0,
      x2: this._width,
      y2: this._height
    }) : this.setViewBox({
      x1: 0,
      y1: 0,
      x2: null !== (_a = params.width) && void 0 !== _a ? _a : this._width,
      y2: null !== (_b = params.height) && void 0 !== _b ? _b : this._height
    }), this.title = this._handler.getTitle(), this.resizable = !0;
  }
  setWindowHandler(handler) {
    this._handler = handler;
  }
  setDpr(dpr) {
    return this._handler.setDpr(dpr);
  }
  resize(w, h) {
    return this._handler.resizeWindow(w, h);
  }
  configure() {
    throw new Error("暂不支持");
  }
  release() {
    return this.global.hooks.onSetEnv.unTap("window", this.active), this._handler.releaseWindow();
  }
  getContext() {
    return this._handler.getContext();
  }
  getNativeHandler() {
    return this._handler.getNativeHandler();
  }
  getImageBuffer(type) {
    return this._handler.getImageBuffer ? this._handler.getImageBuffer(type) : null;
  }
  addEventListener(type, listener, options) {
    return this._handler.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this._handler.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this._handler.dispatchEvent(event);
  }
  getBoundingClientRect() {
    return this._handler.getBoundingClientRect();
  }
  getContainer() {
    return this._handler.container;
  }
  clearViewBox(color) {
    this._handler.clearViewBox(color);
  }
  setViewBox(viewBox) {
    this._handler.setViewBox(viewBox);
  }
  setViewBoxTransform(a, b, c, d, e, f) {
    this._handler.setViewBoxTransform(a, b, c, d, e, f);
  }
  getViewBox() {
    return this._handler.getViewBox();
  }
  getViewBoxTransform() {
    return this._handler.getViewBoxTransform();
  }
  pointTransform(x, y) {
    const vb = this._handler.getViewBox(),
      nextP = {
        x: x,
        y: y
      };
    return this._handler.getViewBoxTransform().transformPoint({
      x: x,
      y: y
    }, nextP), nextP.x -= vb.x1, nextP.y -= vb.y1, nextP;
  }
  hasSubView() {
    const viewBox = this._handler.getViewBox();
    return !(0 === viewBox.x1 && 0 === viewBox.y1 && isNumberClose(this.width, viewBox.width()) && isNumberClose(this.height, viewBox.height()));
  }
  isVisible(bbox) {
    return this._handler.isVisible(bbox);
  }
  onVisibleChange(cb) {
    return this._handler.onVisibleChange(cb);
  }
  getTopLeft(baseWindow) {
    return this._handler.getTopLeft(baseWindow);
  }
};
DefaultWindow = __decorate$1I([injectable(), __metadata$1j("design:paramtypes", [])], DefaultWindow);

var __decorate$1H = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1i = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$V = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultGraphicUtil = class {
  get canvas() {
    return this.tryInitCanvas(), this._canvas;
  }
  get context() {
    return this.tryInitCanvas(), this._context;
  }
  constructor(contributions) {
    this.contributions = contributions, this.configured = !1, this.global = application.global, this.global.hooks.onSetEnv.tap("graphic-util", (lastEnv, env, global) => {
      this.configured = !1, this.configure(global, env);
    });
  }
  get textMeasure() {
    return this._textMeasure || this.configure(this.global, this.global.env), this._textMeasure;
  }
  configure(global, env) {
    this.configured || (this.contributions.getContributions().forEach(contribution => {
      contribution.configure(this, env);
    }), this.configured = !0);
  }
  tryInitCanvas() {
    if (!this._canvas) {
      const canvas = canvasAllocate.shareCanvas();
      this._canvas = canvas, this._context = canvas.getContext("2d");
    }
  }
  bindTextMeasure(tm) {
    this._textMeasure = tm;
  }
  measureText(text, tc) {
    let method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "native";
    var _a;
    this.configure(this.global, this.global.env);
    const m = this.global.measureTextMethod;
    this.global.measureTextMethod = method;
    const data = {
      width: this._textMeasure.measureTextWidth(text, tc),
      height: null !== (_a = tc.fontSize) && void 0 !== _a ? _a : DefaultTextStyle.fontSize
    };
    return this.global.measureTextMethod = m, data;
  }
  createTextMeasureInstance(textSpec, option, getCanvasForMeasure) {
    return this.configure(this.global, this.global.env), new TextMeasure(Object.assign({
      defaultFontParams: {
        fontFamily: DefaultTextStyle.fontFamily,
        fontSize: DefaultTextStyle.fontSize
      },
      getCanvasForMeasure: getCanvasForMeasure || (() => this.canvas),
      getTextBounds: void 0,
      specialCharSet: "-/: .,@%'\"~" + TextMeasure.ALPHABET_CHAR_SET + TextMeasure.ALPHABET_CHAR_SET.toUpperCase()
    }, null != option ? option : {}), textSpec);
  }
  drawGraphicToCanvas(graphic, stage, canvas) {
    if (!stage.defaultLayer) return null;
    const window = container.get(VWindow),
      bounds = graphic.AABBBounds,
      width = bounds.width(),
      height = bounds.height(),
      x1 = -bounds.x1,
      y1 = -bounds.y1;
    window.create({
      viewBox: {
        x1: x1,
        y1: y1,
        x2: bounds.x2,
        y2: bounds.y2
      },
      width: width,
      height: height,
      canvas: canvas,
      dpr: stage.window.dpr,
      canvasControled: !0,
      offscreen: !0,
      title: ""
    });
    const disableCheckGraphicWidthOutRange = stage.params.optimize.disableCheckGraphicWidthOutRange;
    stage.params.optimize.disableCheckGraphicWidthOutRange = !0, stage.defaultLayer.getNativeHandler().drawTo(window, [graphic], {
      transMatrix: window.getViewBoxTransform(),
      viewBox: window.getViewBox(),
      stage: stage,
      layer: stage.defaultLayer,
      renderService: stage.renderService,
      background: "transparent",
      clear: !0,
      updateBounds: !1
    }), stage.params.optimize.disableCheckGraphicWidthOutRange = disableCheckGraphicWidthOutRange;
    const c = window.getNativeHandler();
    return c.nativeCanvas ? c.nativeCanvas : null;
  }
};
DefaultGraphicUtil = __decorate$1H([injectable(), __param$V(0, inject(ContributionProvider)), __param$V(0, named(TextMeasureContribution)), __metadata$1i("design:paramtypes", [Object])], DefaultGraphicUtil);
var TransformMode;
!function (TransformMode) {
  TransformMode[TransformMode.transform = 0] = "transform", TransformMode[TransformMode.matrix = 1] = "matrix";
}(TransformMode || (TransformMode = {}));
const _matrix = new Matrix();
let DefaultTransformUtil = class {
  constructor() {
    this.matrix = new Matrix();
  }
  init(origin) {
    return this.mode = TransformMode.transform, this.originTransform = origin, this.matrix.reset(), this;
  }
  fromMatrix(source, target) {
    return this.mode = TransformMode.matrix, this.outSourceMatrix = source, this.outTargetMatrix = target, this;
  }
  scaleMatrix(sx, sy, center) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
      const {
        x: x,
        y: y
      } = center;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.scale(sx, sy), this.outTargetMatrix.translate(-x, -y);
    } else this.outTargetMatrix.scale(sx, sy);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  rotateMatrix(angle, center) {
    const sMatrix = this.outSourceMatrix;
    if (_matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), center) {
      const {
        x: x,
        y: y
      } = center;
      this.outTargetMatrix.translate(x, y), this.outTargetMatrix.rotate(angle), this.outTargetMatrix.translate(-x, -y);
    } else this.outTargetMatrix.rotate(angle);
    return this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  scale(sx, sy, center) {
    return this.mode === TransformMode.matrix ? this.scaleMatrix(sx, sy, center) : this;
  }
  rotate(angle, center) {
    return this.mode === TransformMode.matrix ? this.rotateMatrix(angle, center) : this;
  }
  translateMatrix(dx, dy) {
    const sMatrix = this.outSourceMatrix;
    return _matrix.setValue(sMatrix.a, sMatrix.b, sMatrix.c, sMatrix.d, sMatrix.e, sMatrix.f), this.outTargetMatrix.reset(), this.outTargetMatrix.translate(dx, dy), this.outTargetMatrix.multiply(_matrix.a, _matrix.b, _matrix.c, _matrix.d, _matrix.e, _matrix.f), this;
  }
  translate(dx, dy) {
    return this.mode === TransformMode.matrix ? this.translateMatrix(dx, dy) : this;
  }
  simplify(target) {
    return this.mode === TransformMode.matrix ? this.simplifyMatrix(target) : this;
  }
  simplifyMatrix(target) {
    return this;
  }
};
DefaultTransformUtil = __decorate$1H([injectable(), __metadata$1i("design:paramtypes", [])], DefaultTransformUtil);

const defaultThemeObj = {
    arc: DefaultArcAttribute,
    area: DefaultAreaAttribute,
    circle: DefaultCircleAttribute,
    line: DefaultLineAttribute,
    path: DefaultPathAttribute,
    symbol: DefaultSymbolAttribute,
    text: DefaultTextAttribute,
    rect: DefaultRectAttribute,
    polygon: DefaultPolygonAttribute,
    richtext: DefaultRichTextAttribute,
    richtextIcon: DefaultRichTextIconAttribute,
    image: DefaultImageAttribute,
    group: DefaultGroupAttribute,
    glyph: DefaultGlyphAttribute
  },
  themeKeys = Object.keys(defaultThemeObj);
function newThemeObj() {
  return {
    arc: Object.assign({}, defaultThemeObj.arc),
    area: Object.assign({}, defaultThemeObj.area),
    circle: Object.assign({}, defaultThemeObj.circle),
    line: Object.assign({}, defaultThemeObj.line),
    path: Object.assign({}, defaultThemeObj.path),
    symbol: Object.assign({}, defaultThemeObj.symbol),
    text: Object.assign({}, defaultThemeObj.text),
    rect: Object.assign({}, defaultThemeObj.rect),
    polygon: Object.assign({}, defaultThemeObj.polygon),
    richtext: Object.assign({}, defaultThemeObj.richtext),
    richtextIcon: Object.assign({}, defaultThemeObj.richtextIcon),
    image: Object.assign({}, defaultThemeObj.image),
    group: Object.assign({}, defaultThemeObj.group),
    glyph: Object.assign({}, defaultThemeObj.glyph)
  };
}
function combine(out, t) {
  Object.keys(t).forEach(k => {
    out[k] = t[k];
  });
}
const globalThemeObj = newThemeObj();
class Theme {
  constructor() {
    this.initTheme(), this.dirty = !1;
  }
  initTheme() {
    this._defaultTheme = {}, themeKeys.forEach(key => {
      this._defaultTheme[key] = Object.create(globalThemeObj[key]);
    }), this.combinedTheme = this._defaultTheme;
  }
  getTheme(group) {
    if (!group) return this.combinedTheme;
    if (!this.dirty) return this.combinedTheme;
    let parentTheme = {};
    const parentGroup = this.getParentWithTheme(group);
    return parentGroup && (parentTheme = parentGroup.theme), this.applyTheme(group, parentTheme), this.combinedTheme;
  }
  getParentWithTheme(group) {
    for (; group.parent;) if ((group = group.parent).theme) return group;
    return null;
  }
  applyTheme(group, pt) {
    let force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    if (this.dirty) {
      const parentGroup = this.getParentWithTheme(group);
      if (parentGroup) {
        const parentTheme = parentGroup.theme;
        (parentTheme.dirty || force) && parentTheme.applyTheme(parentGroup, pt, !0);
      }
      this.userTheme ? this.doCombine(parentGroup && parentGroup.theme.combinedTheme) : (parentGroup ? this.combinedTheme = parentGroup.theme.combinedTheme : (this.combinedTheme = this._defaultTheme, Logger.getInstance().warn("未知错误，走到不应该走的区域里")), this.dirty = !1);
    }
    return this.combinedTheme;
  }
  doCombine(parentCombinedTheme) {
    const userTheme = this.userTheme,
      combinedTheme = this.combinedTheme;
    themeKeys.forEach(k => {
      const obj = Object.create(globalThemeObj[k]);
      parentCombinedTheme && parentCombinedTheme[k] && combine(obj, parentCombinedTheme[k]), combinedTheme[k] && combine(obj, combinedTheme[k]), userTheme[k] && combine(obj, userTheme[k]), this.combinedTheme[k] = obj;
    }), userTheme.common && themeKeys.forEach(k => {
      combine(this.combinedTheme[k], userTheme.common);
    }), this.dirty = !1;
  }
  setTheme(t, g) {
    let userTheme = this.userTheme;
    userTheme ? Object.keys(t).forEach(k => {
      userTheme[k] ? Object.assign(userTheme[k], t[k]) : userTheme[k] = Object.assign({}, t[k]);
    }) : userTheme = t, this.userTheme = userTheme, this.dirty = !0, this.dirtyChildren(g);
  }
  resetTheme(t, g) {
    this.userTheme = t, this.dirty = !0, this.dirtyChildren(g);
  }
  dirtyChildren(g) {
    g.forEachChildren(item => {
      item.isContainer && (item.theme && (item.theme.dirty = !0), this.dirtyChildren(item));
    });
  }
}
const globalTheme = new Theme();
function getTheme(graphic, theme) {
  return graphic.glyphHost ? getTheme(graphic.glyphHost) : theme ? (graphic.isContainer, theme) : getThemeFromGroup(graphic) || graphic.attachedThemeGraphic && getTheme(graphic.attachedThemeGraphic) || globalTheme.getTheme();
}
function getThemeFromGroup(graphic) {
  let g;
  if (g = graphic.isContainer ? graphic : graphic.parent, g) {
    for (; g && !g.theme;) g = g.parent;
    return g ? (g.theme || g.createTheme(), g.theme.getTheme(g)) : globalTheme.getTheme();
  }
  return null;
}

var __awaiter$7 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
class Node extends EventEmitter {
  get previousSibling() {
    return this._prev;
  }
  get nextSibling() {
    return this._next;
  }
  get children() {
    return this.getChildren();
  }
  get firstChild() {
    return this._firstChild;
  }
  get lastChild() {
    return this._lastChild;
  }
  get count() {
    return this._count;
  }
  get childrenCount() {
    return this._idMap ? this._idMap.size : 0;
  }
  constructor() {
    super(), this._uid = Generator.GenAutoIncrementId(), this._firstChild = null, this._lastChild = null, this.parent = null, this._count = 1;
  }
  forEachChildren(cb) {
    let reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (reverse) {
      let child = this._lastChild,
        i = 0;
      for (; child;) {
        if (cb(child, i++)) return;
        child = child._prev;
      }
    } else {
      let child = this._firstChild,
        i = 0;
      for (; child;) {
        if (cb(child, i++)) return;
        child = child._next;
      }
    }
  }
  forEachChildrenAsync(cb) {
    let reverse = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return __awaiter$7(this, void 0, void 0, function* () {
      if (reverse) {
        let child = this._lastChild,
          i = 0;
        for (; child;) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._prev;
        }
      } else {
        let child = this._firstChild,
          i = 0;
        for (; child;) {
          let breakTag = cb(child, i++);
          if (breakTag.then && (breakTag = yield breakTag), breakTag) return;
          child = child._next;
        }
      }
    });
  }
  forEach(cb) {
    return this.forEachChildren(cb);
  }
  appendChild(node) {
    let highPerformance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    if (this._uid === node._uid) return null;
    if (!highPerformance && node.isAncestorsOf(this)) throw new Error("【Node::appendChild】不能将父辈元素append为子元素");
    return node.parent && node.parent.removeChild(node), node.parent = this, this._lastChild ? (this._lastChild._next = node, node._prev = this._lastChild, this._lastChild = node) : (this._firstChild = this._lastChild = node, node._prev = node._next = null), this._idMap || (this._idMap = new Map()), this._idMap.set(node._uid, node), this.setCount(node.count), this._structEdit = !0, node;
  }
  appendChildArrHighPerformance(nodes) {
    return console.error("暂不支持该函数"), nodes;
  }
  insertBefore(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this === newNode || newNode === referenceNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, newNode._prev = referenceNode._prev, referenceNode._prev ? referenceNode._prev._next = newNode : this._firstChild = newNode, referenceNode._prev = newNode, newNode._next = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
  }
  insertAfter(newNode, referenceNode) {
    if (!referenceNode) return this.appendChild(newNode);
    if (this === newNode || newNode === referenceNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertAfter】不能将父辈元素insert为子元素");
    return referenceNode.parent !== this ? null : (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, referenceNode._next ? (referenceNode._next._prev = newNode, newNode._next = referenceNode._next) : this._lastChild = newNode, referenceNode._next = newNode, newNode._prev = referenceNode, this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode);
  }
  insertInto(newNode, idx) {
    if (!this._ignoreWarn && this._nodeList && Logger.getInstance().warn("insertIntoKeepIdx和insertInto混用可能会存在错误"), idx >= this.childrenCount) return this.appendChild(newNode);
    if (this === newNode) return null;
    if (newNode.isAncestorsOf(this)) throw new Error("【Node::insertBefore】不能将父辈元素insert为子元素");
    if (newNode.parent && newNode.parent.removeChild(newNode), newNode.parent = this, 0 === idx) newNode._next = this._firstChild, this._firstChild && (this._firstChild._prev = newNode), newNode._prev = null, this._firstChild = newNode;else {
      let child = this._firstChild;
      for (let i = 0; i < idx; i++) {
        if (!child) return null;
        i > 0 && (child = child._next);
      }
      if (!child) return null;
      newNode._next = child._next, newNode._prev = child, child._next = newNode, newNode._next && (newNode._next._prev = newNode);
    }
    return this._idMap || (this._idMap = new Map()), this._idMap.set(newNode._uid, newNode), this._structEdit = !0, this.setCount(newNode.count), newNode;
  }
  insertIntoKeepIdx(newNode, idx) {
    if (this._nodeList || (this._nodeList = this.children), this._nodeList[idx]) {
      const node = this._nodeList[idx];
      return this._nodeList.splice(idx, 0, newNode), this.insertBefore(newNode, node);
    }
    let node;
    this._nodeList[idx] = newNode;
    for (let i = idx - 1; i >= 0 && (node = this._nodeList[i], !node); i--);
    if (node) return node._next ? this.insertBefore(newNode, node._next) : this.appendChild(newNode);
    this._ignoreWarn = !0;
    const data = this.insertInto(newNode, 0);
    return this._ignoreWarn = !1, data;
  }
  removeChild(child) {
    if (!this._idMap) return null;
    if (!this._idMap.has(child._uid)) return null;
    if (this._idMap.delete(child._uid), this._nodeList) {
      const idx = this._nodeList.findIndex(n => n === child);
      idx >= 0 && this._nodeList.splice(idx, 1);
    }
    return child._prev ? child._prev._next = child._next : this._firstChild = child._next, child._next ? child._next._prev = child._prev : this._lastChild = child._prev, child.parent = null, child._prev = null, child._next = null, this._structEdit = !0, this.setCount(-child.count), child;
  }
  delete() {
    this.parent && this.parent.removeChild(this);
  }
  removeAllChild(deep) {
    if (!this._idMap) return;
    this._nodeList && (this._nodeList.length = 0);
    let child = this._firstChild;
    for (; child;) {
      const next = child._next;
      child.parent = null, child._prev = null, child._next = null, child = child._next, child = next;
    }
    this._firstChild = null, this._lastChild = null, this._idMap.clear(), this._structEdit = !0, this.setCount(1 - this._count);
  }
  replaceChild(newChild, oldChild) {
    throw new Error("暂不支持");
  }
  find(callback) {
    let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    let target = null;
    return this.forEachChildren((node, index) => !(node === this || !callback(node, index)) && (target = node, !0)), deep && this.forEachChildren(child => {
      if (child.isContainer) {
        const node = child.find(callback, !0);
        if (node) return target = node, !0;
      }
      return !1;
    }), target;
  }
  findAll(callback) {
    let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    let nodes = [];
    return this.forEachChildren((node, index) => {
      node !== this && callback(node, index) && nodes.push(node);
    }), deep && this.forEachChildren(child => {
      if (child.isContainer) {
        const targets = child.findAll(callback, !0);
        targets.length && (nodes = nodes.concat(targets));
      }
    }), nodes;
  }
  getElementById(id) {
    return this.find(node => node.id === id, !0);
  }
  findChildById(id) {
    return this.getElementById(id);
  }
  findChildByUid(uid) {
    return this._idMap && this._idMap.get(uid) || null;
  }
  getElementsByName(name) {
    return this.findAll(node => node.name === name, !0);
  }
  findChildrenByName(name) {
    return this.getElementsByName(name);
  }
  getElementsByType(type) {
    return this.findAll(node => node.type === type, !0);
  }
  getChildByName(name) {
    let deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return this.find(node => node.name === name, deep);
  }
  getChildAt(idx) {
    let c = this._firstChild;
    if (!c) return null;
    for (let i = 0; i < idx; i++) {
      if (!c._next) return null;
      c = c._next;
    }
    return c;
  }
  at(idx) {
    return this.getChildAt(idx);
  }
  containNode(node) {
    if (!this._idMap) return !1;
    if (this._idMap.has(node._uid)) return !0;
    let child = this._firstChild;
    for (; child;) {
      if (child.containNode(node)) return !0;
      child = child._next;
    }
    return !1;
  }
  getRootNode() {
    let parent = this.parent;
    for (; null == parent ? void 0 : parent.parent;) parent = parent.parent;
    return parent || this;
  }
  hasChildNodes() {
    return null !== this._firstChild;
  }
  addChild(node) {
    return this.appendChild(node);
  }
  add(node) {
    return this.appendChild(node);
  }
  getChildren() {
    const nodes = [];
    let child = this._firstChild;
    for (; child;) nodes.push(child), child = child._next;
    return nodes;
  }
  isChildOf(node) {
    return !!this.parent && this.parent._uid === node._uid;
  }
  isParentOf(node) {
    return node.isChildOf(this);
  }
  isDescendantsOf(node) {
    let parent = this.parent;
    if (!parent) return !1;
    do {
      if (parent._uid === node._uid) return !0;
      parent = parent.parent;
    } while (null !== parent);
    return !1;
  }
  isAncestorsOf(node) {
    return node.isDescendantsOf(this);
  }
  getAncestor(idx) {
    throw new Error("暂不支持");
  }
  setAllDescendantsProps(propsName, propsValue) {
    let child = this._firstChild;
    for (; child;) child[propsName] = propsValue, child.setAllDescendantsProps(propsName, propsValue), child = child._next;
  }
  setCount(deltaCount) {
    this._count += deltaCount;
    let parent = this.parent;
    if (parent) do {
      parent._count += deltaCount, parent = parent.parent;
    } while (null !== parent);
  }
  clone() {
    throw new Error("暂不支持");
  }
  cloneTo(node) {
    throw new Error("暂不支持");
  }
  getParent() {
    return this.parent;
  }
  del(child) {
    return this.removeChild(child);
  }
  addEventListener(type, listener, options) {
    const capture = isBoolean$1(options, !0) && options || isObject$1(options) && options.capture,
      once = isObject$1(options) && options.once,
      context = isFunction$1(listener) ? void 0 : listener;
    return type = capture ? `${type}capture` : type, listener = isFunction$1(listener) ? listener : listener.handleEvent, once ? super.once(type, listener, context) : super.on(type, listener, context), this;
  }
  on(type, listener, options) {
    return this.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    const capture = isBoolean$1(options, !0) && options || isObject$1(options) && options.capture,
      context = isFunction$1(listener) ? void 0 : listener;
    type = capture ? `${type}capture` : type, listener = isFunction$1(listener) ? listener : listener.handleEvent;
    const once = isObject$1(options) && options.once;
    return super.off(type, listener, context, once), this;
  }
  off(type, listener, options) {
    return this.removeEventListener(type, listener, options);
  }
  once(type, listener, options) {
    return isObject$1(options) ? (options.once = !0, this.addEventListener(type, listener, options)) : this.addEventListener(type, listener, {
      once: !0
    });
  }
  removeAllEventListeners() {
    return super.removeAllListeners(), this;
  }
  removeAllListeners() {
    return this.removeAllEventListeners();
  }
  dispatchEvent(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    return super.emit(event.type, event, ...args), !event.defaultPrevented;
  }
  emit(event, data) {
    return this.dispatchEvent(event, data);
  }
  release() {
    this.removeAllListeners();
  }
}

class FederatedEvent {
  get layerX() {
    return this.layer.x;
  }
  get layerY() {
    return this.layer.y;
  }
  get pageX() {
    return this.page.x;
  }
  get pageY() {
    return this.page.y;
  }
  get x() {
    return this.canvas.x;
  }
  get y() {
    return this.canvas.y;
  }
  get canvasX() {
    return this.canvas.x;
  }
  get canvasY() {
    return this.canvas.y;
  }
  get viewX() {
    return this.viewport.x;
  }
  get viewY() {
    return this.viewport.y;
  }
  constructor(manager) {
    this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = FederatedEvent.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = {
      x: 0,
      y: 0
    }, this.page = {
      x: 0,
      y: 0
    }, this.canvas = {
      x: 0,
      y: 0
    }, this.viewport = {
      x: 0,
      y: 0
    }, this.NONE = 0, this.CAPTURING_PHASE = 1, this.AT_TARGET = 2, this.BUBBLING_PHASE = 3, this.manager = manager;
  }
  composedPath() {
    return !this.manager || this.path && this.path[this.path.length - 1] === this.target || (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.composedDetailPath(), this.path;
  }
  composedDetailPath() {
    return this.pickParams && this.pickParams.graphic ? (this.detailPath = this.path.slice(), this._composedDetailPath(this.pickParams)) : this.detailPath = this.path.slice(), this.detailPath;
  }
  _composedDetailPath(params) {
    if (params && params.graphic) {
      const g = this.pickParams.graphic;
      if (g.stage) {
        const path = g.stage.eventSystem.manager.propagationPath(g);
        this.detailPath.push(path), this._composedDetailPath(params.params);
      }
    }
  }
  preventDefault() {
    try {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault();
    } catch (err) {
      this.nativeEvent.preventDefault && isFunction$1(this.nativeEvent.preventDefault) && this.nativeEvent.preventDefault();
    }
    this.defaultPrevented = !0;
  }
  stopImmediatePropagation() {
    this.propagationImmediatelyStopped = !0;
  }
  stopPropagation() {
    try {
      this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.stopPropagation();
    } catch (err) {
      this.nativeEvent.stopPropagation && isFunction$1(this.nativeEvent.stopPropagation) && this.nativeEvent.stopPropagation();
    }
    this.propagationStopped = !0;
  }
  initEvent() {}
  initUIEvent() {}
  clone() {
    throw new Error("Method not implemented.");
  }
}

class FederatedMouseEvent extends FederatedEvent {
  constructor() {
    super(...arguments), this.client = {
      x: 0,
      y: 0
    }, this.movement = {
      x: 0,
      y: 0
    }, this.offset = {
      x: 0,
      y: 0
    }, this.global = {
      x: 0,
      y: 0
    }, this.screen = {
      x: 0,
      y: 0
    };
  }
  get clientX() {
    return this.client.x;
  }
  get clientY() {
    return this.client.y;
  }
  get movementX() {
    return this.movement.x;
  }
  get movementY() {
    return this.movement.y;
  }
  get offsetX() {
    return this.offset.x;
  }
  get offsetY() {
    return this.offset.y;
  }
  get globalX() {
    return this.global.x;
  }
  get globalY() {
    return this.global.y;
  }
  get screenX() {
    return this.screen.x;
  }
  get screenY() {
    return this.screen.y;
  }
  getModifierState(key) {
    return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(key);
  }
  initMouseEvent(_typeArg, _canBubbleArg, _cancelableArg, _viewArg, _detailArg, _screenXArg, _screenYArg, _clientXArg, _clientYArg, _ctrlKeyArg, _altKeyArg, _shiftKeyArg, _metaKeyArg, _buttonArg, _relatedTargetArg) {
    throw new Error("Method not implemented.");
  }
}

class FederatedPointerEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1;
  }
  getCoalescedEvents() {
    return "pointermove" === this.type || "mousemove" === this.type || "touchmove" === this.type ? [this] : [];
  }
  getPredictedEvents() {
    throw new Error("getPredictedEvents is not supported!");
  }
  clone() {
    var _a, _b, _c;
    const event = new FederatedPointerEvent(this.manager);
    event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyPointerData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice();
    const p = this.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = this.type, event;
  }
}

class FederatedWheelEvent extends FederatedMouseEvent {
  constructor() {
    super(...arguments), this.DOM_DELTA_PIXEL = 0, this.DOM_DELTA_LINE = 1, this.DOM_DELTA_PAGE = 2;
  }
  clone() {
    var _a, _b, _c;
    const event = new FederatedWheelEvent(this.manager);
    event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event.nativeEvent = this.nativeEvent, event.originalEvent = this.originalEvent, null === (_a = this.manager) || void 0 === _a || _a.copyWheelData(this, event), null === (_b = this.manager) || void 0 === _b || _b.copyMouseData(this, event), null === (_c = this.manager) || void 0 === _c || _c.copyData(this, event), event.target = this.target, event.path = this.composedPath().slice();
    const p = this.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = this.type, event;
  }
}
FederatedWheelEvent.DOM_DELTA_PIXEL = 0, FederatedWheelEvent.DOM_DELTA_LINE = 1, FederatedWheelEvent.DOM_DELTA_PAGE = 2;

class CustomEvent extends FederatedEvent {
  constructor(eventName, object) {
    super(), this.type = eventName, this.detail = object;
  }
}

const WILDCARD = "*";

const clock = "object" == typeof performance && performance.now ? performance : Date;

function isMouseLike(pointerType) {
  return "mouse" === pointerType || "pen" === pointerType;
}
class EventManager {
  constructor(root, config) {
    this.dispatch = new EventEmitter(), this.cursorTarget = null, this.pauseNotify = !1, this.mappingState = {
      trackingData: {}
    }, this.eventPool = new Map(), this.onPointerDown = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e, "pointerdown"), "touch" === e.pointerType) this.dispatchEvent(e, "touchstart");else if (isMouseLike(e.pointerType)) {
        const isRightButton = 2 === e.button;
        this.dispatchEvent(e, isRightButton ? "rightdown" : "mousedown");
      }
      this.trackingData(from.pointerId).pressTargetsByButton[from.button] = e.composedPath(), this.freeEvent(e);
    }, this.onPointerMove = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const e = this.createPointerEvent(from, from.type, target),
        isMouse = isMouseLike(e.pointerType),
        trackingData = this.trackingData(from.pointerId),
        outTarget = this.findMountedTarget(trackingData.overTargets);
      if (trackingData.overTargets && outTarget && outTarget !== this.rootTarget && outTarget !== e.target) {
        const outType = "mousemove" === from.type ? "mouseout" : "pointerout",
          outEvent = this.createPointerEvent(from, outType, outTarget || void 0);
        if (this.dispatchEvent(outEvent, "pointerout"), isMouse && this.dispatchEvent(outEvent, "mouseout"), !e.composedPath().includes(outTarget)) {
          const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
          for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && !e.composedPath().includes(leaveEvent.target);) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
          this.freeEvent(leaveEvent);
        }
        this.freeEvent(outEvent);
      }
      if (outTarget !== e.target) {
        const overType = "mousemove" === from.type ? "mouseover" : "pointerover",
          overEvent = this.clonePointerEvent(e, overType);
        this.dispatchEvent(overEvent, "pointerover"), isMouse && this.dispatchEvent(overEvent, "mouseover");
        let overTargetAncestor = null == outTarget ? void 0 : outTarget.parent;
        for (; overTargetAncestor && overTargetAncestor !== this.rootTarget.parent && overTargetAncestor !== e.target;) overTargetAncestor = overTargetAncestor.parent;
        if (!overTargetAncestor || overTargetAncestor === this.rootTarget.parent) {
          const enterEvent = this.clonePointerEvent(e, "pointerenter");
          enterEvent.eventPhase = enterEvent.AT_TARGET;
          let currentTarget = enterEvent.target;
          const outTargetAncestors = new Set();
          let ancestor = outTarget;
          for (; ancestor && ancestor !== this.rootTarget;) outTargetAncestors.add(ancestor), ancestor = ancestor.parent;
          for (; currentTarget && currentTarget !== outTarget && currentTarget !== this.rootTarget.parent;) outTargetAncestors.has(currentTarget) || (enterEvent.currentTarget = currentTarget, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter")), currentTarget = currentTarget.parent;
          this.freeEvent(enterEvent);
        }
        this.freeEvent(overEvent);
      }
      this.dispatchEvent(e, "pointermove"), "touch" === e.pointerType && this.dispatchEvent(e, "touchmove"), isMouse && (this.dispatchEvent(e, "mousemove"), this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor()), trackingData.overTargets = e.composedPath(), this.freeEvent(e);
    }, this.onPointerOver = (from, target) => {
      var _a, _b;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId),
        e = this.createPointerEvent(from, from.type, target),
        isMouse = isMouseLike(e.pointerType);
      this.dispatchEvent(e, "pointerover"), isMouse && this.dispatchEvent(e, "mouseover"), "mouse" === e.pointerType && (this.cursorTarget = e.target, this.cursor = (null === (_b = null === (_a = e.target) || void 0 === _a ? void 0 : _a.attribute) || void 0 === _b ? void 0 : _b.cursor) || this.rootTarget.getCursor());
      const enterEvent = this.clonePointerEvent(e, "pointerenter");
      for (enterEvent.eventPhase = enterEvent.AT_TARGET; enterEvent.target && enterEvent.target !== this.rootTarget.parent;) enterEvent.currentTarget = enterEvent.target, this.notifyTarget(enterEvent), isMouse && this.notifyTarget(enterEvent, "mouseenter"), enterEvent.target = enterEvent.target.parent;
      trackingData.overTargets = e.composedPath(), this.freeEvent(e), this.freeEvent(enterEvent);
    }, this.onPointerOut = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId);
      if (trackingData.overTargets) {
        const isMouse = isMouseLike(from.pointerType),
          outTarget = this.findMountedTarget(trackingData.overTargets),
          outEvent = this.createPointerEvent(from, "pointerout", outTarget || void 0);
        this.dispatchEvent(outEvent), isMouse && this.dispatchEvent(outEvent, "mouseout");
        const leaveEvent = this.createPointerEvent(from, "pointerleave", outTarget || void 0);
        for (leaveEvent.eventPhase = leaveEvent.AT_TARGET; leaveEvent.target && leaveEvent.target !== this.rootTarget.parent;) leaveEvent.currentTarget = leaveEvent.target, this.notifyTarget(leaveEvent), isMouse && this.notifyTarget(leaveEvent, "mouseleave"), leaveEvent.target = leaveEvent.target.parent;
        trackingData.overTargets = [], this.freeEvent(outEvent), this.freeEvent(leaveEvent);
      }
      this.cursorTarget = null, this.cursor = "";
    }, this.onPointerUp = (from, target) => {
      var _a;
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const now = clock.now(),
        e = this.createPointerEvent(from, from.type, target);
      if (this.dispatchEvent(e, "pointerup"), "touch" === e.pointerType) this.dispatchEvent(e, "touchend");else if (isMouseLike(e.pointerType)) {
        const isRightButton = 2 === e.button;
        this.dispatchEvent(e, isRightButton ? "rightup" : "mouseup");
      }
      const trackingData = this.trackingData(from.pointerId),
        pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]);
      let clickTarget = pressTarget;
      if (pressTarget && !e.composedPath().includes(pressTarget)) {
        let currentTarget = pressTarget;
        for (; currentTarget && !e.composedPath().includes(currentTarget);) {
          if (e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType) this.notifyTarget(e, "touchendoutside");else if (isMouseLike(e.pointerType)) {
            const isRightButton = 2 === e.button;
            this.notifyTarget(e, isRightButton ? "rightupoutside" : "mouseupoutside");
          }
          currentTarget = currentTarget.parent;
        }
        delete trackingData.pressTargetsByButton[from.button], clickTarget = currentTarget;
      }
      if (clickTarget) {
        const clickEvent = this.clonePointerEvent(e, "click");
        clickEvent.target = clickTarget, clickEvent.path = [], clickEvent.detailPath = [], trackingData.clicksByButton[from.button] || (trackingData.clicksByButton[from.button] = {
          clickCount: 0,
          target: clickEvent.target,
          timeStamp: now
        });
        const clickHistory = trackingData.clicksByButton[from.button];
        clickHistory.target === clickEvent.target && now - clickHistory.timeStamp < (null !== (_a = this._config.clickInterval) && void 0 !== _a ? _a : 200) ? ++clickHistory.clickCount : clickHistory.clickCount = 1, clickHistory.target = clickEvent.target, clickHistory.timeStamp = now, clickEvent.detail = clickHistory.clickCount, isMouseLike(clickEvent.pointerType) ? (this.dispatchEvent(clickEvent, "click"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dblclick")) : "touch" === clickEvent.pointerType && this._config.supportsTouchEvents && (this.dispatchEvent(clickEvent, "tap"), 2 === clickHistory.clickCount && this.dispatchEvent(clickEvent, "dbltap")), this.dispatchEvent(clickEvent, "pointertap"), this.freeEvent(clickEvent);
      }
      this.freeEvent(e);
    }, this.onPointerUpOutside = (from, target) => {
      if (!(from instanceof FederatedPointerEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-pointer event as a pointer event");
      const trackingData = this.trackingData(from.pointerId),
        pressTarget = this.findMountedTarget(trackingData.pressTargetsByButton[from.button]),
        e = this.createPointerEvent(from, from.type, target);
      if (pressTarget) {
        let currentTarget = pressTarget;
        for (; currentTarget;) e.currentTarget = currentTarget, this.notifyTarget(e, "pointerupoutside"), "touch" === e.pointerType ? this.notifyTarget(e, "touchendoutside") : isMouseLike(e.pointerType) && this.notifyTarget(e, 2 === e.button ? "rightupoutside" : "mouseupoutside"), currentTarget = currentTarget.parent;
        delete trackingData.pressTargetsByButton[from.button];
      }
      this.freeEvent(e);
    }, this.onWheel = (from, target) => {
      if (!(from instanceof FederatedWheelEvent)) return void Logger.getInstance().warn("EventManager cannot map a non-wheel event as a wheel event");
      const wheelEvent = this.createWheelEvent(from, target);
      this.dispatchEvent(wheelEvent), this.freeEvent(wheelEvent);
    }, this.rootTarget = root, this.mappingTable = {}, this._config = Object.assign({
      clickInterval: 200
    }, config), this.addEventMapping("pointerdown", this.onPointerDown), this.addEventMapping("pointermove", this.onPointerMove), this.addEventMapping("pointerout", this.onPointerOut), this.addEventMapping("pointerleave", this.onPointerOut), this.addEventMapping("pointerover", this.onPointerOver), this.addEventMapping("pointerup", this.onPointerUp), this.addEventMapping("pointerupoutside", this.onPointerUpOutside), this.addEventMapping("wheel", this.onWheel);
  }
  addEventMapping(type, fn) {
    this.mappingTable[type] || (this.mappingTable[type] = []), this.mappingTable[type].push({
      fn: fn,
      priority: 0
    }), this.mappingTable[type].sort((a, b) => a.priority - b.priority);
  }
  dispatchEvent(e, type) {
    e.propagationStopped = !1, e.propagationImmediatelyStopped = !1, this.propagate(e, type), this.dispatch.emit(type || e.type, e);
  }
  mapEvent(e) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.rootTarget) return;
    const mappers = this.mappingTable[e.type];
    let target;
    const cacheKey = `${e.canvasX}-${e.canvasY}`;
    if ((null === (_a = this._prePointTargetCache) || void 0 === _a ? void 0 : _a[cacheKey]) && (null === (_c = null === (_b = this._prePointTargetCache) || void 0 === _b ? void 0 : _b[cacheKey]) || void 0 === _c ? void 0 : _c.stage) && (null === (_e = null === (_d = this._prePointTargetCache) || void 0 === _d ? void 0 : _d[cacheKey]) || void 0 === _e ? void 0 : _e.stage.renderCount) === (null === (_f = this._prePointTargetCache) || void 0 === _f ? void 0 : _f.stageRenderCount) ? target = this._prePointTargetCache[cacheKey] : (target = this.pickTarget(e.viewX, e.viewY, e), e.pickParams || (this._prePointTargetCache = {
      [cacheKey]: target,
      stageRenderCount: null !== (_g = null == target ? void 0 : target.stage.renderCount) && void 0 !== _g ? _g : -1
    })), mappers) for (let i = 0, j = mappers.length; i < j; i++) mappers[i].fn(e, target);else Logger.getInstance().warn(`[EventManager]: Event mapping not defined for ${e.type}`);
  }
  propagate(e, type) {
    if (!e.target) return;
    const composedPath = e.composedPath();
    e.eventPhase = e.CAPTURING_PHASE;
    for (let i = 0, j = composedPath.length - 1; i < j; i++) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
    if (e.eventPhase = e.AT_TARGET, e.currentTarget = e.target, this.notifyTarget(e, type), !e.propagationStopped && !e.propagationImmediatelyStopped) {
      e.eventPhase = e.BUBBLING_PHASE;
      for (let i = composedPath.length - 2; i >= 0; i--) if (e.currentTarget = composedPath[i], this.notifyTarget(e, type), e.propagationStopped || e.propagationImmediatelyStopped) return;
    }
  }
  propagationPath(target) {
    const propagationPath = [target];
    for (let i = 0; i < 2048 && target !== this.rootTarget && target.parent; i++) {
      if (!target.parent) throw new Error("Cannot find propagation path to disconnected target");
      propagationPath.push(target.parent), target = target.parent;
    }
    return propagationPath.reverse(), propagationPath;
  }
  notifyTarget(e, type) {
    if (this.pauseNotify) return;
    type = null != type ? type : e.type;
    const key = e.eventPhase === e.CAPTURING_PHASE || e.eventPhase === e.AT_TARGET ? `${type}capture` : type;
    this.notifyListeners(e, key), e.eventPhase === e.AT_TARGET && this.notifyListeners(e, type);
  }
  findMountedTarget(propagationPath) {
    if (!propagationPath) return null;
    let currentTarget = propagationPath[0];
    for (let i = 1; i < propagationPath.length && propagationPath[i].parent === currentTarget; i++) currentTarget = propagationPath[i];
    return currentTarget;
  }
  createPointerEvent(from, type, target) {
    var _a, _b;
    const event = this.allocateEvent(FederatedPointerEvent);
    return this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), "string" == typeof type && (event.type = type), event;
  }
  createWheelEvent(from, target) {
    var _a, _b;
    const event = this.allocateEvent(FederatedWheelEvent);
    return this.copyWheelData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.nativeEvent = from.nativeEvent, event.originalEvent = from, event.target = target || this.pickTarget(null !== (_a = event.viewX) && void 0 !== _a ? _a : event.global.x, null !== (_b = event.viewY) && void 0 !== _b ? _b : event.global.y, event), event;
  }
  clonePointerEvent(from, type) {
    const event = this.allocateEvent(FederatedPointerEvent);
    event.nativeEvent = from.nativeEvent, event.originalEvent = from.originalEvent, this.copyPointerData(from, event), this.copyMouseData(from, event), this.copyData(from, event), event.target = from.target, event.path = from.composedPath().slice();
    const p = from.composedDetailPath();
    return event.detailPath = p && p.slice(), event.type = null != type ? type : event.type, event;
  }
  copyWheelData(from, to) {
    to.deltaMode = from.deltaMode, to.deltaX = from.deltaX, to.deltaY = from.deltaY, to.deltaZ = from.deltaZ;
  }
  copyPointerData(from, to) {
    from instanceof FederatedPointerEvent && to instanceof FederatedPointerEvent && (to.pointerId = from.pointerId, to.width = from.width, to.height = from.height, to.isPrimary = from.isPrimary, to.pointerType = from.pointerType, to.pressure = from.pressure, to.tangentialPressure = from.tangentialPressure, to.tiltX = from.tiltX, to.tiltY = from.tiltY, to.twist = from.twist);
  }
  copyMouseData(from, to) {
    from instanceof FederatedMouseEvent && to instanceof FederatedMouseEvent && (to.altKey = from.altKey, to.button = from.button, to.buttons = from.buttons, to.ctrlKey = from.ctrlKey, to.shiftKey = from.shiftKey, to.metaKey = from.metaKey, ["client", "movement", "canvas", "screen", "global", "offset", "viewport"].forEach(key => {
      to[key].x = from[key].x, to[key].y = from[key].y;
    }));
  }
  copyData(from, to) {
    to.isTrusted = from.isTrusted, to.srcElement = from.srcElement, to.timeStamp = clock.now(), to.type = from.type, to.detail = from.detail, to.view = from.view, to.which = from.which, to.layer.x = from.layer.x, to.layer.y = from.layer.y, to.page.x = from.page.x, to.page.y = from.page.y, to.pickParams = from.pickParams;
  }
  trackingData(id) {
    return this.mappingState.trackingData[id] || (this.mappingState.trackingData[id] = {
      pressTargetsByButton: {},
      clicksByButton: {},
      overTarget: null
    }), this.mappingState.trackingData[id];
  }
  allocateEvent(constructor) {
    var _a;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []);
    const event = (null === (_a = this.eventPool.get(constructor)) || void 0 === _a ? void 0 : _a.pop()) || new constructor(this);
    return event.eventPhase = event.NONE, event.currentTarget = null, event.path = [], event.detailPath = [], event.target = null, event;
  }
  freeEvent(event) {
    var _a;
    if (event.manager !== this) throw new Error("It is illegal to free an event not managed by this EventManager!");
    const constructor = event.constructor;
    this.eventPool.has(constructor) || this.eventPool.set(constructor, []), null === (_a = this.eventPool.get(constructor)) || void 0 === _a || _a.push(event);
  }
  notifyListeners(e, type) {
    const listeners = e.currentTarget._events[type];
    if (listeners) if ("fn" in listeners) listeners.once && e.currentTarget.removeEventListener(type, listeners.fn, {
      once: !0
    }), listeners.fn.call(listeners.context, e);else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].once && e.currentTarget.removeEventListener(type, listeners[i].fn, {
      once: !0
    }), listeners[i].fn.call(listeners[i].context, e);
    this.emitDelegation(e, type);
  }
  emitDelegation(e, type) {
    const listeners = e.currentTarget._events[WILDCARD];
    if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
  }
  pickTarget(x, y, e) {
    let target;
    const pickResult = this.rootTarget.pick(x, y);
    return target = pickResult && pickResult.graphic ? pickResult.graphic : pickResult && pickResult.group ? pickResult.group : this.rootTarget.AABBBounds.contains(x, y) ? this.rootTarget : null, e && (e.pickParams = pickResult.params), target;
  }
  release() {
    this.dispatch.removeAllListeners(), this.eventPool.clear(), this.rootTarget = null, this.mappingTable = null, this.mappingState = null, this.cursorTarget = null;
  }
}

const EventTarget = {
  dispatchEvent(e) {
    var _a;
    if (!(e instanceof FederatedEvent)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
    return e.defaultPrevented = !1, e.path = [], e.detailPath && (e.detailPath = []), e.target = this, null === (_a = null == e ? void 0 : e.manager) || void 0 === _a || _a.dispatchEvent(e), !e.defaultPrevented;
  },
  emit(eventName, object) {
    return this.dispatchEvent(new CustomEvent(eventName, object));
  }
};

const TOUCH_TO_POINTER = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
  };
class EventSystem {
  constructor(params) {
    this.resolution = 1, this.onPointerDown = nativeEvent => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const events = this.normalizeToPointerData(nativeEvent);
      if (this.autoPreventDefault && events[0].isNormalized) {
        (nativeEvent.cancelable || !("cancelable" in nativeEvent)) && nativeEvent.preventDefault();
      }
      for (let i = 0, j = events.length; i < j; i++) {
        const nativeEvent = events[i],
          federatedEvent = this.bootstrapEvent(this.rootPointerEvent, nativeEvent);
        this.manager.mapEvent(federatedEvent);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerMove = nativeEvent => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      if (this.isEventOutsideOfTargetElement(nativeEvent)) return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerUp = nativeEvent => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const outside = this.isEventOutsideOfTargetViewPort(nativeEvent) ? "outside" : "",
        normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        event.type += outside, this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onPointerOverOut = nativeEvent => {
      if (this.supportsTouchEvents && "touch" === nativeEvent.pointerType) return;
      const normalizedEvents = this.normalizeToPointerData(nativeEvent);
      for (let i = 0, j = normalizedEvents.length; i < j; i++) {
        const event = this.bootstrapEvent(this.rootPointerEvent, normalizedEvents[i]);
        this.manager.mapEvent(event);
      }
      this.setCursor(this.manager.cursor, this.manager.cursorTarget), this.rootPointerEvent.nativeEvent = null;
    }, this.onWheel = nativeEvent => {
      const wheelEvent = this.normalizeWheelEvent(nativeEvent);
      this.manager.mapEvent(wheelEvent);
    };
    const {
      targetElement: targetElement,
      resolution: resolution,
      rootNode: rootNode,
      global: global,
      autoPreventDefault = !1,
      clickInterval: clickInterval,
      supportsTouchEvents = global.supportsTouchEvents,
      supportsPointerEvents = global.supportsPointerEvents
    } = params;
    this.manager = new EventManager(rootNode, {
      clickInterval: clickInterval,
      supportsTouchEvents: supportsTouchEvents
    }), this.globalObj = global, this.supportsPointerEvents = supportsPointerEvents, this.supportsTouchEvents = supportsTouchEvents, this.supportsMouseEvents = global.supportsMouseEvents, this.applyStyles = global.applyStyles, this.autoPreventDefault = autoPreventDefault, this.eventsAdded = !1, this.rootPointerEvent = new FederatedPointerEvent(), this.rootWheelEvent = new FederatedWheelEvent(), this.cursorStyles = {
      default: "inherit",
      pointer: "pointer"
    }, this.resolution = resolution, this.setTargetElement(targetElement);
  }
  release() {
    this.removeEvents(), this.manager && this.manager.release(), this.domElement = null, this.manager = null, this.globalObj = null;
  }
  setCursor(mode, target) {
    if (!target && !this.manager.rootTarget.window._handler.canvas.controled) return;
    mode || (mode = "default");
    const {
      applyStyles: applyStyles,
      domElement: domElement
    } = this;
    if (this.currentCursor === mode) return;
    this.currentCursor = mode;
    const style = this.cursorStyles[mode];
    style ? "string" == typeof style && applyStyles ? domElement.style.cursor = style : "function" == typeof style ? style(mode) : "object" == typeof style && applyStyles && Object.assign(domElement.style, style) : applyStyles && isString$1(mode) && !has$1(this.cursorStyles, mode) && (domElement.style.cursor = mode);
  }
  setTargetElement(element) {
    this.removeEvents(), this.domElement = element, this.addEvents();
  }
  addEvents() {
    if (this.eventsAdded || !this.domElement) return;
    const {
      globalObj: globalObj,
      domElement: domElement
    } = this;
    this.supportsPointerEvents ? (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("pointermove", this.onPointerMove, !0), globalObj.getDocument().addEventListener("pointerup", this.onPointerUp, !0)) : (domElement.addEventListener("pointermove", this.onPointerMove, !0), domElement.addEventListener("pointerup", this.onPointerUp, !0)), domElement.addEventListener("pointerdown", this.onPointerDown, !0), domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), domElement.addEventListener("pointerover", this.onPointerOverOut, !0)) : (globalObj.getDocument() ? (globalObj.getDocument().addEventListener("mousemove", this.onPointerMove, !0), globalObj.getDocument().addEventListener("mouseup", this.onPointerUp, !0)) : (domElement.addEventListener("mousemove", this.onPointerMove, !0), domElement.addEventListener("mouseup", this.onPointerUp, !0)), domElement.addEventListener("mousedown", this.onPointerDown, !0), domElement.addEventListener("mouseout", this.onPointerOverOut, !0), domElement.addEventListener("mouseover", this.onPointerOverOut, !0)), this.supportsTouchEvents && (domElement.addEventListener("touchstart", this.onPointerDown, !0), domElement.addEventListener("touchend", this.onPointerUp, !0), domElement.addEventListener("touchmove", this.onPointerMove, !0)), domElement.addEventListener("wheel", this.onWheel, {
      capture: !0
    }), this.eventsAdded = !0;
  }
  removeEvents() {
    var _a;
    if (!this.eventsAdded || !this.domElement) return;
    const {
        globalObj: globalObj,
        domElement: domElement
      } = this,
      globalDocument = null !== (_a = globalObj.getDocument()) && void 0 !== _a ? _a : domElement;
    this.supportsPointerEvents ? (globalDocument.removeEventListener("pointermove", this.onPointerMove, !0), globalDocument.removeEventListener("pointerup", this.onPointerUp, !0), domElement.removeEventListener("pointerdown", this.onPointerDown, !0), domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), domElement.removeEventListener("pointerover", this.onPointerOverOut, !0)) : (globalDocument.removeEventListener("mousemove", this.onPointerMove, !0), globalDocument.removeEventListener("mouseup", this.onPointerUp, !0), domElement.removeEventListener("mousedown", this.onPointerDown, !0), domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), domElement.removeEventListener("mouseover", this.onPointerOverOut, !0)), this.supportsTouchEvents && (domElement.removeEventListener("touchstart", this.onPointerDown, !0), domElement.removeEventListener("touchend", this.onPointerUp, !0), domElement.removeEventListener("touchmove", this.onPointerMove, !0)), domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1;
  }
  mapToViewportPoint(event) {
    return this.domElement.pointTransform ? this.domElement.pointTransform(event.x, event.y) : event;
  }
  mapToCanvasPoint(nativeEvent) {
    var _a, _b;
    const point = null === (_a = this.globalObj) || void 0 === _a ? void 0 : _a.mapToCanvasPoint(nativeEvent, this.domElement);
    if (point) return point;
    let x = 0,
      y = 0;
    if (nativeEvent.changedTouches) {
      const data = null !== (_b = nativeEvent.changedTouches[0]) && void 0 !== _b ? _b : {};
      x = data.clientX || 0, y = data.clientY || 0;
    } else x = nativeEvent.clientX || 0, y = nativeEvent.clientY || 0;
    const rect = this.domElement.getBoundingClientRect();
    return {
      x: x - rect.left,
      y: y - rect.top
    };
  }
  normalizeToPointerData(event) {
    const normalizedEvents = [];
    if (this.supportsTouchEvents && event.changedTouches && event.changedTouches.length) for (let i = 0, li = event.changedTouches.length; i < li; i++) {
      const touch = event.changedTouches[i];
      isUndefined$1(touch.button) && (touch.button = 0), isUndefined$1(touch.buttons) && (touch.buttons = 1), isUndefined$1(touch.isPrimary) && (touch.isPrimary = 1 === event.touches.length && "touchstart" === event.type), isUndefined$1(touch.width) && (touch.width = touch.radiusX || 1), isUndefined$1(touch.height) && (touch.height = touch.radiusY || 1), isUndefined$1(touch.tiltX) && (touch.tiltX = 0), isUndefined$1(touch.tiltY) && (touch.tiltY = 0), isUndefined$1(touch.pointerType) && (touch.pointerType = "touch"), isUndefined$1(touch.pointerId) && (touch.pointerId = touch.identifier || 0), isUndefined$1(touch.pressure) && (touch.pressure = touch.force || .5), isUndefined$1(touch.twist) && (touch.twist = 0), isUndefined$1(touch.tangentialPressure) && (touch.tangentialPressure = 0), isUndefined$1(touch.layerX) && (touch.layerX = touch.offsetX = touch.clientX), isUndefined$1(touch.layerY) && (touch.layerY = touch.offsetY = touch.clientY), touch.isNormalized = !0, touch.type = event.type, normalizedEvents.push(touch);
    } else if (this.globalObj.supportsMouseEvents && (!(event instanceof MouseEvent) || this.supportsPointerEvents && event instanceof PointerEvent)) normalizedEvents.push(event);else {
      const tempEvent = event;
      isUndefined$1(tempEvent.isPrimary) && (tempEvent.isPrimary = !0), isUndefined$1(tempEvent.width) && (tempEvent.width = 1), isUndefined$1(tempEvent.height) && (tempEvent.height = 1), isUndefined$1(tempEvent.tiltX) && (tempEvent.tiltX = 0), isUndefined$1(tempEvent.tiltY) && (tempEvent.tiltY = 0), isUndefined$1(tempEvent.pointerType) && (tempEvent.pointerType = "mouse"), isUndefined$1(tempEvent.pointerId) && (tempEvent.pointerId = 1), isUndefined$1(tempEvent.pressure) && (tempEvent.pressure = .5), isUndefined$1(tempEvent.twist) && (tempEvent.twist = 0), isUndefined$1(tempEvent.tangentialPressure) && (tempEvent.tangentialPressure = 0), tempEvent.isNormalized = !0, normalizedEvents.push(tempEvent);
    }
    return normalizedEvents;
  }
  normalizeWheelEvent(nativeEvent) {
    const event = this.rootWheelEvent;
    this.transferMouseData(event, nativeEvent), event.deltaMode = nativeEvent.deltaMode, event.deltaX = nativeEvent.deltaX, event.deltaY = nativeEvent.deltaY, event.deltaZ = nativeEvent.deltaZ;
    const {
      x: canvasX,
      y: canvasY
    } = this.mapToCanvasPoint(nativeEvent);
    event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
    const {
      x: viewX,
      y: viewY
    } = this.mapToViewportPoint(event);
    return event.viewport.x = viewX, event.viewport.y = viewY, event.nativeEvent = nativeEvent, event.type = nativeEvent.type, event;
  }
  bootstrapEvent(event, nativeEvent) {
    event.originalEvent = null, event.nativeEvent = nativeEvent, event.pointerId = nativeEvent.pointerId, event.width = nativeEvent.width, event.height = nativeEvent.height, event.isPrimary = nativeEvent.isPrimary, event.pointerType = nativeEvent.pointerType, event.pressure = nativeEvent.pressure, event.tangentialPressure = nativeEvent.tangentialPressure, event.tiltX = nativeEvent.tiltX, event.tiltY = nativeEvent.tiltY, event.twist = nativeEvent.twist, this.transferMouseData(event, nativeEvent);
    const {
      x: canvasX,
      y: canvasY
    } = this.mapToCanvasPoint(nativeEvent);
    event.canvas.x = canvasX, event.canvas.y = canvasY, event.global.x = canvasX, event.global.y = canvasY, event.offset.x = canvasX, event.offset.y = canvasY;
    const {
      x: viewX,
      y: viewY
    } = this.mapToViewportPoint(event);
    return event.viewport.x = viewX, event.viewport.y = viewY, event.isTrusted = nativeEvent.isTrusted, "pointerleave" === event.type && (event.type = "pointerout"), event.type.startsWith("mouse") && (event.type = event.type.replace("mouse", "pointer")), event.type.startsWith("touch") && (event.type = TOUCH_TO_POINTER[event.type] || event.type), event;
  }
  transferMouseData(event, nativeEvent) {
    event.isTrusted = nativeEvent.isTrusted, event.srcElement = nativeEvent.srcElement, event.timeStamp = clock.now(), event.type = nativeEvent.type, event.altKey = nativeEvent.altKey, event.button = nativeEvent.button, event.buttons = nativeEvent.buttons, event.client.x = nativeEvent.clientX, event.client.y = nativeEvent.clientY, event.ctrlKey = nativeEvent.ctrlKey, event.shiftKey = nativeEvent.shiftKey, event.metaKey = nativeEvent.metaKey, event.movement.x = nativeEvent.movementX, event.movement.y = nativeEvent.movementY, event.page.x = nativeEvent.pageX, event.page.y = nativeEvent.pageY, event.relatedTarget = null;
  }
  isEventOutsideOfTargetViewPort(nativeEvent) {
    if (this.isEventOutsideOfTargetElement(nativeEvent)) return !0;
    if (this.domElement.getViewBox) {
      const p = this.mapToViewportPoint(this.mapToCanvasPoint(nativeEvent)),
        b = this.domElement.getViewBox(),
        w = b.width(),
        h = b.height();
      return !(p.x < w && p.y < h && p.x > 0 && p.y > 0);
    }
    return !1;
  }
  isEventOutsideOfTargetElement(nativeEvent) {
    let target = nativeEvent.target;
    nativeEvent.composedPath && nativeEvent.composedPath().length > 0 && (target = nativeEvent.composedPath()[0]);
    return target !== (this.domElement.getNativeHandler ? this.domElement.getNativeHandler().nativeCanvas : this.domElement);
  }
  pauseTriggerEvent() {
    this.manager.pauseNotify = !0;
  }
  resumeTriggerEvent() {
    this.manager.pauseNotify = !1;
  }
}

var STATUS$1;
!function (STATUS) {
  STATUS[STATUS.INITIAL = 0] = "INITIAL", STATUS[STATUS.RUNNING = 1] = "RUNNING", STATUS[STATUS.PAUSE = 2] = "PAUSE";
}(STATUS$1 || (STATUS$1 = {}));

class RAFTickHandler {
  static Avaliable() {
    return !!application.global.getRequestAnimationFrame();
  }
  avaliable() {
    return RAFTickHandler.Avaliable();
  }
  tick(interval, cb) {
    application.global.getRequestAnimationFrame()(() => {
      this.released || cb(this);
    });
  }
  release() {
    this.released = !0;
  }
  getTime() {
    return Date.now();
  }
}

class TimeOutTickHandler {
  static Avaliable() {
    return !0;
  }
  avaliable() {
    return TimeOutTickHandler.Avaliable();
  }
  tick(interval, cb) {
    this.timerId = setTimeout(() => {
      cb(this);
    }, interval);
  }
  release() {
    this.timerId > 0 && (clearTimeout(this.timerId), this.timerId = -1);
  }
  getTime() {
    return Date.now();
  }
}

class DefaultTicker extends EventEmitter {
  set mode(m) {
    this._mode !== m && (this._mode = m, this.setupTickHandler());
  }
  get mode() {
    return this._mode;
  }
  constructor() {
    let timelines = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    super(), this.handleTick = (handler, params) => {
      const {
        once = !1
      } = null != params ? params : {};
      this.ifCanStop() ? this.stop() : (this._handlerTick(), once || handler.tick(this.interval, this.handleTick));
    }, this._handlerTick = () => {
      const time = this.tickerHandler.getTime();
      let delta = 0;
      this.lastFrameTime >= 0 && (delta = time - this.lastFrameTime), this.lastFrameTime = time, this.status === STATUS$1.RUNNING && (this.tickCounts++, this.timelines.forEach(t => {
        t.tick(delta);
      }), this.emit("tick"));
    }, this.init(), this.lastFrameTime = -1, this.tickCounts = 0, this.timelines = timelines, this.autoStop = !0;
  }
  init() {
    this.interval = NaN, this.status = STATUS$1.INITIAL, application.global.hooks.onSetEnv.tap("default-ticker", () => {
      this.initHandler();
    }), application.global.env && this.initHandler();
  }
  addTimeline(timeline) {
    this.timelines.push(timeline);
  }
  remTimeline(timeline) {
    this.timelines = this.timelines.filter(t => t !== timeline);
  }
  getTimelines() {
    return this.timelines;
  }
  initHandler() {
    if (this._mode) return null;
    const ticks = [{
      mode: "raf",
      cons: RAFTickHandler
    }, {
      mode: "timeout",
      cons: TimeOutTickHandler
    }];
    for (let i = 0; i < ticks.length; i++) if (ticks[i].cons.Avaliable()) {
      this.mode = ticks[i].mode;
      break;
    }
    return null;
  }
  setupTickHandler() {
    let handler;
    switch (this._mode) {
      case "raf":
        handler = new RAFTickHandler();
        break;
      case "timeout":
        handler = new TimeOutTickHandler();
        break;
      default:
        Logger.getInstance().warn("非法的计时器模式"), handler = new RAFTickHandler();
    }
    return !!handler.avaliable() && (this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, !0);
  }
  setInterval(interval) {
    this.interval = interval;
  }
  getInterval() {
    return this.interval;
  }
  setFPS(fps) {
    this.setInterval(1e3 / fps);
  }
  getFPS() {
    return 1e3 / this.interval;
  }
  tick(interval) {
    this.tickerHandler.tick(interval, handler => {
      this.handleTick(handler, {
        once: !0
      });
    });
  }
  tickTo(t) {
    this.tickerHandler.tickTo && this.tickerHandler.tickTo(t, handler => {
      this.handleTick(handler, {
        once: !0
      });
    });
  }
  pause() {
    return this.status !== STATUS$1.INITIAL && (this.status = STATUS$1.PAUSE, !0);
  }
  resume() {
    return this.status !== STATUS$1.INITIAL && (this.status = STATUS$1.RUNNING, !0);
  }
  ifCanStop() {
    if (this.autoStop) {
      if (!this.timelines.length) return !0;
      if (0 === this.timelines.reduce((a, b) => a + b.animateCount, 0)) return !0;
    }
    return !1;
  }
  start() {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    if (this.status === STATUS$1.RUNNING) return !1;
    if (!this.tickerHandler) return !1;
    if (!force) {
      if (this.status === STATUS$1.PAUSE) return !1;
      if (!this.timelines.length) return !1;
      if (0 === this.timelines.reduce((a, b) => a + b.animateCount, 0)) return !1;
    }
    return this.status = STATUS$1.RUNNING, this.tickerHandler.tick(0, this.handleTick), !0;
  }
  stop() {
    this.status = STATUS$1.INITIAL, this.setupTickHandler(), this.lastFrameTime = -1;
  }
  release() {
    this.stop(), this.timelines = [], this.tickerHandler.release(), this.emit("afterTick");
  }
  trySyncTickStatus() {
    this.status === STATUS$1.RUNNING && this._handlerTick();
  }
}

class ManualTickHandler {
  constructor() {
    this.time = 0;
  }
  static Avaliable() {
    return !0;
  }
  avaliable() {
    return ManualTickHandler.Avaliable();
  }
  tick(interval, cb) {
    this.time = Math.max(0, interval + this.time), cb(this, {
      once: !0
    });
  }
  tickTo(t, cb) {
    this.time = Math.max(0, t), cb(this, {
      once: !0
    });
  }
  release() {
    this.timerId > 0 && (this.timerId = -1);
  }
  getTime() {
    return this.time;
  }
}

class ManualTicker extends DefaultTicker {
  set mode(m) {
    this.setupTickHandler();
  }
  get mode() {
    return this._mode;
  }
  initHandler() {
    return this.mode = "manual", null;
  }
  setupTickHandler() {
    const handler = new ManualTickHandler();
    return this._mode = "manual", this.tickerHandler && this.tickerHandler.release(), this.tickerHandler = handler, !0;
  }
  tickAt(time) {
    this.tickerHandler.tick(time - Math.max(this.lastFrameTime, 0), handler => {
      this.handleTick(handler, {
        once: !0
      });
    });
  }
  ifCanStop() {
    return !1;
  }
}

class Easing {
  constructor() {}
  static linear(t) {
    return t;
  }
  static none() {
    return this.linear;
  }
  static get(amount) {
    return amount < -1 ? amount = -1 : amount > 1 && (amount = 1), function (t) {
      return 0 === amount ? t : amount < 0 ? t * (t * -amount + 1 + amount) : t * ((2 - t) * amount + (1 - amount));
    };
  }
  static getPowIn(pow) {
    return function (t) {
      return Math.pow(t, pow);
    };
  }
  static getPowOut(pow) {
    return function (t) {
      return 1 - Math.pow(1 - t, pow);
    };
  }
  static getPowInOut(pow) {
    return function (t) {
      return (t *= 2) < 1 ? .5 * Math.pow(t, pow) : 1 - .5 * Math.abs(Math.pow(2 - t, pow));
    };
  }
  static getBackIn(amount) {
    return function (t) {
      return t * t * ((amount + 1) * t - amount);
    };
  }
  static getBackOut(amount) {
    return function (t) {
      return --t * t * ((amount + 1) * t + amount) + 1;
    };
  }
  static getBackInOut(amount) {
    return amount *= 1.525, function (t) {
      return (t *= 2) < 1 ? t * t * ((amount + 1) * t - amount) * .5 : .5 * ((t -= 2) * t * ((amount + 1) * t + amount) + 2);
    };
  }
  static sineIn(t) {
    return 1 - Math.cos(t * Math.PI / 2);
  }
  static sineOut(t) {
    return Math.sin(t * Math.PI / 2);
  }
  static sineInOut(t) {
    return -(Math.cos(Math.PI * t) - 1) / 2;
  }
  static expoIn(t) {
    return 0 === t ? 0 : Math.pow(2, 10 * t - 10);
  }
  static expoOut(t) {
    return 1 === t ? 1 : 1 - Math.pow(2, -10 * t);
  }
  static expoInOut(t) {
    return 0 === t ? 0 : 1 === t ? 1 : t < .5 ? Math.pow(2, 20 * t - 10) / 2 : (2 - Math.pow(2, -20 * t + 10)) / 2;
  }
  static circIn(t) {
    return -(Math.sqrt(1 - t * t) - 1);
  }
  static circOut(t) {
    return Math.sqrt(1 - --t * t);
  }
  static circInOut(t) {
    return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1);
  }
  static bounceOut(t) {
    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;
  }
  static bounceIn(t) {
    return 1 - Easing.bounceOut(1 - t);
  }
  static bounceInOut(t) {
    return t < .5 ? .5 * Easing.bounceIn(2 * t) : .5 * Easing.bounceOut(2 * t - 1) + .5;
  }
  static getElasticIn(amplitude, period) {
    return function (t) {
      if (0 === t || 1 === t) return t;
      const s = period / pi2 * Math.asin(1 / amplitude);
      return -amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period);
    };
  }
  static getElasticOut(amplitude, period) {
    return function (t) {
      if (0 === t || 1 === t) return t;
      const s = period / pi2 * Math.asin(1 / amplitude);
      return amplitude * Math.pow(2, -10 * t) * Math.sin((t - s) * pi2 / period) + 1;
    };
  }
  static getElasticInOut(amplitude, period) {
    return function (t) {
      const s = period / pi2 * Math.asin(1 / amplitude);
      return (t *= 2) < 1 ? amplitude * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * -.5 : amplitude * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - s) * pi2 / period) * .5 + 1;
    };
  }
  static registerFunc(name, func) {
    Easing[name] = func;
  }
}
function flicker(t, n) {
  const step = 1 / n;
  let flag = 1;
  for (; t > step;) t -= step, flag *= -1;
  const v = flag * t / step;
  return v > 0 ? v : 1 + v;
}
Easing.quadIn = Easing.getPowIn(2), Easing.quadOut = Easing.getPowOut(2), Easing.quadInOut = Easing.getPowInOut(2), Easing.cubicIn = Easing.getPowIn(3), Easing.cubicOut = Easing.getPowOut(3), Easing.cubicInOut = Easing.getPowInOut(3), Easing.quartIn = Easing.getPowIn(4), Easing.quartOut = Easing.getPowOut(4), Easing.quartInOut = Easing.getPowInOut(4), Easing.quintIn = Easing.getPowIn(5), Easing.quintOut = Easing.getPowOut(5), Easing.quintInOut = Easing.getPowInOut(5), Easing.backIn = Easing.getBackIn(1.7), Easing.backOut = Easing.getBackOut(1.7), Easing.backInOut = Easing.getBackInOut(1.7), Easing.elasticIn = Easing.getElasticIn(1, .3), Easing.elasticOut = Easing.getElasticOut(1, .3), Easing.elasticInOut = Easing.getElasticInOut(1, .3 * 1.5), Easing.easeInOutQuad = t => (t /= .5) < 1 ? .5 * Math.pow(t, 2) : -.5 * ((t -= 2) * t - 2), Easing.easeOutElastic = x => {
  const c4 = 2 * Math.PI / 3;
  return 0 === x ? 0 : 1 === x ? 1 : Math.pow(2, -10 * x) * Math.sin((10 * x - .75) * c4) + 1;
}, Easing.easeInOutElastic = x => {
  const c5 = 2 * Math.PI / 4.5;
  return 0 === x ? 0 : 1 === x ? 1 : x < .5 ? -Math.pow(2, 20 * x - 10) * Math.sin((20 * x - 11.125) * c5) / 2 : Math.pow(2, -20 * x + 10) * Math.sin((20 * x - 11.125) * c5) / 2 + 1;
};
for (let i = 0; i < 10; i++) Easing[`flicker${i}`] = t => flicker(t, i);
for (let i = 2; i < 10; i++) Easing[`aIn${i}`] = t => i * t * t + (1 - i) * t;

class DefaultTimeline {
  constructor() {
    this.id = Generator.GenAutoIncrementId(), this.animateHead = null, this.animateTail = null, this.animateCount = 0, this.paused = !1;
  }
  addAnimate(animate) {
    this.animateTail ? (this.animateTail.nextAnimate = animate, animate.prevAnimate = this.animateTail, this.animateTail = animate, animate.nextAnimate = null) : (this.animateHead = animate, this.animateTail = animate), this.animateCount++;
  }
  pause() {
    this.paused = !0;
  }
  resume() {
    this.paused = !1;
  }
  tick(delta) {
    if (this.paused) return;
    let animate = this.animateHead;
    for (this.animateCount = 0; animate;) animate.status === AnimateStatus.END ? this.removeAnimate(animate) : animate.status === AnimateStatus.RUNNING || animate.status === AnimateStatus.INITIAL ? (this.animateCount++, animate.advance(delta)) : animate.status === AnimateStatus.PAUSED && this.animateCount++, animate = animate.nextAnimate;
  }
  clear() {
    let animate = this.animateHead;
    for (; animate;) animate.release(), animate = animate.nextAnimate;
    this.animateHead = null, this.animateTail = null, this.animateCount = 0;
  }
  removeAnimate(animate) {
    let release = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    animate._onRemove && animate._onRemove.forEach(cb => cb()), animate === this.animateHead ? (this.animateHead = animate.nextAnimate, animate === this.animateTail ? this.animateTail = null : this.animateHead.prevAnimate = null) : animate === this.animateTail ? (this.animateTail = animate.prevAnimate, this.animateTail.nextAnimate = null) : (animate.prevAnimate.nextAnimate = animate.nextAnimate, animate.nextAnimate.prevAnimate = animate.prevAnimate), release && animate.release();
  }
}
const defaultTimeline = new DefaultTimeline();

class ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    this.from = from, this.to = to, this.duration = duration, this.easing = easing, this.params = params, this.updateCount = 0;
  }
  bind(target, subAni) {
    this.target = target, this.subAnimate = subAni, this.onBind();
  }
  onBind() {}
  onFirstRun() {}
  onStart() {}
  onEnd() {}
  getEndProps() {
    return this.to;
  }
  getFromProps() {
    return this.from;
  }
  getMergedEndProps() {
    var _a;
    const thisEndProps = this.getEndProps();
    return thisEndProps ? this._endProps === thisEndProps ? this._mergedEndProps : (this._endProps = thisEndProps, void (this._mergedEndProps = Object.assign({}, null !== (_a = this.step.prev.getLastProps()) && void 0 !== _a ? _a : {}, thisEndProps))) : this.step.prev ? this.step.prev.getLastProps() : thisEndProps;
  }
  update(end, ratio, out) {
    if (0 === this.updateCount) {
      this.onFirstRun();
      const props = this.step.getLastProps();
      Object.keys(props).forEach(k => {
        this.subAnimate.animate.validAttr(k) && (out[k] = props[k]);
      });
    }
    this.updateCount += 1, this.onUpdate(end, ratio, out), end && this.onEnd();
  }
}
class CbAnimate extends ACustomAnimate {
  constructor(cb) {
    super(null, null, 0, "linear"), this.cb = cb;
  }
  onUpdate(end, ratio, out) {}
  onStart() {
    this.cb();
  }
}
class Animate {
  constructor() {
    let id = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Generator.GenAutoIncrementId();
    let timeline = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultTimeline;
    let slience = arguments.length > 2 ? arguments[2] : undefined;
    this.id = id, this.timeline = timeline || defaultTimeline, this.status = AnimateStatus.INITIAL, this.tailAnimate = new SubAnimate(this), this.subAnimates = [this.tailAnimate], this.timeScale = 1, this.rawPosition = -1, this._startTime = 0, this._duringTime = 0, this.timeline.addAnimate(this), this.slience = slience;
  }
  setTimeline(timeline) {
    timeline !== this.timeline && (this.timeline.removeAnimate(this, !1), timeline.addAnimate(this));
  }
  getStartTime() {
    return this._startTime;
  }
  getDuration() {
    return this.subAnimates.reduce((t, subAnimate) => t + subAnimate.totalDuration, 0);
  }
  after(animate) {
    const t = animate.getDuration();
    return this._startTime = t, this;
  }
  afterAll(list) {
    let maxT = -1 / 0;
    return list.forEach(a => {
      maxT = max(a.getDuration(), maxT);
    }), this._startTime = maxT, this;
  }
  parallel(animate) {
    return this._startTime = animate.getStartTime(), this;
  }
  static AddInterpolate(name, cb) {
    Animate.interpolateMap.set(name, cb);
  }
  play(customAnimate) {
    if (this.tailAnimate.play(customAnimate), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return 1 === this.subAnimates.length && this.tailAnimate.totalDuration === customAnimate.duration && this.trySetAttribute(customAnimate.getFromProps(), customAnimate.mode), this;
  }
  trySetAttribute(attr) {
    let mode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Animate.mode;
    attr && mode & AnimateMode.SET_ATTR_IMMEDIATELY && this.target.setAttributes && this.target.setAttributes(attr, !1, {
      type: AttributeUpdateType.ANIMATE_PLAY
    });
  }
  runCb(cb) {
    const customAnimate = new CbAnimate(() => {
      cb(this, customAnimate.step.prev);
    });
    return this.tailAnimate.play(customAnimate), this;
  }
  customInterpolate(key, ratio, from, to, target, ret) {
    const func = Animate.interpolateMap.get(key) || Animate.interpolateMap.get("");
    return !!func && func(key, ratio, from, to, target, ret);
  }
  pause() {
    this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.PAUSED);
  }
  resume() {
    this.status === AnimateStatus.PAUSED && (this.status = AnimateStatus.RUNNING);
  }
  to(props, duration, easing, params) {
    if (this.tailAnimate.to(props, duration, easing, params), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  from(props, duration, easing, params) {
    if (this.tailAnimate.from(props, duration, easing, params), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  wait(duration) {
    if (this.tailAnimate.wait(duration), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  startAt(t) {
    if (this.tailAnimate.startAt(t), this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  loop(l) {
    if (this.tailAnimate.loop = l, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  reversed(r) {
    if (this.tailAnimate.reversed = r, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  bounce(b) {
    if (this.tailAnimate.bounce = b, this.target) {
      const stage = this.target.stage;
      stage && stage.renderNextFrame();
    }
    return this;
  }
  subAnimate() {
    const sa = new SubAnimate(this, this.tailAnimate);
    return this.tailAnimate = sa, this.subAnimates.push(sa), sa.bind(this.target), this;
  }
  getStartProps() {
    return this.subAnimates[0].getStartProps();
  }
  getEndProps() {
    return this.tailAnimate.getEndProps();
  }
  depreventAttr(key) {
    this._preventAttrs && this._preventAttrs.delete(key);
  }
  preventAttr(key) {
    this._preventAttrs || (this._preventAttrs = new Set()), this._preventAttrs.add(key);
  }
  preventAttrs(keys) {
    keys.forEach(key => this.preventAttr(key));
  }
  validAttr(key) {
    return !this._preventAttrs || !this._preventAttrs.has(key);
  }
  bind(target) {
    return this.target = target, this.target.onAnimateBind && !this.slience && this.target.onAnimateBind(this), this.subAnimates.forEach(sa => {
      sa.bind(target);
    }), this;
  }
  advance(delta) {
    if (this._duringTime < this._startTime) {
      if (this._duringTime + delta * this.timeScale < this._startTime) return void (this._duringTime += delta * this.timeScale);
      delta = this._duringTime + delta * this.timeScale - this._startTime, this._duringTime = this._startTime;
    }
    this.status === AnimateStatus.INITIAL && (this.status = AnimateStatus.RUNNING, this._onStart && this._onStart.forEach(cb => cb()));
    this.setPosition(Math.max(this.rawPosition, 0) + delta * this.timeScale) && this.status === AnimateStatus.RUNNING && (this.status = AnimateStatus.END, this._onEnd && this._onEnd.forEach(cb => cb()));
  }
  setPosition(rawPosition) {
    let sa,
      d = 0;
    const prevRawPos = this.rawPosition,
      maxRawPos = this.subAnimates.reduce((a, b) => a + b.totalDuration, 0);
    rawPosition < 0 && (rawPosition = 0);
    const end = rawPosition >= maxRawPos;
    if (end && (rawPosition = maxRawPos), rawPosition === prevRawPos) return end;
    for (let i = 0; i < this.subAnimates.length && (sa = this.subAnimates[i], !(d + sa.totalDuration >= rawPosition)); i++) d += sa.totalDuration, sa = void 0;
    return this.rawPosition = rawPosition, sa.setPosition(rawPosition - d), end;
  }
  onStart(cb) {
    this._onStart || (this._onStart = []), this._onStart.push(cb);
  }
  onEnd(cb) {
    this._onEnd || (this._onEnd = []), this._onEnd.push(cb);
  }
  onRemove(cb) {
    this._onRemove || (this._onRemove = []), this._onRemove.push(cb);
  }
  onFrame(cb) {
    this._onFrame || (this._onFrame = []), this._onFrame.push(cb);
  }
  release() {
    this.status = AnimateStatus.END;
  }
  stop(nextVal) {
    nextVal || this.target.onStop(), "start" === nextVal ? this.target.onStop(this.getStartProps()) : "end" === nextVal ? this.target.onStop(this.getEndProps()) : this.target.onStop(nextVal), this.release();
  }
}
Animate.mode = AnimateMode.NORMAL, Animate.interpolateMap = new Map();
class SubAnimate {
  get totalDuration() {
    return this.calcAttr(), this._totalDuration + this._startAt;
  }
  constructor(animate, lastSubAnimate) {
    this.rawPosition = -1, this.position = 0, this.loop = 0, this.duration = 0, this.animate = animate, this.stepHead = new Step(0, 0, lastSubAnimate ? Object.assign({}, lastSubAnimate.stepTail.props) : {}), this.stepTail = this.stepHead, this.dirty = !0, this._startAt = 0;
  }
  calcAttr() {
    this.dirty && (this._totalDuration = this.duration * (this.loop + 1));
  }
  bind(target) {
    return this.target = target, this;
  }
  play(customAnimate) {
    let duration = customAnimate.duration;
    (null == duration || duration < 0) && (duration = 0);
    const easing = customAnimate.easing,
      easingFunc = "string" == typeof easing ? Easing[easing] : easing,
      step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.customAnimate, this._appendProps(customAnimate.getEndProps(), step, !1), this._appendCustomAnimate(customAnimate, step), this;
  }
  to(props, duration, easing, params) {
    (null == duration || duration < 0) && (duration = 0);
    const easingFunc = "string" == typeof easing ? Easing[easing] : easing,
      step = this._addStep(duration, null, easingFunc);
    return step.type = AnimateStepType.to, this._appendProps(props, step, !!params && params.tempProps), step.propKeys || (step.propKeys = Object.keys(step.props)), params && params.noPreventAttrs || this.target.animates && this.target.animates.forEach(a => {
      a.id !== this.animate.id && a.preventAttrs(step.propKeys);
    }), this;
  }
  from(props, duration, easing, params) {
    this.to(props, 0, easing, params);
    const toProps = {};
    this.stepTail.propKeys || (this.stepTail.propKeys = Object.keys(this.stepTail.props)), this.stepTail.propKeys.forEach(k => {
      toProps[k] = this.getLastPropByName(k, this.stepTail);
    }), this.to(toProps, duration, easing, params), this.stepTail.type = AnimateStepType.from;
  }
  startAt(t) {
    return t < 0 && (t = 0), this._startAt = t, this;
  }
  getStartProps() {
    var _a;
    return null === (_a = this.stepHead) || void 0 === _a ? void 0 : _a.props;
  }
  getEndProps() {
    return this.stepTail.props;
  }
  getLastStep() {
    return this._lastStep;
  }
  wait(duration) {
    if (duration > 0) {
      const step = this._addStep(+duration, null);
      step.type = AnimateStepType.wait, step.prev.customAnimate ? step.props = step.prev.customAnimate.getEndProps() : step.props = step.prev.props, this.target.onAddStep && this.target.onAddStep(step);
    }
    return this;
  }
  _addStep(duration, props, easingFunc) {
    const step = new Step(this.duration, duration, props, easingFunc);
    return this.duration += duration, this.stepTail.append(step), this.stepTail = step, step;
  }
  _appendProps(props, step, tempProps) {
    step.props = tempProps ? props : Object.assign({}, props);
    let lastStep = step.prev;
    const _props = step.props;
    for (step.propKeys || (step.propKeys = Object.keys(step.props)), step.propKeys.forEach(k => {
      void 0 === step.props[k] && (step.props[k] = this.target.getDefaultAttribute(k));
    }); lastStep.prev;) lastStep.props && (lastStep.propKeys || (lastStep.propKeys = Object.keys(lastStep.props)), lastStep.propKeys.forEach(key => {
      void 0 === _props[key] && (_props[key] = lastStep.props[key]);
    })), step.propKeys = Object.keys(step.props), lastStep = lastStep.prev;
    const initProps = this.stepHead.props;
    step.propKeys || (step.propKeys = Object.keys(_props)), step.propKeys.forEach(key => {
      if (void 0 === initProps[key]) {
        const parentAnimateInitProps = this.animate.getStartProps();
        initProps[key] = parentAnimateInitProps[key] = this.target.getComputedAttribute(key);
      }
    }), this.target.onAddStep && this.target.onAddStep(step);
  }
  _appendCustomAnimate(customAnimate, step) {
    step.customAnimate = customAnimate, customAnimate.step = step, customAnimate.bind(this.target, this);
  }
  setPosition(rawPosition) {
    var _a;
    const d = this.duration,
      loopCount = this.loop,
      prevRawPos = this.rawPosition;
    let loop,
      position,
      end = !1;
    const startAt = null !== (_a = this._startAt) && void 0 !== _a ? _a : 0;
    if (rawPosition < 0 && (rawPosition = 0), rawPosition < startAt) return this.rawPosition = rawPosition, !1;
    if (rawPosition -= startAt, d <= 0 && (end = !0, d < 0)) return end;
    if (loop = Math.floor(rawPosition / d), position = rawPosition - loop * d, end = rawPosition >= loopCount * d + d, end && (position = d, loop = loopCount, rawPosition = position * loop + d), rawPosition === prevRawPos) return end;
    const rev = !this.reversed != !(this.bounce && loop % 2);
    return rev && (position = d - position), this._deltaPosition = position - this.position, this.position = position, this.rawPosition = rawPosition + startAt, this.updatePosition(end, rev), end;
  }
  updatePosition(end, rev) {
    if (!this.stepHead) return;
    let step = this.stepHead.next;
    const position = this.position,
      duration = this.duration;
    if (this.target && step) {
      let stepNext = step.next;
      for (; stepNext && stepNext.position <= position;) step = stepNext, stepNext = step.next;
      let ratio = end ? 0 === duration ? 1 : position / duration : (position - step.position) / step.duration;
      step.easing && (ratio = step.easing(ratio)), this.tryCallCustomAnimateLifeCycle(step, this._lastStep || (rev ? this.stepTail : this.stepHead), rev), this.updateTarget(step, ratio, end), this._lastStep = step, this.animate._onFrame && this.animate._onFrame.forEach(cb => cb(step, ratio));
    }
  }
  tryCallCustomAnimateLifeCycle(step, lastStep, rev) {
    if (step !== lastStep) if (rev) {
      let _step = lastStep.prev;
      for (; _step && _step !== step;) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = step.prev;
      lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
    } else {
      let _step = lastStep.next;
      for (; _step && _step !== step;) _step.customAnimate && (_step.customAnimate.onStart && _step.customAnimate.onStart(), _step.customAnimate.onEnd && _step.customAnimate.onEnd()), _step = _step.next;
      lastStep && lastStep.customAnimate && lastStep.customAnimate.onEnd && lastStep.customAnimate.onEnd(), step && step.customAnimate && step.customAnimate.onStart && step.customAnimate.onStart();
    }
  }
  getLastPropByName(name, step) {
    let lastStep = step.prev;
    for (; lastStep;) {
      if (lastStep.props && void 0 !== lastStep.props[name]) return lastStep.props[name];
      if (lastStep.customAnimate) {
        const val = lastStep.customAnimate.getEndProps()[name];
        if (void 0 !== val) return val;
      }
      lastStep = lastStep.prev;
    }
    return Logger.getInstance().warn("未知错误，step中找不到属性"), step.props[name];
  }
  updateTarget(step, ratio, end) {
    null == step.props && null == step.customAnimate || this.target.onStep(this, this.animate, step, ratio, end);
  }
}
class Step {
  constructor(position, duration, props, easing) {
    this.duration = duration, this.position = position, this.props = props, this.easing = easing;
  }
  append(step) {
    step.prev = this, step.next = this.next, this.next = step;
  }
  getLastProps() {
    let step = this.prev;
    for (; step;) {
      if (step.props) return step.props;
      if (step.customAnimate) return step.customAnimate.getMergedEndProps();
      step = step.prev;
    }
    return null;
  }
}

const DefaultStateAnimateConfig = {
  duration: 200,
  easing: "cubicOut"
};
const DefaultMorphingAnimateConfig = {
  duration: 1e3,
  easing: "quadInOut"
};

var Edge;
!function (Edge) {
  Edge[Edge.Top = 1] = "Top", Edge[Edge.Right = 2] = "Right", Edge[Edge.Bottom = 4] = "Bottom", Edge[Edge.Left = 8] = "Left", Edge[Edge.ALL = 15] = "ALL";
}(Edge || (Edge = {}));
const _strokeVec4 = [!1, !1, !1, !1];
const parseStroke = stroke => {
  var _a;
  let isFullStroke = !0;
  if (isBoolean$1(stroke, !0)) {
    for (let i = 0; i < 4; i++) _strokeVec4[i] = stroke, isFullStroke && (isFullStroke = !(null !== (_a = _strokeVec4[i]) && void 0 !== _a && !_a));
    isFullStroke = stroke;
  } else if (Array.isArray(stroke)) for (let i = 0; i < 4; i++) _strokeVec4[i] = !!stroke[i], isFullStroke && (isFullStroke = !!_strokeVec4[i]);else _strokeVec4[0] = !1, _strokeVec4[1] = !1, _strokeVec4[2] = !1, _strokeVec4[3] = !1;
  return {
    isFullStroke: isFullStroke,
    stroke: _strokeVec4
  };
};
const _paddingVec4 = [0, 0, 0, 0];
const parsePadding = padding => padding ? isArray$1(padding) ? 0 === padding.length ? 0 : 1 === padding.length ? padding[0] : 2 === padding.length ? (_paddingVec4[0] = padding[0], _paddingVec4[2] = padding[0], _paddingVec4[1] = padding[1], _paddingVec4[3] = padding[1], _paddingVec4) : padding : padding : 0;
const _coords = [{
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }, {
    x: 0,
    y: 0
  }],
  indexList = [1, 2, 3, 0, 1, 2, 3, 0];
function circleBounds(startAngle, endAngle, radius, bounds) {
  for (; startAngle >= pi2;) startAngle -= pi2;
  for (; startAngle < 0;) startAngle += pi2;
  for (; startAngle > endAngle;) endAngle += pi2;
  _coords[0].x = radius, _coords[1].y = radius, _coords[2].x = -radius, _coords[3].y = -radius;
  const startIdx = Math.ceil(startAngle / halfPi$1) % 4,
    endIdx = Math.ceil(endAngle / halfPi$1) % 4;
  if (bounds.add(cos(startAngle) * radius, sin(startAngle) * radius), bounds.add(cos(endAngle) * radius, sin(endAngle) * radius), startIdx !== endIdx || endAngle - startAngle > pi) {
    let match = !1;
    for (let i = 0; i < indexList.length; i++) if (match || startIdx !== indexList[i]) {
      if (match && endIdx === indexList[i]) break;
      if (match) {
        const p = _coords[indexList[i]];
        bounds.add(p.x, p.y);
      }
    } else {
      match = !0;
      const p = _coords[startIdx];
      bounds.add(p.x, p.y);
    }
  }
}
function pointsEqual(pointsA, pointsB) {
  return !(!pointsA || !pointsB) && (Array.isArray(pointsA) && Array.isArray(pointsB) ? pointsA.length === pointsB.length && pointsA.every((point, index) => pointEqual(point, pointsB[index])) : !Number.isNaN(pointsA.x + pointsA.y) && pointEqual(pointsA, pointsB));
}
function pointEqual(pointA, pointB) {
  return pointA.x === pointB.x && pointA.y === pointB.y && pointA.x1 === pointB.x1 && pointA.y1 === pointB.y1 && pointA.defined === pointB.defined;
}
function pointInterpolation(pointA, pointB, ratio) {
  const {
      x: x,
      y: y
    } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio),
    {
      x: x1,
      y: y1
    } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio),
    point = new Point(x, y, x1, y1);
  return point.defined = pointB.defined, point;
}
function pointInterpolationHighPerformance(pointA, pointB, ratio, point) {
  const {
      x: x,
      y: y
    } = pointAt(pointA.x, pointA.y, pointB.x, pointB.y, ratio),
    {
      x: x1,
      y: y1
    } = pointAt(pointA.x1, pointA.y1, pointB.x1, pointB.y1, ratio);
  return point.x = x, point.y = y, point.x1 = x1, point.y1 = y1, point.defined = pointB.defined, point;
}
function pointsInterpolation(pointsA, pointsB, ratio) {
  if (!pointsA || !pointsB) return [];
  Array.isArray(pointsA) || (pointsA = [pointsA]), Array.isArray(pointsB) || (pointsB = [pointsB]);
  let points = [];
  if (pointsA.length > pointsB.length) {
    points = pointsB.map(point => {
      const p = new Point(point.x, point.y, point.x1, point.y1);
      return p.defined = point.defined, p;
    });
    for (let i = 0; i < pointsB.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  } else {
    points = pointsB.map(point => {
      const p = new Point(point.x, point.y, point.x1, point.y1);
      return p.defined = point.defined, p;
    });
    for (let i = 0; i < pointsA.length; i++) points[i] = pointInterpolation(pointsA[i], pointsB[i], ratio);
  }
  return points;
}
const transformKeys = ["x", "y", "dx", "dy", "scaleX", "scaleY", "angle", "anchor", "postMatrix", "scrollX", "scrollY"];
const isTransformKey = key => transformKeys.includes(key);
function getAttributeFromDefaultAttrList(attr, key) {
  if (isArray$1(attr)) {
    let val;
    for (let i = 0; i < attr.length && void 0 === val; i++) val = attr[i][key];
    return val;
  }
  return attr[key];
}
class RafBasedSTO {
  constructor() {
    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : RafBasedSTO.TimeOut;
    this.durations = [], this.timeout = timeout, this.lastDate = 0, this.durationsListThreshold = 30;
  }
  call(cb) {
    return this.lastDate = Date.now(), setTimeout(() => {
      this.appendDuration(Date.now() - this.lastDate), cb(0);
    }, this.timeout, !0);
  }
  clear(h) {
    clearTimeout(h);
  }
  appendDuration(d) {
    this.durations.push(d), this.durations.length > this.durationsListThreshold && this.durations.shift(), this.timeout = Math.min(Math.max(this.durations.reduce((a, b) => a + b, 0) / this.durations.length, 1e3 / 60), 1e3 / 30);
  }
}
RafBasedSTO.TimeOut = 1e3 / 60;
const rafBasedSto = new RafBasedSTO();
const _calculateLineHeight = (lineHeight, fontSize) => {
  if (isString$1(lineHeight) && "%" === lineHeight[lineHeight.length - 1]) {
    return fontSize * (Number.parseFloat(lineHeight.substring(0, lineHeight.length - 1)) / 100);
  }
  return lineHeight;
};
const calculateLineHeight = (lineHeight, fontSize) => {
  const _lh = _calculateLineHeight(lineHeight, fontSize);
  return isNaN(_lh) ? _lh : Math.max(fontSize, _lh);
};

class IncreaseCount extends ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    super(from, to, duration, easing, params);
  }
  getEndProps() {
    return !1 === this.valid ? {} : {
      text: this.to
    };
  }
  onBind() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    this.fromNumber = isNumber$1(null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) ? null === (_b = this.from) || void 0 === _b ? void 0 : _b.text : Number.parseFloat(null === (_c = this.from) || void 0 === _c ? void 0 : _c.text), this.toNumber = isNumber$1(null === (_d = this.to) || void 0 === _d ? void 0 : _d.text) ? null === (_e = this.to) || void 0 === _e ? void 0 : _e.text : Number.parseFloat(null === (_f = this.to) || void 0 === _f ? void 0 : _f.text), Number.isFinite(this.toNumber) || (this.fromNumber = 0), Number.isFinite(this.toNumber) || (this.valid = !1), !1 !== this.valid && (this.decimalLength = null !== (_h = null === (_g = this.params) || void 0 === _g ? void 0 : _g.fixed) && void 0 !== _h ? _h : Math.max(getDecimalPlaces(this.fromNumber), getDecimalPlaces(this.toNumber)));
  }
  onEnd() {}
  onUpdate(end, ratio, out) {
    var _a;
    !1 !== this.valid && (out.text = end ? null === (_a = this.to) || void 0 === _a ? void 0 : _a.text : (this.fromNumber + (this.toNumber - this.fromNumber) * ratio).toFixed(this.decimalLength));
  }
}
var Direction;
!function (Direction) {
  Direction[Direction.LEFT_TO_RIGHT = 0] = "LEFT_TO_RIGHT", Direction[Direction.RIGHT_TO_LEFT = 1] = "RIGHT_TO_LEFT", Direction[Direction.TOP_TO_BOTTOM = 2] = "TOP_TO_BOTTOM", Direction[Direction.BOTTOM_TO_TOP = 3] = "BOTTOM_TO_TOP", Direction[Direction.STROKE = 4] = "STROKE";
}(Direction || (Direction = {}));
class FadeInPlus extends ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    super(from, to, duration, easing, params);
    const {
      direction = Direction.LEFT_TO_RIGHT,
      fill = !0,
      stroke = !0
    } = params || {};
    this.direction = direction, this.fill = fill, this.stroke = stroke, this.fillGradient = {
      gradient: "linear",
      stops: []
    }, this.strokeGradient = {
      gradient: "linear",
      stops: []
    };
  }
  getEndProps() {
    return {
      fill: this.toFill,
      stroke: this.toStroke
    };
  }
  onBind() {
    this.toFill = this.target.getComputedAttribute("fill"), this.toStroke = this.target.getComputedAttribute("stroke");
  }
  onEnd() {}
  onUpdate(end, ratio, out) {
    if (this.toFill && this.toStroke) switch (this.direction) {
      case Direction.RIGHT_TO_LEFT:
        this.rightToLeft(end, ratio, out);
        break;
      case Direction.TOP_TO_BOTTOM:
        this.topToBottom(end, ratio, out);
        break;
      case Direction.BOTTOM_TO_TOP:
        this.bottomToTop(end, ratio, out);
        break;
      case Direction.STROKE:
        this.strokePath(end, ratio, out);
        break;
      default:
        this.leftToRight(end, ratio, out);
    }
  }
  leftToRight(end, ratio, out) {
    if (this.fill) {
      const toFillColor = this.toFill;
      this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, this.fillGradient.stops = [{
        offset: 0,
        color: toFillColor
      }, {
        offset: ratio,
        color: toFillColor
      }, {
        offset: Math.min(1, 2 * ratio),
        color: "transparent"
      }], out.fill = this.fillGradient;
    }
    if (this.stroke) {
      const toStrokeColor = this.toStroke;
      this.strokeGradient.x0 = 0, this.strokeGradient.y0 = 0, this.strokeGradient.x1 = 1, this.strokeGradient.y1 = 0, this.strokeGradient.stops = [{
        offset: 0,
        color: toStrokeColor
      }, {
        offset: ratio,
        color: toStrokeColor
      }, {
        offset: Math.min(1, 6 * ratio),
        color: "transparent"
      }], out.stroke = this.strokeGradient;
    }
  }
  strokePath(end, ratio, out) {
    if (this.fill) {
      const toFillColor = this.toFill;
      this.fillGradient.x0 = 0, this.fillGradient.y0 = 0, this.fillGradient.x1 = 1, this.fillGradient.y1 = 0, this.fillGradient.stops = [{
        offset: 0,
        color: toFillColor
      }, {
        offset: ratio,
        color: toFillColor
      }, {
        offset: Math.min(1, 2 * ratio),
        color: "transparent"
      }], out.fill = this.fillGradient;
    }
    if (this.stroke) {
      const dashLen = 300,
        offset = ratio * dashLen;
      out.lineDash = [offset, dashLen - offset];
    }
  }
  rightToLeft(end, ratio, out) {}
  topToBottom(end, ratio, out) {}
  bottomToTop(end, ratio, out) {}
}
class InputText extends ACustomAnimate {
  constructor() {
    super(...arguments), this.fromText = "", this.toText = "";
  }
  getEndProps() {
    return !1 === this.valid ? {} : {
      text: this.to
    };
  }
  onBind() {
    var _a, _b, _c;
    this.fromText = null !== (_b = null === (_a = this.from) || void 0 === _a ? void 0 : _a.text) && void 0 !== _b ? _b : "", this.toText = (null === (_c = this.to) || void 0 === _c ? void 0 : _c.text) || "", (!this.toText || isArray$1(this.toText) && 0 === this.toText.length) && (this.valid = !1), isArray$1(this.toText) && (this.toText = this.toText.map(item => (item || "").toString()));
  }
  onEnd() {
    this.target.detachShadow();
  }
  onUpdate(end, ratio, out) {
    if (!1 === this.valid) return;
    const fromCount = this.fromText.length,
      toTextIsArray = isArray$1(this.toText),
      toCount = toTextIsArray ? this.toText.reduce((c, t) => c + (t || "").length, 0) : this.toText.length,
      count = Math.ceil(fromCount + (toCount - fromCount) * ratio);
    if (toTextIsArray) {
      out.text = [];
      let len = 0;
      this.toText.forEach(t => {
        len + t.length > count ? (out.text.push(t.substr(0, count - len)), len = count) : (out.text.push(t), len += t.length);
      });
    } else out.text = this.toText.substr(0, count);
  }
}
class StreamLight extends ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    super(from, to, duration, easing, params);
  }
  getEndProps() {
    return {};
  }
  onStart() {
    this.target && ("rect" === this.target.type ? this.onStartRect() : "line" === this.target.type ? this.onStartLineOrArea("line") : "area" === this.target.type && this.onStartLineOrArea("area"));
  }
  onStartLineOrArea(type) {
    var _a;
    const root = this.target.attachShadow(),
      line = application.graphicService.creator[type](Object.assign({}, null === (_a = this.params) || void 0 === _a ? void 0 : _a.attribute));
    this[type] = line, line.pathProxy = new CustomPath2D(), root.add(line);
  }
  onStartRect() {
    var _a, _b, _c;
    const root = this.target.attachShadow(),
      isHorizontal = null === (_b = null === (_a = this.params) || void 0 === _a ? void 0 : _a.isHorizontal) || void 0 === _b || _b,
      sizeAttr = isHorizontal ? "height" : "width",
      otherSizeAttr = isHorizontal ? "width" : "height",
      size = this.target.AABBBounds[sizeAttr](),
      y = isHorizontal ? 0 : this.target.AABBBounds.y1,
      rect = application.graphicService.creator.rect(Object.assign(Object.assign({
        [sizeAttr]: size,
        fill: "#bcdeff",
        shadowBlur: 30,
        shadowColor: "#bcdeff"
      }, null === (_c = this.params) || void 0 === _c ? void 0 : _c.attribute), {
        x: 0,
        y: y,
        [otherSizeAttr]: 0
      }));
    this.rect = rect, root.add(rect);
  }
  onBind() {}
  onEnd() {
    this.target.detachShadow();
  }
  onUpdate(end, ratio, out) {
    return this.rect ? this.onUpdateRect(end, ratio, out) : this.line || this.area ? this.onUpdateLineOrArea(end, ratio, out) : void 0;
  }
  onUpdateRect(end, ratio, out) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;
    const isHorizontal = null === (_b = null === (_a = this.params) || void 0 === _a ? void 0 : _a.isHorizontal) || void 0 === _b || _b,
      parentAttr = this.target.attribute;
    if (isHorizontal) {
      const parentWidth = null !== (_d = null !== (_c = parentAttr.width) && void 0 !== _c ? _c : Math.abs(parentAttr.x1 - parentAttr.x)) && void 0 !== _d ? _d : 250,
        streamLength = null !== (_f = null === (_e = this.params) || void 0 === _e ? void 0 : _e.streamLength) && void 0 !== _f ? _f : parentWidth,
        maxLength = null !== (_j = null === (_h = null === (_g = this.params) || void 0 === _g ? void 0 : _g.attribute) || void 0 === _h ? void 0 : _h.width) && void 0 !== _j ? _j : 60,
        startX = -maxLength,
        currentX = startX + (streamLength - startX) * ratio,
        x = Math.max(currentX, 0),
        w = Math.min(Math.min(currentX + maxLength, maxLength), streamLength - currentX),
        width = w + x > parentWidth ? Math.max(parentWidth - x, 0) : w;
      this.rect.setAttributes({
        x: x,
        width: width,
        dx: Math.min(parentAttr.x1 - parentAttr.x, 0)
      }, !1, {
        type: AttributeUpdateType.ANIMATE_PLAY,
        animationState: {
          ratio: ratio,
          end: end
        }
      });
    } else {
      const parentHeight = null !== (_l = null !== (_k = parentAttr.height) && void 0 !== _k ? _k : Math.abs(parentAttr.y1 - parentAttr.y)) && void 0 !== _l ? _l : 250,
        streamLength = null !== (_o = null === (_m = this.params) || void 0 === _m ? void 0 : _m.streamLength) && void 0 !== _o ? _o : parentHeight,
        maxLength = null !== (_r = null === (_q = null === (_p = this.params) || void 0 === _p ? void 0 : _p.attribute) || void 0 === _q ? void 0 : _q.height) && void 0 !== _r ? _r : 60,
        currentY = parentHeight - (streamLength + maxLength) * ratio;
      let y = Math.min(currentY, parentHeight);
      const h = Math.min(parentHeight - currentY, maxLength);
      let height;
      y <= 0 ? (height = Math.max(y + h, 0), y = 0) : height = h, this.rect.setAttributes({
        y: y,
        height: height,
        dy: Math.min(parentAttr.y1 - parentAttr.y, 0)
      }, !1, {
        type: AttributeUpdateType.ANIMATE_PLAY,
        animationState: {
          ratio: ratio,
          end: end
        }
      });
    }
  }
  onUpdateLineOrArea(end, ratio, out) {
    const target = this.line || this.area;
    if (!target) return;
    const customPath = target.pathProxy,
      targetLine = this.target;
    targetLine.cache || targetLine.cacheArea ? this._onUpdateLineOrAreaWithCache(customPath, targetLine, end, ratio, out) : this._onUpdateLineWithoutCache(customPath, targetLine, end, ratio, out);
    const targetAttrs = targetLine.attribute;
    target.setAttributes(Object.assign({
      stroke: targetAttrs.stroke
    }, target.attribute)), target.addUpdateBoundTag();
  }
  _onUpdateLineOrAreaWithCache(customPath, g, end, ratio, out) {
    var _a, _b;
    if (customPath.clear(), "line" === g.type) {
      let cache = g.cache;
      Array.isArray(cache) || (cache = [cache]);
      const totalLen = cache.reduce((l, c) => l + c.getLength(), 0),
        curves = [];
      return cache.forEach(c => {
        c.curves.forEach(ci => curves.push(ci));
      }), this._updateCurves(customPath, curves, totalLen, ratio);
    }
    if ("area" === g.type && (null === (_b = null === (_a = g.cacheArea) || void 0 === _a ? void 0 : _a.top) || void 0 === _b ? void 0 : _b.curves)) {
      const cache = g.cacheArea,
        totalLen = cache.top.curves.reduce((a, b) => a + b.getLength(), 0);
      return this._updateCurves(customPath, cache.top.curves, totalLen, ratio);
    }
  }
  _updateCurves(customPath, curves, totalLen, ratio) {
    var _a, _b;
    const startLen = totalLen * ratio,
      endLen = Math.min(null !== (_b = startLen + (null === (_a = this.params) || void 0 === _a ? void 0 : _a.streamLength)) && void 0 !== _b ? _b : 10, totalLen);
    let lastLen = 0,
      start = !1;
    for (let i = 0; i < curves.length; i++) if (!1 !== curves[i].defined) {
      const curveItem = curves[i],
        len = curveItem.getLength(),
        startPercent = 1 - (lastLen + len - startLen) / len;
      let curveForStart,
        endPercent = 1 - (lastLen + len - endLen) / len;
      if (lastLen < startLen && lastLen + len > startLen) if (start = !0, curveItem.p2 && curveItem.p3) {
        const [_, curve2] = divideCubic(curveItem, startPercent);
        customPath.moveTo(curve2.p0.x, curve2.p0.y), curveForStart = curve2;
      } else {
        const p = curveItem.getPointAt(startPercent);
        customPath.moveTo(p.x, p.y);
      }
      if (lastLen < endLen && lastLen + len > endLen) {
        if (curveItem.p2 && curveItem.p3) {
          curveForStart && (endPercent = (endLen - startLen) / curveForStart.getLength());
          const [curve1] = divideCubic(curveForStart || curveItem, endPercent);
          customPath.bezierCurveTo(curve1.p1.x, curve1.p1.y, curve1.p2.x, curve1.p2.y, curve1.p3.x, curve1.p3.y);
        } else {
          const p = curveItem.getPointAt(endPercent);
          customPath.lineTo(p.x, p.y);
        }
        break;
      }
      if (start) if (curveItem.p2 && curveItem.p3) {
        const curve = curveForStart || curveItem;
        customPath.bezierCurveTo(curve.p1.x, curve.p1.y, curve.p2.x, curve.p2.y, curve.p3.x, curve.p3.y);
      } else customPath.lineTo(curveItem.p1.x, curveItem.p1.y);
      lastLen += len;
    }
  }
  _onUpdateLineWithoutCache(customPath, line, end, ratio, out) {
    var _a, _b;
    const {
      points: points,
      curveType: curveType
    } = line.attribute;
    if (!points || points.length < 2 || "linear" !== curveType) return;
    let totalLen = 0;
    for (let i = 1; i < points.length; i++) totalLen += PointService.distancePP(points[i], points[i - 1]);
    const startLen = totalLen * ratio,
      endLen = Math.min(null !== (_b = startLen + (null === (_a = this.params) || void 0 === _a ? void 0 : _a.streamLength)) && void 0 !== _b ? _b : 10, totalLen),
      nextPoints = [];
    let lastLen = 0;
    for (let i = 1; i < points.length; i++) {
      const len = PointService.distancePP(points[i], points[i - 1]);
      if (lastLen < startLen && lastLen + len > startLen && nextPoints.push(PointService.pointAtPP(points[i - 1], points[i], 1 - (lastLen + len - startLen) / len)), lastLen < endLen && lastLen + len > endLen) {
        nextPoints.push(PointService.pointAtPP(points[i - 1], points[i], 1 - (lastLen + len - endLen) / len));
        break;
      }
      nextPoints.length && nextPoints.push(points[i]), lastLen += len;
    }
    if (nextPoints.length && !(nextPoints.length < 2)) {
      customPath.clear(), customPath.moveTo(nextPoints[0].x, nextPoints[0].y);
      for (let i = 1; i < nextPoints.length; i++) customPath.lineTo(nextPoints[i].x, nextPoints[i].y);
    }
  }
}
class Meteor extends ACustomAnimate {
  get lastPos() {
    return this.posList[this.posList.length - 1];
  }
  constructor(size, duration, easing, params) {
    super(null, null, duration, easing, params), this.size = size, this.posList = [];
  }
  onBind() {
    const root = this.target.attachShadow();
    this.root = root;
    for (let i = 0; i < this.size; i++) {
      const g = this.target.clone(),
        scale = Math.min((this.size - i) / this.size * 3, 1),
        opacity = Math.min(.2 + .7 / this.size);
      g.setAttributes({
        x: 0,
        y: 0,
        dx: 0,
        dy: 0,
        scaleX: scale,
        scaleY: scale,
        opacity: opacity
      }, !1, {
        type: AttributeUpdateType.ANIMATE_BIND
      }), root.add(g);
    }
  }
  onUpdate(end, ratio, out) {
    if (end) return this.target.detachShadow(), void (this.posList.length = 0);
    const x = this.target.getComputedAttribute("x"),
      y = this.target.getComputedAttribute("y"),
      nextPos = new Point(x, y);
    this.posList.length ? (this.target.shadowRoot.forEachChildren((g, i) => {
      const pos = this.posList[Math.max(this.posList.length - i - 1, 0)];
      g.setAttributes({
        x: pos.x - x,
        y: pos.y - y
      }, !1);
    }), this.posList.push(nextPos)) : this.posList.push(nextPos);
  }
}
class MotionPath extends ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    var _a;
    super(from, to, duration, easing, params), params && (this.pathLength = params.path.getLength(), this.path = params.path, this.distance = params.distance, this.to = params.distance * this.pathLength, this.initAngle = null !== (_a = params.initAngle) && void 0 !== _a ? _a : 0, this.changeAngle = !!params.changeAngle, this.cb = params.cb);
  }
  onUpdate(end, ratio, out) {
    const at = this.to * ratio,
      {
        pos: pos,
        angle: angle
      } = this.path.getAttrAt(at);
    out.x = pos.x, out.y = pos.y, this.changeAngle && (out.angle = angle + this.initAngle), this.cb && this.cb(this.from, this.to, ratio, this.target);
  }
}
class TagPointsUpdate extends ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    var _a, _b;
    super(from, to, duration, easing, params), this.newPointAnimateType = null !== (_a = null == params ? void 0 : params.newPointAnimateType) && void 0 !== _a ? _a : "grow", this.clipRangeByDimension = null !== (_b = null == params ? void 0 : params.clipRangeByDimension) && void 0 !== _b ? _b : "x";
  }
  getPoints(attribute) {
    let cache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (attribute.points) return attribute.points;
    if (attribute.segments) {
      const points = [];
      return this.segmentsCache || (this.segmentsCache = []), attribute.segments.map(segment => {
        var _a, _b;
        segment.points && points.push(...segment.points), cache && this.segmentsCache.push(null !== (_b = null === (_a = segment.points) || void 0 === _a ? void 0 : _a.length) && void 0 !== _b ? _b : 0);
      }), points;
    }
    return [];
  }
  onBind() {
    const originFromPoints = this.getPoints(this.from),
      originToPoints = this.getPoints(this.to, !0);
    this.fromPoints = originFromPoints ? Array.isArray(originFromPoints) ? originFromPoints : [originFromPoints] : [], this.toPoints = originToPoints ? Array.isArray(originToPoints) ? originToPoints : [originToPoints] : [];
    const tagMap = new Map();
    this.fromPoints.forEach(point => {
      point.context && tagMap.set(point.context, point);
    });
    let firstMatchedPoint,
      lastMatchedPoint,
      firstMatchedIndex = 1 / 0,
      lastMatchedIndex = -1 / 0;
    for (let i = 0; i < this.toPoints.length; i += 1) if (tagMap.has(this.toPoints[i].context)) {
      firstMatchedIndex = i, firstMatchedPoint = tagMap.get(this.toPoints[i].context);
      break;
    }
    for (let i = this.toPoints.length - 1; i >= 0; i -= 1) if (tagMap.has(this.toPoints[i].context)) {
      lastMatchedIndex = i, lastMatchedPoint = tagMap.get(this.toPoints[i].context);
      break;
    }
    "clip" === this.newPointAnimateType && 0 !== this.toPoints.length && (Number.isFinite(lastMatchedIndex) ? (this.clipRange = this.toPoints[lastMatchedIndex][this.clipRangeByDimension] / this.toPoints[this.toPoints.length - 1][this.clipRangeByDimension], 1 === this.clipRange && (this.shrinkClipRange = this.toPoints[lastMatchedIndex][this.clipRangeByDimension] / this.fromPoints[this.fromPoints.length - 1][this.clipRangeByDimension]), isValidNumber$1(this.clipRange) ? this.clipRange = clamp$1(this.clipRange, 0, 1) : this.clipRange = 0) : this.clipRange = 0);
    let prevMatchedPoint = this.toPoints[0];
    this.interpolatePoints = this.toPoints.map((point, index) => {
      const matchedPoint = tagMap.get(point.context);
      return matchedPoint ? (prevMatchedPoint = matchedPoint, [matchedPoint, point]) : "appear" === this.newPointAnimateType || "clip" === this.newPointAnimateType ? [point, point] : index < firstMatchedIndex && firstMatchedPoint ? [firstMatchedPoint, point] : index > lastMatchedIndex && lastMatchedPoint ? [lastMatchedPoint, point] : [prevMatchedPoint, point];
    }), this.points = this.interpolatePoints.map(interpolate => {
      const fromPoint = interpolate[0],
        toPoint = interpolate[1],
        newPoint = new Point(fromPoint.x, fromPoint.y, fromPoint.x1, fromPoint.y1);
      return newPoint.defined = toPoint.defined, newPoint.context = toPoint.context, newPoint;
    });
  }
  onFirstRun() {
    const lastClipRange = this.target.attribute.clipRange;
    isValidNumber$1(lastClipRange * this.clipRange) && (this.clipRange *= lastClipRange);
  }
  onUpdate(end, ratio, out) {
    if (this.points = this.points.map((point, index) => {
      const newPoint = pointInterpolation(this.interpolatePoints[index][0], this.interpolatePoints[index][1], ratio);
      return newPoint.context = point.context, newPoint;
    }), this.clipRange) {
      if (this.shrinkClipRange) return void (end ? (out.points = this.toPoints, out.clipRange = 1) : (out.points = this.fromPoints, out.clipRange = this.clipRange - (this.clipRange - this.shrinkClipRange) * ratio));
      out.clipRange = this.clipRange + (1 - this.clipRange) * ratio;
    }
    if (this.segmentsCache && this.to.segments) {
      let start = 0;
      out.segments = this.to.segments.map((segment, index) => {
        const end = start + this.segmentsCache[index],
          points = this.points.slice(start, end);
        return start = end, Object.assign(Object.assign({}, segment), {
          points: points
        });
      });
    } else out.points = this.points;
  }
}
class GraphicAnimate extends ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    super(from, to, duration, easing, params), this.graphic = null == params ? void 0 : params.graphic;
  }
  onUpdate(end, ratio, out) {
    this.graphic && Object.keys(this.from).forEach(k => {
      out[k] = this.from[k] + (this.to[k] - this.from[k]) * ratio;
    });
  }
}
class ClipGraphicAnimate extends ACustomAnimate {
  constructor(from, to, duration, easing, params) {
    super(null, null, duration, easing, params), this.clipFromAttribute = from, this.clipToAttribute = to, this._group = null == params ? void 0 : params.group, this._clipGraphic = null == params ? void 0 : params.clipGraphic;
  }
  onBind() {
    this._group && this._clipGraphic && (this._lastClip = this._group.attribute.clip, this._lastPath = this._group.attribute.path, this._group.setAttributes({
      clip: !0,
      path: [this._clipGraphic]
    }, !1, {
      type: AttributeUpdateType.ANIMATE_BIND
    }));
  }
  onEnd() {
    this._group && this._group.setAttributes({
      clip: this._lastClip,
      path: this._lastPath
    }, !1, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  onUpdate(end, ratio, out) {
    if (!this._clipGraphic) return;
    const res = {};
    Object.keys(this.clipFromAttribute).forEach(k => {
      res[k] = this.clipFromAttribute[k] + (this.clipToAttribute[k] - this.clipFromAttribute[k]) * ratio;
    }), this._clipGraphic.setAttributes(res, !1, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio: ratio,
        end: end
      }
    });
  }
}
class ClipAngleAnimate extends ClipGraphicAnimate {
  constructor(from, to, duration, easing, params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {},
      width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0,
      height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0,
      animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : "in",
      startAngle = null !== (_f = null == params ? void 0 : params.startAngle) && void 0 !== _f ? _f : 0,
      orient = null !== (_g = null == params ? void 0 : params.orient) && void 0 !== _g ? _g : "clockwise";
    let arcStartAngle = 0,
      arcEndAngle = 0;
    "anticlockwise" === orient ? (arcEndAngle = "in" === animationType ? startAngle + 2 * Math.PI : startAngle, arcEndAngle = startAngle + 2 * Math.PI) : (arcStartAngle = startAngle, arcEndAngle = "out" === animationType ? startAngle + 2 * Math.PI : startAngle);
    const arc = application.graphicService.creator.arc({
      x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
      y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
      outerRadius: null !== (_m = null == params ? void 0 : params.radius) && void 0 !== _m ? _m : (width + height) / 2,
      innerRadius: 0,
      startAngle: arcStartAngle,
      endAngle: arcEndAngle,
      fill: !0
    });
    let fromAttributes, toAttributes;
    "anticlockwise" === orient ? (fromAttributes = {
      startAngle: startAngle + 2 * Math.PI
    }, toAttributes = {
      startAngle: startAngle
    }) : (fromAttributes = {
      endAngle: startAngle
    }, toAttributes = {
      endAngle: startAngle + 2 * Math.PI
    }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
      group: null == params ? void 0 : params.group,
      clipGraphic: arc
    });
  }
}
class ClipRadiusAnimate extends ClipGraphicAnimate {
  constructor(from, to, duration, easing, params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {},
      width = null !== (_c = groupAttribute.width) && void 0 !== _c ? _c : 0,
      height = null !== (_d = groupAttribute.height) && void 0 !== _d ? _d : 0,
      animationType = null !== (_e = null == params ? void 0 : params.animationType) && void 0 !== _e ? _e : "in",
      startRadius = null !== (_f = null == params ? void 0 : params.startRadius) && void 0 !== _f ? _f : 0,
      endRadius = null !== (_g = null == params ? void 0 : params.endRadius) && void 0 !== _g ? _g : Math.sqrt((width / 2) ** 2 + (height / 2) ** 2),
      arc = application.graphicService.creator.arc({
        x: null !== (_j = null === (_h = null == params ? void 0 : params.center) || void 0 === _h ? void 0 : _h.x) && void 0 !== _j ? _j : width / 2,
        y: null !== (_l = null === (_k = null == params ? void 0 : params.center) || void 0 === _k ? void 0 : _k.y) && void 0 !== _l ? _l : height / 2,
        outerRadius: "out" === animationType ? endRadius : startRadius,
        innerRadius: 0,
        startAngle: 0,
        endAngle: 2 * Math.PI,
        fill: !0
      }),
      fromAttributes = {
        outerRadius: startRadius
      },
      toAttributes = {
        outerRadius: endRadius
      };
    super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
      group: null == params ? void 0 : params.group,
      clipGraphic: arc
    });
  }
}
class ClipDirectionAnimate extends ClipGraphicAnimate {
  constructor(from, to, duration, easing, params) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const groupAttribute = null !== (_b = null === (_a = null == params ? void 0 : params.group) || void 0 === _a ? void 0 : _a.attribute) && void 0 !== _b ? _b : {},
      width = null !== (_d = null !== (_c = null == params ? void 0 : params.width) && void 0 !== _c ? _c : groupAttribute.width) && void 0 !== _d ? _d : 0,
      height = null !== (_f = null !== (_e = null == params ? void 0 : params.height) && void 0 !== _e ? _e : groupAttribute.height) && void 0 !== _f ? _f : 0,
      animationType = null !== (_g = null == params ? void 0 : params.animationType) && void 0 !== _g ? _g : "in",
      direction = null !== (_h = null == params ? void 0 : params.direction) && void 0 !== _h ? _h : "x",
      orient = null !== (_j = null == params ? void 0 : params.orient) && void 0 !== _j ? _j : "positive",
      rect = application.graphicService.creator.rect({
        x: 0,
        y: 0,
        width: "in" === animationType && "x" === direction ? 0 : width,
        height: "in" === animationType && "y" === direction ? 0 : height,
        fill: !0
      });
    let fromAttributes = {},
      toAttributes = {};
    "y" === direction ? "negative" === orient ? (fromAttributes = {
      y: height,
      height: 0
    }, toAttributes = {
      y: 0,
      height: height
    }) : (fromAttributes = {
      height: 0
    }, toAttributes = {
      height: height
    }) : "negative" === orient ? (fromAttributes = {
      x: width,
      width: 0
    }, toAttributes = {
      x: 0,
      width: width
    }) : (fromAttributes = {
      width: 0
    }, toAttributes = {
      width: width
    }), super("in" === animationType ? fromAttributes : toAttributes, "in" === animationType ? toAttributes : fromAttributes, duration, easing, {
      group: null == params ? void 0 : params.group,
      clipGraphic: rect
    });
  }
}
class RotateBySphereAnimate extends ACustomAnimate {
  onStart() {
    const {
        center: center,
        r: r
      } = "function" == typeof this.params ? this.params() : this.params,
      startX = this.target.getComputedAttribute("x"),
      startY = this.target.getComputedAttribute("y"),
      startZ = this.target.getComputedAttribute("z"),
      phi = Math.acos((startY - center.y) / r);
    let theta = Math.acos((startX - center.x) / r / Math.sin(phi));
    startZ - center.z < 0 && (theta = pi2 - theta), this.theta = theta, this.phi = phi;
  }
  onBind() {}
  onEnd() {}
  onUpdate(end, ratio, out) {
    if (null == this.phi || null == this.theta) return;
    const {
        center: center,
        r: r,
        cb: cb
      } = "function" == typeof this.params ? this.params() : this.params,
      deltaAngle = 2 * Math.PI * ratio,
      theta = this.theta + deltaAngle,
      phi = this.phi,
      x = r * Math.sin(phi) * Math.cos(theta) + center.x,
      y = r * Math.cos(phi) + center.y,
      z = r * Math.sin(phi) * Math.sin(theta) + center.z;
    for (out.x = x, out.y = y, out.z = z, out.alpha = theta + pi / 2; out.alpha > pi2;) out.alpha -= pi2;
    out.alpha = pi2 - out.alpha, out.zIndex = -1e4 * out.z, cb && cb(out);
  }
}
class AttributeAnimate extends ACustomAnimate {
  constructor(to, duration, easing) {
    super({}, to, duration, easing);
  }
  getEndProps() {
    return this.to;
  }
  onBind() {
    Object.keys(this.to).forEach(k => {
      this.from[k] = this.target.getComputedAttribute(k);
    });
  }
  onEnd() {}
  onUpdate(end, ratio, out) {
    this.target.stepInterpolate(this.subAnimate, this.subAnimate.animate, out, this.step, ratio, end, this.to, this.from);
  }
}
class AnimateGroup extends ACustomAnimate {
  constructor(duration, customAnimates) {
    super(null, null, duration, "linear"), this.customAnimates = customAnimates;
  }
  initAnimates() {
    this.customAnimates.forEach(a => {
      a.step = this.step, a.subAnimate = this.subAnimate, a.target = this.target;
    });
  }
  getEndProps() {
    const props = {};
    return this.customAnimates.forEach(a => {
      Object.assign(props, a.getEndProps());
    }), props;
  }
  onBind() {
    this.initAnimates(), this.customAnimates.forEach(a => {
      a.onBind();
    });
  }
  onEnd() {
    this.customAnimates.forEach(a => {
      a.onEnd();
    });
  }
  onStart() {
    this.customAnimates.forEach(a => {
      a.onStart();
    });
  }
  onUpdate(end, ratio, out) {
    this.updating || (this.updating = !0, this.customAnimates.forEach(a => {
      const easing = a.easing,
        easingFunc = "string" == typeof easing ? Easing[easing] : easing;
      ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);
    }), this.updating = !1);
  }
}
class AnimateGroup1 extends ACustomAnimate {
  constructor(duration, customAnimates) {
    super(null, null, duration, "linear"), this.customAnimates = customAnimates;
  }
  initAnimates() {
    this.customAnimates.forEach(a => {
      a.step = this.step, a.subAnimate = this.subAnimate, a.target = this.target;
    });
  }
  getEndProps() {
    const props = {};
    return this.customAnimates.forEach(a => {
      Object.assign(props, a.getEndProps());
    }), props;
  }
  onBind() {
    this.initAnimates(), this.customAnimates.forEach(a => {
      a.onBind();
    });
  }
  onEnd() {
    this.customAnimates.forEach(a => {
      a.onEnd();
    });
  }
  onUpdate(end, ratio, out) {
    this.updating || (this.updating = !0, this.customAnimates.forEach(a => {
      const easing = a.easing,
        easingFunc = "string" == typeof easing ? Easing[easing] : easing;
      ratio = easingFunc(ratio), a.onUpdate(end, ratio, out);
    }), this.updating = !1);
  }
}

function cubicSubdivide(p0, p1, p2, p3, t, out) {
  const p01 = (p1 - p0) * t + p0,
    p12 = (p2 - p1) * t + p1,
    p23 = (p3 - p2) * t + p2,
    p012 = (p12 - p01) * t + p01,
    p123 = (p23 - p12) * t + p12,
    p0123 = (p123 - p012) * t + p012;
  out[0] = p0, out[1] = p01, out[2] = p012, out[3] = p0123, out[4] = p0123, out[5] = p123, out[6] = p23, out[7] = p3;
}
function alignSubpath(subpath1, subpath2) {
  const len1 = subpath1.length,
    len2 = subpath2.length;
  if (len1 === len2) return [subpath1, subpath2];
  const tmpSegX = [],
    tmpSegY = [],
    shorterPath = len1 < len2 ? subpath1 : subpath2,
    shorterLen = Math.min(len1, len2),
    diff = Math.abs(len2 - len1) / 6,
    shorterBezierCount = (shorterLen - 2) / 6,
    eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount),
    newSubpath = [shorterPath[0], shorterPath[1]];
  let remained = diff;
  for (let i = 2; i < shorterLen; i += 6) {
    let x0 = shorterPath[i - 2],
      y0 = shorterPath[i - 1],
      x1 = shorterPath[i],
      y1 = shorterPath[i + 1],
      x2 = shorterPath[i + 2],
      y2 = shorterPath[i + 3];
    const x3 = shorterPath[i + 4],
      y3 = shorterPath[i + 5];
    if (remained <= 0) {
      newSubpath.push(x1, y1, x2, y2, x3, y3);
      continue;
    }
    const actualSubDivCount = Math.min(remained, eachCurveSubDivCount) + 1;
    for (let k = 1; k <= actualSubDivCount; k++) {
      const p = k / actualSubDivCount;
      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX), cubicSubdivide(y0, y1, y2, y3, p, tmpSegY), x0 = tmpSegX[3], y0 = tmpSegY[3], newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0), x1 = tmpSegX[5], y1 = tmpSegY[5], x2 = tmpSegX[6], y2 = tmpSegY[6];
    }
    remained -= actualSubDivCount - 1;
  }
  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];
}
function createSubpath(lastSubpath, otherSubpath) {
  const prevSubPath = lastSubpath || otherSubpath,
    len = prevSubPath.length,
    lastX = prevSubPath[len - 2],
    lastY = prevSubPath[len - 1],
    newSubpath = [];
  for (let i = 0; i < otherSubpath.length; i += 2) newSubpath[i] = lastX, newSubpath[i + 1] = lastY;
  return newSubpath;
}
function reverseSubpath(array) {
  const newArr = [],
    len = array.length;
  for (let i = 0; i < len; i += 2) newArr[i] = array[len - i - 2], newArr[i + 1] = array[len - i - 1];
  return newArr;
}
function centroidOfSubpath(array) {
  let signedArea = 0,
    cx = 0,
    cy = 0;
  const len = array.length;
  for (let i = 0, j = len - 2; i < len; j = i, i += 2) {
    const x0 = array[j],
      y0 = array[j + 1],
      x1 = array[i],
      y1 = array[i + 1],
      a = x0 * y1 - x1 * y0;
    signedArea += a, cx += (x0 + x1) * a, cy += (y0 + y1) * a;
  }
  return 0 === signedArea ? [array[0] || 0, array[1] || 0, 0] : [cx / signedArea / 3, cy / signedArea / 3, signedArea];
}
function findBestRotationOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {
  const bezierCount = (fromSubBeziers.length - 2) / 6;
  let bestScore = 1 / 0,
    bestOffset = 0;
  const len = fromSubBeziers.length,
    len2 = len - 2;
  for (let offset = 0; offset < bezierCount; offset++) {
    const cursorOffset = 6 * offset;
    let score = 0;
    for (let k = 0; k < len; k += 2) {
      const idx = 0 === k ? cursorOffset : (cursorOffset + k - 2) % len2 + 2,
        x0 = fromSubBeziers[idx] - fromCp[0],
        y0 = fromSubBeziers[idx + 1] - fromCp[1],
        dx = toSubBeziers[k] - toCp[0] - x0,
        dy = toSubBeziers[k + 1] - toCp[1] - y0;
      score += dx * dx + dy * dy;
    }
    score < bestScore && (bestScore = score, bestOffset = offset);
  }
  return bestOffset;
}
function findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {
  const result = [];
  let fromNeedsReverse;
  for (let i = 0; i < fromArr.length; i++) {
    let fromSubpathBezier = fromArr[i];
    const toSubpathBezier = toArr[i],
      fromCp = centroidOfSubpath(fromSubpathBezier),
      toCp = centroidOfSubpath(toSubpathBezier);
    null == fromNeedsReverse && (fromNeedsReverse = fromCp[2] < 0 != toCp[2] < 0);
    const newFromSubpathBezier = [],
      newToSubpathBezier = [];
    let bestAngle = 0,
      bestScore = 1 / 0;
    const tmpArr = [],
      len = fromSubpathBezier.length;
    fromNeedsReverse && (fromSubpathBezier = reverseSubpath(fromSubpathBezier));
    const offset = 6 * findBestRotationOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp),
      len2 = len - 2;
    for (let k = 0; k < len2; k += 2) {
      const idx = (offset + k) % len2 + 2;
      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0], newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];
    }
    if (newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0], newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1], searchAngleIteration > 0) {
      const step = searchAngleRange / searchAngleIteration;
      for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
        const sa = Math.sin(angle),
          ca = Math.cos(angle);
        let score = 0;
        for (let k = 0; k < fromSubpathBezier.length; k += 2) {
          const x0 = newFromSubpathBezier[k],
            y0 = newFromSubpathBezier[k + 1],
            x1 = toSubpathBezier[k] - toCp[0],
            y1 = toSubpathBezier[k + 1] - toCp[1],
            newX1 = x1 * ca - y1 * sa,
            newY1 = x1 * sa + y1 * ca;
          tmpArr[k] = newX1, tmpArr[k + 1] = newY1;
          const dx = newX1 - x0,
            dy = newY1 - y0;
          score += dx * dx + dy * dy;
        }
        if (score < bestScore) {
          bestScore = score, bestAngle = angle;
          for (let m = 0; m < tmpArr.length; m++) newToSubpathBezier[m] = tmpArr[m];
        }
      }
    } else for (let i = 0; i < len; i += 2) newToSubpathBezier[i] = toSubpathBezier[i] - toCp[0], newToSubpathBezier[i + 1] = toSubpathBezier[i + 1] - toCp[1];
    result.push({
      from: newFromSubpathBezier,
      to: newToSubpathBezier,
      fromCp: fromCp,
      toCp: toCp,
      rotation: -bestAngle
    });
  }
  return result;
}
function alignBezierCurves(array1, array2) {
  let lastSubpath1, lastSubpath2;
  const newArray1 = [],
    newArray2 = [];
  for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
    const subpath1 = array1[i],
      subpath2 = array2[i];
    let newSubpath1, newSubpath2;
    subpath1 ? subpath2 ? ([newSubpath1, newSubpath2] = alignSubpath(subpath1, subpath2), lastSubpath1 = newSubpath1, lastSubpath2 = newSubpath2) : (newSubpath2 = createSubpath(lastSubpath2, subpath1), newSubpath1 = subpath1) : (newSubpath1 = createSubpath(lastSubpath1, subpath2), newSubpath2 = subpath2), newArray1.push(newSubpath1), newArray2.push(newSubpath2);
  }
  return [newArray1, newArray2];
}
const addLineToBezierPath = (bezierPath, x0, y0, x1, y1) => {
  isNumberClose(x0, x1) && isNumberClose(y0, y1) || bezierPath.push(x0, y0, x1, y1, x1, y1);
};
function pathToBezierCurves(path) {
  const commandList = path.commandList,
    bezierArrayGroups = [];
  let currentSubpath,
    xi = 0,
    yi = 0,
    x0 = 0,
    y0 = 0;
  const createNewSubpath = (x, y) => {
    currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), currentSubpath = [x, y];
  };
  let x1, y1, x2, y2;
  for (let i = 0, len = commandList.length; i < len; i++) {
    const cmd = commandList[i],
      isFirst = 0 === i;
    switch (isFirst && (x0 = xi = cmd[1], y0 = yi = cmd[2], [enumCommandMap.L, enumCommandMap.C, enumCommandMap.Q].includes(cmd[0]) && (currentSubpath = [x0, y0])), cmd[0]) {
      case enumCommandMap.M:
        xi = x0 = cmd[1], yi = y0 = cmd[2], createNewSubpath(x0, y0);
        break;
      case enumCommandMap.L:
        x1 = cmd[1], y1 = cmd[2], addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xi = x1, yi = y1;
        break;
      case enumCommandMap.C:
        currentSubpath.push(cmd[1], cmd[2], cmd[3], cmd[4], xi = cmd[5], yi = cmd[6]);
        break;
      case enumCommandMap.Q:
        x1 = cmd[1], y1 = cmd[2], x2 = cmd[3], y2 = cmd[4], currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2), xi = x2, yi = y2;
        break;
      case enumCommandMap.A:
        {
          const cx = cmd[1],
            cy = cmd[2],
            rx = cmd[3],
            ry = rx,
            startAngle = cmd[4],
            endAngle = cmd[5],
            counterClockwise = !!cmd[6];
          x1 = Math.cos(startAngle) * rx + cx, y1 = Math.sin(startAngle) * rx + cy, isFirst ? (x0 = x1, y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xi = Math.cos(endAngle) * rx + cx, yi = Math.sin(endAngle) * rx + cy;
          const step = (counterClockwise ? -1 : 1) * Math.PI / 2;
          for (let angle = startAngle; counterClockwise ? angle > endAngle : angle < endAngle; angle += step) {
            const nextAngle = counterClockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
            addArcToBezierPath$1(currentSubpath, angle, nextAngle, cx, cy, rx, ry);
          }
          break;
        }
      case enumCommandMap.E:
        {
          const cx = cmd[1],
            cy = cmd[2],
            rx = cmd[3],
            ry = cmd[4],
            rotate = cmd[5],
            startAngle = cmd[6],
            endAngle = cmd[7] + startAngle,
            anticlockwise = !!cmd[8],
            hasRotate = !isNumberClose(rotate, 0),
            rc = Math.cos(rotate),
            rs = Math.sin(rotate);
          let xTemp = Math.cos(startAngle) * rx,
            yTemp = Math.sin(startAngle) * ry;
          hasRotate ? (x1 = xTemp * rc - yTemp * rs + cx, y1 = xTemp * rs + yTemp * rc + cy) : (x1 = xTemp + cx, y1 = yTemp + cy), isFirst ? (x0 = x1, y0 = y1, createNewSubpath(x0, y0)) : addLineToBezierPath(currentSubpath, xi, yi, x1, y1), xTemp = Math.cos(endAngle) * rx, yTemp = Math.sin(endAngle) * ry, hasRotate ? (xi = xTemp * rc - yTemp * rs + cx, yi = xTemp * rs + yTemp * rc + cy) : (xi = xTemp + cx, yi = yTemp + cy);
          const step = (anticlockwise ? -1 : 1) * Math.PI / 2;
          for (let angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
            const nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);
            if (addArcToBezierPath$1(currentSubpath, angle, nextAngle, cx, cy, rx, ry), hasRotate) {
              const curLen = currentSubpath.length;
              for (let j = curLen - 6; j <= curLen - 1; j += 2) xTemp = currentSubpath[j], yTemp = currentSubpath[j + 1], currentSubpath[j] = (xTemp - cx) * rc - (yTemp - cy) * rs + cx, currentSubpath[j + 1] = (xTemp - cx) * rs + (yTemp - cy) * rc + cy;
            }
          }
          break;
        }
      case enumCommandMap.R:
        x0 = xi = cmd[1], y0 = yi = cmd[2], x1 = x0 + cmd[3], y1 = y0 + cmd[4], createNewSubpath(x1, y0), addLineToBezierPath(currentSubpath, x1, y0, x1, y1), addLineToBezierPath(currentSubpath, x1, y1, x0, y1), addLineToBezierPath(currentSubpath, x0, y1, x0, y0), addLineToBezierPath(currentSubpath, x0, y0, x1, y0);
        break;
      case enumCommandMap.AT:
        {
          const tx1 = cmd[1],
            ty1 = cmd[2],
            tx2 = cmd[3],
            ty2 = cmd[4],
            r = cmd[5],
            dis1 = PointService.distancePP({
              x: xi,
              y: yi
            }, {
              x: tx1,
              y: ty1
            }),
            dis2 = PointService.distancePP({
              x: tx2,
              y: ty2
            }, {
              x: tx1,
              y: ty1
            }),
            theta = ((xi - tx1) * (tx2 - tx1) + (yi - ty1) * (ty2 - ty1)) / (dis1 * dis2),
            dis = r / Math.sin(theta / 2),
            midX = (xi + tx2 - 2 * tx1) / 2,
            midY = (yi + ty2 - 2 * ty1) / 2,
            midLen = PointService.distancePP({
              x: midX,
              y: midY
            }, {
              x: 0,
              y: 0
            }),
            cx = tx1 + dis * midX / midLen,
            cy = tx2 + dis * midY / midLen,
            disP = Math.sqrt(dis * dis - r * r);
          x0 = tx1 + disP * (xi - tx1) / dis1, y0 = ty1 + disP * (yi - ty1) / dis1, addLineToBezierPath(currentSubpath, xi, yi, x0, y0), xi = tx1 + disP * (tx2 - tx1) / dis2, yi = ty1 + disP * (ty2 - ty1) / dis2;
          const startAngle = getAngleByPoint({
              x: cx,
              y: cy
            }, {
              x: x0,
              y: y0
            }),
            endAngle = getAngleByPoint({
              x: cx,
              y: cy
            }, {
              x: xi,
              y: yi
            });
          addArcToBezierPath$1(currentSubpath, startAngle, endAngle, cx, cy, r, r);
          break;
        }
      case enumCommandMap.Z:
        currentSubpath && addLineToBezierPath(currentSubpath, xi, yi, x0, y0), xi = x0, yi = y0;
    }
  }
  return currentSubpath && currentSubpath.length > 2 && bezierArrayGroups.push(currentSubpath), bezierArrayGroups;
}
function applyTransformOnBezierCurves(bezierCurves, martrix) {
  for (let i = 0; i < bezierCurves.length; i++) {
    const subPath = bezierCurves[i];
    for (let k = 0; k < subPath.length; k += 2) {
      const x = subPath[k],
        y = subPath[k + 1],
        res = {
          x: x,
          y: y
        };
      martrix.transformPoint({
        x: x,
        y: y
      }, res), subPath[k] = res.x, subPath[k + 1] = res.y;
    }
  }
}
function bezierCurversToPath(bezierCurves) {
  const path = new CustomPath2D();
  for (let i = 0; i < bezierCurves.length; i++) {
    const subPath = bezierCurves[i];
    if (subPath.length > 2) {
      path.moveTo(subPath[0], subPath[1]);
      for (let k = 2; k < subPath.length; k += 6) path.bezierCurveTo(subPath[k], subPath[k + 1], subPath[k + 2], subPath[k + 3], subPath[k + 4], subPath[k + 5]);
    }
  }
  return path;
}

const normalizeRectAttributes = attribute => {
  if (!attribute) return {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  let width = isNil$1(attribute.width) ? attribute.x1 - attribute.x : attribute.width,
    height = isNil$1(attribute.height) ? attribute.y1 - attribute.y : attribute.height,
    x = 0,
    y = 0;
  return width < 0 ? (x = width, width = -width) : Number.isNaN(width) && (width = 0), height < 0 ? (y = height, height = -height) : Number.isNaN(height) && (height = 0), {
    x: x,
    y: y,
    width: width,
    height: height
  };
};

function splitToGrids(width, height, count) {
  const ratio = width / height;
  let rowCount, columnCount;
  width >= height ? (columnCount = Math.ceil(Math.sqrt(count * ratio)), rowCount = Math.floor(count / columnCount), 0 === rowCount && (rowCount = 1, columnCount = count)) : (rowCount = Math.ceil(Math.sqrt(count / ratio)), columnCount = Math.floor(count / rowCount), 0 === columnCount && (columnCount = 1, rowCount = count));
  const grids = [];
  for (let i = 0; i < rowCount; i++) grids.push(columnCount);
  const remained = count - rowCount * columnCount;
  if (remained > 0) for (let i = 0; i < remained; i += columnCount) i + columnCount < remained ? grids.push(columnCount) : grids.push(remained - i);
  return grids;
}
const splitRect = (rect, count) => {
  const {
      width: width,
      height: height
    } = normalizeRectAttributes(rect.attribute),
    grids = splitToGrids(width, height, count),
    res = [],
    gridHeight = height / grids.length;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
    const columnCount = grids[i],
      gridWidth = width / columnCount;
    for (let j = 0; j < columnCount; j++) res.push({
      x: 0 + j * gridWidth,
      y: 0 + i * gridHeight,
      width: gridWidth,
      height: gridHeight
    });
  }
  return res;
};
const splitArc = (arc, count) => {
  const angles = arc.getParsedAngle(),
    startAngle = angles.startAngle,
    endAngle = angles.endAngle,
    innerRadius = arc.getComputedAttribute("innerRadius"),
    outerRadius = arc.getComputedAttribute("outerRadius"),
    angleDelta = Math.abs(startAngle - endAngle),
    radiusDelta = Math.abs(outerRadius - innerRadius),
    grids = splitToGrids(angleDelta * (innerRadius + outerRadius) / 2, radiusDelta, count),
    res = [],
    gridRadius = radiusDelta / grids.length,
    radiusSign = outerRadius >= innerRadius ? 1 : -1,
    angleSign = endAngle >= startAngle ? 1 : -1;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++) {
    const columnCount = grids[i],
      gridAngle = angleDelta / columnCount;
    for (let j = 0; j < columnCount; j++) res.push({
      innerRadius: outerRadius - gridRadius * i * radiusSign,
      outerRadius: outerRadius - gridRadius * (i + 1) * radiusSign,
      startAngle: startAngle + gridAngle * j * angleSign,
      endAngle: startAngle + gridAngle * (j + 1) * angleSign
    });
  }
  return res;
};
const splitCircle = (arc, count) => {
  const startAngle = arc.getComputedAttribute("startAngle"),
    endAngle = arc.getComputedAttribute("endAngle"),
    radius = arc.getComputedAttribute("radius"),
    angleDelta = Math.abs(startAngle - endAngle),
    grids = splitToGrids(angleDelta * radius, radius, count),
    res = [],
    gridAngle = angleDelta / grids[0],
    gridRadius = radius / grids.length,
    angleSign = endAngle >= startAngle ? 1 : -1;
  for (let i = 0, rowCount = grids.length; i < rowCount; i++) for (let j = 0, columnCount = grids[i]; j < columnCount; j++) res.push({
    innerRadius: gridRadius * i,
    outerRadius: gridRadius * (i + 1),
    startAngle: startAngle + gridAngle * j * angleSign,
    endAngle: startAngle + gridAngle * (j + 1) * angleSign
  });
  return res;
};
const samplingPoints = (points, count) => {
  const validatePoints = points.filter(point => !1 !== point.defined && isNumber$1(point.x) && isNumber$1(point.y));
  if (0 === validatePoints.length) return [];
  if (1 === validatePoints.length) return new Array(count).fill(0).map(i => validatePoints[0]);
  const res = [];
  if (count <= validatePoints.length) {
    const step = validatePoints.length / count;
    let i = 0,
      cur = 0;
    for (; i < count;) res.push(validatePoints[Math.floor(cur)]), cur += step, i++;
    return res;
  }
  const insertCount = count - validatePoints.length,
    insetRatio = 1 / (insertCount / (validatePoints.length - 1) + 1);
  let curCount = 0;
  for (let i = 0, len = points.length; i < len; i++) if (res.push(points[i]), i < len - 1) {
    let cur = insetRatio;
    const xCur = points[i].x,
      yCur = points[i].y,
      xNext = points[i + 1].x,
      yNext = points[i + 1].y;
    for (; cur < 1 && curCount < insertCount;) res.push({
      x: xCur + (xNext - xCur) * cur,
      y: yCur + (yNext - yCur) * cur
    }), cur += insetRatio, curCount += 1;
  }
  return res;
};
const splitArea = (area, count) => {
  var _a, _b;
  const attribute = area.attribute;
  let points = attribute.points;
  const segements = attribute.segments;
  points || (points = segements.reduce((res, seg) => {
    var _a;
    return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
  }, []));
  const validatePoints = points.filter(point => !1 !== point.defined && isNumber$1(point.x) && isNumber$1(point.y));
  if (!validatePoints.length) return [];
  const allPoints = [];
  validatePoints.forEach(point => {
    allPoints.push({
      x: point.x,
      y: point.y
    });
  });
  for (let i = validatePoints.length - 1; i >= 0; i--) {
    const point = validatePoints[i];
    allPoints.push({
      x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
      y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
    });
  }
  const res = [];
  return recursiveCallBinarySplit(points, count, res), res;
};
const splitLine = (line, count) => {
  const attribute = line.attribute,
    points = attribute.points;
  if (points) return samplingPoints(points, count);
  if (attribute.segments) {
    const allPoints = attribute.segments.reduce((res, seg) => {
      var _a;
      return res.concat(null !== (_a = seg.points) && void 0 !== _a ? _a : []);
    }, []);
    return samplingPoints(allPoints, count);
  }
  return [];
};
function crossProduct(dir1, dir2) {
  return dir1[0] * dir2[1] - dir1[1] * dir2[0];
}
const clonePoints = points => points.map(p => ({
    x: p.x,
    y: p.y
  })),
  splitPolygonByLine = (points, p0, p1) => {
    const len = points.length,
      intersections = [];
    for (let i = 0; i < len; i++) {
      const cur = points[i],
        next = i === len - 1 ? points[0] : points[i + 1],
        res = getIntersectPoint([p0.x, p0.y], [p1.x, p1.y], [cur.x, cur.y], [next.x, next.y]);
      res && "boolean" != typeof res && intersections.push({
        dot: crossProduct([res[0] - p0.x, res[1] - p0.x], [p1.x - p0.x, p1.y - p0.x]),
        point: {
          x: res[0],
          y: res[1]
        },
        edgeIndex: i
      });
    }
    if (intersections.length < 2) return [clonePoints(points), clonePoints(points)];
    intersections.sort((a, b) => a.dot - b.dot);
    let is0 = intersections[0],
      is1 = intersections[intersections.length - 1];
    is0.edgeIndex > is1.edgeIndex && ([is0, is1] = [is1, is0]);
    const newP0 = is0.point,
      newP1 = is1.point,
      newPointsA = [{
        x: newP0.x,
        y: newP0.y
      }];
    for (let i = is0.edgeIndex + 1; i <= is1.edgeIndex; i++) newPointsA.push({
      x: points[i].x,
      y: points[i].y
    });
    newPointsA.push({
      x: newP1.x,
      y: newP1.y
    });
    const newPointsB = [{
      x: newP1.x,
      y: newP1.y
    }];
    for (let i = is1.edgeIndex + 1, maxIndex = is0.edgeIndex + len; i <= maxIndex; i++) {
      const p = points[i % len];
      newPointsB.push({
        x: p.x,
        y: p.y
      });
    }
    return newPointsB.push({
      x: newP0.x,
      y: newP0.y
    }), [newPointsA, newPointsB];
  };
const binarySplitPolygon = points => {
  const box = new Bounds();
  points.forEach(point => {
    box.add(point.x, point.y);
  });
  const width = box.width(),
    height = box.height();
  if (width >= height) {
    const midX = box.x1 + width / 2;
    return splitPolygonByLine(points, {
      x: midX,
      y: box.y1
    }, {
      x: midX,
      y: box.y2
    });
  }
  const midY = box.y1 + height / 2;
  return splitPolygonByLine(points, {
    x: box.x1,
    y: midY
  }, {
    x: box.x2,
    y: midY
  });
};
const recursiveCallBinarySplit = (points, count, out) => {
  if (1 === count) out.push({
    points: points
  });else {
    const half = Math.floor(count / 2),
      res = binarySplitPolygon(points);
    recursiveCallBinarySplit(res[0], half, out), recursiveCallBinarySplit(res[1], count - half, out);
  }
};
const splitPolygon = (polygon, count) => {
  const points = polygon.attribute.points;
  if (!points || !points.length) return [];
  if (1 === count) return [{
    points: clonePoints(points)
  }];
  const res = [];
  return recursiveCallBinarySplit(points, count, res), res;
};
const splitPath = (path, count) => {
  const pathShape = path.getParsedPathShape(),
    bezierCurves = pathToBezierCurves(pathShape);
  if (!bezierCurves.length || count < 0) return [];
  const subPathCnt = bezierCurves.length;
  if (bezierCurves.length >= count) {
    const res = [],
      stepCount = Math.floor(bezierCurves.length / count);
    for (let i = 0; i < count; i++) {
      const curves = bezierCurves.slice(i * stepCount, i === count - 1 ? subPathCnt : (i + 1) * stepCount);
      res.push({
        path: bezierCurversToPath(curves)
      });
    }
    return res;
  }
  const res = [],
    stepCount = Math.floor(count / subPathCnt);
  let remain = count;
  for (let c = 0; c < subPathCnt; c++) {
    const points = [];
    for (let i = 2, len = bezierCurves[c].length; i < len; i += 2) points.push({
      x: bezierCurves[0][i],
      y: bezierCurves[0][i + 1]
    });
    recursiveCallBinarySplit(points, c === subPathCnt - 1 ? remain : stepCount, res), remain -= stepCount;
  }
  return res;
};

function colorEqual(color1, color2) {
  const c1 = Color.parseColorString(color1),
    c2 = Color.parseColorString(color2);
  return !(!c1 || !c2) && c1.r === c2.r && c1.g === c2.g && c1.b === c2.b && c1.opacity === c2.opacity;
}
var ColorType;
!function (ColorType) {
  ColorType[ColorType.Color255 = 0] = "Color255", ColorType[ColorType.Color1 = 1] = "Color1";
}(ColorType || (ColorType = {}));
class ColorStore {
  static Get(str) {
    let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorType.Color1;
    let arr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0, 0, 1];
    if (size === ColorType.Color1) {
      const color = ColorStore.store1[str];
      if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
      const c = Color.parseColorString(str);
      if (c) {
        const data = [c.r / 255, c.g / 255, c.b / 255, c.opacity];
        ColorStore.store1[str] = data, ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = data[0], arr[1] = data[1], arr[2] = data[2], arr[3] = data[3];
      }
      return arr;
    }
    const color = ColorStore.store255[str];
    if (color) return arr[0] = color[0], arr[1] = color[1], arr[2] = color[2], arr[3] = color[3], arr;
    const c = Color.parseColorString(str);
    return c && (ColorStore.store1[str] = [c.r / 255, c.g / 255, c.b / 255, c.opacity], ColorStore.store255[str] = [c.r, c.g, c.b, c.opacity], arr[0] = c.r, arr[1] = c.g, arr[2] = c.b, arr[3] = c.opacity), arr;
  }
  static Set(str, size, arr) {
    if (size === ColorType.Color1) {
      if (ColorStore.store1[str]) return;
      ColorStore.store1[str] = arr, ColorStore.store255[str] = [Math.floor(255 * arr[0]), Math.floor(255 * arr[1]), Math.floor(255 * arr[2]), Math.floor(255 * arr[3])];
    } else {
      if (ColorStore.store255[str]) return;
      ColorStore.store255[str] = arr, ColorStore.store1[str] = [arr[0] / 255, arr[1] / 255, arr[2] / 255, arr[3]];
    }
  }
}
ColorStore.store255 = {}, ColorStore.store1 = {};

function colorArrayToString(color) {
  let alphaChannel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  return Array.isArray(color) && isNumber$1(color[0]) ? alphaChannel ? `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])},${color[3].toFixed(2)})` : `rgb(${Math.round(color[0])},${Math.round(color[1])},${Math.round(color[2])})` : color;
}
function interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (Array.isArray(from) && !isNumber$1(from[0]) || Array.isArray(to) && !isNumber$1(to[0])) {
    return new Array(4).fill(0).map((_, index) => _interpolateColor(isArray$1(from) ? from[index] : from, isArray$1(to) ? to[index] : to, ratio, alphaChannel));
  }
  return _interpolateColor(from, to, ratio, alphaChannel, cb);
}
function _interpolateColor(from, to, ratio, alphaChannel, cb) {
  if (!from || !to) return from && colorArrayToString(from) || to && colorArrayToString(to) || !1;
  let fromArray,
    toArray,
    fromGradient = !1,
    toGradient = !1;
  if (Array.isArray(from) ? fromArray = from : "string" == typeof from ? fromArray = ColorStore.Get(from, ColorType.Color255) : fromGradient = !0, Array.isArray(to) ? toArray = to : "string" == typeof to ? toArray = ColorStore.Get(to, ColorType.Color255) : toGradient = !0, fromGradient !== toGradient) {
    const gradient = fromGradient ? from : to,
      pure = fromGradient ? to : from,
      gradientFromPure = Object.assign(Object.assign({}, gradient), {
        stops: gradient.stops.map(v => Object.assign(Object.assign({}, v), {
          color: colorArrayToString(pure)
        }))
      });
    return fromGradient ? interpolateColor(gradient, gradientFromPure, ratio, alphaChannel, cb) : interpolateColor(gradientFromPure, gradient, ratio, alphaChannel, cb);
  }
  if (fromGradient) {
    if (from.gradient === to.gradient) {
      const fc = from,
        tc = to,
        fromStops = fc.stops,
        toStops = tc.stops;
      if (fromStops.length !== toStops.length) return !1;
      if ("linear" === fc.gradient) return interpolateGradientLinearColor(fc, tc, ratio);
      if ("radial" === fc.gradient) return interpolateGradientRadialColor(fc, tc, ratio);
      if ("conical" === fc.gradient) return interpolateGradientConicalColor(fc, tc, ratio);
    }
    return !1;
  }
  cb && cb(fromArray, toArray);
  return colorArrayToString(interpolatePureColorArray(fromArray, toArray, ratio), alphaChannel);
}
function interpolateGradientLinearColor(fc, tc, ratio) {
  const fStops = fc.stops,
    tStops = tc.stops;
  return {
    gradient: "linear",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientRadialColor(fc, tc, ratio) {
  const fStops = fc.stops,
    tStops = tc.stops;
  return {
    gradient: "radial",
    x0: fc.x0 + (tc.x0 - fc.x0) * ratio,
    x1: fc.x1 + (tc.x1 - fc.x1) * ratio,
    y0: fc.y0 + (tc.y0 - fc.y0) * ratio,
    y1: fc.y1 + (tc.y1 - fc.y1) * ratio,
    r0: fc.r0 + (tc.r0 - fc.r0) * ratio,
    r1: fc.r1 + (tc.r1 - fc.r1) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolateGradientConicalColor(fc, tc, ratio) {
  const fStops = fc.stops,
    tStops = tc.stops;
  return {
    gradient: "conical",
    startAngle: fc.startAngle + (tc.startAngle - fc.startAngle) * ratio,
    endAngle: fc.endAngle + (tc.endAngle - fc.endAngle) * ratio,
    x: fc.x + (tc.x - fc.x) * ratio,
    y: fc.y + (tc.y - fc.y) * ratio,
    stops: new Array(fStops.length).fill(0).map((_, i) => ({
      color: colorStringInterpolationToStr(fStops[i].color, tStops[i].color, ratio),
      offset: fStops[i].offset + (tStops[i].offset - fStops[i].offset) * ratio
    }))
  };
}
function interpolatePureColorArray(from, to, ratio) {
  return [from[0] + (to[0] - from[0]) * ratio, from[1] + (to[1] - from[1]) * ratio, from[2] + (to[2] - from[2]) * ratio, from[3] + (to[3] - from[3]) * ratio];
}
const _fromColorRGB = [0, 0, 0, 0],
  _toColorRGB = [0, 0, 0, 0];
function colorStringInterpolationToStr(fromColor, toColor, ratio) {
  return ColorStore.Get(fromColor, ColorType.Color255, _fromColorRGB), ColorStore.Get(toColor, ColorType.Color255, _toColorRGB), `rgba(${Math.round(_fromColorRGB[0] + (_toColorRGB[0] - _fromColorRGB[0]) * ratio)},${Math.round(_fromColorRGB[1] + (_toColorRGB[1] - _fromColorRGB[1]) * ratio)},${Math.round(_fromColorRGB[2] + (_toColorRGB[2] - _fromColorRGB[2]) * ratio)},${_fromColorRGB[3] + (_toColorRGB[3] - _fromColorRGB[3]) * ratio})`;
}

const interpolateOtherAttrs = (attrs, out, ratio) => {
    attrs.forEach(entry => {
      if (Number.isFinite(entry.to)) out[entry.key] = entry.from + (entry.to - entry.from) * ratio;else if ("fill" === entry.key || "stroke" === entry.key) {
        const color = interpolateColor(entry.from, entry.to, ratio, !1);
        color && (out[entry.key] = color);
      }
    });
  },
  interpolateMorphingData = (morphingData, path, ratio) => {
    const tmpArr = [],
      newCp = [];
    path.clear();
    for (let i = 0; i < morphingData.length; i++) {
      const item = morphingData[i],
        from = item.from,
        to = item.to,
        angle = item.rotation * ratio,
        fromCp = item.fromCp,
        toCp = item.toCp,
        sa = Math.sin(angle),
        ca = Math.cos(angle);
      newCp[0] = fromCp[0] + (toCp[0] - fromCp[0]) * ratio, newCp[1] = fromCp[1] + (toCp[1] - fromCp[1]) * ratio;
      for (let m = 0; m < from.length; m += 2) {
        const x0 = from[m],
          y0 = from[m + 1],
          x = x0 * (1 - ratio) + to[m] * ratio,
          y = y0 * (1 - ratio) + to[m + 1] * ratio;
        tmpArr[m] = x * ca - y * sa + newCp[0], tmpArr[m + 1] = x * sa + y * ca + newCp[1];
      }
      let x0 = tmpArr[0],
        y0 = tmpArr[1];
      path.moveTo(x0, y0);
      for (let m = 2; m < from.length; m += 6) {
        const x1 = tmpArr[m],
          y1 = tmpArr[m + 1],
          x2 = tmpArr[m + 2],
          y2 = tmpArr[m + 3],
          x3 = tmpArr[m + 4],
          y3 = tmpArr[m + 5];
        x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3 ? path.lineTo(x3, y3) : path.bezierCurveTo(x1, y1, x2, y2, x3, y3), x0 = x3, y0 = y3;
      }
    }
  },
  parseMorphingData = (fromPath, toPath, config) => {
    const fromBezier = fromPath ? pathToBezierCurves(fromPath) : [],
      toBezier = pathToBezierCurves(toPath);
    config && fromBezier && (config.fromTransform && applyTransformOnBezierCurves(fromBezier, config.fromTransform.clone().getInverse()), applyTransformOnBezierCurves(fromBezier, config.toTransfrom));
    const [fromBezierCurves, toBezierCurves] = alignBezierCurves(fromBezier, toBezier);
    return fromPath ? findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI) : toBezierCurves.map((to, index) => ({
      from: fromBezierCurves[index],
      to: to,
      fromCp: [0, 0],
      toCp: [0, 0],
      rotation: 0
    }));
  },
  validateOtherAttrs = ["fill", "fillOpacity", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "stroke", "strokeOpacity", "lineDashOffset"],
  parseOtherAnimateAttrs = (fromAttrs, toAttrs) => {
    if (!fromAttrs || !toAttrs) return null;
    const res = [];
    let hasAttr = !1;
    return Object.keys(fromAttrs).forEach(fromKey => {
      if (!validateOtherAttrs.includes(fromKey)) return;
      const toValue = toAttrs[fromKey];
      isNil$1(toValue) || isNil$1(fromAttrs[fromKey]) || toValue === fromAttrs[fromKey] || ("fill" === fromKey || "stroke" === fromKey ? res.push({
        from: "string" == typeof fromAttrs[fromKey] ? ColorStore.Get(fromAttrs[fromKey], ColorType.Color255) : fromAttrs[fromKey],
        to: "string" == typeof toValue ? ColorStore.Get(toValue, ColorType.Color255) : toValue,
        key: fromKey
      }) : res.push({
        from: fromAttrs[fromKey],
        to: toValue,
        key: fromKey
      }), hasAttr = !0);
    }), hasAttr ? res : null;
  };
class MorphingPath extends ACustomAnimate {
  constructor(config, duration, easing) {
    super(0, 1, duration, easing), this.morphingData = config.morphingData, this.otherAttrs = config.otherAttrs, this.saveOnEnd = config.saveOnEnd;
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.createPathProxy(), this.onUpdate(!1, 0, this.target.attribute);
  }
  onEnd() {}
  onUpdate(end, ratio, out) {
    const target = this.target,
      pathProxy = "function" == typeof target.pathProxy ? target.pathProxy(target.attribute) : target.pathProxy;
    interpolateMorphingData(this.morphingData, pathProxy, ratio), this.otherAttrs && this.otherAttrs.length && interpolateOtherAttrs(this.otherAttrs, out, ratio), end && !this.saveOnEnd && (this.target.pathProxy = null);
  }
}
const morphPath = (fromGraphic, toGraphic, animationConfig, fromGraphicTransform) => {
  var _a, _b, _c;
  if (fromGraphic && (!fromGraphic.valid || !fromGraphic.toCustomPath)) return __DEV__ && console.error(fromGraphic, " is not validate"), null;
  if (!toGraphic.valid || !toGraphic.toCustomPath) return __DEV__ && console.error(toGraphic, " is not validate"), null;
  let fromTransform = null == fromGraphic ? void 0 : fromGraphic.globalTransMatrix;
  fromGraphicTransform && fromTransform && (fromTransform = fromGraphicTransform.clone().multiply(fromTransform.a, fromTransform.b, fromTransform.c, fromTransform.d, fromTransform.e, fromTransform.f));
  const morphingData = parseMorphingData(null === (_a = null == fromGraphic ? void 0 : fromGraphic.toCustomPath) || void 0 === _a ? void 0 : _a.call(fromGraphic), toGraphic.toCustomPath(), {
      fromTransform: fromTransform,
      toTransfrom: toGraphic.globalTransMatrix
    }),
    attrs = parseOtherAnimateAttrs(null == fromGraphic ? void 0 : fromGraphic.attribute, toGraphic.attribute),
    animate = toGraphic.animate(animationConfig);
  return (null == animationConfig ? void 0 : animationConfig.delay) && animate.wait(animationConfig.delay), animate.play(new MorphingPath({
    morphingData: morphingData,
    otherAttrs: attrs
  }, null !== (_b = null == animationConfig ? void 0 : animationConfig.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig ? void 0 : animationConfig.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing)), animate;
};
const oneToMultiMorph = (fromGraphic, toGraphics, animationConfig) => {
  var _a;
  const validateToGraphics = toGraphics.filter(graphic => graphic && graphic.toCustomPath && graphic.valid);
  validateToGraphics.length || __DEV__ && console.error(validateToGraphics, " is not validate"), fromGraphic.valid && fromGraphic.toCustomPath || __DEV__ && console.error(fromGraphic, " is not validate");
  const childGraphics = ("clone" === (null == animationConfig ? void 0 : animationConfig.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig ? void 0 : animationConfig.splitPath) && void 0 !== _a ? _a : splitGraphic)(fromGraphic, validateToGraphics.length, !1),
    oldOnEnd = null == animationConfig ? void 0 : animationConfig.onEnd;
  let count = validateToGraphics.length;
  const onEachEnd = () => {
    count--, 0 === count && oldOnEnd && oldOnEnd();
  };
  validateToGraphics.forEach((toChild, index) => {
    var _a;
    const fromChild = childGraphics[index],
      delay = (null !== (_a = null == animationConfig ? void 0 : animationConfig.delay) && void 0 !== _a ? _a : 0) + ((null == animationConfig ? void 0 : animationConfig.individualDelay) ? animationConfig.individualDelay(index, validateToGraphics.length, fromChild, toChild) : 0);
    morphPath(fromChild, toChild, Object.assign({}, animationConfig, {
      onEnd: onEachEnd,
      delay: delay
    }), fromGraphic.globalTransMatrix);
  });
};
class MultiToOneMorphingPath extends ACustomAnimate {
  constructor(config, duration, easing) {
    super(0, 1, duration, easing), this.morphingData = config.morphingData, this.otherAttrs = config.otherAttrs;
  }
  getEndProps() {
    return {};
  }
  onBind() {
    this.addPathProxy();
  }
  addPathProxy() {
    this.target.shadowRoot.forEachChildren(child => {
      child.createPathProxy();
    }), this.onUpdate(!1, 0, this.target.attribute);
  }
  clearPathProxy() {
    this.target.shadowRoot.forEachChildren(child => {
      child.pathProxy = null;
    });
  }
  onEnd() {}
  onUpdate(end, ratio, out) {
    this.target.shadowRoot.forEachChildren((child, index) => {
      var _a;
      interpolateMorphingData(this.morphingData[index], "function" == typeof child.pathProxy ? child.pathProxy(child.attribute) : child.pathProxy, ratio), (null === (_a = this.otherAttrs) || void 0 === _a ? void 0 : _a[index]) && this.otherAttrs[index].length && interpolateOtherAttrs(this.otherAttrs[index], child.attribute, ratio);
    }), end && (this.clearPathProxy(), this.morphingData = null);
  }
}
const parseShadowChildAttrs = graphicAttrs => {
    const attrs = {};
    return Object.keys(graphicAttrs).forEach(key => {
      isTransformKey(key) || (attrs[key] = graphicAttrs[key]);
    }), attrs;
  },
  appendShadowChildrenToGraphic = (graphic, children, count) => {
    const childAttrs = parseShadowChildAttrs(graphic.attribute),
      shadowRoot = graphic.attachShadow();
    if (children.length) shadowRoot.setTheme({
      [children[0].type]: childAttrs
    }), children.forEach(element => {
      element.setAttributes({
        pickable: !1
      }), shadowRoot.appendChild(element);
    });else {
      const box = graphic.AABBBounds,
        width = box.width(),
        height = box.height();
      shadowRoot.setTheme({
        rect: childAttrs
      }), new Array(count).fill(0).forEach(el => {
        const child = application.graphicService.creator.rect({
          x: 0,
          y: 0,
          width: width,
          height: height,
          pickable: !1
        });
        shadowRoot.appendChild(child), children.push(child);
      });
    }
  };
const cloneGraphic = (graphic, count, needAppend) => {
  const children = [],
    childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute),
    path = graphic.toCustomPath();
  for (let i = 0; i < count; i++) {
    const element = {
      path: new CustomPath2D().fromCustomPath2D(path)
    };
    children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element)));
  }
  return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};
const splitGraphic = (graphic, count, needAppend) => {
  const children = [],
    childAttrs = needAppend ? null : parseShadowChildAttrs(graphic.attribute);
  if ("rect" === graphic.type) {
    splitRect(graphic, count).forEach(element => {
      children.push(application.graphicService.creator.rect(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("arc" === graphic.type) {
    splitArc(graphic, count).forEach(element => {
      children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("circle" === graphic.type) {
    splitCircle(graphic, count).forEach(element => {
      children.push(application.graphicService.creator.arc(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("line" === graphic.type) {
    const childrenAttrs = splitLine(graphic, count),
      defaultSymbol = {
        size: 10,
        symbolType: "circle"
      };
    childrenAttrs.forEach(element => {
      children.push(application.graphicService.creator.symbol(needAppend ? Object.assign({}, element, defaultSymbol) : Object.assign({}, childAttrs, element, defaultSymbol)));
    });
  } else if ("polygon" === graphic.type) {
    splitPolygon(graphic, count).forEach(element => {
      children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("area" === graphic.type) {
    splitArea(graphic, count).forEach(element => {
      children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  } else if ("path" === graphic.type) {
    splitPath(graphic, count).forEach(element => {
      "path" in element ? children.push(application.graphicService.creator.path(needAppend ? element : Object.assign({}, childAttrs, element))) : children.push(application.graphicService.creator.polygon(needAppend ? element : Object.assign({}, childAttrs, element)));
    });
  }
  return needAppend && appendShadowChildrenToGraphic(graphic, children, count), children;
};
const multiToOneMorph = (fromGraphics, toGraphic, animationConfig) => {
  var _a, _b, _c;
  const validateFromGraphics = fromGraphics.filter(graphic => graphic.toCustomPath && graphic.valid);
  validateFromGraphics.length || __DEV__ && console.error(fromGraphics, " is not validate"), toGraphic.valid && toGraphic.toCustomPath || __DEV__ && console.error(toGraphic, " is not validate");
  const childGraphics = ("clone" === (null == animationConfig ? void 0 : animationConfig.splitPath) ? cloneGraphic : null !== (_a = null == animationConfig ? void 0 : animationConfig.splitPath) && void 0 !== _a ? _a : splitGraphic)(toGraphic, validateFromGraphics.length, !0),
    toAttrs = toGraphic.attribute;
  toGraphic.setAttribute("visible", !1);
  const morphingData = validateFromGraphics.map((graphic, index) => parseMorphingData(graphic.toCustomPath(), childGraphics[index].toCustomPath(), {
      fromTransform: graphic.globalTransMatrix,
      toTransfrom: childGraphics[index].globalTransMatrix
    })),
    otherAttrs = validateFromGraphics.map((graphic, index) => parseOtherAnimateAttrs(graphic.attribute, toAttrs));
  if (null == animationConfig ? void 0 : animationConfig.individualDelay) {
    const oldOnEnd = animationConfig.onEnd;
    let count = validateFromGraphics.length;
    const onEachEnd = () => {
      count--, 0 === count && (toGraphic.setAttributes({
        visible: !0,
        ratio: null
      }, !1, {
        type: AttributeUpdateType.ANIMATE_END
      }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd());
    };
    childGraphics.forEach((to, index) => {
      var _a, _b, _c;
      const delay = (null !== (_a = animationConfig.delay) && void 0 !== _a ? _a : 0) + animationConfig.individualDelay(index, validateFromGraphics.length, fromGraphics[index], to),
        animate = to.animate(Object.assign({}, animationConfig, {
          onEnd: onEachEnd
        }));
      animate.wait(delay), animate.play(new MorphingPath({
        morphingData: morphingData[index],
        saveOnEnd: !0,
        otherAttrs: otherAttrs[index]
      }, null !== (_b = animationConfig.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = animationConfig.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing));
    });
  } else {
    const oldOnEnd = null == animationConfig ? void 0 : animationConfig.onEnd,
      config = animationConfig ? Object.assign({}, animationConfig) : {};
    config.onEnd = () => {
      toGraphic.setAttribute("visible", !0, !1, {
        type: AttributeUpdateType.ANIMATE_END
      }), toGraphic.detachShadow(), oldOnEnd && oldOnEnd();
    };
    const animate = toGraphic.animate(config);
    (null == animationConfig ? void 0 : animationConfig.delay) && animate.wait(animationConfig.delay), animate.play(new MultiToOneMorphingPath({
      morphingData: morphingData,
      otherAttrs: otherAttrs
    }, null !== (_b = null == animationConfig ? void 0 : animationConfig.duration) && void 0 !== _b ? _b : DefaultMorphingAnimateConfig.duration, null !== (_c = null == animationConfig ? void 0 : animationConfig.easing) && void 0 !== _c ? _c : DefaultMorphingAnimateConfig.easing));
  }
};

class GroupFadeIn extends ACustomAnimate {
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.setTheme({
      common: {
        opacity: 0
      }
    });
  }
  onEnd() {
    this.target.setTheme({
      common: {
        opacity: 1
      }
    });
  }
  onUpdate(end, ratio, out) {
    this.target.setTheme({
      common: {
        opacity: ratio
      }
    });
  }
}
class GroupFadeOut extends ACustomAnimate {
  getEndProps() {
    return {};
  }
  onBind() {
    this.target.setTheme({
      common: {
        opacity: 1
      }
    });
  }
  onEnd() {
    this.target.setTheme({
      common: {
        opacity: 0
      }
    });
  }
  onUpdate(end, ratio, out) {
    this.target.setTheme({
      common: {
        opacity: 1 - ratio
      }
    });
  }
}

class ResourceLoader {
  static GetImage(url, mark) {
    var _a;
    const data = ResourceLoader.cache.get(url);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(url);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(url, data.data) : ResourceLoader.loadImage(url, mark);
  }
  static GetSvg(svgStr, mark) {
    var _a;
    let data = ResourceLoader.cache.get(svgStr);
    data ? "fail" === data.loadState ? application.global.getRequestAnimationFrame()(() => {
      mark.imageLoadFail(svgStr);
    }) : "init" === data.loadState || "loading" === data.loadState ? null === (_a = data.waitingMark) || void 0 === _a || _a.push(mark) : mark && mark.imageLoadSuccess(svgStr, data.data) : (data = {
      type: "image",
      loadState: "init"
    }, ResourceLoader.cache.set(svgStr, data), data.dataPromise = application.global.loadSvg(svgStr), data.dataPromise ? (data.waitingMark = [mark], data.dataPromise.then(res => {
      var _a;
      data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
        (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(svgStr, res.data)) : (data.loadState = "fail", mark.imageLoadFail(svgStr));
      }), data.waitingMark && (data.waitingMark = []);
    })) : (data.loadState = "fail", mark.imageLoadFail(svgStr)));
  }
  static GetFile(url, type) {
    let data = ResourceLoader.cache.get(url);
    return data ? "fail" === data.loadState ? Promise.reject() : "init" === data.loadState || "loading" === data.loadState ? data.dataPromise.then(data => data.data) : Promise.resolve(data.data) : (data = {
      type: type,
      loadState: "init"
    }, ResourceLoader.cache.set(url, data), "arrayBuffer" === type ? data.dataPromise = application.global.loadArrayBuffer(url) : "blob" === type ? data.dataPromise = application.global.loadBlob(url) : "json" === type && (data.dataPromise = application.global.loadJson(url)), data.dataPromise.then(data => data.data));
  }
  static loading() {
    setTimeout(() => {
      if (!ResourceLoader.isLoading && ResourceLoader.toLoadAueue.length) {
        ResourceLoader.isLoading = !0;
        const tasks = ResourceLoader.toLoadAueue.splice(0, 10),
          promises = [];
        tasks.forEach(task => {
          const {
              url: url,
              marks: marks
            } = task,
            data = {
              type: "image",
              loadState: "init"
            };
          if (ResourceLoader.cache.set(url, data), data.dataPromise = application.global.loadImage(url), data.dataPromise) {
            data.waitingMark = marks;
            const end = data.dataPromise.then(res => {
              var _a;
              data.loadState = (null == res ? void 0 : res.data) ? "success" : "fail", data.data = null == res ? void 0 : res.data, null === (_a = data.waitingMark) || void 0 === _a || _a.map((mark, index) => {
                (null == res ? void 0 : res.data) ? (data.loadState = "success", data.data = res.data, mark.imageLoadSuccess(url, res.data)) : (data.loadState = "fail", mark.imageLoadFail(url));
              }), data.waitingMark && (data.waitingMark = []);
            });
            promises.push(end);
          } else data.loadState = "fail", marks.forEach(mark => mark.imageLoadFail(url));
        }), Promise.all(promises).then(() => {
          ResourceLoader.isLoading = !1, this.onLoadSuccessCb.forEach(cb => cb()), ResourceLoader.loading();
        }).catch(error => {
          console.error(error), ResourceLoader.isLoading = !1, this.onLoadSuccessCb.forEach(cb => cb()), ResourceLoader.loading();
        });
      }
    }, 0);
  }
  static loadImage(url, mark) {
    const index = getIndex(url, ResourceLoader.toLoadAueue);
    if (-1 !== index) return ResourceLoader.toLoadAueue[index].marks.push(mark), void ResourceLoader.loading();
    ResourceLoader.toLoadAueue.push({
      url: url,
      marks: [mark]
    }), ResourceLoader.loading();
  }
  static improveImageLoading(url) {
    const index = getIndex(url, ResourceLoader.toLoadAueue);
    if (-1 !== index) {
      const elememt = ResourceLoader.toLoadAueue.splice(index, 1);
      ResourceLoader.toLoadAueue.unshift(elememt[0]);
    }
  }
  static onLoadSuccess(cb) {
    this.onLoadSuccessCb.push(cb);
  }
}
function getIndex(url, arr) {
  for (let i = 0; i < arr.length; i++) if (arr[i].url === url) return i;
  return -1;
}
ResourceLoader.cache = new Map(), ResourceLoader.isLoading = !1, ResourceLoader.toLoadAueue = [], ResourceLoader.onLoadSuccessCb = [];

class BaseSymbol {
  bounds(size, bounds) {
    if (isNumber$1(size)) {
      const halfS = size / 2;
      bounds.x1 = -halfS, bounds.x2 = halfS, bounds.y1 = -halfS, bounds.y2 = halfS;
    } else bounds.x1 = -size[0] / 2, bounds.x2 = size[0] / 2, bounds.y1 = -size[1] / 2, bounds.y2 = size[1] / 2;
  }
  parseSize(size) {
    return isNumber$1(size) ? size : Math.min(size[0], size[1]);
  }
}

function circle(ctx, r, x, y, z) {
  return z ? ctx.arc(x, y, r, 0, tau, !1, z) : ctx.arc(x, y, r, 0, tau), !1;
}
class CircleSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "circle", this.pathStr = "M0.5,0A0.5,0.5,0,1,1,-0.5,0A0.5,0.5,0,1,1,0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return circle(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return circle(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y} a ${r},${r} 0 1,0 ${2 * r},0 a ${r},${r} 0 1,0 -${2 * r},0`;
  }
}
var circle$1 = new CircleSymbol();

function cross(ctx, r, x, y, z) {
  return ctx.moveTo(-3 * r + x, -r + y, z), ctx.lineTo(-r + x, -r + y, z), ctx.lineTo(-r + x, -3 * r + y, z), ctx.lineTo(r + x, -3 * r + y, z), ctx.lineTo(r + x, -r + y, z), ctx.lineTo(3 * r + x, -r + y, z), ctx.lineTo(3 * r + x, r + y, z), ctx.lineTo(r + x, r + y, z), ctx.lineTo(r + x, 3 * r + y, z), ctx.lineTo(-r + x, 3 * r + y, z), ctx.lineTo(-r + x, r + y, z), ctx.lineTo(-3 * r + x, r + y, z), ctx.closePath(), !0;
}
function crossOffset(ctx, r, x, y, offset, z) {
  return ctx.moveTo(-3 * r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -r + y - offset, z), ctx.lineTo(-r + x - offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -3 * r + y - offset, z), ctx.lineTo(r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, -r + y - offset, z), ctx.lineTo(3 * r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, r + y + offset, z), ctx.lineTo(r + x + offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, 3 * r + y + offset, z), ctx.lineTo(-r + x - offset, r + y + offset, z), ctx.lineTo(-3 * r + x - offset, r + y + offset, z), ctx.closePath(), !0;
}
class CrossSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "cross", this.pathStr = "M-0.5,-0.2L-0.5,0.2L-0.2,0.2L-0.2,0.5L0.2,0.5L0.2,0.2L0.5,0.2L0.5,-0.2L0.2,-0.2L0.2,-0.5L-0.2,-0.5L-0.2,-0.2Z";
  }
  draw(ctx, size, x, y, z) {
    return cross(ctx, this.parseSize(size) / 6, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return crossOffset(ctx, this.parseSize(size) / 6, x, y, offset, z);
  }
}
var cross$1 = new CrossSymbol();

function diamond(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r, z), ctx.lineTo(r + x, y, z), ctx.lineTo(x, y + r, z), ctx.lineTo(x - r, y, z), ctx.closePath(), !0;
}
class DiamondSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "diamond", this.pathStr = "M-0.5,0L0,-0.5L0.5,0L0,0.5Z";
  }
  draw(ctx, size, x, y, z) {
    return diamond(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawFitDir(ctx, size, x, y, z) {
    return diamond(ctx, this.parseSize(size) / 2, x, y, z);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return diamond(ctx, this.parseSize(size) / 2 + offset, x, y, z);
  }
}
var diamond$1 = new DiamondSymbol();

function square(ctx, r, x, y) {
  const wh = 2 * r;
  return ctx.rect(x - r, y - r, wh, wh), !1;
}
class SquareSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "square", this.pathStr = "M-0.5,-0.5h1v1h-1Z";
  }
  draw(ctx, size, x, y) {
    return square(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return square(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
}
var square$1 = new SquareSymbol();

function trianglUpOffset(ctx, r, x, y) {
  let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return ctx.moveTo(x + r + 2 * offset, r + y + offset), ctx.lineTo(x - r - 2 * offset, r + y + offset), ctx.lineTo(x, y - r - 2 * offset), ctx.closePath(), !0;
}
class TriangleUpSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleUp", this.pathStr = "M0.5,0.5 L-0.5,0.5 L0,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglUpOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
}
var triangleUp = new TriangleUpSymbol();

class TriangleSymbol extends TriangleUpSymbol {
  constructor() {
    super(...arguments), this.type = "triangle";
  }
}
var triangle = new TriangleSymbol();

const kr = Math.sin(Math.PI / 10) / Math.sin(7 * Math.PI / 10),
  kx = Math.sin(tau / 10) * kr,
  ky = -Math.cos(tau / 10) * kr;
function star(ctx, r, transX, transY) {
  const x = kx * r,
    y = ky * r;
  ctx.moveTo(transX, -r + transY), ctx.lineTo(x + transX, y + transY);
  for (let i = 1; i < 5; ++i) {
    const a = tau * i / 5,
      c = Math.cos(a),
      s = Math.sin(a);
    ctx.lineTo(s * r + transX, -c * r + transY), ctx.lineTo(c * x - s * y + transX, s * x + c * y + transY);
  }
  return ctx.closePath(), !0;
}
class StarSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "star", this.pathStr = "M0 -1L0.22451398828979266 -0.3090169943749474L0.9510565162951535 -0.30901699437494745L0.3632712640026804 0.1180339887498948L0.5877852522924732 0.8090169943749473L8.326672684688674e-17 0.3819660112501051L-0.587785252292473 0.8090169943749476L-0.3632712640026804 0.11803398874989487L-0.9510565162951536 -0.30901699437494723L-0.22451398828979274 -0.30901699437494734Z";
  }
  draw(ctx, size, transX, transY) {
    return star(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return star(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var star$1 = new StarSymbol();

const sqrt3$1 = sqrt(3);
function arrow(ctx, r, transX, transY) {
  const triangleH = r,
    trangleBottomSide = triangleH / sqrt3$1,
    rectW = trangleBottomSide / 5,
    rectH = r;
  return ctx.moveTo(0 + transX, -triangleH + transY), ctx.lineTo(trangleBottomSide / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, transY), ctx.lineTo(rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, rectH + transY), ctx.lineTo(-rectW / 2 + transX, transY), ctx.lineTo(-trangleBottomSide / 2 + transX, transY), ctx.closePath(), !0;
}
class ArrowSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow", this.pathStr = "M-0.07142857142857142,0.5L0.07142857142857142,0.5L0.07142857142857142,-0.0625L0.2,-0.0625L0,-0.5L-0.2,-0.0625L-0.07142857142857142,-0.0625Z";
  }
  draw(ctx, size, transX, transY) {
    return arrow(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var arrow$1 = new ArrowSymbol();

function wedge(ctx, r, transX, transY) {
  const h = 2 * r;
  return ctx.moveTo(transX, -r + transY), ctx.lineTo(h / 3 / 2 + transX, r + transY), ctx.lineTo(-h / 3 / 2 + transX, r + transY), ctx.closePath(), !0;
}
class WedgeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wedge", this.pathStr = "M0,-0.5773502691896257L-0.125,0.28867513459481287L0.125,0.28867513459481287Z";
  }
  draw(ctx, size, transX, transY) {
    return wedge(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wedge(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var wedge$1 = new WedgeSymbol();

function stroke(ctx, r, transX, transY) {
  return ctx.moveTo(-r + transX, transY), ctx.lineTo(transX, r + transY), !1;
}
class StrokeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "stroke", this.pathStr = "";
  }
  draw(ctx, size, transX, transY) {
    return stroke(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return stroke(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var stroke$1 = new StrokeSymbol();

const c$1 = -.5,
  s$1 = sqrt(3) / 2,
  k$1 = 1 / sqrt(12);
function wye(ctx, r, transX, transY) {
  const x0 = r / 2,
    y0 = r * k$1,
    x1 = x0,
    y1 = r * k$1 + r,
    x2 = -x1,
    y2 = y1;
  return ctx.moveTo(x0 + transX, y0 + transY), ctx.lineTo(x1 + transX, y1 + transY), ctx.lineTo(x2 + transX, y2 + transY), ctx.lineTo(c$1 * x0 - s$1 * y0 + transX, s$1 * x0 + c$1 * y0 + transY), ctx.lineTo(c$1 * x1 - s$1 * y1 + transX, s$1 * x1 + c$1 * y1 + transY), ctx.lineTo(c$1 * x2 - s$1 * y2 + transX, s$1 * x2 + c$1 * y2 + transY), ctx.lineTo(c$1 * x0 + s$1 * y0 + transX, c$1 * y0 - s$1 * x0 + transY), ctx.lineTo(c$1 * x1 + s$1 * y1 + transX, c$1 * y1 - s$1 * x1 + transY), ctx.lineTo(c$1 * x2 + s$1 * y2 + transX, c$1 * y2 - s$1 * x2 + transY), ctx.closePath(), !1;
}
class WyeSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "wye", this.pathStr = "M0.25 0.14433756729740646L0.25 0.6443375672974064L-0.25 0.6443375672974064L-0.25 0.14433756729740643L-0.6830127018922193 -0.10566243270259357L-0.4330127018922193 -0.5386751345948129L0 -0.28867513459481287L0.4330127018922193 -0.5386751345948129L0.6830127018922193 -0.10566243270259357Z";
  }
  draw(ctx, size, transX, transY) {
    return wye(ctx, this.parseSize(size) / 2, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return wye(ctx, this.parseSize(size) / 2 + offset, transX, transY);
  }
}
var wye$1 = new WyeSymbol();

function trianglLeftOffset(ctx, r, x, y, offset) {
  return ctx.moveTo(-r + x - 2 * offset, y), ctx.lineTo(r + x + offset, r + y + 2 * offset), ctx.lineTo(r + x + offset, y - r - 2 * offset), ctx.closePath(), !0;
}
class TriangleLeftSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleLeft", this.pathStr = "M-0.5,0 L0.5,0.5 L0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, 0);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglLeftOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
}
var triangleLeft = new TriangleLeftSymbol();

function trianglRightOffset(ctx, r, x, y) {
  let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return ctx.moveTo(x - r - offset, r + y + 2 * offset), ctx.lineTo(r + x + 2 * offset, y), ctx.lineTo(x - r - offset, y - r - 2 * offset), ctx.closePath(), !0;
}
class TriangleRightSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleRight", this.pathStr = "M-0.5,0.5 L0.5,0 L-0.5,-0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglRightOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
}
var triangleRight = new TriangleRightSymbol();

function trianglDownOffset(ctx, r, x, y) {
  let offset = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
  return ctx.moveTo(x - r - 2 * offset, y - r - offset), ctx.lineTo(x + r + 2 * offset, y - r - offset), ctx.lineTo(x, y + r + 2 * offset), ctx.closePath(), !0;
}
class TriangleDownSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "triangleDown", this.pathStr = "M-0.5,-0.5 L0.5,-0.5 L0,0.5 Z";
  }
  draw(ctx, size, x, y) {
    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return trianglDownOffset(ctx, this.parseSize(size) / 2, x, y, offset);
  }
}
var triangleDown = new TriangleDownSymbol();

const sqrt3 = sqrt(3);
function thinTriangle(ctx, r, x, y) {
  const h = r * sqrt3;
  return ctx.moveTo(x, y + -h / 3 * 2), ctx.lineTo(r + x, y + h), ctx.lineTo(x - r, y + h), ctx.closePath(), !0;
}
class ThinTriangleSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "thinTriangle", this.pathStr = "M0,-0.5773502691896257L-0.5,0.28867513459481287L0.5,0.28867513459481287Z";
  }
  draw(ctx, size, x, y) {
    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt3, x, y);
  }
  drawOffset(ctx, size, x, y, offset) {
    return thinTriangle(ctx, this.parseSize(size) / 2 / sqrt3 + offset, x, y);
  }
}
var thinTriangle$1 = new ThinTriangleSymbol();

function arrow2Left(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(r + transX, transY - r2), ctx.lineTo(transX - r, transY), ctx.lineTo(r + transX, r2 + transY), !0;
}
class Arrow2LeftSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Left", this.pathStr = "M 0.25 -0.5 L -0.25 0 l 0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Left(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Left(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
}
var arrow2Left$1 = new Arrow2LeftSymbol();

function arrow2Right(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r, transY - r2), ctx.lineTo(transX + r, transY), ctx.lineTo(transX - r, r2 + transY), !0;
}
class Arrow2RightSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Right", this.pathStr = "M -0.25 -0.5 l 0.25 0 l -0.25 0.5";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Right(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Right(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
}
var arrow2Right$1 = new Arrow2RightSymbol();

function arrow2Up(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY + r), ctx.lineTo(transX, transY - r), ctx.lineTo(transX + r2, transY + r), !0;
}
class Arrow2UpSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Up", this.pathStr = "M -0.5 0.25 L 0 -0.25 l 0.5 0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Up(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Up(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
}
var arrow2Up$1 = new Arrow2UpSymbol();

function arrow2Down(ctx, r, transX, transY) {
  const r2 = 2 * r;
  return ctx.moveTo(transX - r2, transY - r), ctx.lineTo(transX, transY + r), ctx.lineTo(transX + r2, transY - r), !0;
}
class Arrow2DownSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "arrow2Down", this.pathStr = "M -0.5 -0.25 L 0 0.25 l 0.5 -0.25";
  }
  draw(ctx, size, transX, transY) {
    return arrow2Down(ctx, this.parseSize(size) / 4, transX, transY);
  }
  drawOffset(ctx, size, transX, transY, offset) {
    return arrow2Down(ctx, this.parseSize(size) / 4 + offset, transX, transY);
  }
}
var arrow2Down$1 = new Arrow2DownSymbol();

function lineV(ctx, r, x, y, z) {
  return ctx.moveTo(x, y - r), ctx.lineTo(x, y + r), !0;
}
class LineVSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineV", this.pathStr = "M0,-0.5L0,0.5";
  }
  draw(ctx, size, x, y, z) {
    return lineV(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineV(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x}, ${y - r} L ${x},${y + r}`;
  }
}
var lineV$1 = new LineVSymbol();

function lineH(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y), ctx.lineTo(x + r, y), !0;
}
class LineHSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "lineH", this.pathStr = "M-0.5,0L0.5,0";
  }
  draw(ctx, size, x, y, z) {
    return lineH(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return lineH(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y} L ${x + r},${y}`;
  }
}
var lineH$1 = new LineHSymbol();

function close(ctx, r, x, y, z) {
  return ctx.moveTo(x - r, y - r), ctx.lineTo(x + r, y + r), ctx.moveTo(x + r, y - r), ctx.lineTo(x - r, y + r), !0;
}
class CloseSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "close", this.pathStr = "M-0.5,-0.5L0.5,0.5,M0.5,-0.5L-0.5,0.5";
  }
  draw(ctx, size, x, y, z) {
    return close(ctx, this.parseSize(size) / 2, x, y);
  }
  drawOffset(ctx, size, x, y, offset, z) {
    return close(ctx, this.parseSize(size) / 2 + offset, x, y);
  }
  drawToSvgPath(size, x, y, z) {
    const r = this.parseSize(size) / 2;
    return `M ${x - r}, ${y - r} L ${x + r},${y + r} M ${x + r}, ${y - r} L ${x - r},${y + r}`;
  }
}
var close$1 = new CloseSymbol();

function rectSizeArray(ctx, size, x, y) {
  return ctx.rect(x - size[0] / 2, y - size[1] / 2, size[0], size[1]), !1;
}
function rectSize(ctx, size, x, y) {
  const w = size,
    h = size / 2;
  return ctx.rect(x - w / 2, y - h / 2, w, h), !1;
}
class RectSymbol extends BaseSymbol {
  constructor() {
    super(...arguments), this.type = "rect", this.pathStr = "M -0.5,0.25 L 0.5,0.25 L 0.5,-0.25,L -0.5,-0.25 Z";
  }
  draw(ctx, size, x, y) {
    return isNumber$1(size) ? rectSize(ctx, size, x, y) : rectSizeArray(ctx, size, x, y);
  }
  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
    isNumber$1(size) && (size = [size, size / 2]);
    const drawLength = 2 * (size[0] + size[1]) * clipRange,
      points = [{
        x: x + size[0] / 2,
        y: y - size[1] / 2
      }, {
        x: x + size[0] / 2,
        y: y + size[1] / 2
      }, {
        x: x - size[0] / 2,
        y: y + size[1] / 2
      }, {
        x: x - size[0] / 2,
        y: y - size[1] / 2
      }];
    let currLength = 0,
      lastP = points[3];
    ctx.moveTo(lastP.x, lastP.y);
    for (let i = 0; i < points.length; i++) {
      const p = points[i],
        len = Math.sqrt((p.x - lastP.x) * (p.x - lastP.x) + (p.y - lastP.y) * (p.y - lastP.y));
      if (currLength + len > drawLength) {
        const dx = (p.x - lastP.x) * (drawLength - currLength) / len,
          dy = (p.y - lastP.y) * (drawLength - currLength) / len;
        ctx.lineTo(lastP.x + dx, lastP.y + dy);
        break;
      }
      ctx.lineTo(p.x, p.y), lastP = p, currLength += len;
    }
    return !1;
  }
  drawOffset(ctx, size, x, y, offset) {
    return isNumber$1(size) ? rectSize(ctx, size + 2 * offset, x, y) : rectSizeArray(ctx, [size[0] + 2 * offset, size[1] + 2 * offset], x, y);
  }
}
var rect = new RectSymbol();

const tempBounds$1 = new AABBBounds();
class CustomSymbolClass {
  constructor(type, path) {
    let isSvg = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;
    this.pathStr = "", this.type = type, isArray$1(path) ? this.svgCache = path : this.path = path, this.isSvg = isSvg;
  }
  drawOffset(ctx, size, x, y, offset, z, cb) {
    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach(item => {
      ctx.beginPath(), renderCommandList(item.path.commandList, ctx, x, y, size, size), cb && cb(item.path, item.attribute);
    }), !1) : (renderCommandList(this.path.commandList, ctx, x, y, size + offset, size + offset), !1);
  }
  draw(ctx, size, x, y, z, cb) {
    return size = this.parseSize(size), this.drawOffset(ctx, size, x, y, 0, z, cb);
  }
  parseSize(size) {
    return isNumber$1(size) ? size : Math.min(size[0], size[1]);
  }
  drawWithClipRange(ctx, size, x, y, clipRange, z, cb) {
    return size = this.parseSize(size), this.isSvg ? !!this.svgCache && (this.svgCache.forEach(item => {
      item.path.drawWithClipRange(ctx, size, x, y, clipRange), cb && cb(item.path, item.attribute);
    }), !1) : (this.path.drawWithClipRange(ctx, size, x, y, clipRange), !1);
  }
  bounds(size, bounds) {
    if (size = this.parseSize(size), this.isSvg) {
      if (!this.svgCache) return;
      return bounds.clear(), void this.svgCache.forEach(_ref => {
        let {
          path: path
        } = _ref;
        tempBounds$1.x1 = path.bounds.x1 * size, tempBounds$1.y1 = path.bounds.y1 * size, tempBounds$1.x2 = path.bounds.x2 * size, tempBounds$1.y2 = path.bounds.y2 * size, bounds.union(tempBounds$1);
      });
    }
    this.path.bounds && (bounds.x1 = this.path.bounds.x1 * size, bounds.y1 = this.path.bounds.y1 * size, bounds.x2 = this.path.bounds.x2 * size, bounds.y2 = this.path.bounds.y2 * size);
  }
}

const builtinSymbols = [circle$1, cross$1, diamond$1, square$1, thinTriangle$1, triangle, star$1, arrow$1, wedge$1, stroke$1, wye$1, triangleLeft, triangleRight, triangleUp, triangleDown, arrow2Left$1, arrow2Right$1, arrow2Up$1, arrow2Down$1, rect, lineV$1, lineH$1, close$1];
const builtinSymbolsMap = {};
builtinSymbols.forEach(symbol => {
  builtinSymbolsMap[symbol.type] = symbol;
});
const builtInSymbolStrMap = {
  arrowLeft: "M 0.25 -0.5 L -0.25 0 l 0.5 0.5",
  arrowRight: "M -0.25 -0.5 l 0.5 0.5 l -0.5 0.5",
  rectRound: "M 0.3 -0.5 C 0.41 -0.5 0.5 -0.41 0.5 -0.3 C 0.5 -0.3 0.5 0.3 0.5 0.3 C 0.5 0.41 0.41 0.5 0.3 0.5 C 0.3 0.5 -0.3 0.5 -0.3 0.5 C -0.41 0.5 -0.5 0.41 -0.5 0.3 C -0.5 0.3 -0.5 -0.3 -0.5 -0.3 C -0.5 -0.41 -0.41 -0.5 -0.3 -0.5 C -0.3 -0.5 0.3 -0.5 0.3 -0.5 Z",
  roundLine: "M 1.2392 -0.258 L -1.3432 -0.258 C -1.4784 -0.258 -1.588 -0.1436 -1.588 -0.002 c 0 0.1416 0.1096 0.256 0.2448 0.256 l 2.5824 0 c 0.1352 0 0.2448 -0.1144 0.2448 -0.256 C 1.484 -0.1436 1.3744 -0.258 1.2392 -0.258 z"
};

function getAllMatches(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  for (; match;) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) allmatches.push(match[index]);
    matches.push(allmatches), match = regex.exec(string);
  }
  return matches;
}

class XmlNode {
  constructor(tagname) {
    this.tagname = tagname, this.child = [], this[":@"] = {};
  }
  add(key, val) {
    "__proto__" === key && (key = "#__proto__"), this.child.push({
      [key]: val
    });
  }
  addChild(node) {
    "__proto__" === node.tagname && (node.tagname = "#__proto__"), node[":@"] && Object.keys(node[":@"]).length > 0 ? this.child.push({
      [node.tagname]: node.child,
      ":@": node[":@"]
    }) : this.child.push({
      [node.tagname]: node.child
    });
  }
}
function findClosingIndex(xmlData, str, i, errMsg) {
  const closingIndex = xmlData.indexOf(str, i);
  if (-1 === closingIndex) throw new Error(errMsg);
  return closingIndex + str.length - 1;
}
function tagExpWithClosingIndex(xmlData, i) {
  let closingChar = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ">";
  let attrBoundary,
    tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) ch === attrBoundary && (attrBoundary = "");else if ('"' === ch || "'" === ch) attrBoundary = ch;else if (ch === closingChar[0]) {
      if (!closingChar[1]) return {
        data: tagExp,
        index: index
      };
      if (xmlData[index + 1] === closingChar[1]) return {
        data: tagExp,
        index: index
      };
    } else "\t" === ch && (ch = " ");
    tagExp += ch;
  }
}
function readTagExp(xmlData, i, removeNSPrefix) {
  let closingChar = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ">";
  const result = tagExpWithClosingIndex(xmlData, i + 1, closingChar);
  if (!result) return;
  let tagExp = result.data;
  const closeIndex = result.index,
    separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp,
    attrExpPresent = !0;
  -1 !== separatorIndex && (tagName = tagExp.substr(0, separatorIndex).replace(/\s\s*$/, ""), tagExp = tagExp.substr(separatorIndex + 1));
  const rawTagName = tagName;
  if (removeNSPrefix) {
    const colonIndex = tagName.indexOf(":");
    -1 !== colonIndex && (tagName = tagName.substr(colonIndex + 1), attrExpPresent = tagName !== result.data.substr(colonIndex + 1));
  }
  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
    rawTagName: rawTagName
  };
}
const attrsRegx = new RegExp("([^\\s=]+)\\s*(=\\s*(['\"])([\\s\\S]*?)\\3)?", "gm");
class OrderedObjParser {
  constructor(options) {
    this.currentNode = null, this.options = options, this.tagsNodeStack = [], this.docTypeEntities = {};
  }
  addChild(currentNode, childNode, jPath) {
    const result = childNode.tagname;
    "string" == typeof result ? (childNode.tagname = result, currentNode.addChild(childNode)) : currentNode.addChild(childNode);
  }
  buildAttributesMap(attrStr, jPath, tagName) {
    const attrs = {};
    if (!attrStr) return;
    const matches = getAllMatches(attrStr, attrsRegx),
      len = matches.length;
    for (let i = 0; i < len; i++) {
      const attrName = matches[i][1],
        oldVal = matches[i][4],
        aName = attrName;
      attrName && (attrs[aName] = void 0 === oldVal || (isNaN(oldVal) ? oldVal : Number(oldVal)));
    }
    return attrs;
  }
  parseXml(xmlData) {
    xmlData = xmlData.replace(/\r\n?/g, "\n");
    const xmlObj = new XmlNode("!xml");
    let currentNode = xmlObj,
      textData = "",
      jPath = "";
    for (let i = 0; i < xmlData.length; i++) {
      if ("<" === xmlData[i]) {
        if ("/" === xmlData[i + 1]) {
          const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed."),
            propIndex = jPath.lastIndexOf(".");
          jPath = jPath.substring(0, propIndex), currentNode = this.tagsNodeStack.pop(), currentNode && currentNode.child && textData && currentNode.child[currentNode.child.length - 1][":@"] && (currentNode.child[currentNode.child.length - 1][":@"].text = textData), textData = "", i = closeIndex;
        } else if ("?" === xmlData[i + 1]) {
          i = readTagExp(xmlData, i, !1, "?>").closeIndex + 1;
        } else if ("!--" === xmlData.substr(i + 1, 3)) {
          i = findClosingIndex(xmlData, "--\x3e", i + 4, "Comment is not closed.");
        } else {
          const result = readTagExp(xmlData, i, !1);
          let tagName = result.tagName,
            tagExp = result.tagExp;
          const attrExpPresent = result.attrExpPresent,
            closeIndex = result.closeIndex;
          if (tagName !== xmlObj.tagname && (jPath += jPath ? "." + tagName : tagName), tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1) {
            "/" === tagName[tagName.length - 1] ? (tagName = tagName.substr(0, tagName.length - 1), jPath = jPath.substr(0, jPath.length - 1), tagExp = tagName) : tagExp = tagExp.substr(0, tagExp.length - 1);
            const childNode = new XmlNode(tagName);
            tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), jPath = jPath.substr(0, jPath.lastIndexOf("."));
          } else {
            const childNode = new XmlNode(tagName);
            this.tagsNodeStack.push(currentNode), tagName !== tagExp && attrExpPresent && (childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName)), this.addChild(currentNode, childNode, jPath), currentNode = childNode;
          }
          textData = "", i = closeIndex;
        }
      } else textData += xmlData[i];
    }
    return xmlObj.child;
  }
}

function prettify(node, options) {
  return compress(node);
}
function compress(arr, jPath) {
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i],
      property = propName(tagObj);
    if (void 0 !== property && tagObj[property]) {
      const val = compress(tagObj[property]);
      isLeafTag(val);
      tagObj[":@"] && assignAttributes(val, tagObj[":@"]), void 0 !== compressedObj[property] && compressedObj.hasOwnProperty(property) ? (Array.isArray(compressedObj[property]) || (compressedObj[property] = [compressedObj[property]]), compressedObj[property].push(val)) : compressedObj[property] = val;
    }
  }
  return compressedObj;
}
function propName(obj) {
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if (":@" !== key) return key;
  }
}
function assignAttributes(obj, attrMap, jpath) {
  if (attrMap) {
    const keys = Object.keys(attrMap),
      len = keys.length;
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      obj[atrrName] = attrMap[atrrName];
    }
  }
}
function isLeafTag(obj) {
  return 0 === Object.keys(obj).length;
}

class XMLParser {
  constructor(options) {
    this.options = Object.assign({}, XMLParser.defaultOptions, options);
  }
  valid(xml) {
    return xml.startsWith("<");
  }
  parse(xmlData) {
    if (!this.valid) return !1;
    const orderedResult = new OrderedObjParser(this.options).parseXml(xmlData);
    return prettify(orderedResult, this.options);
  }
}
XMLParser.defaultOptions = {};
function isSvg(str) {
  return str.startsWith("<svg") || str.startsWith("<?xml");
}
function isXML(str) {
  return str.startsWith("<");
}

var __awaiter$6 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function incrementalAddTo(group, graphic) {
  group.incrementalAppendChild(graphic);
}
function waitForAllSubLayers(stage) {
  return __awaiter$6(this, void 0, void 0, function* () {
    const promiseList = [],
      layers = stage.getChildren();
    yield new Promise(resolve => {
      application.global.getRequestAnimationFrame()(() => {
        resolve(null);
      });
    }), layers.forEach(l => {
      l.subLayers.size && l.subLayers.forEach(sl => {
        sl.drawContribution && sl.drawContribution.hooks && sl.drawContribution.rendering && promiseList.push(new Promise(resolve => {
          sl.drawContribution.hooks.completeDraw.tap("outWait", () => {
            sl.drawContribution.hooks.completeDraw.taps = sl.drawContribution.hooks.completeDraw.taps.filter(i => "outWait" !== i.name), resolve(null);
          });
        }));
      });
    }), yield Promise.all(promiseList);
  });
}
function boundStroke(bounds, halfW, miter) {
  let pad = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return bounds.expand(halfW + (pad / 2 + (miter ? miterAdjustment(miter, halfW) : 0))), bounds;
}
function miterAdjustment(miter, strokeWidth) {
  return miter ? strokeWidth : 0;
}
let NUMBER_TYPE = 0;
function genNumberType() {
  return NUMBER_TYPE++;
}
var TextDirection;
!function (TextDirection) {
  TextDirection[TextDirection.HORIZONTAL = 0] = "HORIZONTAL", TextDirection[TextDirection.VERTICAL = 1] = "VERTICAL";
}(TextDirection || (TextDirection = {}));
function verticalLayout(text) {
  const nextCharacter = [];
  let flag = 0,
    currStr = "";
  for (let i = 0; i < text.length; i++) rotateText(text[i]) ? flag ? currStr += text[i] : (flag = 1, currStr = text[i]) : (flag && (nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), currStr = "", flag = 0), nextCharacter.push({
    text: text[i],
    direction: TextDirection.HORIZONTAL
  }));
  return currStr && nextCharacter.push({
    text: currStr,
    direction: TextDirection.VERTICAL
  }), nextCharacter;
}
const rotateCharList = ["…", "（", "）", "—", "【", "】", "「", "」", "《", "》"],
  rotateCharMap = new Map();
rotateCharList.forEach(c => rotateCharMap.set(c, !0));
const noRotateCharList = [""],
  noRotateCharMap = new Map();
function rotateText(c) {
  if (rotateCharMap.has(c)) return !0;
  if (noRotateCharMap.has(c)) return !1;
  let rotate = !1;
  return c.codePointAt(0) < 256 && (rotate = !0), rotate;
}
noRotateCharList.forEach(c => noRotateCharMap.set(c, !0));
function xul(str) {
  const xmlStr = isArray$1(str) ? str[0] : str,
    config = [];
  if (!xmlStr) return config;
  if (!0 === isXML(xmlStr)) {
    const data = new XMLParser().parse(xmlStr);
    data.tc && Object.keys(data.tc).forEach(k => {
      "text" === k ? config.push(parseRTTextXML(data.tc[k])) : config.push(parseRTImageXML(data.tc[k]));
    });
  }
  return config;
}
function parseRTTextXML(str) {
  const output = {
    text: ""
  };
  parseCommonXML(str, output);
  const inlineText = str["#text"];
  return inlineText && (output.text = inlineText), output;
}
function parseCommonXML(str, output) {
  const attr = str.attribute;
  if (attr) {
    attr.split(";").forEach(attrItem => {
      if (!attrItem) return;
      const kv = attrItem.split(":");
      if (2 === kv.length) {
        const val = parseFloat(kv[1]);
        output[kv[0].trim()] = isFinite(val) ? val : kv[1].trim();
      } else {
        let val = "";
        for (let i = 1; i < kv.length; i++) i > 1 && (val += ":"), val += kv[i].trim();
        output[kv[0].trim()] = val;
      }
    });
  }
}
function parseRTImageXML(str) {
  const output = {
    image: "",
    width: 0,
    height: 0
  };
  parseCommonXML(str, output);
  const image = output.image;
  return image && (output.image = image.replaceAll("&quot", '"').replaceAll("&lt", "<").replaceAll("&gt", ">")), output;
}

const ARC_NUMBER_TYPE = genNumberType();
const ARC3D_NUMBER_TYPE = genNumberType();
const AREA_NUMBER_TYPE = genNumberType();
const CIRCLE_NUMBER_TYPE = genNumberType();
const GLYPH_NUMBER_TYPE = genNumberType();
const GROUP_NUMBER_TYPE = genNumberType();
const IMAGE_NUMBER_TYPE = genNumberType();
const LINE_NUMBER_TYPE = genNumberType();
const PATH_NUMBER_TYPE = genNumberType();
const POLYGON_NUMBER_TYPE = genNumberType();
const PYRAMID3D_NUMBER_TYPE = genNumberType();
const RECT_NUMBER_TYPE = genNumberType();
const RECT3D_NUMBER_TYPE = genNumberType();
const RICHTEXT_NUMBER_TYPE = genNumberType();
const SYMBOL_NUMBER_TYPE = genNumberType();
const TEXT_NUMBER_TYPE = genNumberType();
const GraphicService = Symbol.for("GraphicService");
const GraphicCreator$1 = Symbol.for("GraphicCreator");
const SVG_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity"
};
const SVG_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_ATTRIBUTE_MAP);
const SVG_PARSE_ATTRIBUTE_MAP = {
  "stroke-linecap": "lineCap",
  "stroke-linejoin": "lineJoin",
  "stroke-dasharray": "lineDash",
  "stroke-dashoffset": "lineDashOffset",
  "stroke-width": "lineWidth",
  "fill-opacity": "fillOpacity",
  "stroke-opacity": "strokeOpacity",
  stroke: "stroke",
  fill: "fill"
};
const SVG_PARSE_ATTRIBUTE_MAP_KEYS = Object.keys(SVG_PARSE_ATTRIBUTE_MAP);

const _tempBounds$1 = new AABBBounds(),
  tempMatrix = new Matrix(),
  tempBounds = new AABBBounds();
const PURE_STYLE_KEY = ["stroke", "opacity", "strokeOpacity", "lineDash", "lineDashOffset", "lineCap", "lineJoin", "miterLimit", "fill", "fillOpacity"];
const GRAPHIC_UPDATE_TAG_KEY = ["lineWidth", "scaleX", "scaleY", "angle", "anchor", "visible"];
const tempConstantXYKey = ["x", "y"],
  tempConstantScaleXYKey = ["scaleX", "scaleY"],
  tempConstantAngleKey = ["angle"],
  point = new Point();
const NOWORK_ANIMATE_ATTR = {
  strokeSeg: 1,
  boundsPadding: 2,
  pickMode: 1,
  boundsMode: 1,
  customPickShape: 1,
  pickable: 1,
  childrenPickable: 1,
  visible: 1,
  zIndex: 1,
  layout: 1,
  keepDirIn3d: 1,
  globalZIndex: 1,
  outerBorder: 1,
  innerBorder: 1,
  lineDash: 1,
  lineCap: 1,
  lineJoin: 1,
  miterLimit: 2,
  strokeBoundsBuffer: 2,
  scaleCenter: 1,
  anchor: 1,
  anchor3d: 1,
  postMatrix: 1,
  backgroundMode: 2,
  background: 1,
  texture: 1,
  cursor: 1,
  html: 1
};
class Graphic extends Node {
  static mixin(source) {
    const keys = Object.keys(source);
    for (let i = 0; i < keys.length; ++i) {
      const propertyName = keys[i];
      Object.defineProperty(Graphic.prototype, propertyName, Object.getOwnPropertyDescriptor(source, propertyName));
    }
  }
  get AABBBounds() {
    return this.tryUpdateAABBBounds();
  }
  get OBBBounds() {
    return this.tryUpdateOBBBounds();
  }
  get globalAABBBounds() {
    return this.tryUpdateGlobalAABBBounds();
  }
  get transMatrix() {
    return this.tryUpdateLocalTransMatrix(!0);
  }
  get globalTransMatrix() {
    return this.tryUpdateGlobalTransMatrix(!0);
  }
  constructor() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _a;
    super(), this._AABBBounds = new AABBBounds(), this._updateTag = UpdateTag.INIT, this.attribute = params, this.valid = this.isValid(), this.updateAABBBoundsStamp = 0, params.background ? this.loadImage(null !== (_a = params.background.background) && void 0 !== _a ? _a : params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic);
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = !0;
  }
  set2dMode() {
    this.in3dMode = !1;
  }
  getOffsetXY(attr) {
    let includeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var _a, _b;
    const {
      dx = attr.dx,
      dy = attr.dy
    } = this.attribute;
    if (includeScroll && this.parent) {
      const attribute = this.parent.attribute;
      point.x = dx + (null !== (_a = attribute.scrollX) && void 0 !== _a ? _a : 0), point.y = dy + (null !== (_b = attribute.scrollY) && void 0 !== _b ? _b : 0);
    } else point.x = dx, point.y = dy;
    return point;
  }
  onAnimateBind(animate) {
    this._emitCustomEvent("animate-bind", animate);
  }
  tryUpdateAABBBounds() {
    const full = "imprecise" === this.attribute.boundsMode;
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    if (!this.valid) return this._AABBBounds.clear(), this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
    const bounds = this.doUpdateAABBBounds(full);
    return application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, !0), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
  }
  tryUpdateOBBBounds() {
    if (this._OBBBounds || (this._OBBBounds = new OBBBounds()), this.tryUpdateAABBBounds(), this.updateOBBBoundsStamp === this.updateAABBBoundsStamp) return this._OBBBounds;
    if (this.updateOBBBoundsStamp = this.updateAABBBoundsStamp, !this.valid) return this._OBBBounds.clear(), this._OBBBounds;
    return this.doUpdateOBBBounds();
  }
  combindShadowAABBBounds(bounds) {
    if (this.shadowRoot) {
      const b = this.shadowRoot.AABBBounds.clone();
      bounds.union(b);
    }
  }
  doUpdateOBBBounds() {
    return this._OBBBounds;
  }
  getClipPath() {
    const {
      clipConfig: clipConfig
    } = this.attribute;
    if (!clipConfig) return null;
    this.clipPathMap || (this.clipPathMap = new Map());
    const {
      shape: shape
    } = clipConfig;
    let path = this.clipPathMap.get(shape) || null;
    return path || (this.clipPathMap.size > 10 && this.clipPathMap.clear(), path = this.parsePath(shape), path && this.clipPathMap.set(shape, path)), path;
  }
  parsePath(symbolType) {
    if (!symbolType) return null;
    let path = builtinSymbolsMap[symbolType];
    if (path) return path;
    if (path = Graphic.userSymbolMap[symbolType], path) return path;
    const _symbolType = builtInSymbolStrMap[symbolType];
    if (!0 === isSvg(symbolType = _symbolType || symbolType)) {
      const parser = new XMLParser(),
        {
          svg: svg
        } = parser.parse(symbolType);
      if (!svg) return null;
      const path = isArray$1(svg.path) ? svg.path : [svg.path];
      _tempBounds$1.clear();
      const cacheList = [];
      path.forEach(item => {
        const cache = new CustomPath2D().fromString(item.d),
          attribute = {};
        SVG_PARSE_ATTRIBUTE_MAP_KEYS.forEach(k => {
          item[k] && (attribute[SVG_PARSE_ATTRIBUTE_MAP[k]] = item[k]);
        }), cacheList.push({
          path: cache,
          attribute: attribute
        }), _tempBounds$1.union(cache.bounds);
      });
      const width = _tempBounds$1.width(),
        height = _tempBounds$1.height(),
        scale = 1 / max(width, height);
      cacheList.forEach(cache => cache.path.transform(0, 0, scale, scale));
      const _parsedPath = new CustomSymbolClass(symbolType, cacheList, !0);
      return Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
    }
    const cache = new CustomPath2D().fromString(symbolType),
      width = cache.bounds.width(),
      height = cache.bounds.height(),
      scale = 1 / max(width, height);
    cache.transform(0, 0, scale, scale);
    const _parsedPath = new CustomSymbolClass(symbolType, cache);
    return Graphic.userSymbolMap[symbolType] = _parsedPath, _parsedPath;
  }
  doUpdateAABBBounds(full) {
    this.updateAABBBoundsStamp++;
    const graphicTheme = this.getGraphicTheme();
    this._AABBBounds.clear();
    const attribute = this.attribute,
      bounds = this.updateAABBBounds(attribute, graphicTheme, this._AABBBounds, full),
      {
        boundsPadding = graphicTheme.boundsPadding
      } = attribute,
      paddingArray = parsePadding(boundsPadding);
    return paddingArray && bounds.expand(paddingArray), this.clearUpdateBoundTag(), bounds;
  }
  updatePathProxyAABBBounds(aabbBounds) {
    const path = "function" == typeof this.pathProxy ? this.pathProxy(this.attribute) : this.pathProxy;
    if (!path) return !1;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
  }
  tryUpdateGlobalAABBBounds() {
    const b = this.AABBBounds;
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(b.x1, b.y1, b.x2, b.y2) : this._globalAABBBounds = b.clone(), this._globalAABBBounds.empty() || this.parent && this._globalAABBBounds.transformWithMatrix(this.parent.globalTransMatrix), this._globalAABBBounds;
  }
  tryUpdateGlobalTransMatrix() {
    if (this._globalTransMatrix) {
      if (this.parent) {
        const m = this.parent.globalTransMatrix;
        this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
      }
    } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
    return this.shouldUpdateGlobalMatrix() && this.doUpdateGlobalMatrix(), this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !0;
  }
  tryUpdateLocalTransMatrix() {
    let clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    return this._transMatrix || (this._transMatrix = new Matrix()), this.shouldUpdateLocalMatrix() && (this.doUpdateLocalMatrix(), clearTag && this.clearUpdateLocalPositionTag()), this._transMatrix;
  }
  shouldUpdateAABBBounds() {
    return this.shadowRoot ? (!!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds()) && application.graphicService.validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this) : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) && application.graphicService.validCheck(this.attribute, this.getGraphicTheme(), this._AABBBounds, this);
  }
  shouldSelfChangeUpdateAABBBounds() {
    return this.shadowRoot ? !!(this._updateTag & UpdateTag.UPDATE_BOUNDS) || this.shadowRoot.shouldUpdateAABBBounds() : !!(this._updateTag & UpdateTag.UPDATE_BOUNDS);
  }
  shouldUpdateLocalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_LOCAL_MATRIX);
  }
  isValid() {
    var _a, _b;
    const attribute = this.attribute;
    return Number.isFinite((null !== (_a = attribute.x) && void 0 !== _a ? _a : 0) + (null !== (_b = attribute.y) && void 0 !== _b ? _b : 0));
  }
  _validNumber(num) {
    return null == num || Number.isFinite(num);
  }
  shouldUpdateShape() {
    return !!(this._updateTag & UpdateTag.UPDATE_SHAPE);
  }
  clearUpdateShapeTag() {
    this._updateTag &= UpdateTag.CLEAR_SHAPE;
  }
  containsPoint(x, y, mode, picker) {
    if (!picker) return !1;
    if (mode === IContainPointMode.GLOBAL) {
      const point = new Point(x, y);
      this.parent && this.parent.globalTransMatrix.transformPoint(point, point), x = point.x, y = point.y;
    }
    return picker.containsPoint(this, {
      x: x,
      y: y
    });
  }
  setAttributes(params) {
    let forceUpdateTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    let context = arguments.length > 2 ? arguments[2] : undefined;
    (params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params).background ? this.loadImage(params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic), this._setAttributes(params, forceUpdateTag, context);
  }
  _setAttributes(params) {
    let forceUpdateTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    let context = arguments.length > 2 ? arguments[2] : undefined;
    const keys = Object.keys(params);
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      this.attribute[key] = params[key];
    }
    this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTags(keys) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    var _a;
    const params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
      [key]: value
    }, this.attribute, key, context);
    params ? this._setAttributes(params, forceUpdateTag, context) : isNil$1(null === (_a = this.normalAttrs) || void 0 === _a ? void 0 : _a[key]) ? (this.attribute[key] = value, this.valid = this.isValid(), this.updateShapeAndBoundsTagSetted() || !forceUpdateTag && !this.needUpdateTag(key) ? this.addUpdateBoundTag() : this.addUpdateShapeAndBoundsTag(), this.addUpdatePositionTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context)) : this.normalAttrs[key] = value, "background" === key ? this.loadImage(value, !0) : "shadowGraphic" === key && this.setShadowGraphic(value);
  }
  needUpdateTags(keys) {
    let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GRAPHIC_UPDATE_TAG_KEY;
    for (let i = 0; i < k.length; i++) {
      const attrKey = k[i];
      if (-1 !== keys.indexOf(attrKey)) return !0;
    }
    return !1;
  }
  needUpdateTag(key) {
    let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : GRAPHIC_UPDATE_TAG_KEY;
    for (let i = 0; i < k.length; i++) {
      if (key === k[i]) return !0;
    }
    return !1;
  }
  initAttributes(params) {
    const context = {
      type: AttributeUpdateType.INIT
    };
    params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(params, this.attribute, null, context) || params, this.attribute = params, params.background ? this.loadImage(params.background, !0) : params.shadowGraphic && this.setShadowGraphic(params.shadowGraphic), this._updateTag = UpdateTag.INIT, this.valid = this.isValid(), this.onAttributeUpdate(context);
  }
  translate(x, y) {
    var _a, _b;
    if (0 === x && 0 === y) return this;
    const context = {
        type: AttributeUpdateType.TRANSLATE
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        x: x,
        y: y
      }, this.attribute, tempConstantXYKey, context);
    params && (x = params.x, y = params.y, delete params.x, delete params.y, this._setAttributes(params));
    const attribute = this.attribute,
      postMatrix = attribute.postMatrix;
    return postMatrix ? application.transformUtil.fromMatrix(postMatrix, postMatrix).translate(x, y) : (attribute.x = (null !== (_a = attribute.x) && void 0 !== _a ? _a : DefaultTransform.x) + x, attribute.y = (null !== (_b = attribute.y) && void 0 !== _b ? _b : DefaultTransform.y) + y), this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  translateTo(x, y) {
    const attribute = this.attribute;
    if (attribute.x === x && attribute.y === y) return this;
    const context = {
        type: AttributeUpdateType.TRANSLATE_TO
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        x: x,
        y: y
      }, this.attribute, tempConstantXYKey, context);
    return params ? (this._setAttributes(params, !1, context), this) : (attribute.x = x, attribute.y = y, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  scale(scaleX, scaleY, scaleCenter) {
    var _a, _b;
    if (1 === scaleX && 1 === scaleY) return this;
    const context = {
        type: AttributeUpdateType.SCALE
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        scaleX: scaleX,
        scaleY: scaleY,
        scaleCenter: scaleCenter
      }, this.attribute, tempConstantScaleXYKey, context);
    params && (scaleX = params.scaleX, scaleY = params.scaleY, delete params.scaleX, delete params.scaleY, this._setAttributes(params));
    const attribute = this.attribute;
    if (scaleCenter) {
      let {
        postMatrix: postMatrix
      } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).scale(scaleX, scaleY, scaleCenter);
    } else attribute.scaleX = (null !== (_a = attribute.scaleX) && void 0 !== _a ? _a : DefaultTransform.scaleX) * scaleX, attribute.scaleY = (null !== (_b = attribute.scaleY) && void 0 !== _b ? _b : DefaultTransform.scaleY) * scaleY;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  scaleTo(scaleX, scaleY) {
    const attribute = this.attribute;
    if (attribute.scaleX === scaleX && attribute.scaleY === scaleY) return this;
    const context = {
        type: AttributeUpdateType.SCALE_TO
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        scaleX: scaleX,
        scaleY: scaleY
      }, this.attribute, tempConstantScaleXYKey, context);
    return params ? (this._setAttributes(params, !1, context), this) : (attribute.scaleX = scaleX, attribute.scaleY = scaleY, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  rotate(angle, rotateCenter) {
    var _a;
    if (0 === angle) return this;
    const context = {
        type: AttributeUpdateType.ROTATE
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate({
        angle: angle,
        rotateCenter: rotateCenter
      }, this.attribute, tempConstantAngleKey, context);
    params && (delete params.angle, this._setAttributes(params, !1, context));
    const attribute = this.attribute;
    if (rotateCenter) {
      let {
        postMatrix: postMatrix
      } = this.attribute;
      postMatrix || (postMatrix = new Matrix(), attribute.postMatrix = postMatrix), application.transformUtil.fromMatrix(postMatrix, postMatrix).rotate(angle, rotateCenter);
    } else attribute.angle = (null !== (_a = attribute.angle) && void 0 !== _a ? _a : DefaultTransform.angle) + angle;
    return this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this;
  }
  rotateTo(angle) {
    const attribute = this.attribute;
    if (attribute.angle === angle) return this;
    const context = {
        type: AttributeUpdateType.ROTATE_TO
      },
      params = this.onBeforeAttributeUpdate && this.onBeforeAttributeUpdate(angle, this.attribute, tempConstantAngleKey, context);
    return params ? (this._setAttributes(params, !1, context), this) : (attribute.angle = angle, this.addUpdatePositionTag(), this.addUpdateBoundTag(), this.addUpdateLayoutTag(), this.onAttributeUpdate(context), this);
  }
  skewTo(b, c) {
    return this;
  }
  animate(params) {
    var _a;
    this.animates || (this.animates = new Map());
    const animate = new Animate(null == params ? void 0 : params.id, null !== (_a = null == params ? void 0 : params.timeline) && void 0 !== _a ? _a : this.stage && this.stage.getTimeline(), null == params ? void 0 : params.slience);
    if (animate.bind(this), params) {
      const {
        onStart: onStart,
        onFrame: onFrame,
        onEnd: onEnd,
        onRemove: onRemove
      } = params;
      null != onStart && animate.onStart(onStart), null != onFrame && animate.onFrame(onFrame), null != onEnd && animate.onEnd(onEnd), null != onRemove && animate.onRemove(onRemove), animate.interpolateFunc = params.interpolate;
    }
    return this.animates.set(animate.id, animate), animate.onRemove(() => {
      animate.stop(), this.animates.delete(animate.id);
    }), animate;
  }
  onAttributeUpdate(context) {
    context && context.skipUpdateCallback || (application.graphicService.onAttributeUpdate(this), this._emitCustomEvent("afterAttributeUpdate", context));
  }
  update(d) {
    d ? (d.bounds && this.tryUpdateAABBBounds(), d.trans && this.tryUpdateLocalTransMatrix()) : (this.tryUpdateAABBBounds(), this.tryUpdateLocalTransMatrix());
  }
  hasState(stateName) {
    return !(!this.currentStates || !this.currentStates.length) && (!!isNil$1(stateName) || this.currentStates.includes(stateName));
  }
  getState(stateName) {
    var _a;
    return null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
  }
  applyStateAttrs(attrs, stateNames, hasAnimation, isClear) {
    var _a, _b, _c, _d;
    if (hasAnimation) {
      const keys = Object.keys(attrs),
        noWorkAttrs = this.getNoWorkAnimateAttr(),
        animateAttrs = {};
      let noAnimateAttrs;
      keys.forEach(key => {
        noWorkAttrs[key] ? (noAnimateAttrs || (noAnimateAttrs = {}), noAnimateAttrs[key] = attrs[key]) : animateAttrs[key] = isClear && void 0 === attrs[key] ? this.getDefaultAttribute(key) : attrs[key];
      });
      const animate = this.animate({
        slience: !0
      });
      animate.stateNames = stateNames, animate.to(animateAttrs, null !== (_b = null === (_a = this.stateAnimateConfig) || void 0 === _a ? void 0 : _a.duration) && void 0 !== _b ? _b : DefaultStateAnimateConfig.duration, null !== (_d = null === (_c = this.stateAnimateConfig) || void 0 === _c ? void 0 : _c.easing) && void 0 !== _d ? _d : DefaultStateAnimateConfig.easing), noAnimateAttrs && this.setAttributes(noAnimateAttrs, !1, {
        type: AttributeUpdateType.STATE
      });
    } else this.stopStateAnimates(), this.setAttributes(attrs, !1, {
      type: AttributeUpdateType.STATE
    });
  }
  updateNormalAttrs(stateAttrs) {
    const newNormalAttrs = {};
    this.normalAttrs ? (Object.keys(stateAttrs).forEach(key => {
      key in this.normalAttrs ? (newNormalAttrs[key] = this.normalAttrs[key], delete this.normalAttrs[key]) : newNormalAttrs[key] = this.getNormalAttribute(key);
    }), Object.keys(this.normalAttrs).forEach(key => {
      stateAttrs[key] = this.normalAttrs[key];
    })) : Object.keys(stateAttrs).forEach(key => {
      newNormalAttrs[key] = this.getNormalAttribute(key);
    }), this.normalAttrs = newNormalAttrs;
  }
  stopStateAnimates() {
    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "end";
    this.animates && this.animates.forEach(animate => {
      animate.stateNames && (animate.stop(type), this.animates.delete(animate.id));
    });
  }
  getNormalAttribute(key) {
    let value = this.attribute[key];
    return this.animates && this.animates.forEach(animate => {
      if (animate.stateNames) {
        const endProps = animate.getEndProps();
        has$1(endProps, key) && (value = endProps[key]);
      }
    }), value;
  }
  clearStates(hasAnimation) {
    this.hasState() && this.normalAttrs ? (this.currentStates = [], this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0)) : this.currentStates = [], this.normalAttrs = null;
  }
  removeState(stateName, hasAnimation) {
    if (this.currentStates) {
      const filter = isArray$1(stateName) ? s => !stateName.includes(s) : s => s !== stateName,
        newStates = this.currentStates.filter(filter);
      newStates.length !== this.currentStates.length && this.useStates(newStates, hasAnimation);
    }
  }
  toggleState(stateName, hasAnimation) {
    if (this.hasState(stateName)) this.removeState(stateName, hasAnimation);else {
      if ((this.currentStates ? this.currentStates.indexOf(stateName) : -1) < 0) {
        const nextStates = this.currentStates ? this.currentStates.slice() : [];
        nextStates.push(stateName), this.useStates(nextStates, hasAnimation);
      }
    }
  }
  addState(stateName, keepCurrentStates, hasAnimation) {
    var _a;
    if (this.currentStates && this.currentStates.includes(stateName) && (keepCurrentStates || 1 === this.currentStates.length)) return;
    const newStates = keepCurrentStates && (null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) ? this.currentStates.concat([stateName]) : [stateName];
    this.useStates(newStates, hasAnimation);
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    const stateAttrs = {};
    states.forEach(stateName => {
      var _a;
      const attrs = this.stateProxy ? this.stateProxy(stateName, states) : null === (_a = this.states) || void 0 === _a ? void 0 : _a[stateName];
      attrs && Object.assign(stateAttrs, attrs);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  addUpdateShapeTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE;
  }
  addUpdateShapeAndBoundsTag() {
    this._updateTag |= UpdateTag.UPDATE_SHAPE_AND_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag(), this.glyphHost && this.glyphHost.addUpdateBoundTag();
  }
  updateShapeAndBoundsTagSetted() {
    return (this._updateTag & UpdateTag.UPDATE_SHAPE_AND_BOUNDS) === UpdateTag.UPDATE_SHAPE_AND_BOUNDS;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdatePositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_LOCAL_MATRIX;
  }
  addUpdateGlobalPositionTag() {
    this.shadowRoot && this.shadowRoot.addUpdateGlobalPositionTag(), this._updateTag |= UpdateTag.UPDATE_GLOBAL_MATRIX;
  }
  clearUpdateLocalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_LOCAL_MATRIX;
  }
  clearUpdateGlobalPositionTag() {
    this._updateTag &= UpdateTag.CLEAR_GLOBAL_MATRIX;
  }
  addUpdateLayoutTag() {
    this._updateTag |= UpdateTag.UPDATE_LAYOUT;
  }
  clearUpdateLayoutTag() {
    this._updateTag &= UpdateTag.CLEAR_LAYOUT;
  }
  needUpdateLayout() {
    return !!(this._updateTag & UpdateTag.UPDATE_LAYOUT);
  }
  getAnchor(anchor, params) {
    const _anchor = [0, 0],
      getBounds = () => {
        if (params.b) return params.b;
        const {
          scaleX: scaleX,
          scaleY: scaleY,
          angle: angle
        } = this.attribute;
        return tempBounds.copy(this._AABBBounds), this.setAttributes({
          scaleX: 1,
          scaleY: 1,
          angle: 0
        }), params.b = this.AABBBounds.clone(), this._AABBBounds.copy(tempBounds), this.setAttributes({
          scaleX: scaleX,
          scaleY: scaleY,
          angle: angle
        }), params.b;
      };
    if ("string" == typeof anchor[0]) {
      const ratio = parseFloat(anchor[0]) / 100,
        bounds = getBounds();
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor[0];
    if ("string" == typeof anchor[1]) {
      const ratio = parseFloat(anchor[1]) / 100,
        bounds = getBounds();
      _anchor[1] = bounds.y1 + (bounds.y2 - bounds.y1) * ratio;
    } else _anchor[1] = anchor[1];
    return _anchor;
  }
  doUpdateLocalMatrix() {
    const {
      x = DefaultTransform.x,
      y = DefaultTransform.y,
      scaleX = DefaultTransform.scaleX,
      scaleY = DefaultTransform.scaleY,
      angle = DefaultTransform.angle,
      scaleCenter: scaleCenter,
      anchor: anchor,
      postMatrix: postMatrix
    } = this.attribute;
    let _anchor = [0, 0];
    const params = {};
    if (anchor && (_anchor = this.getAnchor(anchor, params)), !scaleCenter || 1 === scaleX && 1 === scaleY) normalTransform(this._transMatrix, this._transMatrix.reset(), x, y, scaleX, scaleY, angle, anchor && _anchor);else {
      const m = this._transMatrix;
      m.reset(), m.translate(_anchor[0], _anchor[1]), m.rotate(angle), m.translate(-_anchor[0], -_anchor[1]), m.translate(x, y), _anchor = this.getAnchor(scaleCenter, params), application.transformUtil.fromMatrix(m, m).scale(scaleX, scaleY, {
        x: _anchor[0],
        y: _anchor[1]
      });
    }
    const p = this.getOffsetXY(DefaultTransform);
    if (this._transMatrix.e += p.x, this._transMatrix.f += p.y, postMatrix) {
      const m1 = tempMatrix.setValue(postMatrix.a, postMatrix.b, postMatrix.c, postMatrix.d, postMatrix.e, postMatrix.f),
        m2 = this._transMatrix;
      m1.multiply(m2.a, m2.b, m2.c, m2.d, m2.e, m2.f), m2.setValue(m1.a, m1.b, m1.c, m1.d, m1.e, m1.f);
    }
  }
  doUpdateGlobalMatrix() {
    if (this.parent) {
      this._globalTransMatrix.multiply(this.transMatrix.a, this.transMatrix.b, this.transMatrix.c, this.transMatrix.d, this.transMatrix.e, this.transMatrix.f);
      const {
        scrollX = 0,
        scrollY = 0
      } = this.parent.attribute;
      this._globalTransMatrix.translate(scrollX, scrollY);
    }
  }
  setStage(stage, layer) {
    if (this.stage !== stage) {
      if (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this.animates && this.animates.size) {
        const timeline = stage.getTimeline();
        this.animates.forEach(a => {
          a.timeline === defaultTimeline && a.setTimeline(timeline);
        });
      }
      this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage);
    }
  }
  setStageToShadowRoot(stage, layer) {
    this.shadowRoot && this.shadowRoot.setStage(stage, layer);
  }
  onAddStep(step) {}
  onStop(props) {
    props && this.setAttributes(props, !1, {
      type: AttributeUpdateType.ANIMATE_END
    });
  }
  onStep(subAnimate, animate, step, ratio, end) {
    const nextAttributes = {};
    if (step.customAnimate) step.customAnimate.update(end, ratio, nextAttributes);else {
      const nextProps = step.props,
        nextParsedProps = step.parsedProps,
        propKeys = step.propKeys;
      this.stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, void 0, nextParsedProps, propKeys);
    }
    this.setAttributes(nextAttributes, !1, {
      type: AttributeUpdateType.ANIMATE_UPDATE,
      animationState: {
        ratio: ratio,
        end: end,
        step: step,
        isFirstFrameOfStep: subAnimate.getLastStep() !== step
      }
    }), this.stage && this.stage.renderNextFrame();
  }
  stepInterpolate(subAnimate, animate, nextAttributes, step, ratio, end, nextProps, lastProps, nextParsedProps, propKeys) {
    propKeys || (propKeys = Object.keys(nextProps), step.propKeys = propKeys), end ? step.propKeys.forEach(key => {
      animate.validAttr(key) && (nextAttributes[key] = nextProps[key]);
    }) : propKeys.forEach(key => {
      var _a;
      if (!animate.validAttr(key)) return;
      const nextStepVal = nextProps[key],
        lastStepVal = null !== (_a = lastProps && lastProps[key]) && void 0 !== _a ? _a : subAnimate.getLastPropByName(key, step);
      if (null == nextStepVal || null == lastStepVal || nextStepVal === lastStepVal) return void (nextAttributes[key] = nextStepVal);
      let match;
      match = animate.interpolateFunc && animate.interpolateFunc(key, ratio, lastStepVal, nextStepVal, nextAttributes), match || (match = animate.customInterpolate(key, ratio, lastStepVal, nextStepVal, this, nextAttributes), match || this.defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) || this._interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes));
    }), step.parsedProps = nextParsedProps;
  }
  defaultInterpolate(nextStepVal, lastStepVal, key, nextAttributes, nextParsedProps, ratio) {
    if (Number.isFinite(nextStepVal) && Number.isFinite(lastStepVal)) return nextAttributes[key] = lastStepVal + (nextStepVal - lastStepVal) * ratio, !0;
    if ("fill" === key) {
      nextParsedProps || (nextParsedProps = {});
      const fillColorArray = nextParsedProps.fillColorArray,
        color = interpolateColor(lastStepVal, null != fillColorArray ? fillColorArray : nextStepVal, ratio, !1, (fArray, tArray) => {
          nextParsedProps.fillColorArray = tArray;
        });
      return color && (nextAttributes[key] = color), !0;
    }
    if ("stroke" === key) {
      nextParsedProps || (nextParsedProps = {});
      const strokeColorArray = nextParsedProps.strokeColorArray,
        color = interpolateColor(lastStepVal, null != strokeColorArray ? strokeColorArray : nextStepVal, ratio, !1, (fArray, tArray) => {
          nextParsedProps.strokeColorArray = tArray;
        });
      return color && (nextAttributes[key] = color), !0;
    }
    if ("shadowColor" === key) {
      nextParsedProps || (nextParsedProps = {});
      const shadowColorArray = nextParsedProps.shadowColorArray,
        color = interpolateColor(lastStepVal, null != shadowColorArray ? shadowColorArray : nextStepVal, ratio, !0, (fArray, tArray) => {
          nextParsedProps.shadowColorArray = tArray;
        });
      return color && (nextAttributes[key] = color), !0;
    }
    if (Array.isArray(nextStepVal) && nextStepVal.length === lastStepVal.length) {
      const nextList = [];
      let valid = !0;
      for (let i = 0; i < nextStepVal.length; i++) {
        const v = lastStepVal[i],
          val = v + (nextStepVal[i] - v) * ratio;
        if (!Number.isFinite(val)) {
          valid = !1;
          break;
        }
        nextList.push(val);
      }
      valid && (nextAttributes[key] = nextList);
    }
    return !1;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {}
  getDefaultAttribute(name) {
    return this.getGraphicTheme()[name];
  }
  getComputedAttribute(name) {
    var _a;
    return null !== (_a = this.attribute[name]) && void 0 !== _a ? _a : this.getDefaultAttribute(name);
  }
  onSetStage(cb) {
    let immediate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    this._onSetStage = cb, immediate && this.stage && cb(this, this.stage);
  }
  attachShadow(shadowRoot) {
    return shadowRoot && (shadowRoot.shadowHost = this), this.shadowRoot = null != shadowRoot ? shadowRoot : application.graphicService.creator.shadowRoot(this), this.addUpdateBoundTag(), this.shadowRoot.setStage(this.stage, this.layer), this.shadowRoot;
  }
  detachShadow() {
    this.shadowRoot && (this.addUpdateBoundTag(), this.shadowRoot.release(!0), this.shadowRoot = null);
  }
  toJson() {
    return {
      attribute: this.attribute,
      _uid: this._uid,
      type: this.type,
      name: this.name,
      children: this.children.map(item => item.toJson())
    };
  }
  createPathProxy(path) {
    return isString$1(path, !0) ? this.pathProxy = new CustomPath2D().fromString(path) : this.pathProxy = new CustomPath2D(), this.pathProxy;
  }
  loadImage(image) {
    let background = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    if (!image || background && backgroundNotImage(image)) return;
    const url = image;
    this.resources || (this.resources = new Map());
    const cache = {
      data: "init",
      state: null
    };
    this.resources.set(url, cache), "string" == typeof image ? (cache.state = "loading", image.startsWith("<svg") ? (ResourceLoader.GetSvg(image, this), this.backgroundImg = this.backgroundImg || background) : (isValidUrl$1(image) || image.includes("/") || isBase64$1(image)) && (ResourceLoader.GetImage(image, this), this.backgroundImg = this.backgroundImg || background)) : isObject$1(image) ? (cache.state = "success", cache.data = image, this.backgroundImg = this.backgroundImg || background) : cache.state = "fail";
  }
  setShadowGraphic(graphic) {
    if (graphic) {
      this.attachShadow().add(graphic);
    } else this.detachShadow();
  }
  imageLoadSuccess(url, image, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "success", res.data = image, cb && cb(), this.addUpdateBoundTag(), this.stage && this.stage.renderNextFrame());
  }
  imageLoadFail(url, cb) {
    if (!this.resources) return;
    const res = this.resources.get(url);
    res && (res.state = "fail", cb && cb());
  }
  _stopAnimates(animates) {
    animates && animates.forEach(animate => {
      animate.stop();
    });
  }
  stopAnimates() {
    let stopChildren = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    this._stopAnimates(this.animates), this.shadowRoot && this.shadowRoot.stopAnimates(!0), this.isContainer && stopChildren && this.forEachChildren(c => {
      c.stopAnimates(stopChildren);
    });
  }
  release() {
    this.releaseStatus = "released", this.stopAnimates(), application.graphicService.onRelease(this);
  }
  _emitCustomEvent(type, context) {
    var _a, _b;
    if (this._events && type in this._events) {
      const changeEvent = new CustomEvent(type, context);
      changeEvent.bubbles = !1, changeEvent.manager = null === (_b = null === (_a = this.stage) || void 0 === _a ? void 0 : _a.eventSystem) || void 0 === _b ? void 0 : _b.manager, this.dispatchEvent(changeEvent);
    }
  }
}
function backgroundNotImage(image) {
  return !(!image.fill && !image.stroke);
}
Graphic.userSymbolMap = {}, Graphic.mixin(EventTarget);

var GroupUpdateAABBBoundsMode;
!function (GroupUpdateAABBBoundsMode) {
  GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.LESS_GROUP = 0] = "LESS_GROUP", GroupUpdateAABBBoundsMode[GroupUpdateAABBBoundsMode.MORE_GROUP = 1] = "MORE_GROUP";
}(GroupUpdateAABBBoundsMode || (GroupUpdateAABBBoundsMode = {}));
class Group extends Graphic {
  constructor(params) {
    super(params), this.type = "group", this.parent = null, this.isContainer = !0, this.numberType = GROUP_NUMBER_TYPE, this._childUpdateTag = UpdateTag.UPDATE_BOUNDS;
  }
  setMode(mode) {
    "3d" === mode ? this.set3dMode() : this.set2dMode();
  }
  set3dMode() {
    this.in3dMode = !0;
  }
  set2dMode() {
    this.in3dMode = !1;
  }
  setTheme(t) {
    return this.theme || (this.theme = new Theme()), this.theme.setTheme(t, this);
  }
  createTheme() {
    this.theme || (this.theme = new Theme());
  }
  visibleAll(visible) {
    this.setAttribute("visible", visible), this.forEachChildren(item => {
      item.isContainer && item.visibleAll ? item.visibleAll(visible) : item.setAttribute("visible", visible);
    });
  }
  hideAll() {
    this.visibleAll(!1);
  }
  showAll() {
    this.visibleAll(!0);
  }
  containsPoint(x, y, mode) {
    if (mode === IContainPointMode.GLOBAL) {
      const point = new Point(x, y);
      return this.parent && this.parent.globalTransMatrix.transformPoint(point, point), this.AABBBounds.contains(point.x, point.y);
    }
    return this.AABBBounds.contains(x, y);
  }
  shouldUpdateAABBBounds() {
    return !!super.shouldUpdateAABBBounds() || !!(this._childUpdateTag & UpdateTag.UPDATE_BOUNDS);
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    application.graphicService.beforeUpdateAABBBounds(this, this.stage, !0, this._AABBBounds);
    const selfChange = this.shouldSelfChangeUpdateAABBBounds(),
      bounds = this.doUpdateAABBBounds();
    return this.addUpdateLayoutTag(), application.graphicService.afterUpdateAABBBounds(this, this.stage, this._AABBBounds, this, selfChange), "empty" === this.attribute.boundsMode && bounds.clear(), bounds;
  }
  doUpdateLocalMatrix() {
    const {
      x = DefaultTransform.x,
      y = DefaultTransform.y,
      dx = DefaultTransform.dx,
      dy = DefaultTransform.dy,
      scaleX = DefaultTransform.scaleX,
      scaleY = DefaultTransform.scaleY,
      angle = DefaultTransform.angle,
      postMatrix: postMatrix
    } = this.attribute;
    if (0 !== x || 0 !== y || 0 !== dx || 0 !== dy || 1 !== scaleX || 1 !== scaleY || 0 !== angle || postMatrix) return super.doUpdateLocalMatrix();
    this._transMatrix.reset();
  }
  getGraphicTheme() {
    return getTheme(this).group;
  }
  updateAABBBounds(attribute, groupTheme, aabbBounds) {
    const originalAABBBounds = aabbBounds;
    aabbBounds = aabbBounds.clone();
    const {
      width: width,
      height: height,
      path: path,
      clip = groupTheme.clip
    } = attribute;
    if (path && path.length ? path.forEach(g => {
      aabbBounds.union(g.AABBBounds);
    }) : null != width && null != height && aabbBounds.set(0, 0, Math.max(0, width), Math.max(0, height)), !clip) {
      this.forEachChildren(node => {
        aabbBounds.union(node.AABBBounds);
      });
      const {
        scrollX = 0,
        scrollY = 0
      } = attribute;
      aabbBounds.translate(scrollX, scrollY);
    }
    return application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, groupTheme, !1, this), originalAABBBounds.copy(aabbBounds), originalAABBBounds;
  }
  doUpdateAABBBounds() {
    this.updateAABBBoundsStamp++;
    const bounds = super.doUpdateAABBBounds();
    return this.parent && this.parent.addChildUpdateBoundTag(), this._emitCustomEvent("AAABBBoundsChange"), bounds;
  }
  clearUpdateBoundTag() {
    this._updateTag &= UpdateTag.CLEAR_BOUNDS, this._childUpdateTag &= UpdateTag.CLEAR_BOUNDS;
  }
  addUpdateBoundTag() {
    this._updateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag();
  }
  addChildUpdateBoundTag() {
    this._childUpdateTag & UpdateTag.UPDATE_BOUNDS || (this._childUpdateTag |= UpdateTag.UPDATE_BOUNDS, this.parent && this.parent.addChildUpdateBoundTag());
  }
  getTheme() {
    return this.theme.getTheme(this);
  }
  incrementalAppendChild(node) {
    const data = super.appendChild(node);
    return this.stage && data && (data.stage = this.stage, data.layer = this.layer), this.addUpdateBoundTag(), application.graphicService.onAddIncremental(node, this, this.stage), data;
  }
  incrementalClearChild() {
    super.removeAllChild(), this.addUpdateBoundTag(), application.graphicService.onClearIncremental(this, this.stage);
  }
  _updateChildToStage(child) {
    return this.stage && child && child.setStage(this.stage, this.layer), this.addUpdateBoundTag(), child;
  }
  appendChild(node) {
    let addStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    const data = super.appendChild(node);
    return addStage && this.stage && data && data.setStage(this.stage, this.layer), this.addUpdateBoundTag(), data;
  }
  insertBefore(newNode, referenceNode) {
    return this._updateChildToStage(super.insertBefore(newNode, referenceNode));
  }
  insertAfter(newNode, referenceNode) {
    return this._updateChildToStage(super.insertAfter(newNode, referenceNode));
  }
  insertInto(newNode, idx) {
    return this._updateChildToStage(super.insertInto(newNode, idx));
  }
  removeChild(child) {
    const data = super.removeChild(child);
    return child.stage = null, application.graphicService.onRemove(child), this.addUpdateBoundTag(), data;
  }
  removeAllChild() {
    let deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    this.forEachChildren(child => {
      application.graphicService.onRemove(child), deep && child.isContainer && child.removeAllChild(deep);
    }), super.removeAllChild(), this.addUpdateBoundTag();
  }
  setStage(stage, layer) {
    this.stage !== stage && (this.stage = stage, this.layer = layer, this.setStageToShadowRoot(stage, layer), this._onSetStage && this._onSetStage(this, stage, layer), application.graphicService.onSetStage(this, stage), this.forEachChildren(item => {
      item.setStage(stage, this.layer);
    }));
  }
  addUpdatePositionTag() {
    super.addUpdatePositionTag(), this.forEachChildren(g => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  addUpdateGlobalPositionTag() {
    super.addUpdateGlobalPositionTag(), this.forEachChildren(g => {
      g.isContainer && g.addUpdateGlobalPositionTag();
    });
  }
  tryUpdateGlobalTransMatrix() {
    let clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    if (this.shouldUpdateGlobalMatrix()) {
      if (this._globalTransMatrix) {
        if (this.parent) {
          const m = this.parent.globalTransMatrix;
          this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f);
        }
      } else this._globalTransMatrix = this.parent ? this.parent.globalTransMatrix.clone() : this.transMatrix.clone();
      this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  shouldUpdateGlobalMatrix() {
    return !!(this._updateTag & UpdateTag.UPDATE_GLOBAL_MATRIX);
  }
  _getChildByName(name, deep) {
    return this.find(node => node.name === name, deep);
  }
  createOrUpdateChild(graphicName, attributes, graphicType) {
    let graphic = this._getChildByName(graphicName);
    return graphic ? graphic.setAttributes(attributes) : (graphic = application.graphicService.creator[graphicType](attributes), graphic.name = graphicName, this.add(graphic)), graphic;
  }
  clone() {
    return new Group(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Group.NOWORK_ANIMATE_ATTR;
  }
  release(all) {
    all && this.forEachChildren(g => {
      g.release(all);
    }), super.release();
  }
}
Group.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGroup(attributes) {
  return new Group(attributes);
}

class Layer extends Group {
  get offscreen() {
    return this.layerHandler.offscreen;
  }
  get layerMode() {
    return this.layerHandler.type;
  }
  get width() {
    return this.stage ? this.stage.width : 0;
  }
  get height() {
    return this.stage ? this.stage.height : 0;
  }
  get viewWidth() {
    return this.stage ? this.stage.viewWidth : 0;
  }
  get viewHeight() {
    return this.stage ? this.stage.viewHeight : 0;
  }
  get dirtyBound() {
    throw new Error("暂不支持");
  }
  get dpr() {
    return this._dpr;
  }
  constructor(stage, global, window, params) {
    var _a;
    super({}), this.stage = stage, this.global = global, this.window = window, this.main = params.main, this.layerHandler = params.layerHandler, this.layerHandler.init(this, window, {
      main: params.main,
      canvasId: params.canvasId,
      width: this.viewWidth,
      height: this.viewHeight,
      zIndex: null !== (_a = params.zIndex) && void 0 !== _a ? _a : 0
    }), this.layer = this, this.subLayers = new Map(), this.theme = new Theme(), this.background = "rgba(0, 0, 0, 0)", this.afterDrawCbs = [];
  }
  combineSubLayer() {
    let removeIncrementalKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    const subLayers = Array.from(this.subLayers.values()).sort((a, b) => a.zIndex - b.zIndex);
    this.layerHandler.merge(subLayers.map(l => (l.layer.subLayers.size && l.layer.combineSubLayer(removeIncrementalKey), l.layer.getNativeHandler()))), removeIncrementalKey && subLayers.forEach(l => {
      l.group && (l.group.incremental = 0);
    }), subLayers.forEach(l => {
      application.layerService.releaseLayer(this.stage, l.layer);
    }), this.subLayers.clear();
  }
  getNativeHandler() {
    return this.layerHandler;
  }
  setStage(stage, layer) {
    super.setStage(stage, this);
  }
  pick(x, y) {
    throw new Error("暂不支持");
  }
  tryRenderSecondaryLayer(params, userParams) {
    this.layerHandler.secondaryHandlers && this.layerHandler.secondaryHandlers.length && this.layerHandler.secondaryHandlers.forEach(h => {
      h.layer.renderCount = this.renderCount, h.layer.render(params, userParams);
    });
  }
  render(params, userParams) {
    var _a;
    this.layerHandler.render([this], {
      renderService: params.renderService,
      stage: this.stage,
      layer: this,
      viewBox: params.viewBox,
      transMatrix: params.transMatrix,
      background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
      updateBounds: params.updateBounds
    }, userParams), this.afterDrawCbs.forEach(c => c(this)), this.tryRenderSecondaryLayer(params, userParams);
  }
  resize(w, h) {
    this.layerHandler.resize(w, h);
  }
  resizeView(w, h) {
    this.layerHandler.resizeView(w, h);
  }
  setDpr(dpr) {
    this.layerHandler.setDpr(dpr);
  }
  afterDraw(cb) {
    this.afterDrawCbs.push(cb);
  }
  startAnimate(t) {
    throw new Error("暂不支持");
  }
  setToFrame(t) {
    throw new Error("暂不支持");
  }
  prepare(dirtyBounds, params) {}
  release() {
    super.release(), this.layerHandler.release(), this.subLayers && this.subLayers.forEach(l => {
      application.layerService.releaseLayer(this.stage, l.layer);
    });
  }
  drawTo(target, params) {
    var _a;
    this.layerHandler.drawTo(target, [this], Object.assign({
      background: null !== (_a = params.background) && void 0 !== _a ? _a : this.background,
      renderService: params.renderService,
      viewBox: params.viewBox,
      transMatrix: params.transMatrix,
      stage: this.stage,
      layer: this
    }, params)), this.afterDrawCbs.forEach(c => c(this));
  }
}

const TransformUtil = Symbol.for("TransformUtil");
const GraphicUtil = Symbol.for("GraphicUtil");
const LayerService = Symbol.for("LayerService");
const StaticLayerHandlerContribution = Symbol.for("StaticLayerHandlerContribution");
const DynamicLayerHandlerContribution = Symbol.for("DynamicLayerHandlerContribution");
const VirtualLayerHandlerContribution = Symbol.for("VirtualLayerHandlerContribution");

var DefaultLayerService_1,
  __decorate$1G = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1h = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let DefaultLayerService = DefaultLayerService_1 = class {
  static GenerateLayerId() {
    return `${DefaultLayerService_1.idprefix}_${DefaultLayerService_1.prefix_count++}`;
  }
  constructor() {
    this.layerMap = new Map(), this.global = application.global;
  }
  tryInit() {
    this.inited || (this.staticLayerCountInEnv = this.global.getStaticCanvasCount(), this.dynamicLayerCountInEnv = this.global.getDynamicCanvasCount(), this.inited = !0);
  }
  getStageLayer(stage) {
    return this.layerMap.get(stage);
  }
  getRecommendedLayerType(layerMode) {
    return layerMode || (0 !== this.staticLayerCountInEnv ? "static" : 0 !== this.dynamicLayerCountInEnv ? "dynamic" : "virtual");
  }
  getLayerHandler(layerMode) {
    let layerHandler;
    return layerHandler = "static" === layerMode ? container.get(StaticLayerHandlerContribution) : "dynamic" === layerMode ? container.get(DynamicLayerHandlerContribution) : container.get(VirtualLayerHandlerContribution), layerHandler;
  }
  createLayer(stage) {
    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      main: !1
    };
    var _a;
    this.tryInit();
    let layerMode = this.getRecommendedLayerType(options.layerMode);
    layerMode = options.main || options.canvasId ? "static" : layerMode;
    const layerHandler = this.getLayerHandler(layerMode),
      layer = new Layer(stage, this.global, stage.window, Object.assign(Object.assign({
        main: !1
      }, options), {
        layerMode: layerMode,
        canvasId: null !== (_a = options.canvasId) && void 0 !== _a ? _a : DefaultLayerService_1.GenerateLayerId(),
        layerHandler: layerHandler
      })),
      stageLayers = this.layerMap.get(stage) || [];
    return stageLayers.push(layer), this.layerMap.set(stage, stageLayers), this.staticLayerCountInEnv--, layer;
  }
  prepareStageLayer(stage) {
    let mainHandler;
    stage.forEachChildren(l => {
      const handler = l.getNativeHandler();
      "virtual" === handler.type ? (handler.mainHandler = mainHandler, mainHandler.secondaryHandlers.push(handler)) : (mainHandler = handler, mainHandler.secondaryHandlers = []);
    });
  }
  releaseLayer(stage, layer) {
    layer.release();
    const stageLayers = this.layerMap.get(stage) || [];
    this.layerMap.set(stage, stageLayers.filter(l => l !== layer));
  }
  layerCount(stage) {
    return (this.layerMap.get(stage) || []).length;
  }
  restLayerCount(stage) {
    return "browser" === this.global.env ? 10 : 0;
  }
  releaseStage(stage) {
    this.layerMap.delete(stage);
  }
};
DefaultLayerService.idprefix = "visactor_layer", DefaultLayerService.prefix_count = 0, DefaultLayerService = DefaultLayerService_1 = __decorate$1G([injectable(), __metadata$1h("design:paramtypes", [])], DefaultLayerService);

var coreModule = new ContainerModule(bind => {
  bind(VGlobal).to(DefaultGlobal).inSingletonScope(), bind(VWindow).to(DefaultWindow), bind(GraphicUtil).to(DefaultGraphicUtil).inSingletonScope(), bind(TransformUtil).to(DefaultTransformUtil).inSingletonScope(), bind(LayerService).to(DefaultLayerService).inSingletonScope();
});

function runFill(fill, background) {
  return !(!fill && !background);
}
function runStroke(stroke, lineWidth) {
  let s;
  return s = isArray$1(stroke) ? stroke.some(item => item || void 0 === item) : !!stroke, s && lineWidth > 0;
}
function fillVisible(opacity, fillOpacity, fill) {
  return fill && opacity * fillOpacity > 0;
}
function rectFillVisible(opacity, fillOpacity, width, height, fill) {
  return fill && opacity * fillOpacity > 0 && 0 !== width && 0 !== height;
}
function strokeVisible(opacity, strokeOpacity) {
  return opacity * strokeOpacity > 0;
}
function rectStrokeVisible(opacity, strokeOpacity, width, height) {
  return opacity * strokeOpacity > 0 && 0 !== width && 0 !== height;
}
function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  const x10 = x1 - x0,
    y10 = y1 - y0,
    x32 = x3 - x2,
    y32 = y3 - y2;
  let t = y32 * x10 - x32 * y10;
  return t * t < epsilon ? [] : (t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / t, [x0 + t * x10, y0 + t * y10]);
}
function cornerTangents(x0, y0, x1, y1, r1, rc, clockwise) {
  const x01 = x0 - x1,
    y01 = y0 - y1,
    lo = (clockwise ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01),
    ox = lo * y01,
    oy = -lo * x01,
    x11 = x0 + ox,
    y11 = y0 + oy,
    x10 = x1 + ox,
    y10 = y1 + oy,
    x00 = (x11 + x10) / 2,
    y00 = (y11 + y10) / 2,
    dx = x10 - x11,
    dy = y10 - y11,
    d2 = dx * dx + dy * dy,
    r = r1 - rc,
    D = x11 * y10 - x10 * y11,
    d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D));
  let cx0 = (D * dy - dx * d) / d2,
    cy0 = (-D * dx - dy * d) / d2;
  const cx1 = (D * dy + dx * d) / d2,
    cy1 = (-D * dx + dy * d) / d2,
    dx0 = cx0 - x00,
    dy0 = cy0 - y00,
    dx1 = cx1 - x00,
    dy1 = cy1 - y00;
  return dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 && (cx0 = cx1, cy0 = cy1), {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}
function calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius) {
  const deltaAngle = abs(endAngle - startAngle),
    cornerRadius = arc.getParsedCornerRadius(),
    cornerRadiusIsArray = isArray$1(cornerRadius),
    {
      outerDeltaAngle: outerDeltaAngle,
      innerDeltaAngle: innerDeltaAngle,
      outerStartAngle: outerStartAngle,
      outerEndAngle: outerEndAngle,
      innerEndAngle: innerEndAngle,
      innerStartAngle: innerStartAngle
    } = arc.getParsePadAngle(startAngle, endAngle),
    outerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[0] : cornerRadius,
    outerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[1] : cornerRadius,
    innerCornerRadiusEnd = cornerRadiusIsArray ? cornerRadius[2] : cornerRadius,
    innerCornerRadiusStart = cornerRadiusIsArray ? cornerRadius[3] : cornerRadius,
    maxOuterCornerRadius = Math.max(outerCornerRadiusEnd, outerCornerRadiusStart),
    maxInnerCornerRadius = Math.max(innerCornerRadiusEnd, innerCornerRadiusStart);
  let limitedOcr = maxOuterCornerRadius,
    limitedIcr = maxInnerCornerRadius;
  const xors = outerRadius * cos(outerStartAngle),
    yors = outerRadius * sin(outerStartAngle),
    xire = innerRadius * cos(innerEndAngle),
    yire = innerRadius * sin(innerEndAngle);
  let xore, yore, xirs, yirs;
  if ((maxInnerCornerRadius > epsilon || maxOuterCornerRadius > epsilon) && (xore = outerRadius * cos(outerEndAngle), yore = outerRadius * sin(outerEndAngle), xirs = innerRadius * cos(innerStartAngle), yirs = innerRadius * sin(innerStartAngle), deltaAngle < pi)) {
    const oc = intersect(xors, yors, xirs, yirs, xore, yore, xire, yire);
    if (oc) {
      const ax = xors - oc[0],
        ay = yors - oc[1],
        bx = xore - oc[0],
        by = yore - oc[1],
        kc = 1 / sin(acos((ax * bx + ay * by) / (sqrt(ax * ax + ay * ay) * sqrt(bx * bx + by * by))) / 2),
        lc = sqrt(oc[0] * oc[0] + oc[1] * oc[1]);
      limitedIcr = min(maxInnerCornerRadius, (innerRadius - lc) / (kc - 1)), limitedOcr = min(maxOuterCornerRadius, (outerRadius - lc) / (kc + 1));
    }
  }
  return {
    outerDeltaAngle: outerDeltaAngle,
    xors: xors,
    yors: yors,
    xirs: xirs,
    yirs: yirs,
    xore: xore,
    yore: yore,
    xire: xire,
    yire: yire,
    limitedOcr: limitedOcr,
    limitedIcr: limitedIcr,
    outerCornerRadiusStart: outerCornerRadiusStart,
    outerCornerRadiusEnd: outerCornerRadiusEnd,
    maxOuterCornerRadius: maxOuterCornerRadius,
    maxInnerCornerRadius: maxInnerCornerRadius,
    outerStartAngle: outerStartAngle,
    outerEndAngle: outerEndAngle,
    innerDeltaAngle: innerDeltaAngle,
    innerEndAngle: innerEndAngle,
    innerStartAngle: innerStartAngle,
    innerCornerRadiusStart: innerCornerRadiusStart,
    innerCornerRadiusEnd: innerCornerRadiusEnd
  };
}
function drawArcPath$1(arc, context, cx, cy, outerRadius, innerRadius, partStroke) {
  const {
      startAngle: startAngle,
      endAngle: endAngle
    } = arc.getParsedAngle(),
    deltaAngle = abs(endAngle - startAngle),
    clockwise = endAngle > startAngle;
  let collapsedToLine = !1;
  if (outerRadius < innerRadius) {
    const temp = outerRadius;
    outerRadius = innerRadius, innerRadius = temp;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle)), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise));else {
    const {
      outerDeltaAngle: outerDeltaAngle,
      xors: xors,
      yors: yors,
      xirs: xirs,
      yirs: yirs,
      limitedOcr: limitedOcr,
      outerCornerRadiusStart: outerCornerRadiusStart,
      outerCornerRadiusEnd: outerCornerRadiusEnd,
      maxOuterCornerRadius: maxOuterCornerRadius,
      xore: xore,
      yore: yore,
      xire: xire,
      yire: yire,
      outerStartAngle: outerStartAngle,
      outerEndAngle: outerEndAngle,
      limitedIcr: limitedIcr,
      innerDeltaAngle: innerDeltaAngle,
      innerEndAngle: innerEndAngle,
      innerStartAngle: innerStartAngle,
      innerCornerRadiusStart: innerCornerRadiusStart,
      innerCornerRadiusEnd: innerCornerRadiusEnd,
      maxInnerCornerRadius: maxInnerCornerRadius
    } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
    if (outerDeltaAngle < .001) partStroke && (partStroke[3] || partStroke[1]) && context.moveTo(cx + xors, cy + yors), collapsedToLine = !0;else if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
        cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
        t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
        t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd ? !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise)) : context.moveTo(cx + t0.cx + limitedOcr * cos(atan2(t1.y01, t1.x01)), cy + t0.cy + limitedOcr * sin(atan2(t1.y01, t1.x01))) : !partStroke || partStroke[0] ? (context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), cornerRadiusStart > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusStart, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, outerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusEnd > 0 ? context.moveTo(cx + t1.cx + cornerRadiusEnd * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusEnd * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xore, cy + outerRadius * sin(outerEndAngle));
    } else !partStroke || partStroke[0] ? (context.moveTo(cx + xors, cy + yors), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise)) : context.moveTo(cx + outerRadius * cos(outerEndAngle), cy + outerRadius * sin(outerEndAngle));
    if (!(innerRadius > epsilon) || innerDeltaAngle < .001) !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
        cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
        t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)),
        t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (!partStroke || partStroke[1] ? context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01) : context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        !partStroke || partStroke[2] ? context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise) : context.moveTo(cx + t0.cx + cos(arcEndAngle), cy + t0.cy + sin(arcEndAngle));
      } else !partStroke || partStroke[2] ? (cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise), context.arc(cx, cy, innerRadius, atan2(t0.cy + t0.y11, t0.cx + t0.x11), atan2(t1.cy + t1.y11, t1.cx + t1.x11), clockwise), cornerRadiusStart > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusStart, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise)) : cornerRadiusStart > 0 ? context.moveTo(cx + t1.cx + cornerRadiusStart * cos(atan2(t1.y01, t1.x01)), cy + t1.cy + cornerRadiusStart * sin(atan2(t1.y01, t1.x01))) : context.moveTo(cx + xirs, cy + yirs);
    } else !partStroke || partStroke[1] ? context.lineTo(cx + xire, cy + yire) : context.moveTo(cx + xire, cy + yire), !partStroke || partStroke[2] ? context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise) : context.moveTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
  }
  return partStroke ? partStroke[3] && context.lineTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle)) : context.closePath(), collapsedToLine;
}

class ConicalCanvas {
  static GetCanvas() {
    try {
      return ConicalCanvas.canvas || (ConicalCanvas.canvas = application.global.createCanvas({})), ConicalCanvas.canvas;
    } catch (err) {
      return null;
    }
  }
  static GetCtx() {
    if (!ConicalCanvas.ctx) {
      const conicalCanvas = ConicalCanvas.GetCanvas();
      ConicalCanvas.ctx = conicalCanvas.getContext("2d");
    }
    return ConicalCanvas.ctx;
  }
}
class ColorInterpolate extends LRU {
  static getInstance() {
    return ColorInterpolate._instance || (ColorInterpolate._instance = new ColorInterpolate()), ColorInterpolate._instance;
  }
  constructor() {
    let stops = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    let precision = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;
    super(), this.cacheParams = {
      CLEAN_THRESHOLD: 100,
      L_TIME: 1e3
    }, this.dataMap = new Map();
    const canvas = ConicalCanvas.GetCanvas(),
      conicalCtx = ConicalCanvas.GetCtx();
    if (canvas.width = precision, canvas.height = 1, !conicalCtx) return;
    if (conicalCtx.translate(0, 0), !conicalCtx) throw new Error("获取ctx发生错误");
    const gradient = conicalCtx.createLinearGradient(0, 0, precision, 0);
    stops.forEach(stop => {
      gradient.addColorStop(stop[0], stop[1]);
    }), conicalCtx.fillStyle = gradient, conicalCtx.fillRect(0, 0, precision, 1), this.rgbaSet = conicalCtx.getImageData(0, 0, precision, 1).data;
  }
  getColor(offset) {
    const rgba = this.rgbaSet.slice(4 * offset, 4 * offset + 4);
    return `rgba(${rgba[0]}, ${rgba[1]}, ${rgba[2]}, ${rgba[3] / 255})`;
  }
  GetOrCreate(x, y, w, h) {
    let stops = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];
    let precision = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 100;
    let str = `${x}${y}${w}${h}`;
    stops.forEach(item => str += item.join()), str += precision;
    let colorInter = this.dataMap.get(str);
    if (!colorInter) {
      colorInter = {
        data: new ColorInterpolate(stops, precision),
        timestamp: []
      }, this.addLimitedTimestamp(colorInter, Date.now(), {}), this.dataMap.set(str, colorInter);
    }
    return this.clearCache(this.dataMap, this.cacheParams), colorInter.data;
  }
}
class ConicalPatternStore {
  static GetSize(minSize) {
    for (let i = 0; i < ConicalPatternStore.ImageSize.length; i++) if (ConicalPatternStore.ImageSize[i] >= minSize) return ConicalPatternStore.ImageSize[i];
    return minSize;
  }
  static Get(stops, x, y, startAngle, endAngle, w, h) {
    const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle),
      data = ConicalPatternStore.cache[key];
    if (!data || 0 === data.length) return null;
    for (let i = 0; i < data.length; i++) if (data[i].width >= w && data[i].height >= h) return data[i].pattern;
    return null;
  }
  static Set(stops, x, y, startAngle, endAngle, pattern, w, h) {
    const key = ConicalPatternStore.GenKey(stops, x, y, startAngle, endAngle);
    ConicalPatternStore.cache[key] ? ConicalPatternStore.cache[key].push({
      width: w,
      height: h,
      pattern: pattern
    }) : ConicalPatternStore.cache[key] = [{
      width: w,
      height: h,
      pattern: pattern
    }];
  }
  static GenKey(stops, x, y, startAngle, endAngle) {
    return `${x},${y},${startAngle},${endAngle},${stops.join()}`;
  }
}
ConicalPatternStore.cache = {}, ConicalPatternStore.ImageSize = [20, 40, 80, 160, 320, 640, 1280, 2560];
function getConicGradientAt(x, y, angle, color) {
  const {
    stops: stops,
    startAngle: startAngle,
    endAngle: endAngle
  } = color;
  for (; angle < 0;) angle += pi2;
  for (; angle > pi2;) angle -= pi2;
  if (angle < startAngle) return stops[0].color;
  if (angle > endAngle) return stops[0].color;
  let startStop,
    endStop,
    percent = (angle - startAngle) / (endAngle - startAngle);
  for (let i = 0; i < stops.length; i++) if (stops[i].offset >= percent) {
    startStop = stops[i - 1], endStop = stops[i];
    break;
  }
  return percent = (percent - startStop.offset) / (endStop.offset - startStop.offset), interpolateColor(startStop.color, endStop.color, percent, !1);
}
function createConicalGradient(context, stops, x, y, deltaAngle, startAngle, endAngle, minW, minH) {
  const deltaDeg = Math.floor(180 * deltaAngle / Math.PI),
    conicalCanvas = ConicalCanvas.GetCanvas(),
    conicalCtx = ConicalCanvas.GetCtx();
  if (!conicalCtx) return null;
  const width = ConicalPatternStore.GetSize(minW),
    height = ConicalPatternStore.GetSize(minH);
  let pattern = ConicalPatternStore.Get(stops, x, y, startAngle, endAngle, width, height);
  if (pattern) return pattern;
  const r = Math.sqrt(Math.max(Math.max(Math.pow(x, 2) + Math.pow(y, 2), Math.pow(width - x, 2) + Math.pow(y, 2)), Math.max(Math.pow(width - x, 2) + Math.pow(height - y, 2), Math.pow(x, 2) + Math.pow(height - y, 2)))),
    stepNum = deltaDeg + 1,
    step = deltaAngle / Math.max(1, stepNum - 1),
    colorInter = ColorInterpolate.getInstance().GetOrCreate(x, y, width, height, stops, stepNum),
    lineWidth = 2 * Math.PI * r / 360;
  conicalCanvas.width = width, conicalCanvas.height = height, conicalCtx.setTransform(1, 0, 0, 1, 0, 0), conicalCtx.clearRect(0, 0, width, height), conicalCtx.translate(x, y), conicalCtx.rotate(startAngle);
  for (let i = 0, len = stepNum - 1; i < len && !(startAngle + i * step > endAngle); i++) {
    const color = colorInter.getColor(i);
    conicalCtx.beginPath(), conicalCtx.rotate(step), conicalCtx.moveTo(0, 0), conicalCtx.lineTo(r, -2 * lineWidth), conicalCtx.lineTo(r, 0), conicalCtx.fillStyle = color, conicalCtx.closePath(), conicalCtx.fill();
  }
  const imageData = conicalCtx.getImageData(0, 0, width, height);
  return conicalCanvas.width = imageData.width, conicalCanvas.height = imageData.height, conicalCtx.putImageData(imageData, 0, 0), pattern = context.createPattern(conicalCanvas, "no-repeat"), pattern && ConicalPatternStore.Set(stops, x, y, startAngle, endAngle, pattern, width, height), pattern;
}

const ArcRenderContribution = Symbol.for("ArcRenderContribution");
const AreaRenderContribution = Symbol.for("AreaRenderContribution");
const CircleRenderContribution = Symbol.for("CircleRenderContribution");
const GroupRenderContribution = Symbol.for("GroupRenderContribution");
const ImageRenderContribution = Symbol.for("ImageRenderContribution");
const PathRenderContribution = Symbol.for("PathRenderContribution");
const PolygonRenderContribution = Symbol.for("PolygonRenderContribution");
const RectRenderContribution = Symbol.for("RectRenderContribution");
const SymbolRenderContribution = Symbol.for("SymbolRenderContribution");
const TextRenderContribution = Symbol.for("TextRenderContribution");
const CommonRenderContribution = Symbol.for("CommonRenderContribution");
const InteractiveSubRenderContribution = Symbol.for("InteractiveSubRenderContribution");

function textDrawOffsetY(baseline, h) {
  return "top" === baseline ? Math.ceil(.79 * h) : "middle" === baseline ? Math.round(.3 * h) : "bottom" === baseline ? Math.round(-.21 * h) : 0;
}
function textDrawOffsetX(textAlign, width) {
  return "end" === textAlign || "right" === textAlign ? -width : "center" === textAlign ? -width / 2 : 0;
}
function textLayoutOffsetY(baseline, lineHeight, fontSize) {
  let buf = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
  return "middle" === baseline ? -lineHeight / 2 : "top" === baseline ? 0 : "bottom" === baseline ? buf - lineHeight : baseline && "alphabetic" !== baseline ? 0 : (fontSize || (fontSize = lineHeight), -(lineHeight - fontSize) / 2 - .79 * fontSize);
}
function textAttributesToStyle(attrs) {
  const style = {},
    parsePxValue = value => /^\d+(\.\d+)?$/.test(`${value}`) ? `${value}px` : `${value}`;
  return ["textAlign", "fontFamily", "fontVariant", "fontStyle", "fontWeight"].forEach(key => {
    attrs[key] && (style[lowerCamelCaseToMiddle(key)] = attrs[key]);
  }), ["fontSize", "lineHeight"].forEach(key => {
    const styleKey = lowerCamelCaseToMiddle(key);
    isNil$1(attrs[key]) || (style[styleKey] = parsePxValue(attrs[key]));
  }), isValid$1(attrs.maxLineWidth) && (style["max-width"] = parsePxValue(attrs.maxLineWidth)), attrs.underline ? style["text-decoration"] = "underline" : attrs.lineThrough && (style["text-decoration"] = "line-through"), attrs.fill && isString$1(attrs.fill) && (style.color = attrs.fill), style;
}

function identityMat4(out) {
  return out[0] = 1, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = 1, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = 0, out[13] = 0, out[14] = 0, out[15] = 1, out;
}
function rotateX(out, a, rad) {
  const s = Math.sin(rad),
    c = Math.cos(rad),
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  return a !== out && (out[0] = a[0], out[1] = a[1], out[2] = a[2], out[3] = a[3], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[4] = a10 * c + a20 * s, out[5] = a11 * c + a21 * s, out[6] = a12 * c + a22 * s, out[7] = a13 * c + a23 * s, out[8] = a20 * c - a10 * s, out[9] = a21 * c - a11 * s, out[10] = a22 * c - a12 * s, out[11] = a23 * c - a13 * s, out;
}
function rotateY(out, a, rad) {
  const s = Math.sin(rad),
    c = Math.cos(rad),
    a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11];
  return a !== out && (out[4] = a[4], out[5] = a[5], out[6] = a[6], out[7] = a[7], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c - a20 * s, out[1] = a01 * c - a21 * s, out[2] = a02 * c - a22 * s, out[3] = a03 * c - a23 * s, out[8] = a00 * s + a20 * c, out[9] = a01 * s + a21 * c, out[10] = a02 * s + a22 * c, out[11] = a03 * s + a23 * c, out;
}
function rotateZ(out, a, rad) {
  const s = Math.sin(rad),
    c = Math.cos(rad),
    a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7];
  return a !== out && (out[8] = a[8], out[9] = a[9], out[10] = a[10], out[11] = a[11], out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15]), out[0] = a00 * c + a10 * s, out[1] = a01 * c + a11 * s, out[2] = a02 * c + a12 * s, out[3] = a03 * c + a13 * s, out[4] = a10 * c - a00 * s, out[5] = a11 * c - a01 * s, out[6] = a12 * c - a02 * s, out[7] = a13 * c - a03 * s, out;
}
function translate(out, a, v) {
  const x = v[0],
    y = v[1],
    z = v[2];
  let a00, a01, a02, a03, a10, a11, a12, a13, a20, a21, a22, a23;
  return a === out ? (out[12] = a[0] * x + a[4] * y + a[8] * z + a[12], out[13] = a[1] * x + a[5] * y + a[9] * z + a[13], out[14] = a[2] * x + a[6] * y + a[10] * z + a[14], out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]) : (a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3], a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7], a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11], out[0] = a00, out[1] = a01, out[2] = a02, out[3] = a03, out[4] = a10, out[5] = a11, out[6] = a12, out[7] = a13, out[8] = a20, out[9] = a21, out[10] = a22, out[11] = a23, out[12] = a00 * x + a10 * y + a20 * z + a[12], out[13] = a01 * x + a11 * y + a21 * z + a[13], out[14] = a02 * x + a12 * y + a22 * z + a[14], out[15] = a03 * x + a13 * y + a23 * z + a[15]), out;
}
function mat3Tomat4(out, b) {
  out[0] = b.a, out[1] = b.b, out[2] = 0, out[3] = 0, out[4] = b.c, out[5] = b.d, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 1, out[11] = 0, out[12] = b.e, out[13] = b.f, out[14] = 0, out[15] = 1;
}
function multiplyMat4Mat3(out, a, b) {
  const a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11],
    a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  let b0 = b.a,
    b1 = b.b,
    b2 = 0,
    b3 = 0;
  return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b.c, b1 = b.d, b2 = 0, b3 = 0, out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = 0, b1 = 0, b2 = 1, b3 = 0, out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b.e, b1 = b.f, b2 = 0, b3 = 1, out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}
function scaleMat4(out, a, v) {
  const x = v[0],
    y = v[1],
    z = v[2];
  return out[0] = a[0] * x, out[1] = a[1] * x, out[2] = a[2] * x, out[3] = a[3] * x, out[4] = a[4] * y, out[5] = a[5] * y, out[6] = a[6] * y, out[7] = a[7] * y, out[8] = a[8] * z, out[9] = a[9] * z, out[10] = a[10] * z, out[11] = a[11] * z, out[12] = a[12], out[13] = a[13], out[14] = a[14], out[15] = a[15], out;
}
function multiplyMat4Mat4(out, a, b) {
  const a00 = a[0],
    a01 = a[1],
    a02 = a[2],
    a03 = a[3],
    a10 = a[4],
    a11 = a[5],
    a12 = a[6],
    a13 = a[7],
    a20 = a[8],
    a21 = a[9],
    a22 = a[10],
    a23 = a[11],
    a30 = a[12],
    a31 = a[13],
    a32 = a[14],
    a33 = a[15];
  let b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3];
  return out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[4], b1 = b[5], b2 = b[6], b3 = b[7], out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[8], b1 = b[9], b2 = b[10], b3 = b[11], out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, b0 = b[12], b1 = b[13], b2 = b[14], b3 = b[15], out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30, out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31, out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32, out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33, out;
}
function lookAt(out, eye, center, up) {
  let x0, x1, x2, y0, y1, y2, z0, z1, z2, len;
  const eyex = eye[0],
    eyey = eye[1],
    eyez = eye[2],
    upx = up[0],
    upy = up[1],
    upz = up[2],
    centerx = center[0],
    centery = center[1],
    centerz = center[2];
  return Math.abs(eyex - centerx) < epsilon && Math.abs(eyey - centery) < epsilon && Math.abs(eyez - centerz) < epsilon ? identityMat4(out) : (z0 = eyex - centerx, z1 = eyey - centery, z2 = eyez - centerz, len = 1 / Math.hypot(z0, z1, z2), z0 *= len, z1 *= len, z2 *= len, x0 = upy * z2 - upz * z1, x1 = upz * z0 - upx * z2, x2 = upx * z1 - upy * z0, len = Math.hypot(x0, x1, x2), len ? (len = 1 / len, x0 *= len, x1 *= len, x2 *= len) : (x0 = 0, x1 = 0, x2 = 0), y0 = z1 * x2 - z2 * x1, y1 = z2 * x0 - z0 * x2, y2 = z0 * x1 - z1 * x0, len = Math.hypot(y0, y1, y2), len ? (len = 1 / len, y0 *= len, y1 *= len, y2 *= len) : (y0 = 0, y1 = 0, y2 = 0), out[0] = x0, out[1] = y0, out[2] = z0, out[3] = 0, out[4] = x1, out[5] = y1, out[6] = z1, out[7] = 0, out[8] = x2, out[9] = y2, out[10] = z2, out[11] = 0, out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez), out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez), out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez), out[15] = 1, out);
}
function ortho(out, left, right, bottom, top, near, far) {
  const lr = 1 / (left - right),
    bt = 1 / (bottom - top),
    nf = 1 / (near - far);
  return out[0] = -2 * lr, out[1] = 0, out[2] = 0, out[3] = 0, out[4] = 0, out[5] = -2 * bt, out[6] = 0, out[7] = 0, out[8] = 0, out[9] = 0, out[10] = 2 * nf, out[11] = 0, out[12] = (left + right) * lr, out[13] = (top + bottom) * bt, out[14] = (far + near) * nf, out[15] = 1, out;
}
function transformMat4(out, a, m) {
  const x = a[0],
    y = a[1],
    z = a[2];
  let w = m[3] * x + m[7] * y + m[11] * z + m[15];
  return w = w || 1, out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w, out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w, out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w, out;
}

const MatrixAllocate = Symbol.for("MatrixAllocate");
const Mat4Allocate = Symbol.for("Mat4Allocate");
function createMat4() {
  return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
}
class DefaultMatrixAllocate {
  constructor() {
    this.pools = [];
  }
  allocate(a, b, c, d, e, f) {
    if (!this.pools.length) return new Matrix(a, b, c, d, e, f);
    const m = this.pools.pop();
    return m.a = a, m.b = b, m.c = c, m.d = d, m.e = e, m.f = f, m;
  }
  allocateByObj(matrix) {
    if (!this.pools.length) return new Matrix(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f);
    const m = this.pools.pop();
    return m.a = matrix.a, m.b = matrix.b, m.c = matrix.c, m.d = matrix.d, m.e = matrix.e, m.f = matrix.f, m;
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release() {
    this.pools = [];
  }
}
class DefaultMat4Allocate {
  constructor() {
    this.pools = [];
  }
  static identity(out) {
    return identityMat4(out);
  }
  allocate() {
    if (!this.pools.length) return createMat4();
    const m = this.pools.pop();
    return DefaultMat4Allocate.identity(m), m;
  }
  allocateByObj(d) {
    let m;
    m = this.pools.length ? this.pools.pop() : createMat4();
    for (let i = 0; i < m.length; i++) m[i] = d[i];
    return m;
  }
  free(m) {
    m && this.pools.push(m);
  }
  get length() {
    return this.pools.length;
  }
  release() {
    this.pools = [];
  }
}
const matrixAllocate = new DefaultMatrixAllocate();
const mat4Allocate = new DefaultMat4Allocate();

var __decorate$1F = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1g = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$U = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
function getExtraModelMatrix(dx, dy, graphic) {
  const {
    alpha: alpha,
    beta: beta
  } = graphic.attribute;
  if (!alpha && !beta) return null;
  const {
      anchor3d = graphic.attribute.anchor
    } = graphic.attribute,
    _anchor = [0, 0];
  if (anchor3d) {
    if ("string" == typeof anchor3d[0]) {
      const ratio = parseFloat(anchor3d[0]) / 100,
        bounds = graphic.AABBBounds;
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor3d[0];
    if ("string" == typeof anchor3d[1]) {
      const ratio = parseFloat(anchor3d[1]) / 100,
        bounds = graphic.AABBBounds;
      _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[1] = anchor3d[1];
  }
  if ("text" === graphic.type) {
    const {
      textAlign: textAlign
    } = graphic.attribute;
    _anchor[0] += textDrawOffsetX(textAlign, graphic.clipedWidth);
  }
  _anchor[0] += dx, _anchor[1] += dy;
  const modelMatrix = mat4Allocate.allocate();
  return translate(modelMatrix, modelMatrix, [_anchor[0], _anchor[1], 0]), beta && rotateX(modelMatrix, modelMatrix, beta), alpha && rotateY(modelMatrix, modelMatrix, alpha), translate(modelMatrix, modelMatrix, [-_anchor[0], -_anchor[1], 0]), modelMatrix;
}
function getModelMatrix(out, graphic, theme) {
  var _a;
  const {
      x = theme.x,
      y = theme.y,
      z = theme.z,
      dx = theme.dx,
      dy = theme.dy,
      dz = theme.dz,
      scaleX = theme.scaleX,
      scaleY = theme.scaleY,
      scaleZ = theme.scaleZ,
      alpha = theme.alpha,
      beta = theme.beta,
      angle = theme.angle,
      anchor3d = graphic.attribute.anchor,
      anchor: anchor
    } = graphic.attribute,
    _anchor = [0, 0, 0];
  if (anchor3d) {
    if ("string" == typeof anchor3d[0]) {
      const ratio = parseFloat(anchor3d[0]) / 100,
        bounds = graphic.AABBBounds;
      _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[0] = anchor3d[0];
    if ("string" == typeof anchor3d[1]) {
      const ratio = parseFloat(anchor3d[1]) / 100,
        bounds = graphic.AABBBounds;
      _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
    } else _anchor[1] = anchor3d[1];
    _anchor[2] = null !== (_a = anchor3d[2]) && void 0 !== _a ? _a : 0;
  }
  if (identityMat4(out), translate(out, out, [x + dx, y + dy, z + dz]), translate(out, out, [_anchor[0], _anchor[1], _anchor[2]]), rotateX(out, out, beta), rotateY(out, out, alpha), translate(out, out, [-_anchor[0], -_anchor[1], _anchor[2]]), scaleMat4(out, out, [scaleX, scaleY, scaleZ]), angle) {
    const m = mat4Allocate.allocate(),
      _anchor = [0, 0];
    if (anchor) {
      if ("string" == typeof anchor3d[0]) {
        const ratio = parseFloat(anchor3d[0]) / 100,
          bounds = graphic.AABBBounds;
        _anchor[0] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor[0] = anchor3d[0];
      if ("string" == typeof anchor3d[1]) {
        const ratio = parseFloat(anchor3d[1]) / 100,
          bounds = graphic.AABBBounds;
        _anchor[1] = bounds.x1 + (bounds.x2 - bounds.x1) * ratio;
      } else _anchor[1] = anchor3d[1];
    }
    translate(m, m, [_anchor[0], _anchor[1], 0]), rotateZ(m, m, angle), translate(m, m, [-_anchor[0], -_anchor[1], 0]), multiplyMat4Mat4(out, out, m);
  }
}
function shouldUseMat4(graphic) {
  const {
    alpha: alpha,
    beta: beta
  } = graphic.attribute;
  return alpha || beta;
}
let DefaultGraphicService = class {
  constructor(creator) {
    this.creator = creator, this.hooks = {
      onAttributeUpdate: new SyncHook(["graphic"]),
      onSetStage: new SyncHook(["graphic", "stage"]),
      onRemove: new SyncHook(["graphic"]),
      onRelease: new SyncHook(["graphic"]),
      onAddIncremental: new SyncHook(["graphic", "group", "stage"]),
      onClearIncremental: new SyncHook(["graphic", "group", "stage"]),
      beforeUpdateAABBBounds: new SyncHook(["graphic", "stage", "willUpdate", "aabbBounds"]),
      afterUpdateAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds", "globalAABBBounds", "selfChange"]),
      clearAABBBounds: new SyncHook(["graphic", "stage", "aabbBounds"])
    }, this.tempAABBBounds1 = new AABBBounds(), this.tempAABBBounds2 = new AABBBounds();
  }
  onAttributeUpdate(graphic) {
    this.hooks.onAttributeUpdate.taps.length && this.hooks.onAttributeUpdate.call(graphic);
  }
  onSetStage(graphic, stage) {
    this.hooks.onSetStage.taps.length && this.hooks.onSetStage.call(graphic, stage);
  }
  onRemove(graphic) {
    this.hooks.onRemove.taps.length && this.hooks.onRemove.call(graphic);
  }
  onRelease(graphic) {
    this.hooks.onRelease.taps.length && this.hooks.onRelease.call(graphic);
  }
  onAddIncremental(graphic, group, stage) {
    this.hooks.onAddIncremental.taps.length && this.hooks.onAddIncremental.call(graphic, group, stage);
  }
  onClearIncremental(group, stage) {
    this.hooks.onClearIncremental.taps.length && this.hooks.onClearIncremental.call(group, stage);
  }
  beforeUpdateAABBBounds(graphic, stage, willUpdate, bounds) {
    this.hooks.beforeUpdateAABBBounds.taps.length && this.hooks.beforeUpdateAABBBounds.call(graphic, stage, willUpdate, bounds);
  }
  afterUpdateAABBBounds(graphic, stage, bounds, params, selfChange) {
    this.hooks.afterUpdateAABBBounds.taps.length && this.hooks.afterUpdateAABBBounds.call(graphic, stage, bounds, params, selfChange);
  }
  clearAABBBounds(graphic, stage, b) {
    this.hooks.clearAABBBounds.taps.length && this.hooks.clearAABBBounds.call(graphic, stage, b);
  }
  updatePathProxyAABBBounds(aabbBounds, graphic) {
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    if (!path) return !1;
    const boundsContext = new BoundsContext(aabbBounds);
    return renderCommandList(path.commandList, boundsContext, 0, 0), !0;
  }
  updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds, graphic) {
    const {
      textAlign: textAlign,
      textBaseline: textBaseline
    } = attribute;
    if (null != attribute.forceBoundsHeight) {
      const h = isNumber$1(attribute.forceBoundsHeight) ? attribute.forceBoundsHeight : attribute.forceBoundsHeight(),
        dy = textLayoutOffsetY(textBaseline, h, h);
      aabbBounds.set(aabbBounds.x1, dy, aabbBounds.x2, dy + h);
    }
    if (null != attribute.forceBoundsWidth) {
      const w = isNumber$1(attribute.forceBoundsWidth) ? attribute.forceBoundsWidth : attribute.forceBoundsWidth(),
        dx = textDrawOffsetX(textAlign, w);
      aabbBounds.set(dx, aabbBounds.y1, dx + w, aabbBounds.y2);
    }
  }
  combindShadowAABBBounds(bounds, graphic) {
    if (graphic && graphic.shadowRoot) {
      const b = graphic.shadowRoot.AABBBounds;
      bounds.union(b);
    }
  }
  transformAABBBounds(attribute, aabbBounds, theme, miter, graphic) {
    if (!aabbBounds.empty()) {
      const {
          scaleX = theme.scaleX,
          scaleY = theme.scaleY,
          stroke = theme.stroke,
          shadowBlur = theme.shadowBlur,
          lineWidth = theme.lineWidth,
          pickStrokeBuffer = theme.pickStrokeBuffer,
          strokeBoundsBuffer = theme.strokeBoundsBuffer
        } = attribute,
        tb1 = this.tempAABBBounds1,
        tb2 = this.tempAABBBounds2;
      if (stroke && lineWidth) {
        const scaledHalfLineWidth = (lineWidth + pickStrokeBuffer) / Math.abs(scaleX + scaleY);
        boundStroke(tb1, scaledHalfLineWidth, miter, strokeBoundsBuffer), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
      }
      if (shadowBlur) {
        const {
            shadowOffsetX = theme.shadowOffsetX,
            shadowOffsetY = theme.shadowOffsetY
          } = attribute,
          shadowBlurWidth = shadowBlur / Math.abs(scaleX + scaleY) * 2;
        boundStroke(tb1, shadowBlurWidth, !1, strokeBoundsBuffer + 1), tb1.translate(shadowOffsetX, shadowOffsetY), aabbBounds.union(tb1);
      }
    }
    if (this.combindShadowAABBBounds(aabbBounds, graphic), aabbBounds.empty()) return;
    let updateMatrix = !0;
    const m = graphic.transMatrix;
    graphic && graphic.isContainer && (updateMatrix = !(1 === m.a && 0 === m.b && 0 === m.c && 1 === m.d && 0 === m.e && 0 === m.f)), updateMatrix && transformBoundsWithMatrix(aabbBounds, aabbBounds, m);
  }
  validCheck(attribute, theme, aabbBounds, graphic) {
    if (!graphic) return !0;
    if (null != attribute.forceBoundsHeight || null != attribute.forceBoundsWidth) return !0;
    if (graphic.shadowRoot || graphic.isContainer) return !0;
    const {
      visible = theme.visible
    } = attribute;
    return !(!graphic.valid || !visible) || (aabbBounds.empty() || (graphic.parent && aabbBounds.transformWithMatrix(graphic.parent.globalTransMatrix), application.graphicService.clearAABBBounds(graphic, graphic.stage, aabbBounds), aabbBounds.clear()), !1);
  }
  updateTempAABBBounds(aabbBounds) {
    const tb1 = this.tempAABBBounds1,
      tb2 = this.tempAABBBounds2;
    return tb1.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), tb2.setValue(aabbBounds.x1, aabbBounds.y1, aabbBounds.x2, aabbBounds.y2), {
      tb1: tb1,
      tb2: tb2
    };
  }
};
DefaultGraphicService = __decorate$1F([injectable(), __param$U(0, inject(GraphicCreator$1)), __metadata$1g("design:paramtypes", [Object])], DefaultGraphicService);

const updateBoundsOfCommonOuterBorder = (attribute, theme, aabbBounds) => {
  const {
    outerBorder: outerBorder,
    shadowBlur = theme.shadowBlur
  } = attribute;
  if (outerBorder) {
    const defaultOuterBorder = theme.outerBorder,
      {
        distance = defaultOuterBorder.distance,
        lineWidth = defaultOuterBorder.lineWidth
      } = outerBorder;
    aabbBounds.expand(distance + (shadowBlur + lineWidth) / 2);
  }
  return aabbBounds;
};

const CIRCLE_UPDATE_TAG_KEY = ["radius", "startAngle", "endAngle", ...GRAPHIC_UPDATE_TAG_KEY];
class Circle extends Graphic {
  constructor() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      radius: 1
    };
    super(params), this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      startAngle: startAngle,
      endAngle: endAngle,
      radius: radius
    } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(radius);
  }
  getGraphicTheme() {
    return getTheme(this).circle;
  }
  updateAABBBounds(attribute, circleTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) : this.updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds));
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, circleTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), application.graphicService.transformAABBBounds(attribute, aabbBounds, circleTheme, !1, this), aabbBounds;
  }
  updateCircleAABBBoundsImprecise(attribute, circleTheme, aabbBounds) {
    const {
      radius = circleTheme.radius
    } = attribute;
    return aabbBounds.set(-radius, -radius, radius, radius), aabbBounds;
  }
  updateCircleAABBBoundsAccurate(attribute, circleTheme, aabbBounds) {
    const {
      startAngle = circleTheme.startAngle,
      endAngle = circleTheme.endAngle,
      radius = circleTheme.radius
    } = attribute;
    return endAngle - startAngle > pi2 - epsilon ? aabbBounds.set(-radius, -radius, radius, radius) : circleBounds(startAngle, endAngle, radius, aabbBounds), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, CIRCLE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, CIRCLE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c;
    const attribute = this.attribute,
      radius = null !== (_a = attribute.radius) && void 0 !== _a ? _a : this.getDefaultAttribute("radius"),
      startAngle = null !== (_b = attribute.startAngle) && void 0 !== _b ? _b : this.getDefaultAttribute("startAngle"),
      endAngle = null !== (_c = attribute.endAngle) && void 0 !== _c ? _c : this.getDefaultAttribute("endAngle"),
      path = new CustomPath2D();
    return path.arc(0, 0, radius, startAngle, endAngle), path;
  }
  clone() {
    return new Circle(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Circle.NOWORK_ANIMATE_ATTR;
  }
}
Circle.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createCircle(attributes) {
  return new Circle(attributes);
}

class CanvasTextLayout {
  constructor(fontFamily, options, textMeasure) {
    this.fontFamily = fontFamily, this.textOptions = options, this.textMeasure = textMeasure;
  }
  LayoutBBox(bbox, textAlign, textBaseline, linesLayout) {
    if (bbox.xOffset = "left" === textAlign || "start" === textAlign ? 0 : "center" === textAlign ? bbox.width / -2 : "right" === textAlign || "end" === textAlign ? -bbox.width : 0, "top" === textBaseline) bbox.yOffset = 0;else if ("middle" === textBaseline) bbox.yOffset = bbox.height / -2;else if ("alphabetic" === textBaseline) {
      let percent = .79;
      if (1 === linesLayout.length) {
        const lineInfo = linesLayout[0];
        percent = lineInfo.ascent / (lineInfo.ascent + lineInfo.descent);
      }
      bbox.yOffset = bbox.height * -percent;
    } else bbox.yOffset = -bbox.height;
    return bbox;
  }
  GetLayoutByLines(lines, textAlign, textBaseline, lineHeight) {
    let suffix = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "";
    let wordBreak = arguments.length > 5 ? arguments[5] : undefined;
    let params = arguments.length > 6 ? arguments[6] : undefined;
    const {
      lineWidth: lineWidth,
      suffixPosition = "end",
      measureMode = MeasureModeEnum.actualBounding,
      keepCenterInLine = !1
    } = null != params ? params : {};
    lines = lines.map(l => l.toString());
    const linesLayout = [],
      bboxWH = [0, 0];
    if ("number" == typeof lineWidth && lineWidth !== 1 / 0) {
      let width;
      for (let i = 0, len = lines.length; i < len; i++) {
        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
        let str = lines[i].toString();
        if (metrics.width > lineWidth) {
          const data = this.textMeasure.clipTextWithSuffix(lines[i], this.textOptions, lineWidth, suffix, wordBreak, suffixPosition);
          str = data.str, width = data.width;
        } else width = metrics.width;
        linesLayout.push({
          str: str,
          width: width,
          ascent: metrics.ascent,
          descent: metrics.descent,
          keepCenterInLine: keepCenterInLine
        });
      }
      bboxWH[0] = lineWidth;
    } else {
      let width,
        text,
        _lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        text = lines[i];
        const metrics = this.textMeasure.measureTextPixelADscentAndWidth(lines[i], this.textOptions, measureMode);
        width = metrics.width, _lineWidth = Math.max(_lineWidth, width), linesLayout.push({
          str: text,
          width: width,
          ascent: metrics.ascent,
          descent: metrics.descent,
          keepCenterInLine: keepCenterInLine
        });
      }
      bboxWH[0] = _lineWidth;
    }
    bboxWH[1] = linesLayout.length * lineHeight, bboxWH[0] = linesLayout.reduce((a, b) => Math.max(a, b.width), 0);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    return this.LayoutBBox(bbox, textAlign, textBaseline, linesLayout), this.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
  }
  layoutWithBBox(bbox, lines, textAlign, textBaseline, lineHeight) {
    const origin = [0, 0],
      totalLineHeight = lines.length * lineHeight;
    "top" === textBaseline || ("middle" === textBaseline ? origin[1] = (bbox.height - totalLineHeight) / 2 : "bottom" === textBaseline && (origin[1] = bbox.height - totalLineHeight));
    for (let i = 0; i < lines.length; i++) this.lineOffset(bbox, lines[i], textAlign, textBaseline, lineHeight, origin);
    return {
      bbox: bbox,
      lines: lines,
      fontFamily: this.fontFamily,
      fontSize: this.textOptions.fontSize,
      fontWeight: this.textOptions.fontWeight,
      lineHeight: lineHeight,
      textAlign: textAlign,
      textBaseline: textBaseline
    };
  }
  lineOffset(bbox, line, textAlign, textBaseline, lineHeight, origin) {
    if ("left" === textAlign || "start" === textAlign ? line.leftOffset = 0 : "center" === textAlign ? line.leftOffset = (bbox.width - line.width) / 2 : "right" !== textAlign && "end" !== textAlign || (line.leftOffset = bbox.width - line.width), line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 + origin[1], !line.keepCenterInLine) {
      const buf = 0,
        actualHeightWithBuf = line.ascent + line.descent + buf;
      if (actualHeightWithBuf < lineHeight - buf && ("bottom" === textBaseline ? line.topOffset += (lineHeight - actualHeightWithBuf) / 2 : "top" === textBaseline && (line.topOffset -= (lineHeight - actualHeightWithBuf) / 2)), "alphabetic" === textBaseline) {
        const ratio = lineHeight / (line.ascent + line.descent);
        line.topOffset = lineHeight / 2 + (line.ascent - line.descent) / 2 * ratio + origin[1];
      }
    }
    return origin[1] += lineHeight, line;
  }
}

const TEXT_UPDATE_TAG_KEY = ["text", "maxLineWidth", "maxWidth", "textAlign", "textBaseline", "heightLimit", "lineClamp", "fontSize", "fontFamily", "fontWeight", "ellipsis", "lineHeight", "direction", "wordBreak", "heightLimit", "lineClamp", ...GRAPHIC_UPDATE_TAG_KEY];
class Text extends Graphic {
  get font() {
    const textTheme = this.getGraphicTheme();
    return this._font || (this._font = getContextFont(this.attribute, textTheme)), this._font;
  }
  get clipedText() {
    var _a;
    const attribute = this.attribute,
      textTheme = this.getGraphicTheme(),
      maxWidth = this.getMaxWidth(textTheme);
    return Number.isFinite(maxWidth) ? (this.tryUpdateAABBBounds(), this.cache.clipedText) : (null !== (_a = attribute.text) && void 0 !== _a ? _a : textTheme.text).toString();
  }
  get clipedWidth() {
    return this.tryUpdateAABBBounds(), this.cache.clipedWidth;
  }
  get cliped() {
    var _a, _b;
    const textTheme = this.getGraphicTheme(),
      attribute = this.attribute,
      maxWidth = this.getMaxWidth(textTheme);
    if (!Number.isFinite(maxWidth)) return !1;
    const {
      text: text
    } = this.attribute;
    if (this.tryUpdateAABBBounds(), null === (_b = null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData) || void 0 === _b ? void 0 : _b.lines) {
      let mergedText = "";
      this.cache.layoutData.lines.forEach(item => {
        mergedText += item.str;
      });
      return (Array.isArray(text) ? text.join("") : text) !== mergedText;
    }
    return "vertical" === attribute.direction && this.cache.verticalList && this.cache.verticalList[0] ? this.cache.verticalList[0].map(item => item.text).join("") !== attribute.text.toString() : null != this.clipedText && this.clipedText !== attribute.text.toString();
  }
  get multilineLayout() {
    return this.tryUpdateAABBBounds(), this.cache.layoutData;
  }
  get isMultiLine() {
    return Array.isArray(this.attribute.text) || "normal" === this.attribute.whiteSpace;
  }
  constructor() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      text: "",
      fontSize: 16
    };
    super(params), this.type = "text", this.numberType = TEXT_NUMBER_TYPE, this.cache = {};
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      text: text
    } = this.attribute;
    return isArray$1(text) ? !text.every(t => null == t || "" === t) : null != text && "" !== text;
  }
  getGraphicTheme() {
    return getTheme(this).text;
  }
  doUpdateOBBBounds() {
    const graphicTheme = this.getGraphicTheme();
    this._OBBBounds.clear();
    const attribute = this.attribute,
      {
        angle = graphicTheme.angle
      } = attribute;
    if (!angle) {
      const b = this.AABBBounds;
      return this._OBBBounds.setValue(b.x1, b.y1, b.x2, b.y2), this._OBBBounds;
    }
    this.obbText || (this.obbText = new Text({})), this.obbText.setAttributes(Object.assign(Object.assign({}, attribute), {
      angle: 0
    }));
    const bounds1 = this.obbText.AABBBounds,
      {
        x: x,
        y: y
      } = attribute,
      boundsCenter = {
        x: (bounds1.x1 + bounds1.x2) / 2,
        y: (bounds1.y1 + bounds1.y2) / 2
      },
      center = rotatePoint(boundsCenter, angle, {
        x: x,
        y: y
      });
    return this._OBBBounds.copy(bounds1), this._OBBBounds.translate(center.x - boundsCenter.x, center.y - boundsCenter.y), this._OBBBounds.angle = angle, this._OBBBounds;
  }
  updateAABBBounds(attribute, textTheme, aabbBounds) {
    const {
      text = textTheme.text
    } = this.attribute;
    Array.isArray(text) ? this.updateMultilineAABBBounds(text) : this.updateSingallineAABBBounds(text);
    const {
        tb1: tb1
      } = application.graphicService.updateTempAABBBounds(aabbBounds),
      {
        scaleX = textTheme.scaleX,
        scaleY = textTheme.scaleY,
        shadowBlur = textTheme.shadowBlur,
        strokeBoundsBuffer = textTheme.strokeBoundsBuffer
      } = attribute;
    if (shadowBlur) {
      const shadowBlurHalfWidth = shadowBlur / Math.abs(scaleX + scaleY);
      boundStroke(tb1, shadowBlurHalfWidth, !0, strokeBoundsBuffer), aabbBounds.union(tb1);
    }
    return application.graphicService.combindShadowAABBBounds(aabbBounds, this), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, textTheme, aabbBounds), transformBoundsWithMatrix(aabbBounds, aabbBounds, this.transMatrix), aabbBounds;
  }
  updateSingallineAABBBounds(text) {
    this.updateMultilineAABBBounds([text]);
    const layoutData = this.cache.layoutData;
    if (layoutData && layoutData.lines && layoutData.lines.length) {
      const line = layoutData.lines[0];
      this.cache.clipedText = line.str, this.cache.clipedWidth = line.width;
    }
    return this._AABBBounds;
  }
  updateMultilineAABBBounds(text) {
    const textTheme = this.getGraphicTheme(),
      {
        direction = textTheme.direction,
        underlineOffset = textTheme.underlineOffset
      } = this.attribute,
      b = "horizontal" === direction ? this.updateHorizontalMultilineAABBBounds(text) : this.updateVerticalMultilineAABBBounds(text);
    return "horizontal" === direction && underlineOffset && this._AABBBounds.add(this._AABBBounds.x1, this._AABBBounds.y2 + underlineOffset), b;
  }
  guessLineHeightBuf(fontSize) {
    return fontSize ? .1 * fontSize : 0;
  }
  updateHorizontalMultilineAABBBounds(text) {
    var _a;
    const textTheme = this.getGraphicTheme(),
      attribute = this.attribute,
      {
        fontFamily = textTheme.fontFamily,
        textAlign = textTheme.textAlign,
        textBaseline = textTheme.textBaseline,
        fontSize = textTheme.fontSize,
        fontWeight = textTheme.fontWeight,
        ellipsis = textTheme.ellipsis,
        maxLineWidth: maxLineWidth,
        stroke = textTheme.stroke,
        wrap = textTheme.wrap,
        measureMode = textTheme.measureMode,
        lineWidth = textTheme.lineWidth,
        whiteSpace = textTheme.whiteSpace,
        suffixPosition = textTheme.suffixPosition,
        ignoreBuf = textTheme.ignoreBuf,
        keepCenterInLine = textTheme.keepCenterInLine
      } = attribute,
      buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize),
      lineHeight = this.getLineHeight(attribute, textTheme, buf);
    if ("normal" === whiteSpace || wrap) return this.updateWrapAABBBounds(text);
    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
      const bbox = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure,
      layoutData = new CanvasTextLayout(fontFamily, {
        fontSize: fontSize,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        lineHeight: lineHeight
      }, textMeasure).GetLayoutByLines(text, textAlign, textBaseline, lineHeight, !0 === ellipsis ? textTheme.ellipsis : ellipsis || void 0, !1, {
        lineWidth: maxLineWidth,
        suffixPosition: suffixPosition,
        measureMode: measureMode,
        keepCenterInLine: keepCenterInLine
      }),
      {
        bbox: bbox
      } = layoutData;
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateWrapAABBBounds(text) {
    var _a, _b, _c;
    const textTheme = this.getGraphicTheme(),
      {
        fontFamily = textTheme.fontFamily,
        textAlign = textTheme.textAlign,
        textBaseline = textTheme.textBaseline,
        fontSize = textTheme.fontSize,
        ellipsis = textTheme.ellipsis,
        maxLineWidth: maxLineWidth,
        stroke = textTheme.stroke,
        lineWidth = textTheme.lineWidth,
        wordBreak = textTheme.wordBreak,
        fontWeight = textTheme.fontWeight,
        ignoreBuf = textTheme.ignoreBuf,
        measureMode = textTheme.measureMode,
        suffixPosition = textTheme.suffixPosition,
        heightLimit = 0,
        lineClamp: lineClamp,
        keepCenterInLine = textTheme.keepCenterInLine
      } = this.attribute,
      buf = ignoreBuf ? 0 : this.guessLineHeightBuf(fontSize),
      lineHeight = this.getLineHeight(this.attribute, textTheme, buf);
    if (!this.shouldUpdateShape() && (null === (_a = this.cache) || void 0 === _a ? void 0 : _a.layoutData)) {
      const bbox = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure,
      textOptions = {
        fontSize: fontSize,
        fontWeight: fontWeight,
        fontFamily: fontFamily,
        lineHeight: lineHeight
      },
      layoutObj = new CanvasTextLayout(fontFamily, textOptions, textMeasure),
      lines = isArray$1(text) ? text.map(l => l.toString()) : [text.toString()],
      linesLayout = [],
      bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
        const str = lines[i];
        let needCut = !0;
        if (i === lineCountLimit - 1) {
          const clip = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, !1, suffixPosition, i !== lines.length - 1),
            matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: matrics.ascent,
            descent: matrics.descent,
            keepCenterInLine: keepCenterInLine
          });
          break;
        }
        const clip = textMeasure.clipText(str, textOptions, maxLineWidth, "break-all" !== wordBreak, "keep-all" === wordBreak);
        if ("" !== str && "" === clip.str || clip.wordBreaked) {
          if (ellipsis) {
            const clipEllipsis = textMeasure.clipTextWithSuffix(str, textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
            clip.str = null !== (_b = clipEllipsis.str) && void 0 !== _b ? _b : "", clip.width = null !== (_c = clipEllipsis.width) && void 0 !== _c ? _c : 0;
          } else clip.str = "", clip.width = 0;
          needCut = !1;
        }
        const matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
        linesLayout.push({
          str: clip.str,
          width: clip.width,
          ascent: matrics.ascent,
          descent: matrics.descent,
          keepCenterInLine: keepCenterInLine
        });
        let cutLength = clip.str.length;
        if (!clip.wordBreaked || "" !== str && "" === clip.str || (needCut = !0, cutLength = clip.wordBreaked), clip.str.length === str.length) ;else if (needCut) {
          let newStr = str.substring(cutLength);
          "keep-all" === wordBreak && (newStr = newStr.replace(/^\s+/g, "")), lines.splice(i + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach(layout => {
        maxWidth = Math.max(maxWidth, layout.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width,
        text,
        lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = textMeasure.clipTextWithSuffix(lines[i], textOptions, maxLineWidth, ellipsis, !1, suffixPosition),
            matrics = textMeasure.measureTextPixelADscentAndWidth(clip.str, textOptions, measureMode);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: matrics.ascent,
            descent: matrics.descent,
            keepCenterInLine: keepCenterInLine
          }), lineWidth = Math.max(lineWidth, clip.width);
          break;
        }
        text = lines[i], width = textMeasure.measureTextWidth(text, textOptions), lineWidth = Math.max(lineWidth, width);
        const matrics = textMeasure.measureTextPixelADscentAndWidth(text, textOptions, measureMode);
        linesLayout.push({
          str: text,
          width: width,
          ascent: matrics.ascent,
          descent: matrics.descent,
          keepCenterInLine: keepCenterInLine
        });
      }
      bboxWH[0] = lineWidth;
    }
    bboxWH[1] = linesLayout.length * lineHeight;
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline, linesLayout);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  updateVerticalMultilineAABBBounds(text) {
    var _a, _b;
    const textTheme = this.getGraphicTheme(),
      textMeasure = application.graphicUtil.textMeasure;
    let width;
    const attribute = this.attribute,
      {
        maxLineWidth = textTheme.maxLineWidth,
        ellipsis = textTheme.ellipsis,
        fontFamily = textTheme.fontFamily,
        fontSize = textTheme.fontSize,
        fontWeight = textTheme.fontWeight,
        stroke = textTheme.stroke,
        lineWidth = textTheme.lineWidth,
        verticalMode = textTheme.verticalMode,
        suffixPosition = textTheme.suffixPosition
      } = attribute,
      lineHeight = this.getLineHeight(attribute, textTheme, 0);
    let {
      textAlign = textTheme.textAlign,
      textBaseline = textTheme.textBaseline
    } = attribute;
    if (!verticalMode) {
      const t = textAlign;
      textAlign = null !== (_a = Text.baselineMapAlign[textBaseline]) && void 0 !== _a ? _a : "left", textBaseline = null !== (_b = Text.alignMapBaseline[t]) && void 0 !== _b ? _b : "top";
    }
    if (width = 0, !this.shouldUpdateShape() && this.cache) {
      this.cache.verticalList.forEach(item => {
        const w = item.reduce((a, b) => a + b.width, 0);
        width = max(w, width);
      });
      const dx = textDrawOffsetX(textAlign, width),
        height = this.cache.verticalList.length * lineHeight,
        dy = textLayoutOffsetY(textBaseline, height, fontSize);
      return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const verticalLists = text.map(str => verticalLayout(str.toString()));
    verticalLists.forEach((verticalData, i) => {
      if (Number.isFinite(maxLineWidth)) {
        if (ellipsis) {
          const strEllipsis = !0 === ellipsis ? textTheme.ellipsis : ellipsis,
            data = textMeasure.clipTextWithSuffixVertical(verticalData, {
              fontSize: fontSize,
              fontWeight: fontWeight,
              fontFamily: fontFamily
            }, maxLineWidth, strEllipsis, !1, suffixPosition);
          verticalLists[i] = data.verticalList, width = data.width;
        } else {
          const data = textMeasure.clipTextVertical(verticalData, {
            fontSize: fontSize,
            fontWeight: fontWeight,
            fontFamily: fontFamily
          }, maxLineWidth, !1);
          verticalLists[i] = data.verticalList, width = data.width;
        }
      } else width = 0, verticalData.forEach(t => {
        const w = t.direction === TextDirection.HORIZONTAL ? fontSize : textMeasure.measureTextWidth(t.text, {
          fontSize: fontSize,
          fontWeight: fontWeight,
          fontFamily: fontFamily
        });
        width += w, t.width = w;
      });
    }), this.cache.verticalList = verticalLists, this.clearUpdateShapeTag(), this.cache.verticalList.forEach(item => {
      const w = item.reduce((a, b) => a + b.width, 0);
      width = max(w, width);
    });
    const dx = textDrawOffsetX(textAlign, width),
      height = this.cache.verticalList.length * lineHeight,
      dy = textLayoutOffsetY(textBaseline, height, fontSize);
    return this._AABBBounds.set(dy, dx, dy + height, dx + width), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  getMaxWidth(theme) {
    var _a, _b;
    const attribute = this.attribute;
    return null !== (_b = null !== (_a = attribute.maxLineWidth) && void 0 !== _a ? _a : attribute.maxWidth) && void 0 !== _b ? _b : theme.maxWidth;
  }
  getLineHeight(attribute, textTheme, buf) {
    var _a;
    return null !== (_a = calculateLineHeight(attribute.lineHeight, attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : (attribute.fontSize || textTheme.fontSize) + buf;
  }
  needUpdateTags(keys) {
    let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TEXT_UPDATE_TAG_KEY;
    return super.needUpdateTags(keys, k);
  }
  needUpdateTag(key) {
    let k = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : TEXT_UPDATE_TAG_KEY;
    return super.needUpdateTag(key, k);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "text" === key && (nextAttributes.text = nextStepVal);
  }
  clone() {
    return new Text(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Text.NOWORK_ANIMATE_ATTR;
  }
  getBaselineMapAlign() {
    return Text.baselineMapAlign;
  }
  getAlignMapBaseline() {
    return Text.alignMapBaseline;
  }
}
Text.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  direction: 1,
  textAlign: 1,
  textBaseline: 1,
  fontFamily: 1,
  fontWeight: 1
}, NOWORK_ANIMATE_ATTR), Text.baselineMapAlign = {
  top: "left",
  bottom: "right",
  middle: "center"
}, Text.alignMapBaseline = {
  left: "top",
  right: "bottom",
  center: "middle"
};
function createText(attributes) {
  return new Text(attributes);
}

const WRAP_TEXT_UPDATE_TAG_KEY = ["heightLimit", "lineClamp"];
class WrapText extends Text {
  constructor(params) {
    super(Object.assign(Object.assign({}, params), {
      wrap: !0
    }));
  }
  _isValid() {
    const {
      text: text
    } = this.attribute;
    return isArray$1(text) ? !text.every(t => null == t || "" === t) : null != text && "" !== text;
  }
  updateMultilineAABBBounds(text) {
    var _a, _b, _c, _d;
    const textTheme = this.getGraphicTheme(),
      {
        fontFamily = textTheme.fontFamily,
        textAlign = textTheme.textAlign,
        textBaseline = textTheme.textBaseline,
        fontSize = textTheme.fontSize,
        ellipsis = textTheme.ellipsis,
        maxLineWidth: maxLineWidth,
        stroke = textTheme.stroke,
        lineWidth = textTheme.lineWidth,
        wordBreak = textTheme.wordBreak,
        fontWeight = textTheme.fontWeight,
        ignoreBuf = textTheme.ignoreBuf,
        heightLimit = 0,
        suffixPosition = textTheme.suffixPosition,
        lineClamp: lineClamp
      } = this.attribute,
      lineHeight = null !== (_a = calculateLineHeight(this.attribute.lineHeight, this.attribute.fontSize || textTheme.fontSize)) && void 0 !== _a ? _a : this.attribute.fontSize || textTheme.fontSize,
      buf = ignoreBuf ? 0 : 2;
    if (!this.shouldUpdateShape() && (null === (_b = this.cache) || void 0 === _b ? void 0 : _b.layoutData)) {
      const bbox = this.cache.layoutData.bbox;
      return this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
    }
    const textMeasure = application.graphicUtil.textMeasure,
      layoutObj = new CanvasTextLayout(fontFamily, {
        fontSize: fontSize,
        fontWeight: fontWeight,
        fontFamily: fontFamily
      }, textMeasure),
      lines = text.map(l => l.toString()),
      linesLayout = [],
      bboxWH = [0, 0];
    let lineCountLimit = 1 / 0;
    if (heightLimit > 0 && (lineCountLimit = Math.max(Math.floor(heightLimit / lineHeight), 1)), lineClamp && (lineCountLimit = Math.min(lineCountLimit, lineClamp)), "number" == typeof maxLineWidth && maxLineWidth !== 1 / 0) {
      if (maxLineWidth > 0) for (let i = 0; i < lines.length; i++) {
        const str = lines[i];
        let needCut = !0;
        if (i === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: 0,
            descent: 0,
            keepCenterInLine: !1
          });
          break;
        }
        const clip = layoutObj.textMeasure.clipText(str, layoutObj.textOptions, maxLineWidth, "break-word" === wordBreak);
        if ("" !== str && "" === clip.str) {
          if (ellipsis) {
            const clipEllipsis = layoutObj.textMeasure.clipTextWithSuffix(str, layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
            clip.str = null !== (_c = clipEllipsis.str) && void 0 !== _c ? _c : "", clip.width = null !== (_d = clipEllipsis.width) && void 0 !== _d ? _d : 0;
          } else clip.str = "", clip.width = 0;
          needCut = !1;
        }
        if (linesLayout.push({
          str: clip.str,
          width: clip.width,
          ascent: 0,
          descent: 0,
          keepCenterInLine: !1
        }), clip.str.length === str.length) ;else if (needCut) {
          const newStr = str.substring(clip.str.length);
          lines.splice(i + 1, 0, newStr);
        }
      }
      let maxWidth = 0;
      linesLayout.forEach(layout => {
        maxWidth = Math.max(maxWidth, layout.width);
      }), bboxWH[0] = maxWidth;
    } else {
      let width,
        text,
        lineWidth = 0;
      for (let i = 0, len = lines.length; i < len; i++) {
        if (i === lineCountLimit - 1) {
          const clip = layoutObj.textMeasure.clipTextWithSuffix(lines[i], layoutObj.textOptions, maxLineWidth, ellipsis, !1, suffixPosition);
          linesLayout.push({
            str: clip.str,
            width: clip.width,
            ascent: 0,
            descent: 0,
            keepCenterInLine: !1
          }), lineWidth = Math.max(lineWidth, clip.width);
          break;
        }
        text = lines[i], width = layoutObj.textMeasure.measureTextWidth(text, layoutObj.textOptions, "break-word" === wordBreak), lineWidth = Math.max(lineWidth, width), linesLayout.push({
          str: text,
          width: width,
          ascent: 0,
          descent: 0,
          keepCenterInLine: !1
        });
      }
      bboxWH[0] = lineWidth;
    }
    bboxWH[1] = linesLayout.length * (lineHeight + buf);
    const bbox = {
      xOffset: 0,
      yOffset: 0,
      width: bboxWH[0],
      height: bboxWH[1]
    };
    layoutObj.LayoutBBox(bbox, textAlign, textBaseline);
    const layoutData = layoutObj.layoutWithBBox(bbox, linesLayout, textAlign, textBaseline, lineHeight);
    return this.cache.layoutData = layoutData, this.clearUpdateShapeTag(), this._AABBBounds.set(bbox.xOffset, bbox.yOffset, bbox.xOffset + bbox.width, bbox.yOffset + bbox.height), stroke && this._AABBBounds.expand(lineWidth / 2), this._AABBBounds;
  }
  needUpdateTags(keys) {
    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
      const attrKey = WRAP_TEXT_UPDATE_TAG_KEY[i];
      if (-1 !== keys.indexOf(attrKey)) return !0;
    }
    return super.needUpdateTags(keys);
  }
  needUpdateTag(key) {
    for (let i = 0; i < WRAP_TEXT_UPDATE_TAG_KEY.length; i++) {
      if (key === WRAP_TEXT_UPDATE_TAG_KEY[i]) return !0;
    }
    return super.needUpdateTag(key);
  }
  getNoWorkAnimateAttr() {
    return WrapText.NOWORK_ANIMATE_ATTR;
  }
}
function createWrapText(attributes) {
  return new WrapText(attributes);
}

const updateBoundsOfSymbolOuterBorder = (attribute, symbolTheme, aabbBounds) => {
  const {
    outerBorder: outerBorder,
    shadowBlur = symbolTheme.shadowBlur,
    strokeBoundsBuffer = symbolTheme.strokeBoundsBuffer
  } = attribute;
  if (outerBorder) {
    const defaultOuterBorder = symbolTheme.outerBorder,
      {
        distance = defaultOuterBorder.distance,
        lineWidth = defaultOuterBorder.lineWidth
      } = outerBorder;
    boundStroke(aabbBounds, distance + (shadowBlur + lineWidth) / 2, !0, strokeBoundsBuffer);
  }
  return aabbBounds;
};

const SYMBOL_UPDATE_TAG_KEY = ["symbolType", "size", ...GRAPHIC_UPDATE_TAG_KEY];
let Symbol$1 = class Symbol extends Graphic {
  constructor() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
      symbolType: "circle"
    };
    super(params), this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  getParsedPath() {
    return this.shouldUpdateShape() && (this._parsedPath = this.doUpdateParsedPath(), this.clearUpdateShapeTag()), this._parsedPath;
  }
  getParsedPath2D() {
    let x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    let y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    let path = null;
    try {
      path = new Path2D();
    } catch (err) {
      return null;
    }
    const parsedPath = this.getParsedPath();
    if (!parsedPath) return null;
    parsedPath.draw(path, size, x, y);
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      size: size
    } = this.attribute;
    return isArray$1(size) ? 2 === size.length && size.every(this._validNumber) : this._validNumber(size);
  }
  doUpdateParsedPath() {
    const {
      symbolType = "circle"
    } = this.attribute;
    return super.parsePath(symbolType);
  }
  getGraphicTheme() {
    return getTheme(this).symbol;
  }
  updateAABBBounds(attribute, symbolTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) : this.updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds));
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfSymbolOuterBorder(attribute, symbolTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    const {
      lineJoin = symbolTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, symbolTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateSymbolAABBBoundsImprecise(attribute, symbolTheme, aabbBounds) {
    const {
      size = symbolTheme.size
    } = attribute;
    if (isArray$1(size)) aabbBounds.set(-size[0] / 2, -size[1] / 2, size[0] / 2, size[1] / 2);else {
      const halfWH = size / 2;
      aabbBounds.set(-halfWH, -halfWH, halfWH, halfWH);
    }
    return aabbBounds;
  }
  updateSymbolAABBBoundsAccurate(attribute, symbolTheme, aabbBounds) {
    const {
      size = symbolTheme.size
    } = attribute;
    return this.getParsedPath().bounds(size, aabbBounds), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, SYMBOL_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, SYMBOL_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const symbolInstance = this.getParsedPath(),
      size = this.attribute.size,
      formattedSize = isArray$1(size) ? size : [size, size];
    return symbolInstance.path ? new CustomPath2D().fromCustomPath2D(symbolInstance.path, 0, 0, formattedSize[0], formattedSize[1]) : new CustomPath2D().fromString(symbolInstance.pathStr, 0, 0, formattedSize[0], formattedSize[1]);
  }
  clone() {
    return new Symbol(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Symbol.NOWORK_ANIMATE_ATTR;
  }
};
Symbol$1.NOWORK_ANIMATE_ATTR = Object.assign({
  symbolType: 1
}, NOWORK_ANIMATE_ATTR);
function createSymbol(attributes) {
  return new Symbol$1(attributes);
}

const LINE_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
let Line$1 = class Line extends Graphic {
  constructor() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    super(params), this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return !0;
    const {
      points: points,
      segments: segments
    } = this.attribute;
    return segments ? 0 !== segments.length : !!points && !(points.length <= 1);
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  getGraphicTheme() {
    return getTheme(this).line;
  }
  updateAABBBounds(attribute, lineTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds) : this.updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds);
    const {
      lineJoin = lineTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, lineTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateLineAABBBoundsByPoints(attribute, lineTheme, aabbBounds, graphic) {
    const {
        points = lineTheme.points,
        connectedType: connectedType
      } = attribute,
      b = aabbBounds;
    return points.forEach(p => {
      !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
    }), b;
  }
  updateLineAABBBoundsBySegments(attribute, lineTheme, aabbBounds, graphic) {
    const {
        segments = lineTheme.segments,
        connectedType: connectedType
      } = attribute,
      b = aabbBounds;
    return segments.forEach(s => {
      s.points.forEach(p => {
        !1 === p.defined && "connect" !== connectedType || b.add(p.x, p.y);
      });
    }), b;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, LINE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, LINE_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute,
      path = new CustomPath2D(),
      segments = attribute.segments,
      parsePoints = points => {
        if (points && points.length) {
          let isFirst = !0;
          points.forEach(point => {
            !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), isFirst = !1);
          });
        }
      };
    return segments && segments.length ? segments.forEach(seg => {
      parsePoints(seg.points);
    }) : attribute.points && parsePoints(attribute.points), path;
  }
  clone() {
    return new Line(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Line.NOWORK_ANIMATE_ATTR;
  }
};
Line$1.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createLine(attributes) {
  return new Line$1(attributes);
}

const RECT_UPDATE_TAG_KEY = ["width", "x1", "y1", "height", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
class Rect extends Graphic {
  constructor(params) {
    super(params), this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    return !0;
  }
  getGraphicTheme() {
    return getTheme(this).rect;
  }
  updateAABBBounds(attribute, rectTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      let {
        width: width,
        height: height
      } = attribute;
      const {
        x1: x1,
        y1: y1,
        x: x,
        y: y
      } = attribute;
      width = null != width ? width : x1 - x, height = null != height ? height : y1 - y, (isFinite(width) || isFinite(height) || isFinite(x) || isFinite(y)) && aabbBounds.set(0, 0, width || 0, height || 0);
    }
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, rectTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), application.graphicService.transformAABBBounds(attribute, aabbBounds, rectTheme, !1, this), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, RECT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RECT_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const attribute = this.attribute,
      {
        x: x,
        y: y,
        width: width,
        height: height
      } = normalizeRectAttributes(attribute),
      path = new CustomPath2D();
    return path.moveTo(x, y), path.rect(x, y, width, height), path;
  }
  clone() {
    return new Rect(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Rect.NOWORK_ANIMATE_ATTR;
  }
}
Rect.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect(attributes) {
  return new Rect(attributes);
}

const CUBE_VERTICES = [[0, 0, 0], [1, 0, 0], [1, 1, 0], [0, 1, 0], [0, 0, 1], [1, 0, 1], [1, 1, 1], [0, 1, 1]];
class Rect3d extends Rect {
  constructor(params) {
    super(params), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  findFace() {
    const faces = {
        polygons: [],
        vertices: [],
        edges: []
      },
      rectTheme = this.getGraphicTheme(),
      {
        x1: x1,
        y1: y1,
        x: x,
        y: y,
        length = min(rectTheme.width, rectTheme.height)
      } = this.attribute;
    let {
      width: width,
      height: height
    } = this.attribute;
    width = null != width ? width : x1 - x, height = null != height ? height : y1 - y;
    for (let i = 0; i < CUBE_VERTICES.length; i++) {
      const v = CUBE_VERTICES[i];
      faces.vertices.push([v[0] * width, v[1] * height, v[2] * length]);
    }
    return faces.polygons.push({
      polygon: [0, 1, 5, 4],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [2, 3, 7, 6],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [4, 7, 3, 0],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 2, 6, 5],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  getNoWorkAnimateAttr() {
    return Rect3d.NOWORK_ANIMATE_ATTR;
  }
}
Rect3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createRect3d(attributes) {
  return new Rect3d(attributes);
}

class Glyph extends Graphic {
  constructor(params) {
    super(params), this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE, this.subGraphic = [], this._onInit && this._onInit(this), this.valid = this.isValid();
  }
  setSubGraphic(subGraphic) {
    this.detachSubGraphic(), this.subGraphic = subGraphic, subGraphic.forEach(g => {
      g.glyphHost = this, Object.setPrototypeOf(g.attribute, this.attribute);
    }), this.valid = this.isValid(), this.addUpdateBoundTag();
  }
  detachSubGraphic() {
    this.subGraphic.forEach(g => {
      g.glyphHost = null, Object.setPrototypeOf(g.attribute, {});
    });
  }
  getSubGraphic() {
    return this.subGraphic;
  }
  onInit(cb) {
    this._onInit = cb;
  }
  onUpdate(cb) {
    this._onUpdate = cb;
  }
  isValid() {
    return !0;
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), this.subGraphic.forEach(g => {
      g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
    });
  }
  setAttributes(params) {
    let forceUpdateTag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    let context = arguments.length > 2 ? arguments[2] : undefined;
    super.setAttributes(params, forceUpdateTag, context), this.subGraphic.forEach(g => {
      g.addUpdateShapeAndBoundsTag(), g.addUpdatePositionTag();
    });
  }
  translate(x, y) {
    return super.translate(x, y), this.subGraphic.forEach(g => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  translateTo(x, y) {
    return super.translateTo(x, y), this.subGraphic.forEach(g => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  scale(scaleX, scaleY, scaleCenter) {
    return super.scale(scaleX, scaleY, scaleCenter), this.subGraphic.forEach(g => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  scaleTo(scaleX, scaleY) {
    return super.scaleTo(scaleX, scaleY), this.subGraphic.forEach(g => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  rotate(angle) {
    return super.rotate(angle), this.subGraphic.forEach(g => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  rotateTo(angle) {
    return super.rotate(angle), this.subGraphic.forEach(g => {
      g.addUpdatePositionTag(), g.addUpdateBoundTag();
    }), this;
  }
  getGraphicTheme() {
    return getTheme(this).glyph;
  }
  updateAABBBounds(attribute, theme, aabbBounds) {
    return this.getSubGraphic().forEach(node => {
      aabbBounds.union(node.AABBBounds);
    }), aabbBounds;
  }
  doUpdateAABBBounds() {
    this.updateAABBBoundsStamp++, this._AABBBounds.clear();
    const bounds = this.updateAABBBounds(this.attribute, this.getGraphicTheme(), this._AABBBounds);
    return this.clearUpdateBoundTag(), bounds;
  }
  needUpdateTags(keys) {
    return !1;
  }
  needUpdateTag(key) {
    return !1;
  }
  useStates(states, hasAnimation) {
    var _a;
    if (!states.length) return void this.clearStates(hasAnimation);
    if (!((null === (_a = this.currentStates) || void 0 === _a ? void 0 : _a.length) !== states.length || states.some((stateName, index) => this.currentStates[index] !== stateName))) return;
    this.stopStateAnimates();
    const stateAttrs = {},
      subAttrs = this.subGraphic.map(() => ({}));
    states.forEach(stateName => {
      var _a;
      const attrs = this.glyphStateProxy ? this.glyphStateProxy(stateName, states) : this.glyphStates[stateName];
      attrs && (Object.assign(stateAttrs, attrs.attributes), (null === (_a = attrs.subAttributes) || void 0 === _a ? void 0 : _a.length) && subAttrs.forEach((subAttrs, index) => {
        Object.assign(subAttrs, attrs.subAttributes[index]);
      }));
    }), this.subGraphic.forEach((graphic, index) => {
      graphic.updateNormalAttrs(subAttrs[index]), graphic.applyStateAttrs(subAttrs[index], states, hasAnimation);
    }), this.updateNormalAttrs(stateAttrs), this.currentStates = states, this.applyStateAttrs(stateAttrs, states, hasAnimation);
  }
  clearStates(hasAnimation) {
    this.stopStateAnimates(), this.hasState() && this.normalAttrs ? (this.currentStates = [], this.subGraphic.forEach(graphic => {
      graphic.applyStateAttrs(graphic.normalAttrs, this.currentStates, hasAnimation, !0), graphic.normalAttrs = null;
    }), this.applyStateAttrs(this.normalAttrs, this.currentStates, hasAnimation, !0)) : this.currentStates = [], this.normalAttrs = null;
  }
  clone() {
    const glyph = new Glyph(Object.assign({}, this.attribute));
    return glyph.setSubGraphic(this.subGraphic.map(g => g.clone())), glyph;
  }
  getNoWorkAnimateAttr() {
    return Glyph.NOWORK_ANIMATE_ATTR;
  }
}
Glyph.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createGlyph(attributes) {
  return new Glyph(attributes);
}

class Frame {
  constructor(left, top, width, height, ellipsis, wordBreak, verticalDirection, globalAlign, globalBaseline, layoutDirection, isWidthMax, isHeightMax, singleLine, icons) {
    this.left = left, this.top = top, this.width = width, this.height = height, this.actualHeight = 0, this.bottom = top + height, this.right = left + width, this.ellipsis = ellipsis, this.wordBreak = wordBreak, this.verticalDirection = verticalDirection, this.lines = [], this.globalAlign = globalAlign, this.globalBaseline = globalBaseline, this.layoutDirection = layoutDirection, this.directionKey = DIRECTION_KEY[this.layoutDirection], this.isWidthMax = isWidthMax, this.isHeightMax = isHeightMax, this.singleLine = singleLine, icons ? (icons.clear(), this.icons = icons) : this.icons = new Map();
  }
  draw(ctx, drawIcon) {
    const {
        width: actualWidth,
        height: actualHeight
      } = this.getActualSize(),
      width = this.isWidthMax ? Math.min(this.width, actualWidth) : this.width || actualWidth || 0;
    let height = this.isHeightMax ? Math.min(this.height, actualHeight) : this.height || actualHeight || 0;
    height = Math.min(height, actualHeight);
    let deltaY = 0;
    switch (this.globalBaseline) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -height / 2;
        break;
      case "bottom":
        deltaY = -height;
    }
    let deltaX = 0;
    "right" === this.globalAlign || "end" === this.globalAlign ? deltaX = -width : "center" === this.globalAlign && (deltaX = -width / 2);
    let frameHeight = this[this.directionKey.height];
    this.singleLine && (frameHeight = this.lines[0].height + 1);
    let lastLineTag = !1;
    if ("middle" === this.verticalDirection) {
      if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
        const {
          top: top,
          height: height
        } = this.lines[i];
        if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
        let lastLine = !1;
        this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
      } else {
        const detalHeight = Math.floor((frameHeight - this.actualHeight) / 2);
        "vertical" === this.layoutDirection ? deltaX += detalHeight : deltaY += detalHeight;
        for (let i = 0; i < this.lines.length; i++) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
      }
    } else if ("bottom" === this.verticalDirection && "vertical" !== this.layoutDirection) for (let i = 0; i < this.lines.length; i++) {
      const {
          top: top,
          height: height
        } = this.lines[i],
        y = frameHeight - this.lines[i].top - this.lines[i].height;
      if (0 === frameHeight) this.lines[i].draw(ctx, !1, deltaX, y + deltaY, this.ellipsis, drawIcon);else {
        if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) return lastLineTag;
        {
          let lastLine = !1;
          this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top] && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, deltaX, y + deltaY, this.ellipsis, drawIcon);
        }
      }
    } else {
      "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && this.singleLine && this.isWidthMax && (deltaX += this.lines[0].height + 1);
      for (let i = 0; i < this.lines.length; i++) {
        "bottom" === this.verticalDirection && "vertical" === this.layoutDirection && (deltaX -= this.lines[i].height + this.lines[i].top);
        const {
          top: top,
          height: height
        } = this.lines[i];
        if (0 === frameHeight) this.lines[i].draw(ctx, !1, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);else {
          if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) return lastLineTag;
          {
            let lastLine = !1;
            this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight && (lastLine = !0, lastLineTag = !0), this.lines[i].draw(ctx, lastLine, this.lines[i][this.directionKey.left] + deltaX, this.lines[i][this.directionKey.top] + deltaY, this.ellipsis, drawIcon);
          }
        }
      }
    }
    return lastLineTag;
  }
  getActualSize() {
    return this.ellipsis ? this.getActualSizeWidthEllipsis() : this.getRawActualSize();
  }
  getRawActualSize() {
    let width = 0,
      height = 0;
    for (let i = 0; i < this.lines.length; i++) {
      const line = this.lines[i];
      line.actualWidth > width && (width = line.actualWidth), height += line.height;
    }
    return {
      width: "vertical" === this.layoutDirection ? height : width,
      height: "vertical" === this.layoutDirection ? width : height
    };
  }
  getActualSizeWidthEllipsis() {
    let widthBound = 0,
      heightBound = 0;
    const {
      width: actualWidth,
      height: actualHeight
    } = this.getRawActualSize();
    this.width;
    this.height || actualHeight || 0;
    let frameHeight = this[this.directionKey.height];
    if (this.singleLine && (frameHeight = this.lines[0].height + 1), "middle" === this.verticalDirection) {
      if (this.actualHeight >= frameHeight && 0 !== frameHeight) for (let i = 0; i < this.lines.length; i++) {
        const {
          top: top,
          height: height
        } = this.lines[i];
        if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;else if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      } else {
        Math.floor((frameHeight - this.actualHeight) / 2);
        for (let i = 0; i < this.lines.length; i++) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    } else if ("bottom" === this.verticalDirection) for (let i = 0; i < this.lines.length; i++) {
      const {
          top: top,
          height: height
        } = this.lines[i],
        y = frameHeight - this.lines[i].top - this.lines[i].height;
      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;else if (y + height > this[this.directionKey.top] + frameHeight || y < this[this.directionKey.top]) ;else {
        if (this.ellipsis && this.lines[i + 1] && y - this.lines[i + 1].height < this[this.directionKey.top]) {
          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    } else for (let i = 0; i < this.lines.length; i++) {
      const {
        top: top,
        height: height
      } = this.lines[i];
      if (0 === frameHeight) this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;else if (top + height < this[this.directionKey.top] || top + height > this[this.directionKey.top] + frameHeight) ;else {
        if (this.ellipsis && this.lines[i + 1] && this.lines[i + 1].top + this.lines[i + 1].height > this[this.directionKey.top] + frameHeight) {
          const ellipsis = !0 === this.ellipsis ? "..." : this.ellipsis || "",
            lineWidth = this.lines[i].getWidthWithEllips(ellipsis);
          lineWidth > widthBound && (widthBound = lineWidth), heightBound += this.lines[i].height;
        } else this.lines[i].actualWidth > widthBound && (widthBound = this.lines[i].actualWidth), heightBound += this.lines[i].height;
      }
    }
    return {
      width: "vertical" === this.layoutDirection ? heightBound : widthBound,
      height: "vertical" === this.layoutDirection ? widthBound : heightBound
    };
  }
}

function getFixedLRTB(left, right, top, bottom) {
  const leftInt = Math.round(left),
    topInt = Math.round(top),
    rightInt = Math.round(right),
    bottomInt = Math.round(bottom);
  return {
    left: left > leftInt ? leftInt : leftInt - .5,
    top: top > topInt ? topInt : topInt - .5,
    right: rightInt > right ? rightInt : rightInt + .5,
    bottom: bottomInt > bottom ? bottomInt : bottomInt + .5
  };
}
class Paragraph {
  constructor(text, newLine, character, ascentDescentMode) {
    this.fontSize = character.fontSize || 16, this.textBaseline = character.textBaseline || "alphabetic", this.ascentDescentMode = ascentDescentMode;
    const lineHeight = calculateLineHeight(character.lineHeight, this.fontSize);
    this.lineHeight = "number" == typeof lineHeight ? lineHeight > this.fontSize ? lineHeight : this.fontSize : Math.floor(1.2 * this.fontSize), this.height = this.lineHeight;
    const {
      ascent: ascent,
      height: height,
      descent: descent,
      width: width
    } = measureTextCanvas(text, character, this.ascentDescentMode);
    let halfDetaHeight = 0,
      deltaAscent = 0,
      deltaDescent = 0;
    this.height > height && (halfDetaHeight = (this.height - height) / 2, deltaAscent = Math.ceil(halfDetaHeight), deltaDescent = Math.floor(halfDetaHeight)), "top" === this.textBaseline ? (this.ascent = halfDetaHeight, this.descent = height - halfDetaHeight) : "bottom" === this.textBaseline ? (this.ascent = height - halfDetaHeight, this.descent = halfDetaHeight) : "middle" === this.textBaseline ? (this.ascent = this.height / 2, this.descent = this.height / 2) : (this.ascent = ascent + deltaAscent, this.descent = descent + deltaDescent), this.length = text.length, this.width = width || 0, this.text = text || "", this.newLine = newLine || !1, this.character = character, this.left = 0, this.top = 0, this.ellipsis = "normal", this.ellipsisWidth = 0, this.ellipsisOtherParagraphWidth = 0, "vertical" === character.direction && (this.direction = character.direction, this.widthOrigin = this.width, this.heightOrigin = this.height, this.width = this.heightOrigin, this.height = this.widthOrigin, this.lineHeight = this.height), this.ellipsisStr = "...";
  }
  updateWidth() {
    const {
      width: width
    } = measureTextCanvas(this.text, this.character, this.ascentDescentMode);
    this.width = width, "vertical" === this.direction && (this.widthOrigin = this.width, this.width = this.heightOrigin, this.height = this.widthOrigin);
  }
  drawBackground(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
    if ("" === this.text || "\n" === this.text || !this.character.background || this.character.backgroundOpacity && !(this.character.backgroundOpacity > 0)) return;
    let baseline = top + ascent,
      text = this.text,
      left = this.left + deltaLeft;
    baseline += this.top;
    let direction = this.direction;
    if (this.verticalEllipsis) text = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
        if (text = text.slice(0, index), text += this.ellipsisStr, "right" === textAlign || "end" === textAlign) {
          const {
            width: width
          } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          "vertical" === direction || (left -= this.ellipsisWidth - width);
        }
      }
    }
    const lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + lineHeight);
    return Object.assign(Object.assign({}, lrtb), {
      fillStyle: this.character.background,
      globalAlpha: this.character.backgroundOpacity
    });
  }
  draw(ctx, top, ascent, deltaLeft, isLineFirst, textAlign, lineHeight) {
    let baseline = top + ascent,
      text = this.text,
      left = this.left + deltaLeft;
    baseline += this.top;
    let direction = this.direction;
    if (this.verticalEllipsis) text = this.ellipsisStr, direction = "vertical", baseline -= this.ellipsisWidth / 2;else {
      if ("hide" === this.ellipsis) return;
      if ("add" === this.ellipsis) text += this.ellipsisStr, "right" !== textAlign && "end" !== textAlign || (left -= this.ellipsisWidth);else if ("replace" === this.ellipsis) {
        const index = getStrByWithCanvas(text, ("vertical" === direction ? this.height : this.width) - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
        if (text = text.slice(0, index), text += this.ellipsisStr, "right" === textAlign || "end" === textAlign) {
          const {
            width: width
          } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
          "vertical" === direction || (left -= this.ellipsisWidth - width);
        }
      }
    }
    switch (this.character.script) {
      case "super":
        baseline -= this.ascent * (1 / 3);
        break;
      case "sub":
        baseline += this.descent / 2;
    }
    "vertical" === direction && (ctx.save(), ctx.rotateAbout(Math.PI / 2, left, baseline), ctx.translate(-this.heightOrigin || -this.lineHeight / 2, -this.descent / 2), ctx.translate(left, baseline), left = 0, baseline = 0);
    const {
      lineWidth = 1
    } = this.character;
    if (this.character.stroke && lineWidth && ctx.strokeText(text, left, baseline), this.character.fill && ctx.fillText(text, left, baseline), this.character.fill) if (this.character.lineThrough || this.character.underline) {
      if (this.character.underline) {
        const top = 1 + baseline,
          lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
        ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
      }
      if (this.character.lineThrough) {
        const top = 1 + baseline - this.ascent / 2,
          lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
        ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
      }
    } else if ("underline" === this.character.textDecoration) {
      const top = 1 + baseline,
        lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
      ctx.fillRect(lrtb.left, 1 + baseline, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
    } else if ("line-through" === this.character.textDecoration) {
      const top = 1 + baseline - this.ascent / 2,
        lrtb = getFixedLRTB(left, left + (this.widthOrigin || this.width), top, top + (this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1));
      ctx.fillRect(lrtb.left, 1 + baseline - this.ascent / 2, lrtb.right - lrtb.left, this.character.fontSize ? Math.max(1, Math.floor(this.character.fontSize / 10)) : 1);
    }
    "vertical" === direction && ctx.restore();
  }
  getWidthWithEllips(direction) {
    let text = this.text;
    const width = "vertical" === direction ? this.height : this.width;
    if ("hide" === this.ellipsis) return width;
    if ("add" === this.ellipsis) return width + this.ellipsisWidth;
    if ("replace" === this.ellipsis) {
      const index = getStrByWithCanvas(text, width - this.ellipsisWidth + this.ellipsisOtherParagraphWidth, this.character, text.length - 1);
      text = text.slice(0, index), text += this.ellipsisStr;
      const {
        width: measureWidth
      } = measureTextCanvas(this.text.slice(index), this.character, this.ascentDescentMode);
      return width + this.ellipsisWidth - measureWidth;
    }
    return width;
  }
}
function seperateParagraph(paragraph, index) {
  const text1 = paragraph.text.slice(0, index),
    text2 = paragraph.text.slice(index);
  return [new Paragraph(text1, paragraph.newLine, paragraph.character, paragraph.ascentDescentMode), new Paragraph(text2, !0, paragraph.character, paragraph.ascentDescentMode)];
}

const IMAGE_UPDATE_TAG_KEY = ["width", "height", "image", ...GRAPHIC_UPDATE_TAG_KEY];
let Image$1 = class Image extends Graphic {
  constructor(params) {
    super(params), this.type = "image", this.numberType = IMAGE_NUMBER_TYPE, this.loadImage(this.attribute.image);
  }
  getImageElement() {
    const {
      image: image
    } = this.attribute;
    if (!image || !this.resources) return null;
    const res = this.resources.get(image);
    return "success" !== res.state ? null : res.data;
  }
  get width() {
    return this.tryUpdateAABBBounds(), this._actualWidth;
  }
  get height() {
    return this.tryUpdateAABBBounds(), this._actualHeight;
  }
  get repeatX() {
    var _a;
    return null !== (_a = this.attribute.repeatX) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatX(repeatX) {
    this.attribute.repeatX === repeatX && (this.attribute.repeatX = repeatX);
  }
  get repeatY() {
    var _a;
    return null !== (_a = this.attribute.repeatY) && void 0 !== _a ? _a : "no-repeat";
  }
  set repeatY(repeatY) {
    this.attribute.repeatY === repeatY && (this.attribute.repeatY = repeatY);
  }
  get image() {
    return this.attribute.image;
  }
  set image(image) {
    image !== this.attribute.image && (this.attribute.image = image, this.loadImage(this.attribute.image));
  }
  imageLoadSuccess(url, image, cb) {
    super.imageLoadSuccess(url, image, () => {
      this.successCallback && this.successCallback();
    }), this.addUpdateBoundTag();
  }
  imageLoadFail(url, cb) {
    super.imageLoadFail(url, () => {
      this.failCallback && this.failCallback();
    });
  }
  setAttributes(params, forceUpdateTag, context) {
    return params.image && this.loadImage(params.image), super.setAttributes(params, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "image" === key && this.loadImage(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  getGraphicTheme() {
    return getTheme(this).image;
  }
  updateAABBBounds(attribute, imageTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const {
        maxWidth = imageTheme.maxWidth,
        maxHeight = imageTheme.maxHeight
      } = attribute;
      let {
        width: width,
        height: height
      } = attribute;
      if (null == width || null == height) {
        const imageElement = this.getImageElement();
        if (imageElement) {
          const imageWidth = imageElement.width,
            imageHeight = imageElement.height;
          if (null != width) height = width * (imageHeight / imageWidth);else if (null != height) width = height * (imageWidth / imageHeight);else {
            const imageRatio = imageWidth / imageHeight;
            imageRatio > maxWidth / maxHeight ? (width = maxWidth, height = maxWidth / imageRatio) : (height = maxHeight, width = maxHeight * imageRatio);
          }
        } else width = maxWidth, height = maxHeight;
      }
      this._actualWidth = width, this._actualHeight = height, aabbBounds.set(0, 0, width, height);
    }
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    return updateBoundsOfCommonOuterBorder(attribute, imageTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2), application.graphicService.transformAABBBounds(attribute, aabbBounds, imageTheme, !1, this), aabbBounds;
  }
  getDefaultAttribute(name) {
    return DefaultImageAttribute[name];
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, IMAGE_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, IMAGE_UPDATE_TAG_KEY);
  }
  clone() {
    return new Image(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Image.NOWORK_ANIMATE_ATTR;
  }
};
Image$1.NOWORK_ANIMATE_ATTR = Object.assign({
  image: 1,
  repeatX: 1,
  repeatY: 1
}, NOWORK_ANIMATE_ATTR);
function createImage(attributes) {
  return new Image$1(attributes);
}

class RichTextIcon extends Image$1 {
  constructor(params) {
    if (super(params), this._x = 0, this._y = 0, this._hovered = !1, this._marginArray = [0, 0, 0, 0], "always" === params.backgroundShowMode && (this._hovered = !0), params.margin) {
      const marginArray = parsePadding(params.margin);
      this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
    }
    this.onBeforeAttributeUpdate = (val, attributes, key) => {
      if (isArray$1(key) && -1 !== key.indexOf("margin") || "margin" === key) if (attributes.margin) {
        const marginArray = parsePadding(attributes.margin);
        this._marginArray = "number" == typeof marginArray ? [marginArray, marginArray, marginArray, marginArray] : marginArray;
      } else this._marginArray = [0, 0, 0, 0];
    };
  }
  get width() {
    var _a;
    return (null !== (_a = this.attribute.width) && void 0 !== _a ? _a : 0) + this._marginArray[1] + this._marginArray[3];
  }
  get height() {
    var _a;
    return (null !== (_a = this.attribute.height) && void 0 !== _a ? _a : 0) + this._marginArray[0] + this._marginArray[2];
  }
  tryUpdateAABBBounds() {
    if (!this.shouldUpdateAABBBounds()) return this._AABBBounds;
    this.doUpdateAABBBounds();
    const {
        width = DefaultImageAttribute.width,
        height = DefaultImageAttribute.height
      } = this.attribute,
      {
        backgroundWidth = width,
        backgroundHeight = height
      } = this.attribute,
      expandX = (backgroundWidth - width) / 2,
      expandY = (backgroundHeight - height) / 2;
    return this._AABBBounds.expand([0, 2 * expandX, 2 * expandY, 0]), this._AABBBounds;
  }
  setHoverState(hovered) {
    "hover" === this.attribute.backgroundShowMode && this._hovered !== hovered && (this._hovered = hovered);
  }
}

class Line {
  constructor(left, width, baseline, ascent, descent, lineBuffer, direction, isWidthMax) {
    this.left = left, this.width = width, this.baseline = baseline, this.ascent = ascent, this.descent = descent, this.top = baseline - ascent, this.paragraphs = lineBuffer.map(p => p), this.textAlign = (this.paragraphs[0] instanceof RichTextIcon ? this.paragraphs[0].attribute.textAlign : this.paragraphs[0].character.textAlign) || "left", this.direction = direction, this.directionKey = DIRECTION_KEY[this.direction], this.actualWidth = 0;
    let maxHeight = 0;
    this.paragraphs.forEach((word, index) => {
      if (0 === index && word instanceof Paragraph) {
        const result = regFirstSpace.exec(word.text);
        0 !== (null == result ? void 0 : result.index) && (word.text = word.text.slice(null == result ? void 0 : result.index), word.updateWidth());
      }
      this.actualWidth += word[this.directionKey.width], maxHeight = Math.max(word[this.directionKey.height], maxHeight);
    }), this.height = maxHeight, this.blankWidth = isWidthMax ? 0 : this.width - this.actualWidth, this.calcOffset(width, isWidthMax);
  }
  calcOffset(width, isWidthMax) {
    const directionKey = this.directionKey,
      maxHeight = this.height;
    let x = this.left,
      spacing = 0;
    this.actualWidth < width && !isWidthMax && ("right" === this.textAlign || "end" === this.textAlign ? x = width - this.actualWidth : "center" === this.textAlign ? x = (width - this.actualWidth) / 2 : "justify" === this.textAlign && (this.paragraphs.length < 2 ? x = (width - this.actualWidth) / 2 : spacing = (width - this.actualWidth) / (this.paragraphs.length - 1))), this.paragraphs.map(function (paragraph) {
      paragraph instanceof RichTextIcon ? (paragraph["_" + directionKey.x] = x, x += paragraph[directionKey.width] + spacing, paragraph["_" + directionKey.y] = "top" === paragraph.attribute.textBaseline ? 0 : "bottom" === paragraph.attribute.textBaseline ? maxHeight - paragraph.height : (maxHeight - paragraph.height) / 2) : (paragraph[directionKey.left] = x, x += paragraph[directionKey.width] + spacing);
    });
  }
  draw(ctx, lastLine, x, y, drawEllipsis, drawIcon) {
    if (drawEllipsis && (lastLine || this.paragraphs.some(p => p.overflow))) {
      let emptyOverflow = !0,
        skipEllipsis = !1;
      for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow) emptyOverflow = emptyOverflow && "" === paragraph.text;else if (emptyOverflow) {
          skipEllipsis = !0;
          break;
        }
      }
      let otherParagraphWidth = 0;
      if (!skipEllipsis) for (let i = this.paragraphs.length - 1; i >= 0; i--) {
        const paragraph = this.paragraphs[i];
        if (paragraph.overflow) {
          if ("" === paragraph.text) break;
          continue;
        }
        if (paragraph instanceof RichTextIcon) break;
        if ("vertical" === this.direction && "vertical" !== paragraph.direction) {
          paragraph.verticalEllipsis = !0;
          break;
        }
        const ellipsis = !0 === drawEllipsis ? "..." : drawEllipsis || "";
        paragraph.ellipsisStr = ellipsis;
        const {
            width: width
          } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode),
          ellipsisWidth = width || 0;
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
          lastLine && (paragraph.ellipsis = "add");
          break;
        }
        if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
          paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
          break;
        }
        paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
      }
    }
    let fillStyle = "",
      globalAlpha = -1,
      currBgList = [];
    const bgList = [currBgList];
    this.paragraphs.forEach((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return;
      const data = paragraph.drawBackground(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
      data && (fillStyle === data.fillStyle && globalAlpha === data.globalAlpha || (currBgList = [], bgList.push(currBgList), fillStyle = data.fillStyle, globalAlpha = data.globalAlpha), currBgList.push(data));
    }), bgList.forEach(bg => {
      if (0 === bg.length) return;
      const data = bg[0],
        end = bg[bg.length - 1];
      ctx.fillStyle = data.fillStyle, ctx.globalAlpha = data.globalAlpha, ctx.fillRect(data.left, data.top, end.right - data.left, end.bottom - data.top);
    }), this.paragraphs.forEach((paragraph, index) => {
      if (paragraph instanceof RichTextIcon) return paragraph.setAttributes({
        x: x + paragraph._x,
        y: y + paragraph._y
      }), void drawIcon(paragraph, ctx, x + paragraph._x, y + paragraph._y, this.ascent);
      const b = {
        x1: this.left,
        y1: this.top,
        x2: this.left + this.actualWidth,
        y2: this.top + this.height
      };
      applyStrokeStyle(ctx, paragraph.character), applyFillStyle(ctx, paragraph.character, b), paragraph.draw(ctx, y, this.ascent, x, 0 === index, this.textAlign, this.height);
    });
  }
  getWidthWithEllips(ellipsis) {
    let otherParagraphWidth = 0;
    for (let i = this.paragraphs.length - 1; i >= 0; i--) {
      const paragraph = this.paragraphs[i];
      if (paragraph instanceof RichTextIcon) break;
      const {
          width: width
        } = measureTextCanvas(ellipsis, paragraph.character, paragraph.ascentDescentMode),
        ellipsisWidth = width || 0;
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth) {
        paragraph.ellipsis = "add", paragraph.ellipsisWidth = ellipsisWidth;
        break;
      }
      if (ellipsisWidth <= this.blankWidth + otherParagraphWidth + paragraph.width) {
        paragraph.ellipsis = "replace", paragraph.ellipsisWidth = ellipsisWidth, paragraph.ellipsisOtherParagraphWidth = this.blankWidth + otherParagraphWidth;
        break;
      }
      paragraph.ellipsis = "hide", otherParagraphWidth += paragraph.width;
    }
    let width = 0;
    return this.paragraphs.forEach((paragraph, index) => {
      width += paragraph instanceof RichTextIcon ? paragraph.width : paragraph.getWidthWithEllips(this.direction);
    }), width;
  }
}

class Wrapper {
  constructor(frame) {
    this.frame = frame, this.width = this.frame.width, this.height = this.frame.height, this.lineWidth = 0, this.y = this.frame.top, this.maxAscent = 0, this.maxDescent = 0, this.maxAscentForBlank = 0, this.maxDescentForBlank = 0, this.lineBuffer = [], this.direction = frame.layoutDirection, this.directionKey = DIRECTION_KEY[this.direction];
  }
  store(paragraph) {
    if (paragraph instanceof RichTextIcon) {
      this.frame.icons.set(paragraph.richtextId, paragraph), this.lineBuffer.push(paragraph), this.lineWidth += paragraph[this.directionKey.width];
      let iconAscent = 0,
        iconDescent = 0;
      "top" === paragraph.attribute.textBaseline ? (iconAscent = 0, iconDescent = paragraph.height) : "bottom" === paragraph.attribute.textBaseline ? (iconAscent = paragraph.height, iconDescent = 0) : (iconAscent = paragraph.height / 2, iconDescent = paragraph.height / 2), this.maxAscent = Math.max(this.maxAscent, iconAscent), this.maxDescent = Math.max(this.maxDescent, iconDescent);
    } else this.lineBuffer.push(paragraph), 0 !== paragraph.text.length ? (this.lineWidth += paragraph[this.directionKey.width], this.maxAscent = Math.max(this.maxAscent, paragraph.ascent), this.maxDescent = Math.max(this.maxDescent, paragraph.descent)) : (this.maxAscentForBlank = Math.max(this.maxAscentForBlank, paragraph.ascent), this.maxDescentForBlank = Math.max(this.maxDescentForBlank, paragraph.descent));
  }
  send() {
    if (0 === this.lineBuffer.length) return;
    const maxAscent = 0 === this.maxAscent ? this.maxAscentForBlank : this.maxAscent,
      maxDescent = 0 === this.maxDescent ? this.maxDescentForBlank : this.maxDescent,
      line = new Line(this.frame.left, this[this.directionKey.width], this.y + maxAscent, maxAscent, maxDescent, this.lineBuffer, this.direction, "horizontal" === this.direction ? this.frame.isWidthMax : this.frame.isHeightMax);
    this.frame.lines.push(line), this.frame.actualHeight += line.height, this.y += line.height, this.lineBuffer.length = 0, this.lineWidth = this.maxAscent = this.maxDescent = this.maxAscentForBlank = this.maxDescentForBlank = 0;
  }
  deal(paragraph) {
    let singleLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    paragraph instanceof RichTextIcon ? "horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : 0 === this.lineBuffer.length ? (this.store(paragraph), this.send()) : (this.send(), this.deal(paragraph)) : "number" != typeof this.width || this.width < 0 || (paragraph.newLine && this.send(), (0 !== paragraph.text.length || this.newLine) && ("horizontal" === this.direction && 0 === this.width || "vertical" === this.direction && 0 === this.height || this.lineWidth + paragraph[this.directionKey.width] <= this[this.directionKey.width] ? this.store(paragraph) : this.lineWidth === this[this.directionKey.width] ? (this.send(), this.deal(paragraph)) : this.cut(paragraph, singleLine)));
  }
  cut(paragraph, singleLine) {
    const availableWidth = this[this.directionKey.width] - this.lineWidth || 0,
      guessIndex = Math.ceil(availableWidth / paragraph[this.directionKey.width] * paragraph.length) || 0,
      index = getStrByWithCanvas(paragraph.text, availableWidth, paragraph.character, guessIndex, "break-word" === this.frame.wordBreak);
    if (0 !== index) {
      const [p1, p2] = seperateParagraph(paragraph, index);
      this.store(p1), singleLine ? this.send() : this.deal(p2);
    } else 0 !== this.lineBuffer.length && (this.send(), this.deal(paragraph));
  }
}

let supportIntl = !1;
try {
  supportIntl = Intl && "function" == typeof Intl.Segmenter;
} catch (e) {
  supportIntl = !1;
}
const RICHTEXT_UPDATE_TAG_KEY = ["width", "height", "ellipsis", "wordBreak", "verticalDirection", "maxHeight", "maxWidth", "textAlign", "textBaseline", "textConfig", "layoutDirection", "fill", "stroke", "fontSize", "fontFamily", "fontStyle", "fontWeight", "lineWidth", "opacity", "fillOpacity", "strokeOpacity", ...GRAPHIC_UPDATE_TAG_KEY];
class RichText extends Graphic {
  constructor(params) {
    super(params), this.type = "richtext", this._currentHoverIcon = null, this.numberType = RICHTEXT_NUMBER_TYPE, this.onBeforeAttributeUpdate = (val, attributes, key) => {
      for (const key in val) if ("hoverIconId" === key) {
        if (val[key] === attributes[key]) continue;
        const icon = this._frameCache.icons.get(val[key]);
        this.updateHoverIconState(icon);
      }
    };
  }
  get width() {
    var _a;
    return null !== (_a = this.attribute.width) && void 0 !== _a ? _a : DefaultRichTextAttribute.width;
  }
  set width(w) {
    this.attribute.width !== w && (this.attribute.width = w, this.addUpdateShapeAndBoundsTag());
  }
  get height() {
    var _a;
    return null !== (_a = this.attribute.height) && void 0 !== _a ? _a : DefaultRichTextAttribute.height;
  }
  set height(h) {
    this.attribute.height !== h && (this.attribute.height = h, this.addUpdateShapeAndBoundsTag());
  }
  get maxWidth() {
    return this.attribute.maxWidth;
  }
  set maxWidth(mw) {
    this.attribute.maxWidth !== mw && (this.attribute.maxWidth = mw, this.addUpdateShapeAndBoundsTag());
  }
  get maxHeight() {
    return this.attribute.maxHeight;
  }
  set maxHeight(mh) {
    this.attribute.maxHeight !== mh && (this.attribute.maxHeight = mh, this.addUpdateShapeAndBoundsTag());
  }
  get ellipsis() {
    var _a;
    return null !== (_a = this.attribute.ellipsis) && void 0 !== _a ? _a : DefaultRichTextAttribute.ellipsis;
  }
  set ellipsis(e) {
    this.attribute.ellipsis !== e && (this.attribute.ellipsis = e, this.addUpdateShapeAndBoundsTag());
  }
  get wordBreak() {
    var _a;
    return null !== (_a = this.attribute.wordBreak) && void 0 !== _a ? _a : DefaultRichTextAttribute.wordBreak;
  }
  set wordBreak(wb) {
    this.attribute.wordBreak !== wb && (this.attribute.wordBreak = wb, this.addUpdateShapeAndBoundsTag());
  }
  get verticalDirection() {
    var _a;
    return null !== (_a = this.attribute.verticalDirection) && void 0 !== _a ? _a : DefaultRichTextAttribute.verticalDirection;
  }
  set verticalDirection(vd) {
    this.attribute.verticalDirection !== vd && (this.attribute.verticalDirection = vd, this.addUpdateShapeAndBoundsTag());
  }
  get textAlign() {
    var _a;
    return null !== (_a = this.attribute.textAlign) && void 0 !== _a ? _a : DefaultRichTextAttribute.textAlign;
  }
  set textAlign(align) {
    this.attribute.textAlign !== align && (this.attribute.textAlign = align, this.addUpdateShapeAndBoundsTag());
  }
  get textBaseline() {
    var _a;
    return null !== (_a = this.attribute.textBaseline) && void 0 !== _a ? _a : DefaultRichTextAttribute.textBaseline;
  }
  set textBaseline(baseline) {
    this.attribute.textBaseline !== baseline && (this.attribute.textBaseline = baseline, this.addUpdateShapeAndBoundsTag());
  }
  get textConfig() {
    var _a;
    return null !== (_a = this.attribute.textConfig) && void 0 !== _a ? _a : DefaultRichTextAttribute.textConfig;
  }
  set textConfig(config) {
    this.attribute.textConfig = config, this.addUpdateShapeAndBoundsTag();
  }
  getGraphicTheme() {
    return getTheme(this).richtext;
  }
  static AllSingleCharacter(cache) {
    if (cache.lines) {
      return cache.lines.every(line => line.paragraphs.every(item => !(item.text && isString$1(item.text) && RichText.splitText(item.text).length > 1)));
    }
    return cache.every(item => item.isComposing || !(item.text && isString$1(item.text) && RichText.splitText(item.text).length > 1));
  }
  static splitText(text) {
    if (supportIntl) {
      const segmenter = new Intl.Segmenter(void 0, {
          granularity: "grapheme"
        }),
        segments = [];
      for (const {
        segment: segment
      } of segmenter.segment(text)) segments.push(segment);
      return segments;
    }
    return Array.from(text);
  }
  static TransformTextConfig2SingleCharacter(textConfig) {
    const tc = [];
    return textConfig.forEach(item => {
      const textList = RichText.splitText(item.text.toString());
      if (isString$1(item.text) && textList.length > 1) for (let i = 0; i < textList.length; i++) {
        const t = textList[i];
        tc.push(Object.assign(Object.assign({}, item), {
          text: t
        }));
      } else tc.push(item);
    }), tc;
  }
  updateAABBBounds(attribute, richtextTheme, aabbBounds) {
    var _a, _b, _c, _d;
    const {
      width = richtextTheme.width,
      height = richtextTheme.height,
      maxWidth = richtextTheme.maxWidth,
      maxHeight = richtextTheme.maxHeight,
      textAlign = richtextTheme.textAlign,
      verticalDirection = null !== (_b = null !== (_a = attribute.textBaseline) && void 0 !== _a ? _a : richtextTheme.textBaseline) && void 0 !== _b ? _b : richtextTheme.verticalDirection,
      editOptions: editOptions
    } = attribute;
    if (width > 0 && height > 0) aabbBounds.set(0, 0, width, height);else {
      const frameCache = this.getFrameCache(),
        {
          width: actualWidth,
          height: actualHeight
        } = frameCache.getActualSize();
      let contentWidth = width || actualWidth || 0,
        contentHeight = height || actualHeight || 0;
      contentHeight = "number" == typeof maxHeight && contentHeight > maxHeight ? maxHeight : contentHeight || 0, contentWidth = "number" == typeof maxWidth && contentWidth > maxWidth ? maxWidth : contentWidth || 0, aabbBounds.set(0, 0, contentWidth, contentHeight);
    }
    editOptions && editOptions.keepHeightWhileEmpty && !aabbBounds.height() && !(null === (_c = attribute.textConfig) || void 0 === _c ? void 0 : _c.length) && (aabbBounds.y2 = aabbBounds.y1 + (null !== (_d = attribute.fontSize) && void 0 !== _d ? _d : 12), aabbBounds.x2 = aabbBounds.x1 + 2);
    let deltaY = 0;
    switch (verticalDirection) {
      case "top":
        deltaY = 0;
        break;
      case "middle":
        deltaY = -aabbBounds.height() / 2;
        break;
      case "bottom":
        deltaY = -aabbBounds.height();
    }
    let deltaX = 0;
    switch (textAlign) {
      case "left":
        deltaX = 0;
        break;
      case "center":
        deltaX = -aabbBounds.width() / 2;
        break;
      case "right":
        deltaX = -aabbBounds.width();
    }
    return aabbBounds.translate(deltaX, deltaY), application.graphicService.updateTempAABBBounds(aabbBounds), null == attribute.forceBoundsHeight && null == attribute.forceBoundsWidth || application.graphicService.updateHTMLTextAABBBounds(attribute, richtextTheme, aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, richtextTheme, !1, this), 0 === aabbBounds.width() && 0 === aabbBounds.height() && aabbBounds.clear(), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, RICHTEXT_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, RICHTEXT_UPDATE_TAG_KEY);
  }
  getFrameCache() {
    return this.shouldUpdateShape() && (this.doUpdateFrameCache(), this.clearUpdateShapeTag()), this._frameCache;
  }
  get cliped() {
    const frameCache = this.getFrameCache();
    if (frameCache.actualHeight > frameCache.height) return !0;
    const {
      disableAutoWrapLine: disableAutoWrapLine
    } = this.attribute;
    if (disableAutoWrapLine) for (let i = 0; i < frameCache.lines.length; i++) {
      const l = frameCache.lines[i];
      for (let j = 0; j < l.paragraphs.length; j++) {
        const p = l.paragraphs[j];
        if (p.overflow && "" !== p.text) return !0;
      }
    }
    return !1;
  }
  combinedStyleToCharacter(config) {
    const {
        fill: fill,
        stroke: stroke,
        fontSize: fontSize,
        fontFamily: fontFamily,
        fontStyle: fontStyle,
        fontWeight: fontWeight,
        lineWidth: lineWidth,
        opacity: opacity,
        fillOpacity: fillOpacity,
        lineHeight: lineHeight,
        strokeOpacity: strokeOpacity,
        upgradeAttrs: upgradeAttrs
      } = this.attribute,
      out = Object.assign({
        fill: fill,
        stroke: stroke,
        fontSize: fontSize,
        fontFamily: fontFamily,
        fontStyle: fontStyle,
        fontWeight: fontWeight,
        lineWidth: lineWidth,
        opacity: opacity,
        fillOpacity: fillOpacity,
        strokeOpacity: strokeOpacity
      }, config);
    return (null == upgradeAttrs ? void 0 : upgradeAttrs.lineHeight) && (out.lineHeight = lineHeight), out;
  }
  doUpdateFrameCache(tc) {
    var _a;
    const {
        maxWidth: maxWidth,
        maxHeight: maxHeight,
        width: width,
        height: height,
        ellipsis: ellipsis,
        wordBreak: wordBreak,
        verticalDirection: verticalDirection,
        textAlign: textAlign,
        textBaseline: textBaseline,
        layoutDirection: layoutDirection,
        singleLine: singleLine,
        disableAutoWrapLine: disableAutoWrapLine,
        editable: editable,
        ascentDescentMode: ascentDescentMode,
        upgradeAttrs: upgradeAttrs
      } = this.attribute,
      enableMultiBreakLine = upgradeAttrs && upgradeAttrs.multiBreakLine;
    let {
      textConfig: _tc = []
    } = this.attribute;
    editable && _tc.length > 0 && !RichText.AllSingleCharacter(_tc) && (_tc = RichText.TransformTextConfig2SingleCharacter(_tc), this.attribute.textConfig = _tc);
    const paragraphs = [],
      textConfig = null != tc ? tc : _tc;
    for (let i = 0; i < textConfig.length; i++) if ("image" in textConfig[i]) {
      const config = this.combinedStyleToCharacter(textConfig[i]);
      config.lineWidth = void 0;
      const iconCache = config.id && this._frameCache && this._frameCache.icons && this._frameCache.icons.get(config.id);
      if (iconCache) paragraphs.push(iconCache);else {
        const icon = new RichTextIcon(config);
        icon.successCallback = () => {
          var _a;
          this.addUpdateBoundTag(), null === (_a = this.stage) || void 0 === _a || _a.renderNextFrame();
        }, icon.richtextId = config.id, paragraphs.push(icon);
      }
    } else {
      const richTextConfig = this.combinedStyleToCharacter(textConfig[i]);
      if (isNumber$1(richTextConfig.text) && (richTextConfig.text = `${richTextConfig.text}`), richTextConfig.text && richTextConfig.text.includes("\n")) {
        const textParts = richTextConfig.text.split("\n");
        for (let j = 0; j < textParts.length; j++) if (0 === j) paragraphs.push(new Paragraph(textParts[j], !1, richTextConfig, ascentDescentMode));else if (textParts[j] || i === textConfig.length - 1) paragraphs.push(new Paragraph(textParts[j], !0, richTextConfig, ascentDescentMode));else {
          const nextRichTextConfig = this.combinedStyleToCharacter(textConfig[i + 1]);
          paragraphs.push(new Paragraph(textParts[j], !0, nextRichTextConfig, ascentDescentMode));
        }
      } else richTextConfig.text && paragraphs.push(new Paragraph(richTextConfig.text, !1, richTextConfig, ascentDescentMode));
    }
    const maxWidthFinite = "number" == typeof maxWidth && Number.isFinite(maxWidth) && maxWidth > 0,
      maxHeightFinite = "number" == typeof maxHeight && Number.isFinite(maxHeight) && maxHeight > 0,
      richTextWidthEnable = "number" == typeof width && Number.isFinite(width) && width > 0 && (!maxWidthFinite || width <= maxWidth),
      richTextHeightEnable = "number" == typeof height && Number.isFinite(height) && height > 0 && (!maxHeightFinite || height <= maxHeight),
      frame = new Frame(0, 0, (richTextWidthEnable ? width : maxWidthFinite ? maxWidth : 0) || 0, (richTextHeightEnable ? height : maxHeightFinite ? maxHeight : 0) || 0, ellipsis, wordBreak, verticalDirection, textAlign, textBaseline, layoutDirection || "horizontal", !richTextWidthEnable && maxWidthFinite, !richTextHeightEnable && maxHeightFinite, singleLine || !1, null === (_a = this._frameCache) || void 0 === _a ? void 0 : _a.icons),
      wrapper = new Wrapper(frame);
    if (wrapper.newLine = enableMultiBreakLine, disableAutoWrapLine) {
      let lineCount = 0,
        skip = !1;
      for (let i = 0; i < paragraphs.length; i++) {
        const p = paragraphs[i];
        skip ? (p.overflow = !0, p.left = 1 / 0, p.top = 1 / 0, !p.newLine && frame.lines[frame.lines.length - 1].paragraphs.push(p)) : wrapper.deal(p, !0), frame.lines.length !== lineCount && (lineCount = frame.lines.length, wrapper.lineBuffer.length = 0, p.overflow = !0, p.left = 1e3, p.top = 1e3, frame.lines[frame.lines.length - 1].paragraphs.push(p), skip = !0), p.newLine && (skip = !1, wrapper.lineWidth = 0), wrapper.send();
      }
    } else for (let i = 0; i < paragraphs.length; i++) wrapper.deal(paragraphs[i]);
    wrapper.send();
    if (!("horizontal" === frame.layoutDirection ? richTextWidthEnable : richTextHeightEnable)) {
      const frameSize = frame.getActualSizeWidthEllipsis();
      let offsetSize = "horizontal" === frame.layoutDirection ? frameSize.width : frameSize.height;
      ("horizontal" === frame.layoutDirection ? maxWidthFinite : maxHeightFinite) && (offsetSize = Math.min(offsetSize, "horizontal" === frame.layoutDirection ? maxWidth : maxHeight)), frame.lines.forEach(function (l) {
        l.calcOffset(offsetSize, !1);
      });
    }
    enableMultiBreakLine && frame.lines.forEach(item => {
      const lastParagraphs = item.paragraphs;
      item.paragraphs = item.paragraphs.filter(p => "" !== p.text), 0 === item.paragraphs.length && lastParagraphs.length && (lastParagraphs[0].text = "\n", item.paragraphs.push(lastParagraphs[0]));
    }), this._frameCache = frame;
  }
  clone() {
    return new RichText(Object.assign({}, this.attribute));
  }
  setStage(stage, layer) {
    super.setStage(stage, layer);
    this.getFrameCache().icons.forEach(icon => {
      icon.setStage(stage, layer);
    });
  }
  bindIconEvent() {
    this.addEventListener("pointermove", e => {
      const pickedIcon = this.pickIcon(e.global);
      pickedIcon && pickedIcon === this._currentHoverIcon || (pickedIcon ? this.setAttribute("hoverIconId", pickedIcon.richtextId) : !pickedIcon && this._currentHoverIcon && this.setAttribute("hoverIconId", void 0));
    }), this.addEventListener("pointerleave", e => {
      this._currentHoverIcon && this.setAttribute("hoverIconId", void 0);
    });
  }
  updateHoverIconState(pickedIcon) {
    var _a, _b, _c, _d, _e;
    pickedIcon ? (null === (_a = this._currentHoverIcon) || void 0 === _a || _a.setHoverState(!1), this._currentHoverIcon = pickedIcon, this._currentHoverIcon.setHoverState(!0), null === (_b = this.stage) || void 0 === _b || _b.setCursor(pickedIcon.attribute.cursor), null === (_c = this.stage) || void 0 === _c || _c.renderNextFrame()) : (this._currentHoverIcon.setHoverState(!1), this._currentHoverIcon = null, null === (_d = this.stage) || void 0 === _d || _d.setCursor(), null === (_e = this.stage) || void 0 === _e || _e.renderNextFrame());
  }
  pickIcon(point) {
    const frameCache = this.getFrameCache(),
      {
        e: x,
        f: y
      } = this.globalTransMatrix;
    let pickIcon;
    return frameCache.icons.forEach((icon, key) => {
      var _a, _b;
      const bounds = icon.AABBBounds.clone();
      bounds.translate(icon._marginArray[3], icon._marginArray[0]), bounds.containsPoint({
        x: point.x - x,
        y: point.y - y
      }) && (pickIcon = icon, pickIcon.globalX = (null !== (_a = pickIcon.attribute.x) && void 0 !== _a ? _a : 0) + x + icon._marginArray[3], pickIcon.globalY = (null !== (_b = pickIcon.attribute.y) && void 0 !== _b ? _b : 0) + y + icon._marginArray[0]);
    }), pickIcon;
  }
  getNoWorkAnimateAttr() {
    return RichText.NOWORK_ANIMATE_ATTR;
  }
}
RichText.NOWORK_ANIMATE_ATTR = Object.assign({
  ellipsis: 1,
  wordBreak: 1,
  verticalDirection: 1,
  textAlign: 1,
  textBaseline: 1,
  textConfig: 1,
  layoutDirection: 1
}, NOWORK_ANIMATE_ATTR);
function createRichText(attributes) {
  return new RichText(attributes);
}

const PATH_UPDATE_TAG_KEY = ["path", "customPath", ...GRAPHIC_UPDATE_TAG_KEY];
class Path extends Graphic {
  constructor(params) {
    super(params), this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  get pathShape() {
    return this.tryUpdateAABBBounds(), this.getParsedPathShape();
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      path: path
    } = this.attribute;
    return null != path && "" !== path;
  }
  getParsedPathShape() {
    const pathTheme = this.getGraphicTheme();
    if (!this.valid) return pathTheme.path;
    const attribute = this.attribute;
    return attribute.path instanceof CustomPath2D ? attribute.path : (isNil$1(this.cache) && this.doUpdatePathShape(), this.cache instanceof CustomPath2D ? this.cache : pathTheme.path);
  }
  getGraphicTheme() {
    return getTheme(this).path;
  }
  updateAABBBounds(attribute, pathTheme, aabbBounds) {
    if (!this.updatePathProxyAABBBounds(aabbBounds)) {
      const pathShape = this.getParsedPathShape();
      aabbBounds.union(pathShape.getBounds());
    }
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfCommonOuterBorder(attribute, pathTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    const {
      lineJoin = pathTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, pathTheme, "miter" === lineJoin, this), aabbBounds;
  }
  doUpdateAABBBounds(full) {
    return this.doUpdatePathShape(), super.doUpdateAABBBounds(full);
  }
  doUpdatePathShape() {
    const attribute = this.attribute;
    isString$1(attribute.path, !0) ? this.cache = new CustomPath2D().fromString(attribute.path) : attribute.customPath && (this.cache = new CustomPath2D(), attribute.customPath(this.cache, this));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, PATH_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, PATH_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    return new CustomPath2D().fromCustomPath2D(this.getParsedPathShape(), 0, 0);
  }
  clone() {
    return new Path(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Path.NOWORK_ANIMATE_ATTR;
  }
}
Path.NOWORK_ANIMATE_ATTR = Object.assign({
  path: 1,
  customPath: 1
}, NOWORK_ANIMATE_ATTR);
function createPath(attributes) {
  return new Path(attributes);
}

const AREA_UPDATE_TAG_KEY = ["segments", "points", "curveType", "curveTension", ...GRAPHIC_UPDATE_TAG_KEY];
class Area extends Graphic {
  constructor(params) {
    super(params), this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    if (this.pathProxy) return !0;
    const {
      points: points,
      segments: segments
    } = this.attribute;
    return segments ? 0 !== segments.length : !!points && 0 !== points.length;
  }
  getGraphicTheme() {
    return getTheme(this).area;
  }
  updateAABBBounds(attribute, areaTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || (attribute.segments ? this.updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds) : this.updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds)), application.graphicService.updateTempAABBBounds(aabbBounds);
    const {
      lineJoin = areaTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, areaTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateAreaAABBBoundsByPoints(attribute, areaTheme, aabbBounds, graphic) {
    const {
        points = areaTheme.points
      } = attribute,
      b = aabbBounds;
    return points.forEach(p => {
      var _a, _b;
      b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }), b;
  }
  updateAreaAABBBoundsBySegments(attribute, areaTheme, aabbBounds, graphic) {
    const {
        segments = areaTheme.segments
      } = attribute,
      b = aabbBounds;
    return segments.forEach(s => {
      s.points.forEach(p => {
        var _a, _b;
        b.add(p.x, p.y), b.add(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
      });
    }), b;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, AREA_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, AREA_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const path = new CustomPath2D(),
      attribute = this.attribute,
      segments = attribute.segments,
      parsePoints = points => {
        if (points && points.length) {
          let isFirst = !0;
          const basePoints = [];
          if (points.forEach(point => {
            var _a, _b;
            !1 !== point.defined && (isFirst ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y), basePoints.push({
              x: null !== (_a = point.x1) && void 0 !== _a ? _a : point.x,
              y: null !== (_b = point.y1) && void 0 !== _b ? _b : point.y
            }), isFirst = !1);
          }), basePoints.length) {
            for (let i = basePoints.length - 1; i >= 0; i--) path.lineTo(basePoints[i].x, basePoints[i].y);
            path.closePath();
          }
        }
      };
    return attribute.points ? parsePoints(attribute.points) : segments && segments.length && segments.forEach(seg => {
      parsePoints(seg.points);
    }), path;
  }
  clone() {
    return new Area(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Area.NOWORK_ANIMATE_ATTR;
  }
}
Area.NOWORK_ANIMATE_ATTR = Object.assign({
  segments: 1,
  curveType: 1
}, NOWORK_ANIMATE_ATTR);
function createArea(attributes) {
  return new Area(attributes);
}

const ARC_UPDATE_TAG_KEY = ["innerRadius", "outerRadius", "startAngle", "endAngle", "cornerRadius", "padAngle", "padRadius", "cap", ...GRAPHIC_UPDATE_TAG_KEY];
class Arc extends Graphic {
  constructor(params) {
    super(params), this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      startAngle: startAngle,
      endAngle: endAngle,
      outerRadius: outerRadius,
      innerRadius: innerRadius
    } = this.attribute;
    return this._validNumber(startAngle) && this._validNumber(endAngle) && this._validNumber(outerRadius) && this._validNumber(innerRadius);
  }
  getParsedCornerRadius() {
    const arcTheme = this.getGraphicTheme(),
      {
        cornerRadius = arcTheme.cornerRadius,
        innerPadding = arcTheme.innerPadding,
        outerPadding = arcTheme.outerPadding
      } = this.attribute;
    let {
      outerRadius = arcTheme.outerRadius,
      innerRadius = arcTheme.innerRadius
    } = this.attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, 0 === cornerRadius || "0%" === cornerRadius) return 0;
    const deltaRadius = Math.abs(outerRadius - innerRadius),
      parseCR = cornerRadius => Math.min(isNumber$1(cornerRadius, !0) ? cornerRadius : deltaRadius * parseFloat(cornerRadius) / 100, deltaRadius / 2);
    if (isArray$1(cornerRadius)) {
      const crList = cornerRadius.map(cr => parseCR(cr) || 0);
      return 0 === crList.length ? [crList[0], crList[0], crList[0], crList[0]] : 2 === crList.length ? [crList[0], crList[1], crList[0], crList[1]] : (3 === crList.length && crList.push(0), crList);
    }
    return parseCR(cornerRadius);
  }
  getParsedAngle() {
    const arcTheme = this.getGraphicTheme();
    let {
      startAngle = arcTheme.startAngle,
      endAngle = arcTheme.endAngle
    } = this.attribute;
    const {
        cap = arcTheme.cap
      } = this.attribute,
      sign = endAngle - startAngle >= 0 ? 1 : -1,
      deltaAngle = endAngle - startAngle;
    if (startAngle = clampAngleByRadian(startAngle), endAngle = startAngle + deltaAngle, cap && abs(deltaAngle) < pi2 - epsilon) {
      let startCap = 1,
        endCap = 1;
      cap.length && (startCap = Number(cap[0]), endCap = Number(cap[1]));
      let {
        outerRadius = arcTheme.outerRadius,
        innerRadius = arcTheme.innerRadius
      } = this.attribute;
      const {
        outerPadding = arcTheme.outerPadding,
        innerPadding = arcTheme.innerPadding
      } = this.attribute;
      outerRadius += outerPadding, innerRadius -= innerPadding;
      const capWidth = Math.abs(outerRadius - innerRadius) / 2,
        capAngle = capWidth / outerRadius;
      if (capWidth > epsilon && outerRadius > epsilon) return {
        startAngle: startAngle - sign * capAngle * startCap,
        endAngle: endAngle + sign * capAngle * endCap,
        sc: sign * capAngle * startCap,
        ec: sign * capAngle * endCap
      };
    }
    return {
      startAngle: startAngle,
      endAngle: endAngle
    };
  }
  getParsePadAngle(startAngle, endAngle) {
    const arcTheme = this.getGraphicTheme(),
      {
        innerPadding = arcTheme.innerPadding,
        outerPadding = arcTheme.outerPadding,
        padAngle = arcTheme.padAngle
      } = this.attribute;
    let {
      outerRadius = arcTheme.outerRadius,
      innerRadius = arcTheme.innerRadius
    } = this.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const {
        padRadius = sqrt(outerRadius * outerRadius + innerRadius * innerRadius)
      } = this.attribute,
      deltaAngle = abs(endAngle - startAngle);
    let outerStartAngle = startAngle,
      outerEndAngle = endAngle,
      innerStartAngle = startAngle,
      innerEndAngle = endAngle;
    const halfPadAngle = padAngle / 2;
    let innerDeltaAngle = deltaAngle,
      outerDeltaAngle = deltaAngle;
    if (halfPadAngle > epsilon && padRadius > epsilon) {
      const sign = endAngle > startAngle ? 1 : -1;
      let p0 = asin(Number(padRadius) / innerRadius * sin(halfPadAngle)),
        p1 = asin(Number(padRadius) / outerRadius * sin(halfPadAngle));
      return (innerDeltaAngle -= 2 * p0) > epsilon ? (p0 *= sign, innerStartAngle += p0, innerEndAngle -= p0) : (innerDeltaAngle = 0, innerStartAngle = innerEndAngle = (startAngle + endAngle) / 2), (outerDeltaAngle -= 2 * p1) > epsilon ? (p1 *= sign, outerStartAngle += p1, outerEndAngle -= p1) : (outerDeltaAngle = 0, outerStartAngle = outerEndAngle = (startAngle + endAngle) / 2), {
        outerStartAngle: outerStartAngle,
        outerEndAngle: outerEndAngle,
        innerStartAngle: innerStartAngle,
        innerEndAngle: innerEndAngle,
        innerDeltaAngle: innerDeltaAngle,
        outerDeltaAngle: outerDeltaAngle
      };
    }
    return {
      outerStartAngle: outerStartAngle,
      outerEndAngle: outerEndAngle,
      innerStartAngle: innerStartAngle,
      innerEndAngle: innerEndAngle,
      innerDeltaAngle: innerDeltaAngle,
      outerDeltaAngle: outerDeltaAngle
    };
  }
  getGraphicTheme() {
    return getTheme(this).arc;
  }
  updateAABBBounds(attribute, arcTheme, aabbBounds, full) {
    this.updatePathProxyAABBBounds(aabbBounds) || (full ? this.updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) : this.updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds));
    const {
      tb1: tb1,
      tb2: tb2
    } = application.graphicService.updateTempAABBBounds(aabbBounds);
    updateBoundsOfCommonOuterBorder(attribute, arcTheme, tb1), aabbBounds.union(tb1), tb1.setValue(tb2.x1, tb2.y1, tb2.x2, tb2.y2);
    const {
      lineJoin = arcTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updateArcAABBBoundsImprecise(attribute, arcTheme, aabbBounds) {
    let {
      outerRadius = arcTheme.outerRadius,
      innerRadius = arcTheme.innerRadius
    } = attribute;
    const {
      outerPadding = arcTheme.outerPadding,
      innerPadding = arcTheme.innerPadding
    } = attribute;
    return outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius && (outerRadius = innerRadius), aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius), aabbBounds;
  }
  updateArcAABBBoundsAccurate(attribute, arcTheme, aabbBounds) {
    let {
      outerRadius = arcTheme.outerRadius,
      innerRadius = arcTheme.innerRadius
    } = attribute;
    const {
      outerPadding = arcTheme.outerPadding,
      innerPadding = arcTheme.innerPadding
    } = attribute;
    if (outerRadius += outerPadding, innerRadius -= innerPadding, outerRadius < innerRadius) {
      const temp = outerRadius;
      outerRadius = innerRadius, innerRadius = temp;
    }
    let {
      endAngle = arcTheme.endAngle,
      startAngle = arcTheme.startAngle
    } = attribute;
    if (startAngle > endAngle) {
      const temp = startAngle;
      startAngle = endAngle, endAngle = temp;
    }
    return outerRadius <= epsilon ? aabbBounds.set(0, 0, 0, 0) : Math.abs(endAngle - startAngle) > pi2 - epsilon ? aabbBounds.set(-outerRadius, -outerRadius, outerRadius, outerRadius) : (circleBounds(startAngle, endAngle, outerRadius, aabbBounds), circleBounds(startAngle, endAngle, innerRadius, aabbBounds)), aabbBounds;
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, ARC_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, ARC_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    var _a, _b, _c, _d;
    const attribute = this.attribute,
      {
        startAngle: startAngle,
        endAngle: endAngle
      } = this.getParsedAngle();
    let innerRadius = (null !== (_a = attribute.innerRadius) && void 0 !== _a ? _a : 0) - (null !== (_b = attribute.innerPadding) && void 0 !== _b ? _b : 0),
      outerRadius = (null !== (_c = attribute.outerRadius) && void 0 !== _c ? _c : 0) - (null !== (_d = attribute.outerPadding) && void 0 !== _d ? _d : 0);
    const deltaAngle = abs(endAngle - startAngle),
      clockwise = endAngle > startAngle;
    if (outerRadius < innerRadius) {
      const temp = outerRadius;
      outerRadius = innerRadius, innerRadius = temp;
    }
    const path = new CustomPath2D();
    if (outerRadius <= epsilon) path.moveTo(0, 0);else if (deltaAngle >= pi2 - epsilon) path.moveTo(0 + outerRadius * cos(startAngle), 0 + outerRadius * sin(startAngle)), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), innerRadius > epsilon && (path.moveTo(0 + innerRadius * cos(endAngle), 0 + innerRadius * sin(endAngle)), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise));else {
      const xors = outerRadius * cos(startAngle),
        yors = outerRadius * sin(startAngle),
        xire = innerRadius * cos(endAngle),
        yire = innerRadius * sin(endAngle);
      path.moveTo(0 + xors, 0 + yors), path.arc(0, 0, outerRadius, startAngle, endAngle, !clockwise), path.lineTo(0 + xire, 0 + yire), path.arc(0, 0, innerRadius, endAngle, startAngle, clockwise), path.closePath();
    }
    return path;
  }
  clone() {
    return new Arc(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Arc.NOWORK_ANIMATE_ATTR;
  }
}
Arc.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc(attributes) {
  return new Arc(attributes);
}

class Arc3d extends Arc {
  constructor(params) {
    super(params), this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE;
  }
  updateAABBBounds(attribute, arcTheme, aabbBounds) {
    const stage = this.stage;
    if (!stage || !stage.camera) return aabbBounds;
    const {
        outerRadius = arcTheme.outerRadius,
        height = 0
      } = attribute,
      r = outerRadius + height;
    return aabbBounds.setValue(-r, -r, r, r), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, arcTheme, !1, this), aabbBounds;
  }
  getNoWorkAnimateAttr() {
    return Arc3d.NOWORK_ANIMATE_ATTR;
  }
}
Arc3d.NOWORK_ANIMATE_ATTR = Object.assign({
  cap: 1
}, NOWORK_ANIMATE_ATTR);
function createArc3d(attributes) {
  return new Arc3d(attributes);
}

const POLYGON_UPDATE_TAG_KEY = ["points", "cornerRadius", ...GRAPHIC_UPDATE_TAG_KEY];
class Polygon extends Graphic {
  constructor(params) {
    super(params), this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
  isValid() {
    return super.isValid() && this._isValid();
  }
  _isValid() {
    const {
      points: points
    } = this.attribute;
    return points && points.length >= 2;
  }
  getGraphicTheme() {
    return getTheme(this).polygon;
  }
  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
    this.updatePathProxyAABBBounds(aabbBounds) || this.updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds), application.graphicService.updateTempAABBBounds(aabbBounds);
    const {
      lineJoin = polygonTheme.lineJoin
    } = attribute;
    return application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, "miter" === lineJoin, this), aabbBounds;
  }
  updatePolygonAABBBoundsImprecise(attribute, polygonTheme, aabbBounds) {
    const {
      points = polygonTheme.points
    } = attribute;
    return points.forEach(p => {
      aabbBounds.add(p.x, p.y);
    }), aabbBounds;
  }
  _interpolate(key, ratio, lastStepVal, nextStepVal, nextAttributes) {
    "points" === key && (nextAttributes.points = pointsInterpolation(lastStepVal, nextStepVal, ratio));
  }
  needUpdateTags(keys) {
    return super.needUpdateTags(keys, POLYGON_UPDATE_TAG_KEY);
  }
  needUpdateTag(key) {
    return super.needUpdateTag(key, POLYGON_UPDATE_TAG_KEY);
  }
  toCustomPath() {
    const points = this.attribute.points,
      path = new CustomPath2D();
    return points.forEach((point, index) => {
      0 === index ? path.moveTo(point.x, point.y) : path.lineTo(point.x, point.y);
    }), path.closePath(), path;
  }
  clone() {
    return new Polygon(Object.assign({}, this.attribute));
  }
  getNoWorkAnimateAttr() {
    return Polygon.NOWORK_ANIMATE_ATTR;
  }
}
Polygon.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPolygon(attributes) {
  return new Polygon(attributes);
}

class Pyramid3d extends Polygon {
  constructor(params) {
    super(params), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  updateAABBBounds(attribute, polygonTheme, aabbBounds) {
    const stage = this.stage;
    if (!stage || !stage.camera) return aabbBounds;
    return this.findFace().vertices.forEach(v => {
      const x = v[0],
        y = v[1];
      aabbBounds.add(x, y);
    }), application.graphicService.updateTempAABBBounds(aabbBounds), application.graphicService.transformAABBBounds(attribute, aabbBounds, polygonTheme, !1, this), aabbBounds;
  }
  findFace() {
    const {
        points: points
      } = this.attribute,
      kList = points.map((p, i) => {
        const p1 = 3 === i ? points[0] : points[i + 1],
          dx = p.x - p1.x;
        return 0 === dx ? 0 : (p.y - p1.y) / dx;
      }),
      pointsMap = points.map(p => ({
        p: p,
        d: 0
      }));
    let find = !1,
      maxD = 0;
    for (let i = 0; i < kList.length - 1; i++) {
      for (let j = i + 1; j < kList.length; j++) {
        if (kList[i] === kList[j]) {
          find = !0;
          const d1 = PointService.distancePP(pointsMap[i].p, pointsMap[i + 1].p);
          pointsMap[i].d = d1, pointsMap[i + 1].d = d1, maxD = max(maxD, d1);
          const d2 = PointService.distancePP(pointsMap[j].p, pointsMap[j + 1].p);
          pointsMap[j].d = d2, pointsMap[j + 1].d = d2, maxD = max(maxD, d2);
        }
        if (find) break;
      }
      if (find) break;
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      pointsMap.unshift({
        p: p,
        d: 0
      });
    }
    for (let i = 0; i < points.length; i++) {
      const delta = (maxD - pointsMap[i + points.length].d) / 2;
      pointsMap[i].d += delta, pointsMap[i + points.length].d += delta;
    }
    const faces = {
      polygons: [],
      vertices: [],
      edges: []
    };
    return pointsMap.forEach(p => {
      faces.vertices.push([p.p.x, p.p.y, p.d]);
    }), faces.polygons.push({
      polygon: [0, 4, 5, 1],
      normal: [0, -1, 0]
    }), faces.polygons.push({
      polygon: [7, 6, 2, 3],
      normal: [0, 1, 0]
    }), faces.polygons.push({
      polygon: [0, 4, 7, 3],
      normal: [-1, 0, 0]
    }), faces.polygons.push({
      polygon: [1, 5, 6, 2],
      normal: [1, 0, 0]
    }), faces.polygons.push({
      polygon: [0, 1, 2, 3],
      normal: [0, 0, -1]
    }), faces.polygons.push({
      polygon: [4, 5, 6, 7],
      normal: [0, 0, 1]
    }), faces.edges = [[0, 1], [1, 2], [2, 3], [3, 0], [4, 5], [5, 6], [6, 7], [7, 4], [0, 4], [3, 7], [1, 5], [2, 6]], faces;
  }
  _isValid() {
    return super._isValid() && 4 === this.attribute.points.length;
  }
  getNoWorkAnimateAttr() {
    return Pyramid3d.NOWORK_ANIMATE_ATTR;
  }
}
Pyramid3d.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createPyramid3d(attributes) {
  return new Pyramid3d(attributes);
}

class ShadowRoot extends Group {
  constructor(graphic) {
    super({
      x: 0,
      y: 0
    }), this.type = "shadowroot", this.shadowHost = graphic;
  }
  clearUpdateBoundTag() {
    super.clearUpdateBoundTag(), this.shadowHost && this.shadowHost.clearUpdateBoundTag();
  }
  addUpdateBoundTag() {
    super.addUpdateBoundTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  addUpdateShapeAndBoundsTag() {
    super.addUpdateShapeAndBoundsTag(), this.shadowHost && this.shadowHost.addUpdateBoundTag();
  }
  tryUpdateGlobalTransMatrix() {
    let clearTag = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    if (this.shouldUpdateGlobalMatrix()) {
      const m = this.transMatrix;
      this._globalTransMatrix ? this._globalTransMatrix.setValue(m.a, m.b, m.c, m.d, m.e, m.f) : this._globalTransMatrix = m.clone(), this.doUpdateGlobalMatrix(), clearTag && this.clearUpdateGlobalPositionTag();
    }
    return this._globalTransMatrix;
  }
  doUpdateGlobalMatrix() {
    if (this.shadowHost) {
      const parentMatrix = this.shadowHost.globalTransMatrix;
      this._globalTransMatrix.multiply(parentMatrix.a, parentMatrix.b, parentMatrix.c, parentMatrix.d, parentMatrix.e, parentMatrix.f);
    }
  }
  tryUpdateGlobalAABBBounds() {
    return this._globalAABBBounds ? this._globalAABBBounds.setValue(this._AABBBounds.x1, this._AABBBounds.y1, this._AABBBounds.x2, this._AABBBounds.y2) : this._globalAABBBounds = this._AABBBounds.clone(), this.shadowHost && this._globalAABBBounds.transformWithMatrix(this.shadowHost.globalTransMatrix), this._globalAABBBounds;
  }
}
function createShadowRoot(graphic) {
  return new ShadowRoot(graphic);
}

class GraphicCreator {
  constructor() {
    this.store = new Map();
  }
  RegisterGraphicCreator(name, cb) {
    this.store.set(name, cb), this[name] = cb;
  }
  CreateGraphic(name, params) {
    const cb = this.store.get(name);
    return cb ? cb(params) : null;
  }
}
const graphicCreator = new GraphicCreator();

let text, richText;
function getTextBounds(params) {
  return text || (text = graphicCreator.CreateGraphic("text", {})), text.initAttributes(params), text.AABBBounds;
}
function getRichTextBounds(params) {
  return richText || (richText = graphicCreator.CreateGraphic("richtext", {})), richText.setAttributes(params), richText.AABBBounds;
}

var __decorate$1E = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1f = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$T = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
class DefaultBaseBackgroundRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a;
    const {
      background: background,
      backgroundOpacity = null !== (_a = graphic.attribute.fillOpacity) && void 0 !== _a ? _a : graphicAttribute.backgroundOpacity,
      opacity = graphicAttribute.opacity,
      backgroundMode = graphicAttribute.backgroundMode,
      backgroundFit = graphicAttribute.backgroundFit,
      backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio,
      backgroundScale = graphicAttribute.backgroundScale,
      backgroundOffsetX = graphicAttribute.backgroundOffsetX,
      backgroundOffsetY = graphicAttribute.backgroundOffsetY,
      backgroundClip = graphicAttribute.backgroundClip
    } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      if (context.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const groupAttribute = getTheme(graphic.parent).group,
          {
            scrollX = groupAttribute.scrollX,
            scrollY = groupAttribute.scrollY
          } = graphic.parent.attribute;
        context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.translate(scrollX, scrollY);
      }
      backgroundClip && context.clip();
      const b = graphic.AABBBounds;
      context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, this.doDrawImage(context, res.data, b, {
        backgroundMode: backgroundMode,
        backgroundFit: backgroundFit,
        backgroundKeepAspectRatio: backgroundKeepAspectRatio,
        backgroundScale: backgroundScale,
        backgroundOffsetX: backgroundOffsetX,
        backgroundOffsetY: backgroundOffsetY
      }), context.restore(), graphic.transMatrix.onlyTranslate() || context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.globalAlpha = backgroundOpacity * opacity, context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
  doDrawImage(context, data, b, params) {
    const {
        backgroundMode: backgroundMode,
        backgroundFit: backgroundFit,
        backgroundKeepAspectRatio: backgroundKeepAspectRatio,
        backgroundScale = 1,
        backgroundOffsetX = 0,
        backgroundOffsetY = 0
      } = params,
      targetW = b.width(),
      targetH = b.height();
    let w = targetW,
      h = targetH;
    if ("no-repeat" === backgroundMode) {
      if (backgroundFit) {
        if (backgroundKeepAspectRatio) {
          const maxScale = Math.max(targetW / data.width, targetH / data.height);
          context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, data.width * maxScale * backgroundScale, data.height * maxScale * backgroundScale);
        } else context.drawImage(data, b.x1, b.y1, b.width(), b.height());
      } else {
        const resW = data.width * backgroundScale,
          resH = data.height * backgroundScale;
        context.drawImage(data, b.x1 + backgroundOffsetX, b.y1 + backgroundOffsetY, resW, resH);
      }
    } else {
      if (backgroundFit && "repeat" !== backgroundMode && (data.width || data.height)) {
        const resW = data.width,
          resH = data.height;
        if ("repeat-x" === backgroundMode) {
          w = resW * (targetH / resH), h = targetH;
        } else if ("repeat-y" === backgroundMode) {
          h = resH * (targetW / resW), w = targetW;
        }
        const dpr = context.dpr,
          canvas = canvasAllocate.allocate({
            width: w,
            height: h,
            dpr: dpr
          }),
          ctx = canvas.getContext("2d");
        ctx && (ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, w, h), ctx.drawImage(data, 0, 0, w, h), data = canvas.nativeCanvas), canvasAllocate.free(canvas);
      }
      const dpr = context.dpr,
        pattern = context.createPattern(data, backgroundMode);
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), context.fillStyle = pattern, context.translate(b.x1, b.y1), context.fillRect(0, 0, targetW, targetH), context.translate(-b.x1, -b.y1);
    }
  }
}
const defaultBaseBackgroundRenderContribution = new DefaultBaseBackgroundRenderContribution();
let DefaultBaseInteractiveRenderContribution = class {
  constructor(subRenderContribitions) {
    this.subRenderContribitions = subRenderContribitions, this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this._subRenderContribitions || (this._subRenderContribitions = this.subRenderContribitions.getContributions()), this._subRenderContribitions.forEach(c => {
      c.render(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options);
    });
  }
};
DefaultBaseInteractiveRenderContribution = __decorate$1E([injectable(), __param$T(0, inject(ContributionProvider)), __param$T(0, named(InteractiveSubRenderContribution)), __metadata$1f("design:paramtypes", [Object])], DefaultBaseInteractiveRenderContribution);
class DefaultBaseClipRenderBeforeContribution {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b;
    const {
      clipConfig: clipConfig
    } = graphic.attribute;
    if (!clipConfig) return;
    const clipPath = graphic.getClipPath();
    if (!clipPath) return;
    const draw = !(fillCb || strokeCb),
      b = graphic.AABBBounds,
      width = null !== (_a = graphic.attribute.width) && void 0 !== _a ? _a : b.width(),
      height = null !== (_b = graphic.attribute.height) && void 0 !== _b ? _b : b.height();
    draw && context.save(), context.beginPath(), !1 === clipPath.draw(context, [width, height], x + width / 2, y + height / 2, 0) && context.closePath(), fillCb && fillCb(context, graphic.attribute, graphicAttribute, !0), draw && context.clip();
  }
}
const defaultBaseClipRenderBeforeContribution = new DefaultBaseClipRenderBeforeContribution();
class DefaultBaseClipRenderAfterContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const {
      clipConfig: clipConfig
    } = graphic.attribute;
    if (!clipConfig) return;
    graphic.getClipPath() && (fillCb || strokeCb || context.restore());
  }
}
const defaultBaseClipRenderAfterContribution = new DefaultBaseClipRenderAfterContribution();

function formatRatio(ratio) {
  return ratio <= .5 ? 4 * ratio - 1 : -4 * ratio + 3;
}
function drawWave(ctx, ratio, boundsWidth, boundsHeight, textureOptions, offsetX, offsetY) {
  const {
    fill = "orange",
    percent = .6,
    frequency = 4,
    opacity: opacity,
    phi = 0
  } = textureOptions;
  let {
    amplitude = 10
  } = textureOptions;
  amplitude *= formatRatio(ratio);
  const height = boundsHeight * (1 - percent),
    width = boundsWidth,
    step = Math.max(Math.round(width / 70), 2);
  ctx.beginPath(), ctx.moveTo(0 + offsetX, boundsHeight + offsetY), ctx.lineTo(0 + offsetX, height + offsetY);
  const delta = width / frequency * ratio,
    c = width / Math.PI / (2 * frequency);
  for (let i = 0; i < width; i += step) {
    const y = amplitude * Math.sin((i + delta + phi) / c + phi);
    ctx.lineTo(i + offsetX, height + y + offsetY);
  }
  ctx.lineTo(width + offsetX, boundsHeight + offsetY), ctx.closePath(), ctx.fillStyle = fill, isFinite(opacity) && (ctx.globalAlpha = opacity), ctx.fill();
}
class DefaultBaseTextureRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 10, this._tempSymbolGraphic = null;
  }
  createCommonPattern(size, padding, color, targetContext, cb) {
    const r = (size - 2 * padding) / 2,
      dpr = targetContext.dpr,
      canvas = canvasAllocate.allocate({
        width: size,
        height: size,
        dpr: dpr
      }),
      ctx = canvas.getContext("2d");
    if (!ctx) return null;
    ctx.inuse = !0, ctx.clearMatrix(), ctx.setTransformForCurrent(!0), ctx.clearRect(0, 0, size, size), cb(r, ctx);
    const pattern = targetContext.createPattern(canvas.nativeCanvas, "repeat");
    return pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, 0, 0])), canvasAllocate.free(canvas), pattern;
  }
  createCirclePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.fillStyle = color, ctx.arc(r, r, r, 0, pi2), ctx.fill();
    });
  }
  createDiamondPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = size / 2,
        y = x;
      ctx.fillStyle = color, ctx.moveTo(x, y - r), ctx.lineTo(r + x, y), ctx.lineTo(x, y + r), ctx.lineTo(x - r, y), ctx.closePath(), ctx.fill();
    });
  }
  createRectPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding,
        y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, 2 * r, 2 * r);
    });
  }
  createVerticalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding;
      ctx.fillStyle = color, ctx.fillRect(x, 0, 2 * r, size);
    });
  }
  createHorizontalLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const y = padding;
      ctx.fillStyle = color, ctx.fillRect(0, y, size, 2 * r);
    });
  }
  createBiasLRLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(0, 0), ctx.lineTo(size, size);
      const dx = size / 2,
        dy = -dx;
      ctx.moveTo(dx, dy), ctx.lineTo(dx + size, dy + size), ctx.moveTo(-dx, -dy), ctx.lineTo(-dx + size, -dy + size), ctx.stroke();
    });
  }
  createBiasRLLinePattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      ctx.strokeStyle = color, ctx.lineWidth = r, ctx.moveTo(size, 0), ctx.lineTo(0, size);
      const dx = size / 2,
        dy = dx;
      ctx.moveTo(size + dx, dy), ctx.lineTo(dx, dy + size), ctx.moveTo(size - dx, -dy), ctx.lineTo(-dx, -dy + size), ctx.stroke();
    });
  }
  createGridPattern(size, padding, color, targetContext) {
    return this.createCommonPattern(size, padding, color, targetContext, (r, ctx) => {
      const x = padding,
        y = x;
      ctx.fillStyle = color, ctx.fillRect(x, y, r, r), ctx.fillRect(x + r, y + r, r, r);
    });
  }
  initTextureMap(ctx, stage) {
    this.textureMap = new Map();
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const {
      texture = graphicAttribute.texture,
      textureColor = graphicAttribute.textureColor,
      textureSize = graphicAttribute.textureSize,
      texturePadding = graphicAttribute.texturePadding
    } = graphic.attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
  drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding) {
    var _a;
    const {
      textureRatio = graphicAttribute.textureRatio,
      textureOptions = null
    } = graphic.attribute;
    let pattern = this.textureMap.get(texture);
    if (!pattern) switch (texture) {
      case "circle":
        pattern = this.createCirclePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "diamond":
        pattern = this.createDiamondPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "rect":
        pattern = this.createRectPattern(textureSize, texturePadding, textureColor, context);
        break;
      case "vertical-line":
        pattern = this.createVerticalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "horizontal-line":
        pattern = this.createHorizontalLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-lr":
        pattern = this.createBiasLRLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "bias-rl":
        pattern = this.createBiasRLLinePattern(textureSize, texturePadding, textureColor, context);
        break;
      case "grid":
        pattern = this.createGridPattern(textureSize, texturePadding, textureColor, context);
    }
    if (textureOptions && textureOptions.dynamicTexture) {
      const {
          gridConfig = {},
          useNewCanvas: useNewCanvas
        } = textureOptions,
        b = graphic.AABBBounds;
      x = b.x1, y = b.y1;
      const originalContext = context;
      let newCanvas;
      if (useNewCanvas) {
        newCanvas = canvasAllocate.allocate({
          width: b.width(),
          height: b.height(),
          dpr: context.dpr
        });
        const ctx = newCanvas.getContext("2d");
        ctx.clearRect(0, 0, b.width(), b.height()), x = 0, y = 0, context = ctx;
      }
      if (originalContext.save(), graphic.parent && !graphic.transMatrix.onlyTranslate()) {
        const {
          scrollX = 0,
          scrollY = 0
        } = graphic.parent.attribute;
        originalContext.setTransformFromMatrix(graphic.parent.globalTransMatrix), originalContext.translate(scrollX, scrollY, !0);
      }
      originalContext.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), originalContext.clip();
      const width = b.width(),
        height = b.height(),
        padding = texturePadding,
        cellSize = textureSize,
        gridColumns = gridConfig.columns ? gridConfig.columns : Math.ceil(width / cellSize),
        gridRows = gridConfig.rows ? gridConfig.rows : Math.ceil(height / cellSize),
        gutterColumn = gridConfig.gutterColumn ? gridConfig.gutterColumn : 2 * padding,
        gutterRow = gridConfig.gutterRow ? gridConfig.gutterRow : 2 * padding;
      this._tempSymbolGraphic || (this._tempSymbolGraphic = createSymbol({}));
      const sizeW = gridConfig.columns ? width / gridConfig.columns : cellSize,
        sizeH = gridConfig.rows ? height / gridConfig.rows : cellSize;
      this._tempSymbolGraphic.setAttributes({
        size: [sizeW - gutterColumn, sizeH - gutterRow],
        symbolType: texture
      });
      const parsedPath = this._tempSymbolGraphic.getParsedPath();
      for (let i = 0; i < gridRows; i++) for (let j = 0; j < gridColumns; j++) {
        const _x = x + cellSize / 2 + j * cellSize,
          _y = y + cellSize / 2 + i * cellSize;
        null === (_a = textureOptions.beforeDynamicTexture) || void 0 === _a || _a.call(textureOptions, context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height()), context.beginPath(), !1 === parsedPath.draw(context, Math.min(sizeW - gutterColumn, sizeH - gutterRow), _x, _y, 0) && context.closePath(), context.fillStyle = textureColor, textureOptions.dynamicTexture(context, i, j, gridRows, gridColumns, textureRatio, graphic, b.width(), b.height());
      }
      useNewCanvas && (originalContext.globalAlpha = 1, originalContext.drawImage(newCanvas.nativeCanvas, 0, 0, newCanvas.nativeCanvas.width, newCanvas.nativeCanvas.height, b.x1, b.y1, b.width() * originalContext.dpr, b.height() * originalContext.dpr)), originalContext.restore();
    } else if (pattern) context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = pattern, context.fill(), context.highPerformanceRestore();else if ("wave" === texture) {
      context.save(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.clip();
      const b = graphic.AABBBounds;
      drawWave(context, textureRatio, b.width(), b.height(), Object.assign(Object.assign({}, textureOptions || {}), {
        fill: textureColor
      }), x + b.x1 - x, y + b.y1 - y), context.restore();
    }
  }
}
const defaultBaseTextureRenderContribution = new DefaultBaseTextureRenderContribution();

class DefaultArcRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb) {
    const {
        outerBorder: outerBorder,
        innerBorder: innerBorder
      } = arc.attribute,
      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const {
      innerPadding = arcAttribute.innerPadding,
      outerPadding = arcAttribute.outerPadding,
      startAngle = arcAttribute.startAngle,
      endAngle = arcAttribute.endAngle,
      opacity = arcAttribute.opacity,
      x: originX = arcAttribute.x,
      y: originY = arcAttribute.y,
      scaleX = arcAttribute.scaleX,
      scaleY = arcAttribute.scaleY,
      keepStrokeScale = arcAttribute.keepStrokeScale
    } = arc.attribute;
    let {
      innerRadius = arcAttribute.innerRadius,
      outerRadius = arcAttribute.outerRadius
    } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const renderBorder = (borderStyle, key) => {
      const doStroke = !(!borderStyle || !borderStyle.stroke),
        {
          distance = arcAttribute[key].distance
        } = borderStyle,
        d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
        deltaAngle = distance / outerRadius,
        sign = "outerBorder" === key ? 1 : -1;
      if (arc.setAttributes({
        outerRadius: outerRadius + sign * d,
        innerRadius: innerRadius - sign * d,
        startAngle: startAngle - sign * deltaAngle,
        endAngle: endAngle + sign * deltaAngle
      }), context.beginPath(), drawArcPath$1(arc, context, x, y, outerRadius + sign * d, innerRadius - sign * d), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), strokeCb) strokeCb(context, borderStyle, arcAttribute[key]);else if (doStroke) {
        const lastOpacity = arcAttribute[key].opacity;
        arcAttribute[key].opacity = opacity, context.setStrokeStyle(arc, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, arcAttribute[key]), arcAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder"), arc.setAttributes({
      outerRadius: outerRadius,
      innerRadius: innerRadius,
      startAngle: startAngle,
      endAngle: endAngle
    });
  }
}
const defaultArcRenderContribution = new DefaultArcRenderContribution();
const defaultArcTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultArcBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultCircleRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb) {
    const {
        outerBorder: outerBorder,
        innerBorder: innerBorder
      } = circle.attribute,
      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const {
        radius = circleAttribute.radius,
        startAngle = circleAttribute.startAngle,
        endAngle = circleAttribute.endAngle,
        opacity = circleAttribute.opacity,
        x: originX = circleAttribute.x,
        y: originY = circleAttribute.y,
        scaleX = circleAttribute.scaleX,
        scaleY = circleAttribute.scaleY,
        keepStrokeScale = circleAttribute.keepStrokeScale
      } = circle.attribute,
      renderBorder = (borderStyle, key) => {
        const doStroke = !(!borderStyle || !borderStyle.stroke),
          {
            distance = circleAttribute[key].distance
          } = borderStyle,
          d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
          sign = "outerBorder" === key ? 1 : -1;
        if (context.beginPath(), context.arc(x, y, radius + sign * d, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), strokeCb) strokeCb(context, borderStyle, circleAttribute[key]);else if (doStroke) {
          const lastOpacity = circleAttribute[key].opacity;
          circleAttribute[key].opacity = opacity, context.setStrokeStyle(circle, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, circleAttribute[key]), circleAttribute[key].opacity = lastOpacity, context.stroke();
        }
      };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
}
const defaultCircleRenderContribution = new DefaultCircleRenderContribution();
const defaultCircleTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultCircleBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultGroupBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    const {
      background: background,
      backgroundMode = graphicAttribute.backgroundMode,
      backgroundFit = graphicAttribute.backgroundFit,
      backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio,
      backgroundScale = graphicAttribute.backgroundScale,
      backgroundOffsetX = graphicAttribute.backgroundOffsetX,
      backgroundOffsetY = graphicAttribute.backgroundOffsetY
    } = graphic.attribute;
    if (background) if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return;
      context.highPerformanceSave(), context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0);
      const b = graphic.AABBBounds;
      this.doDrawImage(context, res.data, b, {
        backgroundMode: backgroundMode,
        backgroundFit: backgroundFit,
        backgroundKeepAspectRatio: backgroundKeepAspectRatio,
        backgroundScale: backgroundScale,
        backgroundOffsetX: backgroundOffsetX,
        backgroundOffsetY: backgroundOffsetY
      }), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else context.highPerformanceSave(), context.fillStyle = background, context.fill(), context.highPerformanceRestore();
  }
}
const defaultGroupBackgroundRenderContribution = new DefaultGroupBackgroundRenderContribution();

const halfPi = pi / 2;
function createRectPath(path, x, y, width, height, rectCornerRadius) {
  let roundCorner = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
  let edgeCb = arguments.length > 7 ? arguments[7] : undefined;
  let cornerRadius;
  if (Array.isArray(roundCorner) && (edgeCb = roundCorner, roundCorner = !0), width < 0 && (x += width, width = -width), height < 0 && (y += height, height = -height), isNumber$1(rectCornerRadius, !0)) cornerRadius = [rectCornerRadius = abs(rectCornerRadius), rectCornerRadius, rectCornerRadius, rectCornerRadius];else if (Array.isArray(rectCornerRadius)) {
    const cornerRadiusArr = rectCornerRadius;
    let cr0, cr1;
    switch (cornerRadiusArr.length) {
      case 0:
        cornerRadius = [0, 0, 0, 0];
        break;
      case 1:
        cr0 = abs(cornerRadiusArr[0]), cornerRadius = [cr0, cr0, cr0, cr0];
        break;
      case 2:
      case 3:
        cr0 = abs(cornerRadiusArr[0]), cr1 = abs(cornerRadiusArr[1]), cornerRadius = [cr0, cr1, cr0, cr1];
        break;
      default:
        cornerRadius = cornerRadiusArr, cornerRadius[0] = abs(cornerRadius[0]), cornerRadius[1] = abs(cornerRadius[1]), cornerRadius[2] = abs(cornerRadius[2]), cornerRadius[3] = abs(cornerRadius[3]);
    }
  } else cornerRadius = [0, 0, 0, 0];
  if (width < 0 || cornerRadius[0] + cornerRadius[1] + cornerRadius[2] + cornerRadius[3] < 1e-12) return path.rect(x, y, width, height);
  const [leftTop, rightTop, rightBottom, leftBottom] = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]],
    maxCornerRadius = Math.min(width / 2, height / 2),
    _cornerRadius = [Math.min(maxCornerRadius, cornerRadius[0]), Math.min(maxCornerRadius, cornerRadius[1]), Math.min(maxCornerRadius, cornerRadius[2]), Math.min(maxCornerRadius, cornerRadius[3])],
    leftTopPoint1 = [leftTop[0] + _cornerRadius[0], leftTop[1]],
    leftTopPoint2 = [leftTop[0], leftTop[1] + _cornerRadius[0]],
    rightTopPoint1 = [rightTop[0] - _cornerRadius[1], rightTop[1]],
    rightTopPoint2 = [rightTop[0], rightTop[1] + _cornerRadius[1]],
    rightBottomPoint1 = [rightBottom[0] - _cornerRadius[2], rightBottom[1]],
    rightBottomPoint2 = [rightBottom[0], rightBottom[1] - _cornerRadius[2]],
    leftBottomPoint1 = [leftBottom[0] + _cornerRadius[3], leftBottom[1]],
    leftBottomPoint2 = [leftBottom[0], leftBottom[1] - _cornerRadius[3]];
  if (path.moveTo(leftTopPoint1[0], leftTopPoint1[1]), roundCorner) {
    if (edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), !arrayEqual(rightTopPoint1, rightTopPoint2)) {
      edgeCb && edgeCb[0] && path.moveTo(rightTopPoint1[0], rightTopPoint1[1]);
      const centerX = rightTopPoint1[0],
        centerY = rightTopPoint1[1] + _cornerRadius[1];
      path.arc(centerX, centerY, _cornerRadius[1], -halfPi, 0, !1);
    }
    if (edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint2[0], rightTopPoint2[1], rightBottomPoint2[0], rightBottomPoint2[1]) : path.lineTo(rightBottomPoint2[0], rightBottomPoint2[1]), !arrayEqual(rightBottomPoint1, rightBottomPoint2)) {
      const centerX = rightBottomPoint2[0] - _cornerRadius[2],
        centerY = rightBottomPoint2[1];
      edgeCb && edgeCb[1] && path.moveTo(rightBottomPoint2[0], rightBottomPoint2[1]), path.arc(centerX, centerY, _cornerRadius[2], 0, halfPi, !1);
    }
    if (edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), !arrayEqual(leftBottomPoint1, leftBottomPoint2)) {
      const centerX = leftBottomPoint1[0],
        centerY = leftBottomPoint1[1] - _cornerRadius[3];
      edgeCb && edgeCb[2] && path.moveTo(leftBottomPoint1[0], leftBottomPoint1[1]), path.arc(centerX, centerY, _cornerRadius[3], halfPi, pi, !1);
    }
    if (edgeCb && edgeCb[3] ? edgeCb[3](leftBottomPoint2[0], leftBottomPoint2[1], leftTopPoint2[0], leftTopPoint2[1]) : path.lineTo(leftTopPoint2[0], leftTopPoint2[1]), !arrayEqual(leftTopPoint1, leftTopPoint2)) {
      const centerX = leftTopPoint1[0],
        centerY = leftTopPoint1[1] + _cornerRadius[0];
      edgeCb && edgeCb[3] && path.moveTo(leftTopPoint2[0], leftTopPoint2[1]), path.arc(centerX, centerY, _cornerRadius[0], pi, pi + halfPi, !1);
    }
  } else edgeCb && edgeCb[0] ? edgeCb[0](leftTopPoint1[0], leftTopPoint1[1], rightTopPoint1[0], rightTopPoint1[1]) : path.lineTo(rightTopPoint1[0], rightTopPoint1[1]), edgeCb && edgeCb[1] ? edgeCb[1](rightTopPoint1[0], rightTopPoint1[1], rightBottomPoint1[0], rightBottomPoint1[1]) : path.lineTo(rightBottomPoint1[0], rightBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](rightBottomPoint1[0], rightBottomPoint1[1], leftBottomPoint1[0], leftBottomPoint1[1]) : path.lineTo(leftBottomPoint1[0], leftBottomPoint1[1]), edgeCb && edgeCb[2] ? edgeCb[2](leftBottomPoint1[0], leftBottomPoint1[1], leftTopPoint1[0], leftTopPoint1[1]) : path.lineTo(leftTopPoint1[0], leftTopPoint1[1]);
  return !edgeCb && path.closePath(), path;
}

var __decorate$1D = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
class DefaultRectRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    const {
        outerBorder: outerBorder,
        innerBorder: innerBorder
      } = rect.attribute,
      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const {
      cornerRadius = rectAttribute.cornerRadius,
      cornerType = rectAttribute.cornerType,
      opacity = rectAttribute.opacity,
      x: originX = rectAttribute.x,
      y: originY = rectAttribute.y,
      scaleX = rectAttribute.scaleX,
      scaleY = rectAttribute.scaleY,
      x1: x1,
      y1: y1,
      keepStrokeScale = rectAttribute.keepStrokeScale
    } = rect.attribute;
    let {
      width: width,
      height: height
    } = rect.attribute;
    width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0;
    const renderBorder = (borderStyle, key) => {
      const doStroke = !(!borderStyle || !borderStyle.stroke),
        sign = "outerBorder" === key ? -1 : 1,
        {
          distance = rectAttribute[key].distance
        } = borderStyle,
        d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
        nextX = x + sign * d,
        nextY = y + sign * d,
        dw = 2 * d;
      if (0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(nextX, nextY, width - sign * dw, height - sign * dw)) : (context.beginPath(), createRectPath(context, nextX, nextY, width - sign * dw, height - sign * dw, cornerRadius, "bevel" !== cornerType)), context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), strokeCb) strokeCb(context, borderStyle, rectAttribute[key]);else if (doStroke) {
        const lastOpacity = rectAttribute[key].opacity;
        rectAttribute[key].opacity = opacity, context.setStrokeStyle(rect, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, rectAttribute[key]), rectAttribute[key].opacity = lastOpacity, context.stroke();
      }
    };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
}
let SplitRectBeforeRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.beforeFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke) {
    const {
      stroke = groupAttribute.stroke
    } = group.attribute;
    Array.isArray(stroke) && stroke.some(s => !1 === s) && (doFillOrStroke.doStroke = !1);
  }
};
SplitRectBeforeRenderContribution = __decorate$1D([injectable()], SplitRectBeforeRenderContribution);
let SplitRectAfterRenderContribution = class {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(rect, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb) {
    const {
      x1: x1,
      y1: y1,
      x: originX = groupAttribute.x,
      y: originY = groupAttribute.y,
      stroke = groupAttribute.stroke,
      cornerRadius = groupAttribute.cornerRadius,
      cornerType = groupAttribute.cornerType
    } = rect.attribute;
    let {
      width: width,
      height: height
    } = rect.attribute;
    if (width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0, Array.isArray(stroke) && stroke.some(s => !1 === s)) {
      if (context.setStrokeStyle(rect, rect.attribute, x, y, groupAttribute), !(0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num))) {
        let lastStroke,
          lastStrokeI = 0;
        return createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType, new Array(4).fill(0).map((_, i) => (x1, y1, x2, y2) => {
          stroke[i] && (lastStrokeI === i - 1 && stroke[i] === lastStroke || (context.setStrokeStyle(rect, Object.assign(Object.assign({}, rect.attribute), {
            stroke: stroke[i]
          }), x, y, groupAttribute), context.beginPath(), context.moveTo(x1, y1), lastStroke = stroke[i]), lastStrokeI = i, context.lineTo(x2, y2), context.stroke(), 3 === i && context.beginPath());
        })), void context.stroke();
      }
      if (context.beginPath(), context.moveTo(x, y), stroke[0] ? context.lineTo(x + width, y) : context.moveTo(x + width, y), stroke[1] ? context.lineTo(x + width, y + height) : context.moveTo(x + width, y + height), stroke[2] ? context.lineTo(x, y + height) : context.moveTo(x, y + height), stroke[3]) {
        const adjustY = stroke[0] ? y - context.lineWidth / 2 : y;
        context.lineTo(x, adjustY);
      } else context.moveTo(x, y);
      context.stroke();
    }
  }
};
SplitRectAfterRenderContribution = __decorate$1D([injectable()], SplitRectAfterRenderContribution);
const defaultRectRenderContribution = new DefaultRectRenderContribution();
const defaultRectTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultRectBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultImageRenderContribution extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    return super.drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
}
const defaultImageRenderContribution = new DefaultImageRenderContribution();
const defaultImageBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultSymbolRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb) {
    const parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const {
        outerBorder: outerBorder,
        innerBorder: innerBorder
      } = symbol.attribute,
      doOuterBorder = outerBorder && !1 !== outerBorder.visible,
      doInnerBorder = innerBorder && !1 !== innerBorder.visible;
    if (!doOuterBorder && !doInnerBorder) return;
    const {
        size = symbolAttribute.size,
        opacity = symbolAttribute.opacity,
        x: originX = symbolAttribute.x,
        y: originY = symbolAttribute.y,
        scaleX = symbolAttribute.scaleX,
        scaleY = symbolAttribute.scaleY,
        keepStrokeScale = symbolAttribute.keepStrokeScale
      } = symbol.attribute,
      renderBorder = (borderStyle, key) => {
        const doStroke = !(!borderStyle || !borderStyle.stroke),
          {
            distance = symbolAttribute[key].distance
          } = borderStyle,
          d = keepStrokeScale ? distance : getScaledStroke(context, distance, context.dpr),
          sign = "outerBorder" === key ? 1 : -1;
        if (context.beginPath(), !1 === parsedPath.drawOffset(context, size, x, y, sign * d) && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), strokeCb) strokeCb(context, borderStyle, symbolAttribute[key]);else if (doStroke) {
          const lastOpacity = symbolAttribute[key].opacity;
          symbolAttribute[key].opacity = opacity, context.setStrokeStyle(symbol, borderStyle, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute[key]), symbolAttribute[key].opacity = lastOpacity, context.stroke();
        }
      };
    doOuterBorder && renderBorder(outerBorder, "outerBorder"), doInnerBorder && renderBorder(innerBorder, "innerBorder");
  }
}
class DefaultSymbolClipRangeStrokeRenderContribution {
  constructor() {
    this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    const {
        clipRange = graphicAttribute.clipRange,
        x: originX = graphicAttribute.x,
        y: originY = graphicAttribute.y,
        z = graphicAttribute.z,
        size = graphicAttribute.size,
        scaleX = graphicAttribute.scaleX,
        scaleY = graphicAttribute.scaleY
      } = graphic.attribute,
      parsedPath = graphic.getParsedPath();
    if (!(parsedPath && clipRange < 1 && clipRange > 0)) return;
    context.beginPath(), parsedPath.drawWithClipRange && parsedPath.drawWithClipRange(context, size, x, y, clipRange, z, (p, a) => {
      var _a, _b, _c, _d;
      if (graphic._parsedPath.svgCache) {
        const obj = Object.assign({}, a);
        obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : graphic.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : graphic.attribute.opacity, obj.fillOpacity = graphic.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : graphic.attribute.stroke, obj.lineWidth = null !== (_d = a.lineWidth) && void 0 !== _d ? _d : graphic.attribute.lineWidth, a = obj;
      }
      a.stroke && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, a, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
    }), doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, graphic.attribute, graphicAttribute) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, (originX - x) / scaleX, (originY - y) / scaleY, graphicAttribute), context.stroke()));
  }
}
const defaultSymbolRenderContribution = new DefaultSymbolRenderContribution();
const defaultSymbolClipRangeStrokeRenderContribution = new DefaultSymbolClipRangeStrokeRenderContribution();
const defaultSymbolTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultSymbolBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

class DefaultAreaTextureRenderContribution extends DefaultBaseTextureRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, options) {
    var _a, _b, _c, _d;
    this.textureMap || this.initTextureMap(context, graphic.stage);
    const {
        attribute = graphic.attribute
      } = options || {},
      {
        texture = null !== (_a = graphic.attribute.texture) && void 0 !== _a ? _a : getAttributeFromDefaultAttrList(graphicAttribute, "texture"),
        textureColor = null !== (_b = graphic.attribute.textureColor) && void 0 !== _b ? _b : getAttributeFromDefaultAttrList(graphicAttribute, "textureColor"),
        textureSize = null !== (_c = graphic.attribute.textureSize) && void 0 !== _c ? _c : getAttributeFromDefaultAttrList(graphicAttribute, "textureSize"),
        texturePadding = null !== (_d = graphic.attribute.texturePadding) && void 0 !== _d ? _d : getAttributeFromDefaultAttrList(graphicAttribute, "texturePadding")
      } = attribute;
    texture && this.drawTexture(texture, graphic, context, x, y, graphicAttribute, textureColor, textureSize, texturePadding);
  }
}

const result = {
  x: 0,
  y: 0,
  z: 0,
  lastModelMatrix: null
};
class BaseRender {
  init(contributions) {
    contributions && (this._renderContribitions = contributions.getContributions()), this._renderContribitions || (this._renderContribitions = []), this.builtinContributions || (this.builtinContributions = []), this.builtinContributions.push(defaultBaseClipRenderBeforeContribution), this.builtinContributions.push(defaultBaseClipRenderAfterContribution), this.builtinContributions.forEach(item => this._renderContribitions.push(item)), this._renderContribitions.length && (this._renderContribitions.sort((a, b) => b.order - a.order), this._beforeRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.beforeFillStroke), this._afterRenderContribitions = this._renderContribitions.filter(c => c.time === BaseRenderContributionTime.afterFillStroke));
  }
  beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
    this._beforeRenderContribitions && this._beforeRenderContribitions.forEach(c => {
      if (c.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
      }
      c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
    });
  }
  afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params) {
    this._afterRenderContribitions && this._afterRenderContribitions.forEach(c => {
      if (c.supportedAppName && graphic.stage && graphic.stage.params && graphic.stage.params.context && graphic.stage.params.context.appName) {
        if (!(Array.isArray(c.supportedAppName) ? c.supportedAppName : [c.supportedAppName]).includes(graphic.stage.params.context.appName)) return;
      }
      c.drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb, params);
    });
  }
  drawPathProxy(graphic, context, x, y, drawContext, params, fillCb, strokeCb) {
    if (!graphic.pathProxy) return !1;
    const themeAttributes = getTheme(graphic, null == params ? void 0 : params.theme)[graphic.type.replace("3d", "")],
      {
        fill = themeAttributes.fill,
        stroke = themeAttributes.stroke,
        opacity = themeAttributes.opacity,
        fillOpacity = themeAttributes.fillOpacity,
        lineWidth = themeAttributes.lineWidth,
        strokeOpacity = themeAttributes.strokeOpacity,
        visible = themeAttributes.visible,
        x: originX = themeAttributes.x,
        y: originY = themeAttributes.y
      } = graphic.attribute,
      fVisible = fillVisible(opacity, fillOpacity, fill),
      sVisible = strokeVisible(opacity, strokeOpacity),
      doFill = runFill(fill),
      doStroke = runStroke(stroke, lineWidth);
    if (!visible) return !0;
    if (!doFill && !doStroke) return !0;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return !0;
    context.beginPath();
    const path = "function" == typeof graphic.pathProxy ? graphic.pathProxy(graphic.attribute) : graphic.pathProxy;
    return renderCommandList(path.commandList, context, x, y), context.setShadowBlendStyle && context.setShadowBlendStyle(graphic, graphic.attribute, themeAttributes), this.beforeRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), doStroke && (strokeCb ? strokeCb(context, graphic.attribute, themeAttributes) : sVisible && (context.setStrokeStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.stroke())), doFill && (fillCb ? fillCb(context, graphic.attribute, themeAttributes) : fVisible && (context.setCommonStyle(graphic, graphic.attribute, x - originX, y - originY, themeAttributes), context.fill())), this.afterRenderStep(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, themeAttributes, drawContext, fillCb, strokeCb), !0;
  }
  valid(graphic, defaultAttribute, fillCb, strokeCb) {
    const {
        fill = defaultAttribute.fill,
        background: background,
        stroke = defaultAttribute.stroke,
        opacity = defaultAttribute.opacity,
        fillOpacity = defaultAttribute.fillOpacity,
        lineWidth = defaultAttribute.lineWidth,
        strokeOpacity = defaultAttribute.strokeOpacity,
        visible = defaultAttribute.visible
      } = graphic.attribute,
      fVisible = fillVisible(opacity, fillOpacity, fill),
      sVisible = strokeVisible(opacity, strokeOpacity),
      doFill = runFill(fill, background),
      doStroke = runStroke(stroke, lineWidth);
    return !(!graphic.valid || !visible) && !(!doFill && !doStroke) && !!(fVisible || sVisible || fillCb || strokeCb || background) && {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    };
  }
  transform(graphic, graphicAttribute, context) {
    let use3dMatrixIn3dMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
    const {
        x = graphicAttribute.x,
        y = graphicAttribute.y,
        z = graphicAttribute.z,
        scaleX = graphicAttribute.scaleX,
        scaleY = graphicAttribute.scaleY,
        angle = graphicAttribute.angle,
        postMatrix: postMatrix
      } = graphic.attribute,
      lastModelMatrix = context.modelMatrix,
      camera = context.camera;
    result.x = x, result.y = y, result.z = z, result.lastModelMatrix = lastModelMatrix;
    const shouldTransform3d = camera && (use3dMatrixIn3dMode || shouldUseMat4(graphic)),
      onlyTranslate = shouldTransform3d ? graphic.transMatrix.onlyTranslate() && !postMatrix : 1 === scaleX && 1 === scaleY && 0 === angle && !postMatrix;
    if (shouldTransform3d) {
      const nextModelMatrix = mat4Allocate.allocate(),
        modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, graphic, graphicAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), result.x = 0, result.y = 0, result.z = 0, context.modelMatrix = nextModelMatrix, context.setTransform(1, 0, 0, 1, 0, 0, !0), mat4Allocate.free(modelMatrix);
    }
    if (onlyTranslate && !lastModelMatrix) {
      const point = graphic.getOffsetXY(graphicAttribute);
      result.x += point.x, result.y += point.y, result.z = z, context.setTransformForCurrent();
    } else if (shouldTransform3d) result.x = 0, result.y = 0, result.z = 0, context.setTransform(1, 0, 0, 1, 0, 0, !0);else if (camera && context.project) {
      const point = graphic.getOffsetXY(graphicAttribute);
      result.x += point.x, result.y += point.y, this.transformWithoutTranslate(context, result.x, result.y, result.z, scaleX, scaleY, angle);
    } else context.transformFromMatrix(graphic.transMatrix, !0), result.x = 0, result.y = 0, result.z = 0;
    return result;
  }
  transformUseContext2d(graphic, graphicAttribute, z, context) {
    const camera = context.camera;
    if (this.camera = camera, camera) {
      const bounds = graphic.AABBBounds,
        width = bounds.x2 - bounds.x1,
        height = bounds.y2 - bounds.y1,
        p1 = context.project(0, 0, z),
        p2 = context.project(width, 0, z),
        p3 = context.project(width, height, z),
        _p1 = {
          x: 0,
          y: 0
        },
        _p2 = {
          x: width,
          y: 0
        },
        _p3 = {
          x: width,
          y: height
        };
      context.camera = null;
      const denom = 1 / (_p1.x * (_p3.y - _p2.y) - _p2.x * _p3.y + _p3.x * _p2.y + (_p2.x - _p3.x) * _p1.y),
        m11 = -(_p1.y * (p3.x - p2.x) - _p2.y * p3.x + _p3.y * p2.x + (_p2.y - _p3.y) * p1.x) * denom,
        m12 = (_p2.y * p3.y + _p1.y * (p2.y - p3.y) - _p3.y * p2.y + (_p3.y - _p2.y) * p1.y) * denom,
        m21 = (_p1.x * (p3.x - p2.x) - _p2.x * p3.x + _p3.x * p2.x + (_p2.x - _p3.x) * p1.x) * denom,
        m22 = -(_p2.x * p3.y + _p1.x * (p2.y - p3.y) - _p3.x * p2.y + (_p3.x - _p2.x) * p1.y) * denom,
        dx = (_p1.x * (_p3.y * p2.x - _p2.y * p3.x) + _p1.y * (_p2.x * p3.x - _p3.x * p2.x) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.x) * denom,
        dy = (_p1.x * (_p3.y * p2.y - _p2.y * p3.y) + _p1.y * (_p2.x * p3.y - _p3.x * p2.y) + (_p3.x * _p2.y - _p2.x * _p3.y) * p1.y) * denom;
      context.setTransform(m11, m12, m21, m22, dx, dy, !0);
    }
  }
  restoreTransformUseContext2d(graphic, graphicAttribute, z, context) {
    this.camera && (context.camera = this.camera);
  }
  transformWithoutTranslate(context, x, y, z, scaleX, scaleY, angle) {
    const p = context.project(x, y, z);
    context.translate(p.x, p.y, !1), context.scale(scaleX, scaleY, !1), context.rotate(angle, !1), context.translate(-p.x, -p.y, !1), context.setTransformForCurrent();
  }
  _draw(graphic, defaultAttr, computed3dMatrix, drawContext, params) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const {
      renderable: renderable
    } = graphic.attribute;
    if (!1 === renderable) return;
    context.highPerformanceSave();
    const data = this.transform(graphic, defaultAttr, context, computed3dMatrix),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    this.z = z, this.drawPathProxy(graphic, context, x, y, drawContext, params) || (this.drawShape(graphic, context, x, y, drawContext, params), this.z = 0, context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix), context.highPerformanceRestore();
  }
}

var __decorate$1C = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1e = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$S = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasArcRender = class extends BaseRender {
  constructor(arcRenderContribitions) {
    super(), this.arcRenderContribitions = arcRenderContribitions, this.numberType = ARC_NUMBER_TYPE, this.builtinContributions = [defaultArcRenderContribution, defaultArcBackgroundRenderContribution, defaultArcTextureRenderContribution], this.init(arcRenderContribitions);
  }
  drawArcTailCapPath(arc, context, cx, cy, outerRadius, innerRadius, _sa, _ea) {
    const capAngle = _ea - _sa,
      data = arc.getParsedAngle(),
      startAngle = data.startAngle;
    let endAngle = data.endAngle;
    endAngle = _ea;
    const clockwise = endAngle > startAngle;
    let collapsedToLine = !1;
    if (outerRadius < innerRadius) {
      const temp = outerRadius;
      outerRadius = innerRadius, innerRadius = temp;
    }
    const {
      outerDeltaAngle: outerDeltaAngle,
      xors: xors,
      yors: yors,
      xirs: xirs,
      yirs: yirs,
      limitedOcr: limitedOcr,
      outerCornerRadiusStart: outerCornerRadiusStart,
      outerCornerRadiusEnd: outerCornerRadiusEnd,
      maxOuterCornerRadius: maxOuterCornerRadius,
      xore: xore,
      yore: yore,
      xire: xire,
      yire: yire,
      limitedIcr: limitedIcr,
      innerDeltaAngle: innerDeltaAngle,
      innerStartAngle: innerStartAngle,
      innerCornerRadiusStart: innerCornerRadiusStart,
      innerCornerRadiusEnd: innerCornerRadiusEnd,
      maxInnerCornerRadius: maxInnerCornerRadius
    } = calculateArcCornerRadius(arc, startAngle, endAngle, innerRadius, outerRadius);
    if (limitedOcr > epsilon) {
      const cornerRadiusStart = min(outerCornerRadiusStart, limitedOcr),
        cornerRadiusEnd = min(outerCornerRadiusEnd, limitedOcr),
        t0 = cornerTangents(xirs, yirs, xors, yors, outerRadius, cornerRadiusStart, Number(clockwise)),
        t1 = cornerTangents(xore, yore, xire, yire, outerRadius, cornerRadiusEnd, Number(clockwise));
      if (limitedOcr < maxOuterCornerRadius && cornerRadiusStart === cornerRadiusEnd) context.moveTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), context.arc(cx + t0.cx, cy + t0.cy, limitedOcr, atan2(t0.y01, t0.x01), atan2(t1.y01, t1.x01), !clockwise);else {
        const a1 = endAngle - capAngle - .03,
          a2 = atan2(t1.y11, t1.x11);
        context.arc(cx, cy, outerRadius, a1, a2, !clockwise), cornerRadiusEnd > 0 && context.arc(cx + t1.cx, cy + t1.cy, cornerRadiusEnd, atan2(t1.y11, t1.x11), atan2(t1.y01, t1.x01), !clockwise);
      }
    } else context.moveTo(cx + xors, cy + yors);
    if (!(innerRadius > epsilon) || innerDeltaAngle < .001) context.lineTo(cx + xire, cy + yire), collapsedToLine = !0;else if (limitedIcr > epsilon) {
      const cornerRadiusStart = min(innerCornerRadiusStart, limitedIcr),
        cornerRadiusEnd = min(innerCornerRadiusEnd, limitedIcr),
        t0 = cornerTangents(xire, yire, xore, yore, innerRadius, -cornerRadiusEnd, Number(clockwise)),
        t1 = cornerTangents(xors, yors, xirs, yirs, innerRadius, -cornerRadiusStart, Number(clockwise));
      if (context.lineTo(cx + t0.cx + t0.x01, cy + t0.cy + t0.y01), limitedIcr < maxInnerCornerRadius && cornerRadiusStart === cornerRadiusEnd) {
        const arcEndAngle = atan2(t1.y01, t1.x01);
        context.arc(cx + t0.cx, cy + t0.cy, limitedIcr, atan2(t0.y01, t0.x01), arcEndAngle, !clockwise);
      } else {
        cornerRadiusEnd > 0 && context.arc(cx + t0.cx, cy + t0.cy, cornerRadiusEnd, atan2(t0.y01, t0.x01), atan2(t0.y11, t0.x11), !clockwise);
        const a1 = atan2(t0.cy + t0.y11, t0.cx + t0.x11),
          a2 = endAngle - capAngle - .03;
        context.arc(cx, cy, innerRadius, a1, a2, clockwise);
      }
    } else context.lineTo(cx + innerRadius * cos(innerStartAngle), cy + innerRadius * sin(innerStartAngle));
    return collapsedToLine;
  }
  drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
    const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc,
      {
        fill = arcAttribute.fill,
        stroke = arcAttribute.stroke,
        x: originX = arcAttribute.x,
        y: originY = arcAttribute.y,
        fillStrokeOrder = arcAttribute.fillStrokeOrder
      } = arc.attribute,
      data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        fVisible: fVisible,
        sVisible: sVisible,
        doFill: doFill,
        doStroke: doStroke
      } = data,
      {
        outerPadding = arcAttribute.outerPadding,
        innerPadding = arcAttribute.innerPadding,
        cap = arcAttribute.cap,
        forceShowCap = arcAttribute.forceShowCap
      } = arc.attribute;
    let {
      outerRadius = arcAttribute.outerRadius,
      innerRadius = arcAttribute.innerRadius
    } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    let conicalOffset = 0;
    const tempChangeConicalColor = (isBoolean$1(cap) && cap || cap[0]) && "conical" === fill.gradient;
    if (tempChangeConicalColor) {
      const {
        sc: sc,
        startAngle: startAngle,
        endAngle: endAngle
      } = arc.getParsedAngle();
      abs(endAngle - startAngle) < pi2 - epsilon && (conicalOffset = sc || 0, fill.startAngle -= conicalOffset, fill.endAngle -= conicalOffset);
    }
    let beforeRenderContribitionsRuned = !1;
    const {
      isFullStroke: isFullStroke,
      stroke: arrayStroke
    } = parseStroke(stroke);
    if (doFill || isFullStroke) {
      context.beginPath(), drawArcPath$1(arc, context, x, y, outerRadius, innerRadius), beforeRenderContribitionsRuned = !0, context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
      const _runFill = () => {
          doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.fill()));
        },
        _runStroke = () => {
          doStroke && isFullStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, originX - x, originY - y, arcAttribute), context.stroke()));
        };
      fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke());
    }
    if (!isFullStroke && doStroke) {
      context.beginPath();
      drawArcPath$1(arc, context, x, y, outerRadius, innerRadius, arrayStroke);
      beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke());
    }
    if ((isBoolean$1(cap) && cap || cap[1]) && forceShowCap) {
      const {
        startAngle: sa,
        endAngle: ea
      } = arc.getParsedAngle();
      if (abs(ea - sa) >= pi2 - epsilon) {
        context.beginPath();
        const capAngle = Math.abs(outerRadius - innerRadius) / 2 / outerRadius,
          {
            endAngle = arcAttribute.endAngle,
            fill = arcAttribute.fill
          } = arc.attribute,
          startAngle = endAngle;
        this.drawArcTailCapPath(arc, context, x, y, outerRadius, innerRadius, startAngle, startAngle + capAngle), beforeRenderContribitionsRuned || this.beforeRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb);
        const _runFill = () => {
            if (doFill) {
              const color = fill;
              if ("conical" === color.gradient) {
                const lastColor = getConicGradientAt(0, 0, endAngle, color);
                fillCb || fillVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = lastColor, context.fill());
              }
            }
          },
          _runStroke = () => {
            doStroke && (strokeCb || sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()));
          };
        _runFill(), _runStroke();
      }
    }
    this.afterRenderStep(arc, context, x, y, doFill, doStroke, fVisible, sVisible, arcAttribute, drawContext, fillCb, strokeCb), tempChangeConicalColor && (fill.startAngle += conicalOffset, fill.endAngle += conicalOffset);
  }
  draw(arc, renderService, drawContext, params) {
    const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
    this._draw(arc, arcAttribute, !1, drawContext, params);
  }
};
DefaultCanvasArcRender = __decorate$1C([injectable(), __param$S(0, inject(ContributionProvider)), __param$S(0, named(ArcRenderContribution)), __metadata$1e("design:paramtypes", [Object])], DefaultCanvasArcRender);

var __decorate$1B = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1d = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$R = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasCircleRender = class extends BaseRender {
  constructor(circleRenderContribitions) {
    super(), this.circleRenderContribitions = circleRenderContribitions, this.numberType = CIRCLE_NUMBER_TYPE, this.builtinContributions = [defaultCircleRenderContribution, defaultCircleBackgroundRenderContribution, defaultCircleTextureRenderContribution], this.init(circleRenderContribitions);
  }
  drawShape(circle, context, x, y, drawContext, params, fillCb, strokeCb) {
    const circleAttribute = getTheme(circle, null == params ? void 0 : params.theme).circle,
      {
        radius = circleAttribute.radius,
        startAngle = circleAttribute.startAngle,
        endAngle = circleAttribute.endAngle,
        x: originX = circleAttribute.x,
        y: originY = circleAttribute.y,
        fillStrokeOrder = circleAttribute.fillStrokeOrder
      } = circle.attribute,
      data = this.valid(circle, circleAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    } = data;
    context.beginPath(), context.arc(x, y, radius, startAngle, endAngle), context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(circle, circle.attribute, circleAttribute), this.beforeRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
        doFill && (fillCb ? fillCb(context, circle.attribute, circleAttribute) : fVisible && (context.setCommonStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), context.fill()));
      },
      _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, circle.attribute, circleAttribute) : sVisible && (context.setStrokeStyle(circle, circle.attribute, originX - x, originY - y, circleAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(circle, context, x, y, doFill, doStroke, fVisible, sVisible, circleAttribute, drawContext, fillCb, strokeCb);
  }
  draw(circle, renderService, drawContext, params) {
    const circleAttribute = getTheme(circle, null == params ? void 0 : params.theme).circle;
    this._draw(circle, circleAttribute, !1, drawContext, params);
  }
};
DefaultCanvasCircleRender = __decorate$1B([injectable(), __param$R(0, inject(ContributionProvider)), __param$R(0, named(CircleRenderContribution)), __metadata$1d("design:paramtypes", [Object])], DefaultCanvasCircleRender);

function drawSegItem(ctx, curve, endPercent, params) {
  if (!curve.p1) return;
  const {
    offsetX = 0,
    offsetY = 0,
    offsetZ = 0
  } = params || {};
  if (1 === endPercent) curve.p2 && curve.p3 ? ctx.bezierCurveTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetX + curve.p2.x, offsetY + curve.p2.y, offsetX + curve.p3.x, offsetY + curve.p3.y, offsetZ) : ctx.lineTo(offsetX + curve.p1.x, offsetY + curve.p1.y, offsetZ);else if (curve.p2 && curve.p3) {
    const [curve1] = divideCubic(curve, endPercent);
    ctx.bezierCurveTo(offsetX + curve1.p1.x, offsetY + curve1.p1.y, offsetX + curve1.p2.x, offsetY + curve1.p2.y, offsetX + curve1.p3.x, offsetY + curve1.p3.y, offsetZ);
  } else {
    const p = curve.getPointAt(endPercent);
    ctx.lineTo(offsetX + p.x, offsetY + p.y, offsetZ);
  }
}

function drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ) {
  var _a;
  let p0 = curve.p0,
    newDefined0 = defined0;
  if (lastCurve && lastCurve.originP1 === lastCurve.originP2 && (p0 = lastCurve.p0), curve.defined) defined0 || (path.lineTo(p0.x + offsetX, p0.y + offsetY, offsetZ), newDefined0 = !defined0);else {
    const {
      originP1: originP1,
      originP2: originP2
    } = curve;
    let validP;
    if (originP1 && !1 !== originP1.defined && !lastCurve ? validP = p0 : originP1 && !1 !== originP2.defined && (validP = null !== (_a = curve.p3) && void 0 !== _a ? _a : curve.p1), defined0) {
      newDefined0 = !defined0;
      const x = validP ? validP.x : curve.p0.x,
        y = validP ? validP.y : curve.p0.y;
      path.moveTo(x + offsetX, y + offsetY, offsetZ);
    } else validP && (newDefined0 = !defined0, path.lineTo(validP.x + offsetX, validP.y + offsetY, offsetZ));
  }
  return newDefined0;
}
function drawSegments(path, segPath, percent, clipRangeByDimension, params) {
  const {
    offsetX = 0,
    offsetY = 0,
    offsetZ = 0,
    mode = "none",
    drawConnect = !1
  } = params || {};
  if (drawConnect && "none" === mode) return;
  if (!segPath) return;
  let needMoveTo = !0;
  const {
    curves: curves
  } = segPath;
  if (percent >= 1) {
    if (drawConnect) {
      let lastCurve,
        defined0 = !0;
      curves.forEach((curve, i) => {
        curve.originP1 !== curve.originP2 ? (defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve) : lastCurve = curve;
      });
    } else curves.forEach(curve => {
      curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
    });
    return;
  }
  if (percent <= 0) return;
  let direction;
  "x" === clipRangeByDimension ? direction = Direction$1.ROW : "y" === clipRangeByDimension ? direction = Direction$1.COLUMN : "auto" === clipRangeByDimension && (direction = segPath.direction);
  const totalDrawLength = percent * segPath.tryUpdateLength(direction);
  let drawedLengthUntilLast = 0,
    defined0 = !0,
    lastCurve = null;
  for (let i = 0, n = curves.length; i < n; i++) {
    const curve = curves[i],
      curCurveLength = curve.getLength(direction),
      _p = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (drawedLengthUntilLast += curCurveLength, _p < 0) break;
    if (drawConnect) {
      if (curve.originP1 === curve.originP2) {
        lastCurve = curve;
        continue;
      }
      defined0 = drawEachCurve(path, curve, lastCurve, defined0, offsetX, offsetY, offsetZ), lastCurve = curve;
    } else {
      if (!curve.defined) {
        needMoveTo = !0;
        continue;
      }
      needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, min(_p, 1), params), needMoveTo = !1;
    }
  }
}
function drawIncrementalSegments(path, lastSeg, segments, params) {
  const {
      offsetX = 0,
      offsetY = 0
    } = params || {},
    startP = lastSeg ? lastSeg.points[lastSeg.points.length - 1] : segments.points[0];
  path.moveTo(startP.x + offsetX, startP.y + offsetY), segments.points.forEach(p => {
    !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
  });
}
function drawIncrementalAreaSegments(path, lastSeg, segments, params) {
  const {
      offsetX = 0,
      offsetY = 0
    } = params || {},
    {
      points: points
    } = segments,
    definedPointsList = [];
  for (let i = 0; i < points.length; i++) !1 === points[i].defined && (i);
  definedPointsList.push(points), definedPointsList.forEach((points, i) => {
    var _a, _b, _c, _d;
    const startP = lastSeg && 0 === i ? lastSeg.points[lastSeg.points.length - 1] : points[0];
    path.moveTo(startP.x + offsetX, startP.y + offsetY), points.forEach(p => {
      !1 !== p.defined ? path.lineTo(p.x + offsetX, p.y + offsetY) : path.moveTo(p.x + offsetX, p.y + offsetY);
    });
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      path.lineTo(null !== (_a = p.x1) && void 0 !== _a ? _a : p.x, null !== (_b = p.y1) && void 0 !== _b ? _b : p.y);
    }
    path.lineTo(null !== (_c = startP.x1) && void 0 !== _c ? _c : startP.x, null !== (_d = startP.y1) && void 0 !== _d ? _d : startP.y), path.closePath();
  });
}

var __decorate$1A = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultCanvasLineRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  draw(line, renderService, drawContext, params) {
    const lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line;
    this._draw(line, lineAttribute, !1, drawContext, params);
  }
  drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
    var _a;
    if (!cache) return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX: offsetX,
      offsetY: offsetY,
      offsetZ: z
    }), line.cache && !isArray$1(line.cache) && line.cache.curves.every(c => c.defined) && line.attribute.curveType && line.attribute.curveType.includes("Closed") && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute);
    const {
      x: originX = 0,
      x: originY = 0
    } = attribute;
    return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, attribute, defaultAttribute) : strokeOpacity && (context.setStrokeStyle(line, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke())), !1;
  }
  drawLinearLineHighPerformance(line, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, lineAttribute, drawContext, params, fillCb, strokeCb) {
    var _a;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
      {
        points: points
      } = line.attribute,
      startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(line, line.attribute, lineAttribute);
    const {
      x: originX = 0,
      x: originY = 0
    } = line.attribute;
    !1 !== fill && (fillCb ? fillCb(context, line.attribute, lineAttribute) : fillOpacity && (context.setCommonStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.fill())), !1 !== stroke && (strokeCb ? strokeCb(context, line.attribute, lineAttribute) : strokeOpacity && (context.setStrokeStyle(line, line.attribute, originX - offsetX, originY - offsetY, lineAttribute), context.stroke()));
  }
  drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
    const lineAttribute = getTheme(line, null == params ? void 0 : params.theme).line,
      {
        fill = lineAttribute.fill,
        stroke = lineAttribute.stroke,
        fillOpacity = lineAttribute.fillOpacity,
        strokeOpacity = lineAttribute.strokeOpacity,
        segments: segments,
        points: points,
        closePath: closePath,
        curveTension = lineAttribute.curveTension,
        connectedType = lineAttribute.connectedType
      } = line.attribute;
    if (!this.valid(line, lineAttribute, fillCb, strokeCb)) return;
    let {
      curveType = lineAttribute.curveType
    } = line.attribute;
    closePath && "linear" === curveType && (curveType = "linearClosed");
    const {
      clipRange = lineAttribute.clipRange,
      clipRangeByDimension = lineAttribute.clipRangeByDimension
    } = line.attribute;
    if (1 === clipRange && !segments && !points.some(p => !1 === p.defined) && "linear" === curveType) return this.drawLinearLineHighPerformance(line, context, !!fill, !!stroke, fillOpacity, strokeOpacity, x, y, lineAttribute, drawContext, params, fillCb, strokeCb);
    function parsePoint(points, connectedType) {
      return "none" === connectedType ? points : points.filter(p => !1 !== p.defined);
    }
    if (line.shouldUpdateShape()) {
      const {
          points: points,
          segments: segments
        } = line.attribute,
        _points = points;
      if (segments && segments.length) {
        let startPoint, lastSeg;
        if (line.cache = segments.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y,
            curves: [{
              defined: !1 !== seg.points[0].defined
            }]
          }), null;
          1 === index ? startPoint = {
            x: lastSeg.endX,
            y: lastSeg.endY,
            defined: lastSeg.curves[lastSeg.curves.length - 1].defined
          } : index > 1 && (startPoint.x = lastSeg.endX, startPoint.y = lastSeg.endY, startPoint.defined = lastSeg.curves[lastSeg.curves.length - 1].defined);
          const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
            startPoint: startPoint,
            curveTension: curveTension
          });
          return lastSeg = data, data;
        }).filter(item => !!item), "linearClosed" === curveType) {
          let startP;
          for (let i = 0; i < line.cache.length; i++) {
            const cacheItem = line.cache[i];
            for (let i = 0; i < cacheItem.curves.length; i++) if (cacheItem.curves[i].defined) {
              startP = cacheItem.curves[i].p0;
              break;
            }
            if (startP) break;
          }
          line.cache[line.cache.length - 1] && line.cache[line.cache.length - 1].lineTo(startP.x, startP.y, !0);
        }
      } else {
        if (!points || !points.length) return line.cache = null, void line.clearUpdateShapeTag();
        line.cache = calcLineCache(parsePoint(_points, connectedType), curveType, {
          curveTension: curveTension
        });
      }
      line.clearUpdateShapeTag();
    }
    if (Array.isArray(line.cache)) {
      const segments = line.attribute.segments.filter(item => item.points.length);
      if (1 === segments[0].points.length && segments.shift(), 1 === clipRange) {
        let skip = !1;
        line.cache.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb));
        });
      } else {
        const totalLength = line.cache.reduce((l, c) => l + c.getLength(), 0),
          totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0,
          skip = !1;
        line.cache.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.getLength(),
            _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, !!fill, !!stroke, fillOpacity, strokeOpacity, segments[index], [lineAttribute, line.attribute], min(_cr, 1), clipRangeByDimension, x, y, line, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, line.cache, !!fill, !!stroke, fillOpacity, strokeOpacity, line.attribute, lineAttribute, clipRange, clipRangeByDimension, x, y, line, fillCb, strokeCb);
  }
};
DefaultCanvasLineRender = __decorate$1A([injectable()], DefaultCanvasLineRender);

function drawAreaSegments(path, segPath, percent, params) {
  var _a;
  const {
    top: top,
    bottom: bottom
  } = segPath;
  if (top.curves.length !== bottom.curves.length) return;
  if (percent >= 1) {
    const topList = [],
      bottomList = [];
    let lastDefined = !0;
    for (let i = 0, n = top.curves.length; i < n; i++) {
      const topCurve = top.curves[i];
      lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0) : (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1])), lastDefined = !lastDefined) : lastDefined && (topList.push(topCurve), bottomList.push(bottom.curves[n - i - 1]));
    }
    return void drawAreaBlock(path, topList, bottomList, params);
  }
  if (percent <= 0) return;
  let {
    direction: direction
  } = params || {};
  const {
      curves: topCurves
    } = top,
    endP = null !== (_a = topCurves[topCurves.length - 1].p3) && void 0 !== _a ? _a : topCurves[topCurves.length - 1].p1,
    xTotalLength = abs(endP.x - topCurves[0].p0.x),
    yTotalLength = abs(endP.y - topCurves[0].p0.y);
  direction = null != direction ? direction : xTotalLength > yTotalLength ? Direction$1.ROW : Direction$1.COLUMN, Number.isFinite(xTotalLength) || (direction = Direction$1.COLUMN), Number.isFinite(yTotalLength) || (direction = Direction$1.ROW);
  const totalDrawLength = percent * (direction === Direction$1.ROW ? xTotalLength : yTotalLength);
  let drawedLengthUntilLast = 0,
    lastDefined = !0;
  const topList = [],
    bottomList = [];
  for (let i = 0, n = top.curves.length; i < n; i++) {
    const topCurve = top.curves[i],
      curCurveLength = topCurve.getLength(direction),
      percent = (totalDrawLength - drawedLengthUntilLast) / curCurveLength;
    if (percent < 0) break;
    drawedLengthUntilLast += curCurveLength;
    let tc = null,
      bc = null;
    lastDefined !== topCurve.defined ? (lastDefined ? (drawAreaBlock(path, topList, bottomList, params), topList.length = 0, bottomList.length = 0) : (tc = topCurve, bc = bottom.curves[n - i - 1]), lastDefined = !lastDefined) : lastDefined && (tc = topCurve, bc = bottom.curves[n - i - 1]), tc && bc && (percent < 1 && (tc = tc.p2 && tc.p3 ? divideCubic(tc, percent)[0] : divideLinear(tc, percent)[0], bc = bc.p2 && bc.p3 ? divideCubic(bc, 1 - percent)[1] : divideLinear(bc, 1 - percent)[1]), tc.defined = lastDefined, bc.defined = lastDefined, topList.push(tc), bottomList.push(bc)), tc = null, bc = null;
  }
  drawAreaBlock(path, topList, bottomList, params);
}
function drawAreaBlock(path, topList, bottomList, params) {
  const {
    offsetX = 0,
    offsetY = 0,
    offsetZ = 0
  } = params || {};
  let needMoveTo = !0;
  topList.forEach(curve => {
    curve.defined ? (needMoveTo && path.moveTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
  }), needMoveTo = !0;
  for (let i = bottomList.length - 1; i >= 0; i--) {
    const curve = bottomList[i];
    curve.defined ? (needMoveTo && path.lineTo(curve.p0.x + offsetX, curve.p0.y + offsetY, offsetZ), drawSegItem(path, curve, 1, params), needMoveTo = !1) : needMoveTo = !0;
  }
  path.closePath();
}

const defaultAreaTextureRenderContribution = new DefaultAreaTextureRenderContribution();
const defaultAreaBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

var __decorate$1z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1c = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$Q = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasAreaRender = class extends BaseRender {
  constructor(areaRenderContribitions) {
    super(), this.areaRenderContribitions = areaRenderContribitions, this.numberType = AREA_NUMBER_TYPE, this.builtinContributions = [defaultAreaTextureRenderContribution, defaultAreaBackgroundRenderContribution], this.init(areaRenderContribitions);
  }
  drawLinearAreaHighPerformance(area, context, fill, stroke, fillOpacity, strokeOpacity, offsetX, offsetY, areaAttribute, drawContext, params, fillCb, strokeCb) {
    var _a, _b, _c;
    const {
      points: points
    } = area.attribute;
    if (points.length < 2) return;
    context.beginPath();
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
      startP = points[0];
    context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
    for (let i = 1; i < points.length; i++) {
      const p = points[i];
      context.lineTo(p.x + offsetX, p.y + offsetY, z);
    }
    for (let i = points.length - 1; i >= 0; i--) {
      const p = points[i];
      context.lineTo((null !== (_b = p.x1) && void 0 !== _b ? _b : p.x) + offsetX, (null !== (_c = p.y1) && void 0 !== _c ? _c : p.y) + offsetY, z);
    }
    context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(area, area.attribute, areaAttribute), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, areaAttribute, drawContext, fillCb, null, {
      attribute: area.attribute
    });
    const {
      x: originX = 0,
      x: originY = 0
    } = area.attribute;
    !1 !== fill && (fillCb ? fillCb(context, area.attribute, areaAttribute) : fillOpacity && (context.setCommonStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, areaAttribute, drawContext, fillCb, null, {
      attribute: area.attribute
    }), (() => {
      var _a, _b;
      if (stroke) {
        const {
          stroke = areaAttribute && areaAttribute.stroke
        } = area.attribute;
        if (isArray$1(stroke) && (stroke[0] || stroke[2]) && !1 === stroke[1]) if (context.beginPath(), stroke[0]) {
          context.moveTo(startP.x + offsetX, startP.y + offsetY, z);
          for (let i = 1; i < points.length; i++) {
            const p = points[i];
            context.lineTo(p.x + offsetX, p.y + offsetY, z);
          }
        } else if (stroke[2]) {
          const endP = points[points.length - 1];
          context.moveTo(endP.x + offsetX, endP.y + offsetY, z);
          for (let i = points.length - 2; i >= 0; i--) {
            const p = points[i];
            context.lineTo((null !== (_a = p.x1) && void 0 !== _a ? _a : p.x) + offsetX, (null !== (_b = p.y1) && void 0 !== _b ? _b : p.y) + offsetY, z);
          }
        }
        strokeCb ? strokeCb(context, area.attribute, areaAttribute) : (context.setStrokeStyle(area, area.attribute, originX - offsetX, originY - offsetY, areaAttribute), context.stroke());
      }
    })();
  }
  drawShape(area, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a, _b, _c, _d, _e, _f;
    const areaAttribute = getTheme(area, null == params ? void 0 : params.theme).area,
      {
        fill = areaAttribute.fill,
        stroke = areaAttribute.stroke,
        fillOpacity = areaAttribute.fillOpacity,
        z = areaAttribute.z,
        strokeOpacity = areaAttribute.strokeOpacity,
        curveTension = areaAttribute.curveTension,
        connectedType = areaAttribute.connectedType
      } = area.attribute,
      data = this.valid(area, areaAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        doFill: doFill
      } = data,
      doStroke = data.doStroke && data.sVisible,
      {
        clipRange = areaAttribute.clipRange,
        closePath: closePath,
        points: points,
        segments: segments
      } = area.attribute;
    let {
      curveType = areaAttribute.curveType
    } = area.attribute;
    function parsePoint(points, connectedType) {
      return "connect" !== connectedType ? points : points.filter(p => !1 !== p.defined);
    }
    if (closePath && "linear" === curveType && (curveType = "linearClosed"), 1 === clipRange && !segments && !points.some(p => !1 === p.defined) && "linear" === curveType) return this.drawLinearAreaHighPerformance(area, context, !!fill, doStroke, fillOpacity, strokeOpacity, x, y, areaAttribute, drawContext, params, fillCb, strokeCb);
    if (area.shouldUpdateShape()) {
      if (segments && segments.length) {
        let startPoint, lastTopSeg;
        const topCaches = segments.map((seg, index) => {
          if (seg.points.length <= 1 && 0 === index) return seg.points[0] && (lastTopSeg = {
            endX: seg.points[0].x,
            endY: seg.points[0].y
          }), null;
          1 === index ? startPoint = {
            x: lastTopSeg.endX,
            y: lastTopSeg.endY
          } : index > 1 && (startPoint.x = lastTopSeg.endX, startPoint.y = lastTopSeg.endY);
          const data = calcLineCache(parsePoint(seg.points, connectedType), curveType, {
            startPoint: startPoint,
            curveTension: curveTension
          });
          return lastTopSeg = data, data;
        }).filter(item => !!item);
        let lastBottomSeg;
        const bottomCaches = [];
        for (let i = segments.length - 1; i >= 0; i--) {
          const points = segments[i].points,
            bottomPoints = [];
          for (let i = points.length - 1; i >= 0; i--) bottomPoints.push({
            x: null !== (_a = points[i].x1) && void 0 !== _a ? _a : points[i].x,
            y: null !== (_b = points[i].y1) && void 0 !== _b ? _b : points[i].y
          });
          if (0 !== i) {
            const lastSegmentPoints = segments[i - 1].points,
              endPoint = lastSegmentPoints[lastSegmentPoints.length - 1];
            endPoint && bottomPoints.push({
              x: null !== (_c = endPoint.x1) && void 0 !== _c ? _c : endPoint.x,
              y: null !== (_d = endPoint.y1) && void 0 !== _d ? _d : endPoint.y
            });
          }
          bottomPoints.length > 1 && (lastBottomSeg = calcLineCache(parsePoint(bottomPoints, connectedType), "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
            curveTension: curveTension
          }), bottomCaches.unshift(lastBottomSeg));
        }
        area.cacheArea = bottomCaches.map((item, index) => ({
          top: topCaches[index],
          bottom: item
        }));
      } else {
        if (!points || !points.length) return area.cacheArea = null, void area.clearUpdateShapeTag();
        {
          const topPoints = parsePoint(points, connectedType),
            bottomPoints = [];
          for (let i = topPoints.length - 1; i >= 0; i--) bottomPoints.push({
            x: null !== (_e = topPoints[i].x1) && void 0 !== _e ? _e : topPoints[i].x,
            y: null !== (_f = topPoints[i].y1) && void 0 !== _f ? _f : topPoints[i].y
          });
          const topCache = calcLineCache(topPoints, curveType, {
              curveTension: curveTension
            }),
            bottomCache = calcLineCache(bottomPoints, "stepBefore" === curveType ? "stepAfter" : "stepAfter" === curveType ? "stepBefore" : curveType, {
              curveTension: curveTension
            });
          area.cacheArea = {
            top: topCache,
            bottom: bottomCache
          };
        }
      }
      area.clearUpdateShapeTag();
    }
    if (Array.isArray(area.cacheArea)) {
      const segments = area.attribute.segments.filter(item => item.points.length);
      if (1 === segments[0].points.length && segments.shift(), 1 === clipRange) {
        let skip = !1;
        area.cacheArea.forEach((cache, index) => {
          skip || (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments[index], [areaAttribute, area.attribute], clipRange, x, y, z, area, drawContext, fillCb, strokeCb));
        });
      } else {
        const totalLength = area.cacheArea.reduce((l, c) => l + c.top.getLength(), 0),
          totalDrawLength = clipRange * totalLength;
        let drawedLengthUntilLast = 0,
          skip = !1;
        area.cacheArea.forEach((cache, index) => {
          if (skip) return;
          const curSegLength = cache.top.getLength(),
            _cr = (totalDrawLength - drawedLengthUntilLast) / curSegLength;
          drawedLengthUntilLast += curSegLength, _cr > 0 && (skip = this.drawSegmentItem(context, cache, doFill, fillOpacity, doStroke, strokeOpacity, segments[index], [areaAttribute, area.attribute], min(_cr, 1), x, y, z, area, drawContext, fillCb, strokeCb));
        });
      }
    } else this.drawSegmentItem(context, area.cacheArea, doFill, fillOpacity, doStroke, strokeOpacity, area.attribute, areaAttribute, clipRange, x, y, z, area, drawContext, fillCb, strokeCb);
  }
  draw(area, renderService, drawContext, params) {
    const areaAttribute = getTheme(area, null == params ? void 0 : params.theme).area;
    this._draw(area, areaAttribute, !1, drawContext, params);
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
    return this._drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb);
  }
  _drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb, strokeCb) {
    if (!(cache && cache.top && cache.bottom && cache.top.curves && cache.top.curves.length && cache.bottom.curves && cache.bottom.curves.length)) return;
    context.beginPath();
    const {
      points: points,
      segments: segments
    } = area.attribute;
    let endP,
      startP,
      direction = Direction$1.ROW;
    if (segments) {
      const endSeg = segments[segments.length - 1];
      startP = segments[0].points[0], endP = endSeg.points[endSeg.points.length - 1];
    } else startP = points[0], endP = points[points.length - 1];
    const xTotalLength = abs(endP.x - startP.x),
      yTotalLength = abs(endP.y - startP.y);
    direction = null == endP.x1 ? Direction$1.ROW : null == endP.y1 ? Direction$1.COLUMN : Number.isFinite(xTotalLength + yTotalLength) ? xTotalLength > yTotalLength ? Direction$1.ROW : Direction$1.COLUMN : Direction$1.ROW, drawAreaSegments(context.camera ? context : context.nativeContext, cache, clipRange, {
      offsetX: offsetX,
      offsetY: offsetY,
      offsetZ: offsetZ,
      direction: direction
    }), this.beforeRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, drawContext, fillCb, null, {
      attribute: attribute
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute);
    const {
      x: originX = 0,
      x: originY = 0
    } = attribute;
    return !1 !== fill && (fillCb ? fillCb(context, attribute, defaultAttribute) : fillOpacity && (context.setCommonStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.fill())), this.afterRenderStep(area, context, offsetX, offsetY, !!fillOpacity, !1, fill, !1, defaultAttribute, drawContext, fillCb, null, {
      attribute: attribute
    }), (() => {
      if (!1 !== stroke) if (strokeCb) strokeCb(context, attribute, defaultAttribute);else {
        const {
          stroke = defaultAttribute && defaultAttribute[1] && defaultAttribute[1].stroke
        } = attribute;
        isArray$1(stroke) && (stroke[0] || stroke[2]) && !1 === stroke[1] && (context.beginPath(), drawSegments(context.camera ? context : context.nativeContext, stroke[0] ? cache.top : cache.bottom, clipRange, direction === Direction$1.ROW ? "x" : "y", {
          offsetX: offsetX,
          offsetY: offsetY,
          offsetZ: offsetZ
        })), context.setStrokeStyle(area, attribute, originX - offsetX, originY - offsetY, defaultAttribute), context.stroke();
      }
    })(), !1;
  }
};
DefaultCanvasAreaRender = __decorate$1z([injectable(), __param$Q(0, inject(ContributionProvider)), __param$Q(0, named(AreaRenderContribution)), __metadata$1c("design:paramtypes", [Object])], DefaultCanvasAreaRender);

const defaultPathTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultPathBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

var __decorate$1y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1b = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$P = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPathRender = class extends BaseRender {
  constructor(pathRenderContribitions) {
    super(), this.pathRenderContribitions = pathRenderContribitions, this.numberType = PATH_NUMBER_TYPE, this.builtinContributions = [defaultPathBackgroundRenderContribution, defaultPathTextureRenderContribution], this.init(pathRenderContribitions);
  }
  drawShape(path, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a, _b, _c;
    const pathAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(path, null == params ? void 0 : params.theme).path,
      {
        x: originX = pathAttribute.x,
        y: originY = pathAttribute.y,
        fillStrokeOrder = pathAttribute.fillStrokeOrder
      } = path.attribute,
      z = null !== (_b = this.z) && void 0 !== _b ? _b : 0,
      data = this.valid(path, pathAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    } = data;
    if (context.beginPath(), path.pathShape) renderCommandList(path.pathShape.commandList, context, x, y, 1, 1, z);else {
      const path2D = null !== (_c = path.attribute.path) && void 0 !== _c ? _c : pathAttribute.path;
      renderCommandList(path2D.commandList, context, x, y, 1, 1, z);
    }
    context.setShadowBlendStyle && context.setShadowBlendStyle(path, path.attribute, pathAttribute), this.beforeRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
    const _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, path.attribute, pathAttribute) : sVisible && (context.setStrokeStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.stroke()));
      },
      _runFill = () => {
        doFill && (fillCb ? fillCb(context, path.attribute, pathAttribute) : fVisible && (context.setCommonStyle(path, path.attribute, originX - x, originY - y, pathAttribute), context.fill()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(path, context, x, y, doFill, doStroke, fVisible, sVisible, pathAttribute, drawContext, fillCb, strokeCb);
  }
  draw(path, renderService, drawContext, params) {
    const pathAttribute = getTheme(path, null == params ? void 0 : params.theme).path;
    this.tempTheme = pathAttribute, this._draw(path, pathAttribute, !1, drawContext, params), this.tempTheme = null;
  }
};
DefaultCanvasPathRender = __decorate$1y([injectable(), __param$P(0, inject(ContributionProvider)), __param$P(0, named(PathRenderContribution)), __metadata$1b("design:paramtypes", [Object])], DefaultCanvasPathRender);

var __decorate$1x = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1a = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$O = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasRectRender = class extends BaseRender {
  constructor(rectRenderContribitions) {
    super(), this.rectRenderContribitions = rectRenderContribitions, this.type = "rect", this.numberType = RECT_NUMBER_TYPE, this.builtinContributions = [defaultRectRenderContribution, defaultRectBackgroundRenderContribution, defaultRectTextureRenderContribution], this.init(rectRenderContribitions);
  }
  drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a;
    const rectAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(rect, null == params ? void 0 : params.theme).rect,
      {
        fill = rectAttribute.fill,
        background: background,
        stroke = rectAttribute.stroke,
        cornerRadius = rectAttribute.cornerRadius,
        cornerType = rectAttribute.cornerType,
        opacity = rectAttribute.opacity,
        fillOpacity = rectAttribute.fillOpacity,
        lineWidth = rectAttribute.lineWidth,
        strokeOpacity = rectAttribute.strokeOpacity,
        visible = rectAttribute.visible,
        x1: x1,
        y1: y1,
        x: originX = rectAttribute.x,
        y: originY = rectAttribute.y,
        fillStrokeOrder = rectAttribute.fillStrokeOrder
      } = rect.attribute;
    let {
      width: width,
      height: height
    } = rect.attribute;
    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
    const fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
      sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
      doFill = runFill(fill, background),
      doStroke = runStroke(stroke, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
    const doFillOrStroke = {
      doFill: doFill,
      doStroke: doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(rect, rect.attribute, rectAttribute), this.beforeRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    const _runFill = () => {
        doFillOrStroke.doFill && (fillCb ? fillCb(context, rect.attribute, rectAttribute) : fVisible && (context.setCommonStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.fill()));
      },
      _runStroke = () => {
        doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, rect.attribute, rectAttribute) : sVisible && (context.setStrokeStyle(rect, rect.attribute, originX - x, originY - y, rectAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(rect, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb);
  }
  draw(rect, renderService, drawContext, params) {
    const rectAttribute = getTheme(rect, null == params ? void 0 : params.theme).rect;
    this.tempTheme = rectAttribute, this._draw(rect, rectAttribute, !1, drawContext, params), this.tempTheme = null;
  }
};
DefaultCanvasRectRender = __decorate$1x([injectable(), __param$O(0, inject(ContributionProvider)), __param$O(0, named(RectRenderContribution)), __metadata$1a("design:paramtypes", [Object])], DefaultCanvasRectRender);

var __decorate$1w = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$19 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$N = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasSymbolRender = class extends BaseRender {
  constructor(symbolRenderContribitions) {
    super(), this.symbolRenderContribitions = symbolRenderContribitions, this.numberType = SYMBOL_NUMBER_TYPE, this.builtinContributions = [defaultSymbolRenderContribution, defaultSymbolBackgroundRenderContribution, defaultSymbolTextureRenderContribution, defaultSymbolClipRangeStrokeRenderContribution], this.init(symbolRenderContribitions);
  }
  drawShape(symbol, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a;
    const symbolAttribute = getTheme(symbol, null == params ? void 0 : params.theme).symbol,
      {
        size = symbolAttribute.size,
        x: originX = symbolAttribute.x,
        y: originY = symbolAttribute.y,
        scaleX = symbolAttribute.scaleX,
        scaleY = symbolAttribute.scaleY,
        fillStrokeOrder = symbolAttribute.fillStrokeOrder,
        clipRange = symbolAttribute.clipRange
      } = symbol.attribute,
      data = this.valid(symbol, symbolAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        fVisible: fVisible,
        sVisible: sVisible,
        doFill: doFill,
        doStroke: doStroke
      } = data,
      parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const {
        keepDirIn3d = symbolAttribute.keepDirIn3d
      } = symbol.attribute,
      z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    context.beginPath();
    let _x = x,
      _y = y,
      _z = z;
    const camera = context.camera;
    if (keepDirIn3d && camera && context.project) {
      const p = context.project(x, y, z);
      context.camera = null, isArray$1(size) ? [size[0] * scaleX, size[1] * scaleY] : size * scaleX, _x = p.x, _y = p.y, _z = void 0;
    }
    !1 === parsedPath.draw(context, size, _x, _y, _z, (p, a) => {
      var _a, _b, _c, _d;
      if (symbol._parsedPath.svgCache) {
        const obj = Object.assign({}, a);
        obj.fill = null !== (_a = a.fill) && void 0 !== _a ? _a : symbol.attribute.fill, obj.opacity = null !== (_b = a.opacity) && void 0 !== _b ? _b : symbol.attribute.opacity, obj.fillOpacity = symbol.attribute.fillOpacity, obj.stroke = null !== (_c = a.stroke) && void 0 !== _c ? _c : symbol.attribute.stroke, obj.lineWidth = null !== (_d = a.lineWidth) && void 0 !== _d ? _d : symbol.attribute.lineWidth, a = obj;
      }
      const _runFill = () => {
          a.fill && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : (context.setCommonStyle(symbol, a, originX - x, originY - y, symbolAttribute), context.fill()));
        },
        _runStroke = () => {
          a.stroke && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, a, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
        };
      fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke());
    }) && context.closePath(), context.camera = camera, context.setShadowBlendStyle && context.setShadowBlendStyle(symbol, symbol.attribute, symbolAttribute), this.beforeRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
        doFill && !parsedPath.isSvg && (fillCb ? fillCb(context, symbol.attribute, symbolAttribute) : fVisible && (context.setCommonStyle(symbol, symbol.attribute, originX - x, originY - y, symbolAttribute), context.fill()));
      },
      _runStroke = () => {
        doStroke && !parsedPath.isSvg && (strokeCb ? strokeCb(context, symbol.attribute, symbolAttribute) : sVisible && clipRange >= 1 && (context.setStrokeStyle(symbol, symbol.attribute, (originX - x) / scaleX, (originY - y) / scaleY, symbolAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(symbol, context, x, y, doFill, doStroke, fVisible, sVisible, symbolAttribute, drawContext, fillCb, strokeCb);
  }
  draw(symbol, renderService, drawContext, params) {
    const symbolAttribute = getTheme(symbol, null == params ? void 0 : params.theme).symbol;
    this._draw(symbol, symbolAttribute, !1, drawContext, params);
  }
};
DefaultCanvasSymbolRender = __decorate$1w([injectable(), __param$N(0, inject(ContributionProvider)), __param$N(0, named(SymbolRenderContribution)), __metadata$19("design:paramtypes", [Object])], DefaultCanvasSymbolRender);

class DefaultBoundsAllocate {
  constructor() {
    this.pools = [];
    for (let i = 0; i < 10; i++) this.pools.push(new AABBBounds());
  }
  allocate(x1, y1, x2, y2) {
    if (!this.pools.length) return new AABBBounds().setValue(x1, y1, x2, y2);
    const b = this.pools.pop();
    return b.x1 = x1, b.y1 = y1, b.x2 = x2, b.y2 = y2, b;
  }
  allocateByObj(b) {
    if (!this.pools.length) return new AABBBounds(b);
    const _b = this.pools.pop();
    return _b.x1 = b.x1, _b.y1 = b.y1, _b.x2 = b.x2, _b.y2 = b.y2, _b;
  }
  free(b) {
    this.pools.push(b);
  }
  get length() {
    return this.pools.length;
  }
  release() {
    this.pools = [];
  }
}
const boundsAllocate = new DefaultBoundsAllocate();

class DefaultTextBackgroundRenderContribution extends DefaultBaseBackgroundRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.beforeFillStroke;
  }
  drawShape(graphic, context, x, y, doFill, doStroke, fVisible, sVisible, graphicAttribute, drawContext, fillCb, strokeCb) {
    var _a, _c, _d, _e, _f, _g, _h, _j, _k, _l;
    const {
      backgroundMode = graphicAttribute.backgroundMode,
      backgroundFit = graphicAttribute.backgroundFit,
      backgroundKeepAspectRatio = graphicAttribute.backgroundKeepAspectRatio
    } = graphic.attribute;
    let matrix,
      {
        background: background
      } = graphic.attribute;
    if (!background) return;
    const restore = () => {
      "richtext" === graphic.type && (context.restore(), context.save(), matrix && context.setTransformFromMatrix(matrix, !0, 1));
    };
    let b;
    "richtext" === graphic.type && (matrix = context.currentMatrix.clone(), context.restore(), context.save(), context.setTransformForCurrent());
    const shouldReCalBounds = isObject$1(background) && background.background,
      onlyTranslate = graphic.transMatrix.onlyTranslate();
    if (shouldReCalBounds) {
      const _b = graphic.AABBBounds,
        x = (null !== (_a = background.x) && void 0 !== _a ? _a : _b.x1) + (null !== (_c = background.dx) && void 0 !== _c ? _c : 0),
        y = (null !== (_d = background.y) && void 0 !== _d ? _d : _b.y1) + (null !== (_e = background.dy) && void 0 !== _e ? _e : 0),
        w = null !== (_f = background.width) && void 0 !== _f ? _f : _b.width(),
        h = null !== (_g = background.height) && void 0 !== _g ? _g : _b.height();
      if (b = boundsAllocate.allocate(x, y, x + w, y + h), background = background.background, !onlyTranslate) {
        const w = b.width(),
          h = b.height();
        b.set((null !== (_h = background.x) && void 0 !== _h ? _h : 0) + (null !== (_j = background.dx) && void 0 !== _j ? _j : 0), (null !== (_k = background.y) && void 0 !== _k ? _k : 0) + (null !== (_l = background.dy) && void 0 !== _l ? _l : 0), w, h);
      }
    } else b = graphic.AABBBounds, onlyTranslate || (b = getTextBounds(Object.assign(Object.assign({}, graphic.attribute), {
      angle: 0,
      scaleX: 1,
      scaleY: 1,
      x: 0,
      y: 0,
      dx: 0,
      dy: 0
    })).clone());
    if (graphic.backgroundImg && graphic.resources) {
      const res = graphic.resources.get(background);
      if ("success" !== res.state || !res.data) return void restore();
      context.highPerformanceSave(), onlyTranslate && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), this.doDrawImage(context, res.data, b, {
        backgroundMode: backgroundMode,
        backgroundFit: backgroundFit,
        backgroundKeepAspectRatio: backgroundKeepAspectRatio
      }), context.highPerformanceRestore(), context.setTransformForCurrent();
    } else {
      const {
        backgroundCornerRadius: backgroundCornerRadius
      } = graphic.attribute;
      context.highPerformanceSave(), context.setCommonStyle(graphic, graphic.attribute, x, y, graphicAttribute), context.fillStyle = background, backgroundCornerRadius ? (createRectPath(context, b.x1, b.y1, b.width(), b.height(), backgroundCornerRadius, !0), context.fill()) : context.fillRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore();
    }
    shouldReCalBounds && boundsAllocate.free(b), restore();
  }
}
const defaultTextBackgroundRenderContribution = new DefaultTextBackgroundRenderContribution();

var __decorate$1v = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$18 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$M = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasTextRender = class extends BaseRender {
  constructor(textRenderContribitions) {
    super(), this.textRenderContribitions = textRenderContribitions, this.numberType = TEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init(textRenderContribitions);
  }
  drawShape(text, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a, _b, _c;
    const textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
      {
        text: str,
        underline = textAttribute.underline,
        lineThrough = textAttribute.lineThrough,
        keepDirIn3d = textAttribute.keepDirIn3d,
        direction = textAttribute.direction,
        fontSize = textAttribute.fontSize,
        verticalMode = textAttribute.verticalMode,
        x: originX = textAttribute.x,
        y: originY = textAttribute.y
      } = text.attribute,
      lineHeight = null !== (_a = calculateLineHeight(text.attribute.lineHeight, fontSize)) && void 0 !== _a ? _a : fontSize,
      data = this.valid(text, textAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        fVisible: fVisible,
        sVisible: sVisible,
        doFill: doFill,
        doStroke: doStroke
      } = data,
      transform3dMatrixToContextMatrix = !keepDirIn3d,
      z = this.z || 0;
    context.beginPath(), context.setShadowBlendStyle && context.setShadowBlendStyle(text, text.attribute, textAttribute), this.beforeRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb), transform3dMatrixToContextMatrix && this.transformUseContext2d(text, textAttribute, z, context);
    const drawText = (t, offsetX, offsetY, direction) => {
      let _x = x + offsetX;
      const _y = y + offsetY;
      if (direction) {
        context.highPerformanceSave(), _x += fontSize;
        const matrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0);
        matrix.rotateByCenter(Math.PI / 2, _x, _y), context.transformFromMatrix(matrix, !0), matrixAllocate.free(matrix);
      }
      doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.strokeText(t, _x, _y, z))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), context.fillText(t, _x, _y, z))), direction && (context.highPerformanceRestore(), context.setTransformForCurrent());
    };
    if (context.setTextStyleWithoutAlignBaseline(text.attribute, textAttribute, z), "horizontal" === direction) {
      const {
        multilineLayout: multilineLayout
      } = text;
      if (!multilineLayout) return void context.highPerformanceRestore();
      const {
        xOffset: xOffset,
        yOffset: yOffset
      } = multilineLayout.bbox;
      doStroke && (strokeCb ? strokeCb(context, text.attribute, textAttribute) : sVisible && (context.setStrokeStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(line => {
        context.strokeText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z);
      }))), doFill && (fillCb ? fillCb(context, text.attribute, textAttribute) : fVisible && (context.setCommonStyle(text, text.attribute, originX - x, originY - y, textAttribute), multilineLayout.lines.forEach(line => {
        context.fillText(line.str, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, z), this.drawUnderLine(underline, lineThrough, text, (line.leftOffset || 0) + xOffset + x, (line.topOffset || 0) + yOffset + y, line.descent, (line.descent - line.ascent) / 2, z, textAttribute, context, {
          width: line.width
        });
      })));
    } else {
      let {
        textAlign = textAttribute.textAlign,
        textBaseline = textAttribute.textBaseline
      } = text.attribute;
      if (!verticalMode) {
        const t = textAlign;
        textAlign = null !== (_b = text.getBaselineMapAlign()[textBaseline]) && void 0 !== _b ? _b : "left", textBaseline = null !== (_c = text.getAlignMapBaseline()[t]) && void 0 !== _c ? _c : "top";
      }
      text.tryUpdateAABBBounds();
      const cache = text.cache,
        {
          verticalList: verticalList
        } = cache;
      context.textAlign = "left", context.textBaseline = "top";
      const totalHeight = lineHeight * verticalList.length;
      let totalW = 0;
      verticalList.forEach(verticalData => {
        const _w = verticalData.reduce((a, b) => a + (b.width || 0), 0);
        totalW = max(_w, totalW);
      });
      let offsetY = 0,
        offsetX = 0;
      "bottom" === textBaseline ? offsetX = -totalHeight : "middle" === textBaseline && (offsetX = -totalHeight / 2), "center" === textAlign ? offsetY -= totalW / 2 : "right" === textAlign && (offsetY -= totalW), verticalList.forEach((verticalData, i) => {
        const currentW = verticalData.reduce((a, b) => a + (b.width || 0), 0),
          dw = totalW - currentW;
        let currentOffsetY = offsetY;
        "center" === textAlign ? currentOffsetY += dw / 2 : "right" === textAlign && (currentOffsetY += dw), verticalData.forEach(item => {
          const {
            text: text,
            width: width,
            direction: direction
          } = item;
          drawText(text, totalHeight - (i + 1) * lineHeight + offsetX, currentOffsetY, direction), currentOffsetY += width;
        });
      });
    }
    transform3dMatrixToContextMatrix && this.restoreTransformUseContext2d(text, textAttribute, z, context), this.afterRenderStep(text, context, x, y, doFill, doStroke, fVisible, sVisible, textAttribute, drawContext, fillCb, strokeCb);
  }
  draw(text, renderService, drawContext, params) {
    const textAttribute = getTheme(text, null == params ? void 0 : params.theme).text,
      {
        keepDirIn3d = textAttribute.keepDirIn3d
      } = text.attribute,
      computed3dMatrix = !keepDirIn3d;
    this._draw(text, textAttribute, computed3dMatrix, drawContext, params);
  }
  drawUnderLine(underline, lineThrough, text, anchorX, anchorY, offsetUnderLineY, offsetThroughLineY, z, textAttribute, context, multiOption) {
    if (lineThrough + underline <= 0) return;
    const {
        textAlign = textAttribute.textAlign,
        fill = textAttribute.fill,
        opacity = textAttribute.opacity,
        underlineOffset = textAttribute.underlineOffset,
        underlineDash = textAttribute.underlineDash,
        fillOpacity = textAttribute.fillOpacity
      } = text.attribute,
      isMulti = !isNil$1(multiOption),
      w = isMulti ? multiOption.width : text.clipedWidth,
      offsetX = isMulti ? 0 : textDrawOffsetX(textAlign, w),
      attribute = {
        lineWidth: 0,
        stroke: fill,
        opacity: opacity,
        strokeOpacity: fillOpacity
      };
    if (underline) {
      attribute.lineWidth = underline, context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute), underlineDash && context.setLineDash(underlineDash), context.beginPath();
      const dy = anchorY + offsetUnderLineY + underlineOffset;
      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
    }
    if (lineThrough) {
      attribute.lineWidth = lineThrough, context.setStrokeStyle(text, attribute, anchorX, anchorY, textAttribute), context.beginPath();
      const dy = anchorY + offsetThroughLineY;
      context.moveTo(anchorX + offsetX, dy, z), context.lineTo(anchorX + offsetX + w, dy, z), context.stroke();
    }
  }
};
DefaultCanvasTextRender = __decorate$1v([injectable(), __param$M(0, inject(ContributionProvider)), __param$M(0, named(TextRenderContribution)), __metadata$18("design:paramtypes", [Object])], DefaultCanvasTextRender);

var __decorate$1u = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let AbstractGraphicRender = class {};
AbstractGraphicRender = __decorate$1u([injectable()], AbstractGraphicRender);

function drawPolygon(path, points, x, y) {
  path.moveTo(points[0].x + x, points[0].y + y);
  for (let i = 1; i < points.length; i++) path.lineTo(points[i].x + x, points[i].y + y);
}
function drawRoundedPolygon(path, points, x, y, cornerRadius) {
  let closePath = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !0;
  var _a;
  if (points.length < 3) return void drawPolygon(path, points, x, y);
  let startI = 0,
    endI = points.length - 1;
  closePath || (startI += 1, endI -= 1, path.moveTo(points[0].x + x, points[0].y + y));
  for (let i = startI; i <= endI; i++) {
    const p1 = points[0 === i ? endI : (i - 1) % points.length],
      angularPoint = points[i % points.length],
      p2 = points[(i + 1) % points.length],
      dx1 = angularPoint.x - p1.x,
      dy1 = angularPoint.y - p1.y,
      dx2 = angularPoint.x - p2.x,
      dy2 = angularPoint.y - p2.y,
      angle = (Math.atan2(dy1, dx1) - Math.atan2(dy2, dx2)) / 2,
      tan = Math.abs(Math.tan(angle));
    let radius = Array.isArray(cornerRadius) ? null !== (_a = cornerRadius[i % points.length]) && void 0 !== _a ? _a : 0 : cornerRadius,
      segment = radius / tan;
    const length1 = getLength(dx1, dy1),
      length2 = getLength(dx2, dy2),
      length = Math.min(length1, length2);
    segment > length && (segment = length, radius = length * tan);
    const p1Cross = getProportionPoint(angularPoint, segment, length1, dx1, dy1),
      p2Cross = getProportionPoint(angularPoint, segment, length2, dx2, dy2),
      dx = 2 * angularPoint.x - p1Cross.x - p2Cross.x,
      dy = 2 * angularPoint.y - p1Cross.y - p2Cross.y,
      L = getLength(dx, dy),
      circlePoint = getProportionPoint(angularPoint, getLength(segment, radius), L, dx, dy);
    let startAngle = Math.atan2(p1Cross.y - circlePoint.y, p1Cross.x - circlePoint.x);
    const endAngle = Math.atan2(p2Cross.y - circlePoint.y, p2Cross.x - circlePoint.x);
    let sweepAngle = endAngle - startAngle;
    sweepAngle < 0 && (startAngle = endAngle, sweepAngle = -sweepAngle), sweepAngle > Math.PI && (sweepAngle -= Math.PI), 0 === i ? path.moveTo(p1Cross.x + x, p1Cross.y + y) : path.lineTo(p1Cross.x + x, p1Cross.y + y), sweepAngle && path.arcTo(angularPoint.x + x, angularPoint.y + y, p2Cross.x + x, p2Cross.y + y, radius), path.lineTo(p2Cross.x + x, p2Cross.y + y);
  }
  closePath || path.lineTo(points[endI + 1].x + x, points[endI + 1].y + y);
}
function getLength(dx, dy) {
  return Math.sqrt(dx * dx + dy * dy);
}
function getProportionPoint(point, segment, length, dx, dy) {
  const factor = segment / length;
  return {
    x: point.x - dx * factor,
    y: point.y - dy * factor
  };
}

const defaultPolygonTextureRenderContribution = defaultBaseTextureRenderContribution;
const defaultPolygonBackgroundRenderContribution = defaultBaseBackgroundRenderContribution;

var __decorate$1t = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$17 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$L = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPolygonRender = class extends BaseRender {
  constructor(polygonRenderContribitions) {
    super(), this.polygonRenderContribitions = polygonRenderContribitions, this.numberType = POLYGON_NUMBER_TYPE, this.builtinContributions = [defaultPolygonBackgroundRenderContribution, defaultPolygonTextureRenderContribution], this.init(polygonRenderContribitions);
  }
  drawShape(polygon, context, x, y, drawContext, params, fillCb, strokeCb) {
    const polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon,
      {
        points = polygonAttribute.points,
        cornerRadius = polygonAttribute.cornerRadius,
        x: originX = polygonAttribute.x,
        y: originY = polygonAttribute.y,
        closePath = polygonAttribute.closePath,
        fillStrokeOrder = polygonAttribute.fillStrokeOrder
      } = polygon.attribute,
      data = this.valid(polygon, polygonAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    } = data;
    context.beginPath(), cornerRadius <= 0 || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? drawPolygon(context.camera ? context : context.nativeContext, points, x, y) : drawRoundedPolygon(context.camera ? context : context.nativeContext, points, x, y, cornerRadius, closePath), closePath && context.closePath(), context.setShadowBlendStyle && context.setShadowBlendStyle(polygon, polygon.attribute, polygonAttribute), this.beforeRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
    const _runFill = () => {
        doFill && (fillCb ? fillCb(context, polygon.attribute, polygonAttribute) : fVisible && (context.setCommonStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.fill()));
      },
      _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, polygon.attribute, polygonAttribute) : sVisible && (context.setStrokeStyle(polygon, polygon.attribute, originX - x, originY - y, polygonAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this.afterRenderStep(polygon, context, x, y, doFill, doStroke, fVisible, sVisible, polygonAttribute, drawContext, fillCb, strokeCb);
  }
  draw(polygon, renderService, drawContext, params) {
    const polygonAttribute = getTheme(polygon, null == params ? void 0 : params.theme).polygon;
    this._draw(polygon, polygonAttribute, !1, drawContext, params);
  }
};
DefaultCanvasPolygonRender = __decorate$1t([injectable(), __param$L(0, inject(ContributionProvider)), __param$L(0, named(PolygonRenderContribution)), __metadata$17("design:paramtypes", [Object])], DefaultCanvasPolygonRender);

var __decorate$1s = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$16 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$K = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasGroupRender = class {
  constructor(groupRenderContribitions) {
    this.groupRenderContribitions = groupRenderContribitions, this.numberType = GROUP_NUMBER_TYPE;
  }
  drawShape(group, context, x, y, drawContext, params, fillCb, strokeCb) {
    const groupAttribute = getTheme(group, null == params ? void 0 : params.theme).group,
      {
        fill = groupAttribute.fill,
        background: background,
        stroke = groupAttribute.stroke,
        opacity = groupAttribute.opacity,
        width = groupAttribute.width,
        height = groupAttribute.height,
        clip = groupAttribute.clip,
        fillOpacity = groupAttribute.fillOpacity,
        strokeOpacity = groupAttribute.strokeOpacity,
        cornerRadius = groupAttribute.cornerRadius,
        path = groupAttribute.path,
        lineWidth = groupAttribute.lineWidth,
        visible = groupAttribute.visible,
        fillStrokeOrder = groupAttribute.fillStrokeOrder,
        cornerType = groupAttribute.cornerType,
        x: originX = groupAttribute.x,
        y: originY = groupAttribute.y
      } = group.attribute,
      fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
      sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
      doFill = runFill(fill, background),
      doStroke = runStroke(stroke, lineWidth);
    if (!group.valid || !visible) return;
    if (!clip) {
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb || background)) return;
    }
    if (path && path.length && drawContext.drawContribution) {
      const disableFill = context.disableFill,
        disableStroke = context.disableStroke,
        disableBeginPath = context.disableBeginPath;
      context.disableFill = !0, context.disableStroke = !0, context.disableBeginPath = !0, path.forEach(g => {
        drawContext.drawContribution.getRenderContribution(g).draw(g, drawContext.renderService, drawContext, params);
      }), context.disableFill = disableFill, context.disableStroke = disableStroke, context.disableBeginPath = disableBeginPath;
    } else 0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? (context.beginPath(), context.rect(x, y, width, height)) : (context.beginPath(), createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType));
    this._groupRenderContribitions || (this._groupRenderContribitions = this.groupRenderContribitions.getContributions() || [], this._groupRenderContribitions.push(defaultGroupBackgroundRenderContribution));
    const doFillOrStroke = {
      doFill: doFill,
      doStroke: doStroke
    };
    context.setShadowBlendStyle && context.setShadowBlendStyle(group, group.attribute, groupAttribute), this._groupRenderContribitions.forEach(c => {
      c.time === BaseRenderContributionTime.beforeFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb, doFillOrStroke);
    }), clip && context.clip();
    const _runFill = () => {
        doFillOrStroke.doFill && (fillCb ? fillCb(context, group.attribute, groupAttribute) : fVisible && (context.setCommonStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.fill()));
      },
      _runStroke = () => {
        doFillOrStroke.doStroke && (strokeCb ? strokeCb(context, group.attribute, groupAttribute) : sVisible && (context.setStrokeStyle(group, group.attribute, originX - x, originY - y, groupAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), _runFill()) : (_runFill(), _runStroke()), this._groupRenderContribitions.forEach(c => {
      c.time === BaseRenderContributionTime.afterFillStroke && c.drawShape(group, context, x, y, doFill, doStroke, fVisible, sVisible, groupAttribute, drawContext, fillCb, strokeCb);
    });
  }
  draw(group, renderService, drawContext, params) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const {
        clip: clip,
        baseOpacity = 1,
        drawMode: drawMode,
        x: x,
        y: y,
        width: width,
        height: height
      } = group.attribute,
      lastNativeContext = context.nativeContext,
      lastNativeCanvas = context.canvas.nativeCanvas;
    if (drawMode > 0) {
      const canvas = context.canvas,
        newCanvas = vglobal.createCanvas({
          width: canvas.width,
          height: canvas.height,
          dpr: 1
        }),
        newContext = newCanvas.getContext("2d"),
        transform = context.nativeContext.getTransform();
      newContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f), 1 === drawMode && (newContext.save(), newContext.clearRect(0, 0, canvas.width, canvas.height), newContext.beginPath(), newContext.rect(x, y, width, height), newContext.clip(), newContext.drawImage(canvas.nativeCanvas, 0, 0, canvas.width, canvas.height, 0, 0, canvas.displayWidth, canvas.displayHeight), newContext.restore()), context.nativeContext = newContext, canvas.nativeCanvas = newCanvas;
    }
    clip ? context.save() : context.highPerformanceSave();
    const baseGlobalAlpha = context.baseGlobalAlpha;
    context.baseGlobalAlpha *= baseOpacity;
    const groupAttribute = getTheme(group, null == params ? void 0 : params.theme).group,
      lastModelMatrix = context.modelMatrix;
    if (context.camera) {
      const nextModelMatrix = mat4Allocate.allocate(),
        modelMatrix = mat4Allocate.allocate();
      getModelMatrix(modelMatrix, group, groupAttribute), multiplyMat4Mat4(nextModelMatrix, lastModelMatrix || nextModelMatrix, modelMatrix), context.modelMatrix = nextModelMatrix, mat4Allocate.free(modelMatrix), context.setTransform(1, 0, 0, 1, 0, 0, !0);
    } else context.transformFromMatrix(group.transMatrix, !0);
    context.beginPath(), params.skipDraw ? this.drawShape(group, context, 0, 0, drawContext, params, () => !1, () => !1) : this.drawShape(group, context, 0, 0, drawContext);
    const {
      scrollX = groupAttribute.scrollX,
      scrollY = groupAttribute.scrollY
    } = group.attribute;
    let p;
    if ((scrollX || scrollY) && context.translate(scrollX, scrollY), params && params.drawingCb && (p = params.drawingCb()), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, context.baseGlobalAlpha = baseGlobalAlpha, drawMode > 0) {
      const newContext = context.nativeContext,
        newCanvas = context.canvas.nativeCanvas;
      lastNativeContext.save(), lastNativeContext.setTransform(context.dpr, 0, 0, context.dpr, 0, 0, !0), 1 === drawMode && newContext.rect(x, y, width, height), lastNativeContext.drawImage(newCanvas, 0, 0, newCanvas.width, newCanvas.height, 0, 0, context.canvas.displayWidth, context.canvas.displayHeight);
      const transform = newContext.getTransform();
      lastNativeContext.setTransform(transform.a, transform.b, transform.c, transform.d, transform.e, transform.f), context.nativeContext = lastNativeContext, context.canvas.nativeCanvas = lastNativeCanvas, lastNativeContext.restore();
    }
    p && p.then ? p.then(() => {
      clip ? context.restore() : context.highPerformanceRestore();
    }) : clip ? context.restore() : context.highPerformanceRestore();
  }
};
DefaultCanvasGroupRender = __decorate$1s([injectable(), __param$K(0, inject(ContributionProvider)), __param$K(0, named(GroupRenderContribution)), __metadata$16("design:paramtypes", [Object])], DefaultCanvasGroupRender);

var __decorate$1r = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$15 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$J = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
const repeatStr = ["", "repeat-x", "repeat-y", "repeat"];
let DefaultCanvasImageRender = class extends BaseRender {
  constructor(imageRenderContribitions) {
    super(), this.imageRenderContribitions = imageRenderContribitions, this.numberType = IMAGE_NUMBER_TYPE, this.builtinContributions = [defaultImageRenderContribution, defaultImageBackgroundRenderContribution], this.init(imageRenderContribitions);
  }
  drawShape(image, context, x, y, drawContext, params, fillCb, strokeCb) {
    const imageAttribute = getTheme(image).image,
      {
        repeatX = imageAttribute.repeatX,
        repeatY = imageAttribute.repeatY,
        x: originX = imageAttribute.x,
        y: originY = imageAttribute.y,
        cornerRadius = imageAttribute.cornerRadius,
        fillStrokeOrder = imageAttribute.fillStrokeOrder,
        cornerType = imageAttribute.cornerType,
        image: url
      } = image.attribute,
      data = this.valid(image, imageAttribute, fillCb);
    if (!data) return;
    const {
      fVisible: fVisible,
      sVisible: sVisible,
      doFill: doFill,
      doStroke: doStroke
    } = data;
    if (!url || !image.resources) return;
    const res = image.resources.get(url);
    if ("success" !== res.state) return;
    const width = image.width,
      height = image.height;
    context.beginPath();
    let needRestore = !1;
    0 === cornerRadius || isArray$1(cornerRadius) && cornerRadius.every(num => 0 === num) ? context.rect(x, y, width, height) : (createRectPath(context, x, y, width, height, cornerRadius, "bevel" !== cornerType), needRestore = !0), context.setShadowBlendStyle && context.setShadowBlendStyle(image, image.attribute, imageAttribute);
    const _runFill = () => {
        if (doFill) if (fillCb) fillCb(context, image.attribute, imageAttribute);else if (fVisible) {
          context.setCommonStyle(image, image.attribute, x, y, imageAttribute);
          let repeat = 0;
          if ("repeat" === repeatX && (repeat |= 1), "repeat" === repeatY && (repeat |= 2), repeat) {
            const pattern = context.createPattern(res.data, repeatStr[repeat]);
            context.fillStyle = pattern, context.translate(x, y, !0), context.fillRect(0, 0, width, height), context.translate(-x, -y, !0);
          } else context.drawImage(res.data, x, y, width, height);
        }
      },
      _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore()) : (needRestore && (context.save(), context.clip()), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), needRestore && context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const {
      image: url
    } = image.attribute;
    if (!url || !image.resources) return;
    const res = image.resources.get(url);
    if ("loading" === res.state && isString$1(url)) return void ResourceLoader.improveImageLoading(url);
    if ("success" !== res.state) return;
    const {
      context: context
    } = renderService.drawParams;
    if (!context) return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, !1, drawContext);
  }
};
DefaultCanvasImageRender = __decorate$1r([injectable(), __param$J(0, inject(ContributionProvider)), __param$J(0, named(ImageRenderContribution)), __metadata$15("design:paramtypes", [Object])], DefaultCanvasImageRender);

const IncrementalDrawContribution = Symbol.for("IncrementalDrawContribution");
const ArcRender = Symbol.for("ArcRender");
const Arc3dRender = Symbol.for("Arc3dRender");
const AreaRender = Symbol.for("AreaRender");
const CircleRender = Symbol.for("CircleRender");
const GraphicRender = Symbol.for("GraphicRender");
const GroupRender = Symbol.for("GroupRender");
const LineRender = Symbol.for("LineRender");
const PathRender = Symbol.for("PathRender");
const PolygonRender = Symbol.for("PolygonRender");
const RectRender = Symbol.for("RectRender");
const Rect3DRender = Symbol.for("Rect3DRender");
const SymbolRender = Symbol.for("SymbolRender");
const TextRender = Symbol.for("TextRender");
const RichTextRender = Symbol.for("RichTextRender");
const Pyramid3dRender = Symbol.for("Pyramid3dRender");
const GlyphRender = Symbol.for("GlyphRender");
const ImageRender = Symbol.for("ImageRender");
const RenderSelector = Symbol.for("RenderSelector");
const DrawContribution = Symbol.for("DrawContribution");

const draw3dItem = (context, graphic, callback, output) => {
  let result,
    isPie = !1,
    is3d = !1;
  if (graphic.forEachChildren(c => (isPie = c.numberType === ARC3D_NUMBER_TYPE, !isPie)), graphic.forEachChildren(c => (is3d = !!c.findFace, !is3d)), isPie) {
    const children = graphic.getChildren(),
      sortedChildren = [...children];
    sortedChildren.sort((a, b) => {
      var _a, _b, _c, _d;
      let angle1 = (null !== (_b = null !== (_a = a.attribute.startAngle) && void 0 !== _a ? _a : 0 + a.attribute.endAngle) && void 0 !== _b ? _b : 0) / 2,
        angle2 = (null !== (_d = null !== (_c = b.attribute.startAngle) && void 0 !== _c ? _c : 0 + b.attribute.endAngle) && void 0 !== _d ? _d : 0) / 2;
      for (; angle1 < 0;) angle1 += pi2;
      for (; angle2 < 0;) angle2 += pi2;
      return angle2 - angle1;
    }), sortedChildren.forEach(c => {
      c._next = null, c._prev = null;
    }), graphic.removeAllChild(), graphic.update(), sortedChildren.forEach(c => {
      graphic.appendChild(c);
    }), output.hack_pieFace = "outside", result = callback(isPie, is3d), result && result.graphic || (output.hack_pieFace = "inside", result = callback(isPie, is3d)), result && result.graphic || (output.hack_pieFace = "top", result = callback(isPie, is3d)), graphic.removeAllChild(), children.forEach(c => {
      c._next = null, c._prev = null;
    }), children.forEach(c => {
      graphic.appendChild(c);
    });
  } else if (is3d) {
    const children = graphic.getChildren(),
      zChildren = children.map(g => ({
        ave_z: g.findFace().vertices.map(v => {
          var _a;
          return context.view(v[0], v[1], null !== (_a = v[2] + g.attribute.z) && void 0 !== _a ? _a : 0)[2];
        }).reduce((a, b) => a + b, 0),
        g: g
      }));
    zChildren.sort((a, b) => b.ave_z - a.ave_z), graphic.removeAllChild(), zChildren.forEach(i => {
      i.g._next = null, i.g._prev = null;
    }), graphic.update(), zChildren.forEach(i => {
      graphic.add(i.g);
    }), result = callback(isPie, is3d), graphic.removeAllChild(), children.forEach(g => {
      g._next = null, g._prev = null;
    }), graphic.update(), children.forEach(g => {
      graphic.add(g);
    });
  } else result = callback(isPie, is3d);
  return result;
};

var __decorate$1q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$14 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
const DrawItemInterceptor = Symbol.for("DrawItemInterceptor");
const tempDirtyBounds = new AABBBounds(),
  tempBackupDirtyBounds = new AABBBounds();
class ShadowRootDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0 || (graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    return null == graphic.attribute.shadowRootIdx && graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx > 0 || (graphic.attribute.shadowRootIdx < 0 || graphic.shadowRoot && graphic.shadowRoot.attribute.shadowRootIdx < 0) && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params) {
    if (!graphic.shadowRoot) return !1;
    const {
      context: context
    } = drawContext;
    if (context.highPerformanceSave(), context.transformFromMatrix(graphic.transMatrix, !0), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds) {
      tempDirtyBounds.copy(drawContribution.dirtyBounds), tempBackupDirtyBounds.copy(drawContribution.backupDirtyBounds);
      const m = graphic.globalTransMatrix.getInverse();
      drawContribution.dirtyBounds.copy(drawContribution.backupDirtyBounds).transformWithMatrix(m), drawContribution.backupDirtyBounds.copy(drawContribution.dirtyBounds);
    }
    return drawContribution.renderGroup(graphic.shadowRoot, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), context.highPerformanceRestore(), drawContribution.dirtyBounds && drawContribution.backupDirtyBounds && (drawContribution.dirtyBounds.copy(tempDirtyBounds), drawContribution.backupDirtyBounds.copy(tempBackupDirtyBounds)), !0;
  }
}
class DebugDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    return graphic.attribute._debug_bounds && this.drawItem(graphic, renderService, drawContext, drawContribution, params), !1;
  }
  drawItem(graphic, renderService, drawContext, drawContribution, params) {
    if (!graphic.attribute._debug_bounds) return !1;
    const {
      context: context
    } = drawContext;
    context.highPerformanceSave(), graphic.parent && context.setTransformFromMatrix(graphic.parent.globalTransMatrix, !0), graphic.glyphHost && graphic.glyphHost.parent && context.setTransformFromMatrix(graphic.glyphHost.parent.globalTransMatrix, !0);
    const b = graphic.AABBBounds;
    return !0 !== graphic.attribute._debug_bounds && graphic.attribute._debug_bounds(context, graphic), context.strokeRect(b.x1, b.y1, b.width(), b.height()), context.highPerformanceRestore(), !0;
  }
}
let CommonDrawItemInterceptorContribution = class {
  constructor() {
    this.order = 1, this.interceptors = [new ShadowRootDrawItemInterceptorContribution(), new Canvas3DDrawItemInterceptor(), new InteractiveDrawItemInterceptorContribution(), new DebugDrawItemInterceptorContribution()];
  }
  afterDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].afterDrawItem && this.interceptors[i].afterDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
    return !1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    if ((!graphic.in3dMode || drawContext.in3dInterceptor) && !graphic.shadowRoot && !(graphic.baseGraphic || graphic.attribute.globalZIndex || graphic.interactiveGraphic)) return !1;
    for (let i = 0; i < this.interceptors.length; i++) if (this.interceptors[i].beforeDrawItem && this.interceptors[i].beforeDrawItem(graphic, renderService, drawContext, drawContribution, params)) return !0;
    return !1;
  }
};
CommonDrawItemInterceptorContribution = __decorate$1q([injectable(), __metadata$14("design:paramtypes", [])], CommonDrawItemInterceptorContribution);
class InteractiveDrawItemInterceptorContribution {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    return !this.processing && (graphic.baseGraphic ? this.beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) : this.beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params));
  }
  beforeSetInteractive(graphic, renderService, drawContext, drawContribution, params) {
    let interactiveGraphic = graphic.interactiveGraphic;
    if (graphic.attribute.globalZIndex) {
      interactiveGraphic || (interactiveGraphic = graphic.clone(), graphic.interactiveGraphic = interactiveGraphic, interactiveGraphic.baseGraphic = graphic), interactiveGraphic.setAttributes({
        globalZIndex: 0,
        zIndex: graphic.attribute.globalZIndex
      }, !1, {
        skipUpdateCallback: !0
      }), drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).add(interactiveGraphic);
      }
      return !0;
    }
    if (interactiveGraphic) {
      drawContext.stage.tryInitInteractiveLayer();
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(interactiveGraphic);
      }
      graphic.interactiveGraphic = null, interactiveGraphic.baseGraphic = null;
    }
    return !1;
  }
  beforeDrawInteractive(graphic, renderService, drawContext, drawContribution, params) {
    const baseGraphic = graphic.baseGraphic;
    let intree = !!baseGraphic.stage,
      _g = baseGraphic.parent;
    for (; intree && _g && _g.stage !== _g;) intree = !!_g.stage, _g = _g.parent;
    if (!intree) {
      const interactiveLayer = drawContext.stage.getLayer("_builtin_interactive");
      if (interactiveLayer) {
        this.getShadowRoot(interactiveLayer).removeChild(graphic);
      }
      return !0;
    }
    if (baseGraphic) {
      this.processing = !0;
      const {
        context: context
      } = drawContext;
      return context.highPerformanceSave(), context.setTransformFromMatrix(baseGraphic.parent.globalTransMatrix, !0), baseGraphic.isContainer ? drawContribution.renderGroup(baseGraphic, drawContext, baseGraphic.parent.globalTransMatrix) : drawContribution.renderItem(baseGraphic, drawContext), context.highPerformanceRestore(), this.processing = !1, !0;
    }
    return !1;
  }
  getShadowRoot(interactiveLayer) {
    var _a;
    let group = interactiveLayer.getElementById("_interactive_group");
    return group || (group = graphicCreator.CreateGraphic("group", {}), group.id = "_interactive_group", interactiveLayer.add(group)), null !== (_a = group.shadowRoot) && void 0 !== _a ? _a : group.attachShadow();
  }
}
class Canvas3DDrawItemInterceptor {
  constructor() {
    this.order = 1;
  }
  beforeDrawItem(graphic, renderService, drawContext, drawContribution, params) {
    if (!graphic.in3dMode || drawContext.in3dInterceptor) return !1;
    drawContext.in3dInterceptor = !0;
    const {
      context: context,
      stage: stage
    } = renderService.drawParams;
    context.canvas;
    context.save(), this.initCanvasCtx(context), context.camera = stage.camera;
    const m = context.currentMatrix;
    m.a /= context.dpr, m.b /= context.dpr, m.c /= context.dpr, m.d /= context.dpr, m.e /= context.dpr, m.f /= context.dpr;
    const matrix = mat4Allocate.allocate();
    mat3Tomat4(matrix, m);
    const lastModelMatrix = context.modelMatrix;
    if (lastModelMatrix) {
      if (matrix) {
        const m = mat4Allocate.allocate();
        context.modelMatrix = multiplyMat4Mat4(m, lastModelMatrix, matrix);
      }
    } else context.modelMatrix = matrix;
    return context.setTransform(1, 0, 0, 1, 0, 0, !0), graphic.isContainer ? draw3dItem(context, graphic, (isPie, is3d) => drawContribution.renderGroup(graphic, drawContext, graphic.parent.globalTransMatrix, !isPie && is3d), drawContext) : drawContribution.renderItem(graphic, drawContext), context.camera = null, context.restore(), context.modelMatrix !== lastModelMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastModelMatrix, drawContext.in3dInterceptor = !1, !0;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
}

var __decorate$1p = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$13 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$I = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
const RenderService = Symbol.for("RenderService");
const BeforeRenderConstribution = Symbol.for("BeforeRenderConstribution");
let DefaultRenderService = class {
  constructor(drawContribution) {
    this.drawContribution = drawContribution;
  }
  prepare(updateBounds) {
    updateBounds && this.renderTreeRoots.forEach(g => {
      this._prepare(g, updateBounds);
    });
  }
  _prepare(g, updateBounds) {
    g.forEachChildren(g => {
      this._prepare(g, updateBounds);
    }), g.update({
      bounds: updateBounds,
      trans: !0
    });
  }
  prepareRenderList() {}
  beforeDraw(params) {}
  draw(params) {
    this.drawContribution.draw(this, Object.assign({}, this.drawParams));
  }
  afterDraw(params) {
    this.drawContribution.afterDraw && this.drawContribution.afterDraw(this, Object.assign({}, this.drawParams));
  }
  render(groups, params) {
    this.renderTreeRoots = groups, this.drawParams = params;
    const updateBounds = params.updateBounds;
    this.prepare(updateBounds), this.prepareRenderList(), this.beforeDraw(params), this.draw(params), this.afterDraw(params), this.drawParams = null;
  }
};
DefaultRenderService = __decorate$1p([injectable(), __param$I(0, inject(DrawContribution)), __metadata$13("design:paramtypes", [Object])], DefaultRenderService);

var renderModule$1 = new ContainerModule(bind => {
  bind(RenderService).to(DefaultRenderService);
});

const GraphicPicker = Symbol.for("GraphicPicker");
const PickerService = Symbol.for("PickerService");
const BoundsPicker = Symbol.for("BoundsPicker");
const GlobalPickerService = Symbol.for("GlobalPickerService");
const PickItemInterceptor = Symbol.for("PickItemInterceptor");
const PickServiceInterceptor = Symbol.for("PickServiceInterceptor");

var __decorate$1o = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let ShadowPickServiceInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(result, pickerService, point, pickParams, params) {
    if (result.graphic) {
      let g = result.graphic;
      for (; g.parent;) g = g.parent;
      g.shadowHost && (result.params = {
        shadowTarget: result.graphic
      }, result.graphic = g.shadowHost);
    }
    return result;
  }
};
ShadowPickServiceInterceptorContribution = __decorate$1o([injectable()], ShadowPickServiceInterceptorContribution);
let ShadowRootPickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  afterPickItem(graphic, pickerService, point, pickParams, params) {
    return graphic.attribute.shadowRootIdx > 0 || !graphic.attribute.shadowRootIdx ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
  }
  beforePickItem(graphic, pickerService, point, pickParams, params) {
    return graphic.attribute.shadowRootIdx < 0 ? this._pickItem(graphic, pickerService, point, pickParams, params) : null;
  }
  _pickItem(graphic, pickerService, point, pickParams, params) {
    var _a;
    if (!graphic.shadowRoot) return null;
    const {
      parentMatrix: parentMatrix
    } = params || {};
    if (!parentMatrix) return null;
    const context = pickerService.pickContext;
    context.highPerformanceSave();
    const theme = null === (_a = getTheme(graphic)) || void 0 === _a ? void 0 : _a[graphic.type],
      {
        shadowPickMode = null == theme ? void 0 : theme.shadowPickMode
      } = graphic.attribute,
      g = graphic.shadowRoot,
      currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix),
      newPoint = new Point(currentGroupMatrix.a * point.x + currentGroupMatrix.c * point.y + currentGroupMatrix.e, currentGroupMatrix.b * point.x + currentGroupMatrix.d * point.y + currentGroupMatrix.f),
      result = pickerService.pickGroup(g, newPoint, currentGroupMatrix, pickParams);
    return context.highPerformanceRestore(), !result.graphic && result.group && "full" === shadowPickMode && (result.graphic = result.group), result;
  }
};
ShadowRootPickItemInterceptorContribution = __decorate$1o([injectable()], ShadowRootPickItemInterceptorContribution);
let InteractivePickItemInterceptorContribution = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point, pickParams, params) {
    const originGraphic = graphic.baseGraphic;
    if (originGraphic && originGraphic.parent) {
      const newPoint = new Point(point.x, point.y),
        context = pickerService.pickContext;
      context.highPerformanceSave();
      const parentMatrix = originGraphic.parent.globalTransMatrix;
      parentMatrix.transformPoint(newPoint, newPoint);
      const result = originGraphic.isContainer ? pickerService.pickGroup(originGraphic, newPoint.clone(), parentMatrix, pickParams) : pickerService.pickItem(originGraphic, newPoint.clone(), parentMatrix, pickParams);
      return context.highPerformanceRestore(), result;
    }
    return null;
  }
};
InteractivePickItemInterceptorContribution = __decorate$1o([injectable()], InteractivePickItemInterceptorContribution);
let Canvas3DPickItemInterceptor = class {
  constructor() {
    this.order = 1;
  }
  beforePickItem(graphic, pickerService, point, pickParams, params) {
    if (!graphic.in3dMode || pickParams.in3dInterceptor) return null;
    const context = pickerService.pickContext,
      stage = graphic.stage;
    if (!context || !stage) return null;
    if (pickParams.in3dInterceptor = !0, context.save(), this.initCanvasCtx(context), context.camera = stage.camera, graphic.isContainer) {
      const result = draw3dItem(context, graphic, () => pickerService.pickGroup(graphic, point, params.parentMatrix, pickParams), pickParams);
      return context.camera = null, pickParams.in3dInterceptor = !1, context.restore(), result;
    }
    return context.restore(), null;
  }
  initCanvasCtx(context) {
    context.setTransformForCurrent();
  }
};
Canvas3DPickItemInterceptor = __decorate$1o([injectable()], Canvas3DPickItemInterceptor);

var pickModule = new ContainerModule((bind, unbind, isBound) => {
  isBound(PickerService) || (bind(GlobalPickerService).toSelf(), bind(PickerService).toService(GlobalPickerService)), bind(Canvas3DPickItemInterceptor).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(Canvas3DPickItemInterceptor), bind(ShadowRootPickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(ShadowRootPickItemInterceptorContribution), bind(InteractivePickItemInterceptorContribution).toSelf().inSingletonScope(), bind(PickItemInterceptor).toService(InteractivePickItemInterceptorContribution), bindContributionProvider(bind, PickItemInterceptor), bind(ShadowPickServiceInterceptorContribution).toSelf().inSingletonScope(), bind(PickServiceInterceptor).toService(ShadowPickServiceInterceptorContribution), bindContributionProvider(bind, PickServiceInterceptor);
});

var graphicModule = new ContainerModule(bind => {
  bind(GraphicService).to(DefaultGraphicService).inSingletonScope(), bind(GraphicCreator$1).toConstantValue(graphicCreator);
});

const AutoEnablePlugins = Symbol.for("AutoEnablePlugins");
const PluginService = Symbol.for("PluginService");

var __decorate$1n = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$12 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$H = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultPluginService = class {
  constructor(autoEnablePlugins) {
    this.autoEnablePlugins = autoEnablePlugins, this.onStartupFinishedPlugin = [], this.onRegisterPlugin = [], this.actived = !1;
  }
  active(stage, params) {
    this.stage = stage, this.actived = !0;
    const {
      pluginList: pluginList
    } = params;
    pluginList && container.isBound(AutoEnablePlugins) && this.autoEnablePlugins.getContributions().forEach(p => {
      pluginList.includes(p.name) && this.register(p);
    });
  }
  findPluginsByName(name) {
    const arr = [];
    return this.onStartupFinishedPlugin.forEach(plugin => {
      plugin.name === name && arr.push(plugin);
    }), this.onRegisterPlugin.forEach(plugin => {
      plugin.name === name && arr.push(plugin);
    }), arr;
  }
  register(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.push(plugin) : "onRegister" === plugin.activeEvent && (this.onRegisterPlugin.push(plugin), plugin.activate(this));
  }
  unRegister(plugin) {
    "onStartupFinished" === plugin.activeEvent ? this.onStartupFinishedPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1) : "onRegister" === plugin.activeEvent && this.onRegisterPlugin.splice(this.onStartupFinishedPlugin.indexOf(plugin), 1), plugin.deactivate(this);
  }
  release() {
    this.onStartupFinishedPlugin.forEach(plugin => {
      plugin.deactivate(this);
    }), this.onStartupFinishedPlugin = [], this.onRegisterPlugin.forEach(plugin => {
      plugin.deactivate(this);
    }), this.onRegisterPlugin = [];
  }
};
DefaultPluginService = __decorate$1n([injectable(), __param$H(0, inject(ContributionProvider)), __param$H(0, named(AutoEnablePlugins)), __metadata$12("design:paramtypes", [Object])], DefaultPluginService);

var pluginModule = new ContainerModule(bind => {
  bind(PluginService).to(DefaultPluginService), bindContributionProviderNoSingletonScope(bind, AutoEnablePlugins);
});

var envModules = new ContainerModule(bind => {
  bindContributionProvider(bind, EnvContribution);
});

var textMeasureModules = new ContainerModule(bind => {
  bind(TextMeasureContribution).to(DefaultTextMeasureContribution).inSingletonScope(), bindContributionProvider(bind, TextMeasureContribution);
});

var __decorate$1m = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$11 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let CanvasLayerHandlerContribution = class {
  constructor() {
    this.type = "static", this.offscreen = !1, this.global = application.global;
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  init(layer, window, params) {
    if (this.layer = layer, this.window = window, params.main) this.main = !0, this.context = window.getContext(), this.canvas = this.context.getCanvas();else {
      let nativeCanvas;
      this.main = !1, params.canvasId && (nativeCanvas = this.global.getElementById(params.canvasId)), nativeCanvas || (nativeCanvas = this.global.createCanvas({
        width: window.width,
        height: window.height
      })), nativeCanvas.style && (nativeCanvas.style["pointer-events"] = "none");
      const windowCanvas = window.getContext().getCanvas().nativeCanvas,
        canvas = wrapCanvas({
          nativeCanvas: nativeCanvas,
          width: window.width,
          height: window.height,
          dpr: window.dpr,
          id: params.canvasId,
          canvasControled: !0,
          container: window.getContainer(),
          x: windowCanvas.offsetLeft,
          y: windowCanvas.offsetTop
        });
      canvas.applyPosition(), this.canvas = canvas, this.context = canvas.getContext();
    }
  }
  resize(w, h) {
    this.canvas.resize(w, h);
  }
  resizeView(w, h) {}
  render(group, params, userParams) {
    var _a;
    if (!this.main) {
      const windowCanvas = this.window.getContext().getCanvas().nativeCanvas;
      !windowCanvas || this.canvas.x === windowCanvas.offsetLeft && this.canvas.y === windowCanvas.offsetTop || (this.canvas.x = windowCanvas.offsetLeft, this.canvas.y = windowCanvas.offsetTop, this.canvas.applyPosition());
    }
    params.renderService.render(group, Object.assign(Object.assign({
      context: this.context,
      clear: null !== (_a = params.background) && void 0 !== _a ? _a : "#ffffff"
    }, params), userParams));
  }
  merge(layerHandlers) {
    layerHandlers.forEach(l => {
      const canvas = l.getContext().canvas.nativeCanvas;
      this.context.drawImage(canvas, 0, 0);
    });
  }
  prepare(dirtyBounds, params) {}
  drawTo(target, group, params) {
    var _a;
    const context = target.getContext();
    params.renderService.render(group, Object.assign(Object.assign({
      context: context
    }, params), {
      clear: params.clear ? null !== (_a = params.background) && void 0 !== _a ? _a : "#fff" : void 0
    }));
  }
  getContext() {
    return this.context;
  }
  release() {
    this.canvas.release();
  }
};
CanvasLayerHandlerContribution = __decorate$1m([injectable(), __metadata$11("design:paramtypes", [])], CanvasLayerHandlerContribution);

var layerHandlerModules = new ContainerModule(bind => {
  bind(CanvasLayerHandlerContribution).toSelf(), bind(StaticLayerHandlerContribution).toService(CanvasLayerHandlerContribution);
});

function load$1(container) {
  container.load(envModules), container.load(textMeasureModules), container.load(layerHandlerModules);
}

var __awaiter$5 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      var value;
      result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
        resolve(value);
      })).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
function parseChildMap(graphic, defaultZIndex, reverse) {
  const childMap = {},
    zIdxArray = [];
  return graphic.forEachChildren(item => {
    const {
      zIndex = defaultZIndex
    } = item.attribute;
    childMap[zIndex] ? childMap[zIndex].push(item) : (childMap[zIndex] = [item], zIdxArray.push(zIndex));
  }, reverse), zIdxArray.sort((a, b) => reverse ? b - a : a - b), {
    childMap: childMap,
    zIdxArray: zIdxArray
  };
}
function foreach(graphic, defaultZIndex, cb) {
  let reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  let sort3d = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !1;
  let needSort = !1;
  if (sort3d) needSort = !0;else {
    let lastZIndex;
    graphic.forEachChildren((item, i) => {
      const {
        zIndex = defaultZIndex
      } = item.attribute;
      if (0 === i) lastZIndex = zIndex;else if (lastZIndex !== zIndex) return needSort = !0, !0;
      return !1;
    }, reverse);
  }
  if (needSort) {
    const {
      childMap: childMap,
      zIdxArray: zIdxArray
    } = parseChildMap(graphic, defaultZIndex, reverse);
    let skip = !1;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const children = childMap[zIdxArray[i]];
      sort3d && children.sort((a, b) => {
        var _a, _b;
        return (reverse ? -1 : 1) * ((null !== (_a = b.attribute.z) && void 0 !== _a ? _a : 0) - (null !== (_b = a.attribute.z) && void 0 !== _b ? _b : 0));
      });
      for (let i = 0; i < children.length; i++) if (cb(children[i], i)) {
        skip = !0;
        break;
      }
    }
  } else graphic.forEachChildren(cb, reverse);
}
function foreachAsync(graphic, defaultZIndex, cb) {
  let reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  return __awaiter$5(this, void 0, void 0, function* () {
    yield graphic.forEachChildrenAsync(cb, reverse);
  });
}
function findNextGraphic(graphic, id, defaultZIndex) {
  let reverse = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;
  let needSort = !1;
  graphic.forEachChildren((item, i) => {
    const {
      zIndex = defaultZIndex
    } = item.attribute;
    if (0 === i) ;else if (undefined !== zIndex) return needSort = !0, !0;
    return !1;
  }, reverse);
  let result = null,
    next = !1;
  if (needSort) {
    const {
      childMap: childMap,
      zIdxArray: zIdxArray
    } = parseChildMap(graphic, defaultZIndex, reverse);
    let skip = !1;
    for (let i = 0; i < zIdxArray.length && !skip; i++) {
      const children = childMap[zIdxArray[i]];
      for (let i = 0; i < children.length; i++) {
        if (next) {
          skip = !0, result = children[i];
          break;
        }
        children[i]._uid !== id || (next = !0);
      }
    }
  } else graphic.forEachChildren(item => next ? (result = item, !0) : (item._uid === id && (next = !0), !1), reverse);
  return result;
}

var __decorate$1l = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$10 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$G = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultDrawContribution = class {
  constructor(contributions, drawItemInterceptorContributions) {
    this.contributions = contributions, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.currentRenderMap = new Map(), this.defaultRenderMap = new Map(), this.styleRenderMap = new Map(), this.dirtyBounds = new Bounds(), this.backupDirtyBounds = new Bounds(), this.global = application.global, this.layerService = application.layerService, isArray$1(this.contributions) || (this.contributions = [this.contributions]), this.init();
  }
  init() {
    this.contributions.forEach(item => {
      if (item.style) {
        const map = this.styleRenderMap.get(item.style) || new Map();
        map.set(item.numberType, item), this.styleRenderMap.set(item.style, map);
      } else this.defaultRenderMap.set(item.numberType, item);
    }), this.InterceptorContributions = this.drawItemInterceptorContributions.getContributions().sort((a, b) => a.order - b.order);
  }
  prepareForDraw(renderService, drawContext) {
    drawContext.updateBounds ? this.useDirtyBounds = !0 : this.useDirtyBounds = !drawContext.stage.params.optimize.disableCheckGraphicWidthOutRange;
  }
  draw(renderService, drawContext) {
    this.prepareForDraw(renderService, drawContext), drawContext.drawContribution = this, this.currentRenderMap = this.styleRenderMap.get(drawContext.renderStyle) || this.defaultRenderMap, this.currentRenderService = renderService;
    const {
      context: context,
      stage: stage,
      viewBox: viewBox,
      transMatrix: transMatrix
    } = drawContext;
    if (!context) return;
    const dirtyBounds = this.dirtyBounds.setValue(0, 0, viewBox.width(), viewBox.height());
    if (stage.dirtyBounds && !stage.dirtyBounds.empty()) {
      const b = getRectIntersect(dirtyBounds, stage.dirtyBounds, !1);
      dirtyBounds.x1 = Math.floor(b.x1), dirtyBounds.y1 = Math.floor(b.y1), dirtyBounds.x2 = Math.ceil(b.x2), dirtyBounds.y2 = Math.ceil(b.y2);
    }
    const d = context.dpr % 1;
    (d || .5 !== d) && (dirtyBounds.x1 = Math.floor(dirtyBounds.x1 * context.dpr) / context.dpr, dirtyBounds.y1 = Math.floor(dirtyBounds.y1 * context.dpr) / context.dpr, dirtyBounds.x2 = Math.ceil(dirtyBounds.x2 * context.dpr) / context.dpr, dirtyBounds.y2 = Math.ceil(dirtyBounds.y2 * context.dpr) / context.dpr), this.backupDirtyBounds.copy(dirtyBounds), context.inuse = !0, context.setClearMatrix(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), context.clearMatrix(), context.setTransformForCurrent(!0), context.translate(viewBox.x1, viewBox.y1, !0), context.beginPath(), context.rect(dirtyBounds.x1, dirtyBounds.y1, dirtyBounds.width(), dirtyBounds.height()), context.clip(), stage.camera && (this.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), this.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0)), this.clearScreen(renderService, context, drawContext), context.save(), renderService.renderTreeRoots.sort((a, b) => {
      var _a, _b;
      return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach(group => {
      group.isContainer ? this.renderGroup(group, drawContext, matrixAllocate.allocate(1, 0, 0, 1, 0, 0)) : this.renderItem(group, drawContext);
    }), context.restore(), context.setClearMatrix(1, 0, 0, 1, 0, 0), context.inuse = !1, context.draw();
  }
  doRegister() {
    throw new Error("暂不支持");
  }
  _findNextGraphic(group) {
    let parent = group.parent,
      id = group._uid;
    for (; parent;) {
      const g = findNextGraphic(parent, id, DefaultAttribute.zIndex);
      if (g) return g;
      id = parent._uid, parent = parent.parent;
    }
    return null;
  }
  renderGroup(group, drawContext, parentMatrix, skipSort) {
    if (drawContext.break || !1 === group.attribute.visibleAll) return;
    if (group.incremental && (null == drawContext.startAtId || drawContext.startAtId === group._uid)) return drawContext.break = !0, void this._increaseRender(group, drawContext);
    if (this.useDirtyBounds && !isRectIntersect(group.AABBBounds, this.dirtyBounds, !1) && "empty" !== group.attribute.boundsMode) return;
    let tempBounds,
      nextM = parentMatrix;
    if (this.useDirtyBounds) {
      tempBounds = boundsAllocate.allocateByObj(this.dirtyBounds);
      const gm = group.transMatrix;
      nextM = matrixAllocate.allocateByObj(parentMatrix).multiply(gm.a, gm.b, gm.c, gm.d, gm.e, gm.f), this.dirtyBounds.copy(this.backupDirtyBounds).transformWithMatrix(nextM.getInverse());
    }
    this.renderItem(group, drawContext, {
      drawingCb: () => {
        var _a;
        skipSort ? group.forEachChildren(item => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }) : foreach(group, DefaultAttribute.zIndex, item => {
          drawContext.break || (item.isContainer ? this.renderGroup(item, drawContext, nextM) : this.renderItem(item, drawContext));
        }, !1, !!(null === (_a = drawContext.context) || void 0 === _a ? void 0 : _a.camera));
      }
    }), this.useDirtyBounds && (this.dirtyBounds.copy(tempBounds), boundsAllocate.free(tempBounds), matrixAllocate.free(nextM));
  }
  _increaseRender(group, drawContext) {
    const {
        layer: layer,
        stage: stage
      } = drawContext,
      {
        subLayers: subLayers
      } = layer;
    let incrementalLayer = subLayers.get(group._uid);
    incrementalLayer || (incrementalLayer = {
      layer: this.layerService.createLayer(stage),
      zIndex: subLayers.size,
      group: group
    }, subLayers.set(group._uid, incrementalLayer));
    const incrementalContext = incrementalLayer.layer.getNativeHandler().getContext(),
      idc = incrementalLayer.drawContribution || container.get(IncrementalDrawContribution);
    idc.dirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.backupDirtyBounds.setValue(-1 / 0, -1 / 0, 1 / 0, 1 / 0), idc.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
      drawContribution: idc,
      clear: "transparent",
      layer: incrementalLayer.layer,
      context: incrementalContext,
      startAtId: group._uid,
      break: !1
    })), incrementalLayer.drawContribution = idc;
    const nextGraphic = this._findNextGraphic(group);
    if (nextGraphic) if (nextGraphic.isContainer && nextGraphic.incremental) this._increaseRender(nextGraphic, drawContext);else {
      let afterLayer = subLayers.get(nextGraphic._uid);
      afterLayer || (afterLayer = {
        layer: this.layerService.createLayer(stage),
        zIndex: subLayers.size
      }, subLayers.set(nextGraphic._uid, afterLayer));
      const afterContext = afterLayer.layer.getNativeHandler().getContext();
      this.draw(this.currentRenderService, Object.assign(Object.assign({}, drawContext), {
        drawContribution: idc,
        clear: "transparent",
        layer: afterLayer.layer,
        context: afterContext,
        startAtId: nextGraphic._uid,
        break: !1
      }));
    }
  }
  getRenderContribution(graphic) {
    let renderer;
    return renderer || (renderer = this.selectRenderByNumberType(graphic.numberType, graphic)), renderer || (renderer = this.selectRenderByType(graphic.type)), renderer;
  }
  renderItem(graphic, drawContext, params) {
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforeDrawItem && drawContribution.beforeDrawItem(graphic, this.currentRenderService, drawContext, this, params)) return;
    }
    const renderer = this.getRenderContribution(graphic);
    if (!renderer) return;
    let tempBounds,
      retrans = this.scrollMatrix && (0 !== this.scrollMatrix.e || 0 !== this.scrollMatrix.f);
    if (graphic.parent) {
      const {
        scrollX = 0,
        scrollY = 0
      } = graphic.parent.attribute;
      (scrollX || scrollY) && (retrans = !0, this.scrollMatrix || (this.scrollMatrix = matrixAllocate.allocate(1, 0, 0, 1, 0, 0)), this.scrollMatrix.translate(-scrollX, -scrollY));
    }
    if (retrans && (tempBounds = this.dirtyBounds.clone().transformWithMatrix(this.scrollMatrix)), this.useDirtyBounds && !graphic.isContainer && "empty" !== graphic.attribute.boundsMode && !isRectIntersect(graphic.AABBBounds, null != tempBounds ? tempBounds : this.dirtyBounds, !1)) {
      if (retrans && graphic.parent) {
        const {
          scrollX = 0,
          scrollY = 0
        } = graphic.parent.attribute;
        this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
      }
      return;
    }
    const skipDraw = null != drawContext.startAtId && graphic._uid !== drawContext.startAtId;
    if (graphic._uid === drawContext.startAtId && (drawContext.startAtId = null), params && (params.skipDraw = skipDraw), skipDraw ? graphic.isContainer && renderer.draw(graphic, this.currentRenderService, drawContext, params) : renderer.draw(graphic, this.currentRenderService, drawContext, params), retrans && graphic.parent) {
      const {
        scrollX = 0,
        scrollY = 0
      } = graphic.parent.attribute;
      this.scrollMatrix && this.scrollMatrix.translate(scrollX, scrollY);
    }
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.afterDrawItem && drawContribution.afterDrawItem(graphic, this.currentRenderService, drawContext, this)) return;
    }
  }
  selectRenderByType(type) {
    return Logger.getInstance().warn("未知错误，不应该走到这里"), null;
  }
  selectRenderByNumberType(type, graphic) {
    let data;
    if (graphic.attribute.renderStyle) {
      const currentRenderMap = this.styleRenderMap.get(graphic.attribute.renderStyle);
      data = currentRenderMap && currentRenderMap.get(type);
    }
    return data || this.currentRenderMap.get(type) || this.defaultRenderMap.get(type);
  }
  clearScreen(renderService, context, drawContext) {
    var _a, _b;
    const {
        clear: clear,
        viewBox: viewBox
      } = drawContext,
      width = viewBox.width(),
      height = viewBox.height();
    if (clear) {
      context.clearRect(0, 0, width, height);
      const stage = null === (_a = renderService.drawParams) || void 0 === _a ? void 0 : _a.stage;
      if (stage && (context.globalAlpha = null !== (_b = stage.attribute.opacity) && void 0 !== _b ? _b : 1), stage && stage.backgroundImg && stage.resources) {
        const res = stage.resources.get(clear);
        res && "success" === res.state && res.data && context.drawImage(res.data, 0, 0, width, height);
      } else context.fillStyle = createColor(context, clear, {
        AABBBounds: {
          x1: 0,
          y1: 0,
          x2: 0 + width,
          y2: 0 + height
        }
      }, 0, 0), context.fillRect(0, 0, width, height);
    }
  }
  afterDraw(renderService, drawParams) {}
};
DefaultDrawContribution = __decorate$1l([injectable(), __param$G(0, multiInject(GraphicRender)), __param$G(1, inject(ContributionProvider)), __param$G(1, named(DrawItemInterceptor)), __metadata$10("design:paramtypes", [Array, Object])], DefaultDrawContribution);

var __decorate$1k = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultIncrementalCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.numberType = LINE_NUMBER_TYPE;
  }
  drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb) {
    if (line.incremental && drawContext.multiGraphicOptions) {
      const {
          startAtIdx: startAtIdx,
          length: length
        } = drawContext.multiGraphicOptions,
        {
          segments = []
        } = line.attribute;
      if (startAtIdx > segments.length) return;
      const lineAttribute = getTheme(line).line,
        {
          fill = lineAttribute.fill,
          stroke = lineAttribute.stroke,
          opacity = lineAttribute.opacity,
          fillOpacity = lineAttribute.fillOpacity,
          strokeOpacity = lineAttribute.strokeOpacity,
          lineWidth = lineAttribute.lineWidth,
          visible = lineAttribute.visible
        } = line.attribute,
        fVisible = fillVisible(opacity, fillOpacity, fill),
        sVisible = strokeVisible(opacity, strokeOpacity),
        doFill = runFill(fill),
        doStroke = runStroke(stroke, lineWidth);
      if (!line.valid || !visible) return;
      if (!doFill && !doStroke) return;
      if (!(fVisible || sVisible || fillCb || strokeCb)) return;
      const {
        context: context
      } = drawContext;
      for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(line, context, segments[i - 1], segments[i], line.attribute.segments[i], [lineAttribute, line.attribute], x, y);
    } else super.drawShape(line, context, x, y, drawContext, params, fillCb, strokeCb);
  }
  drawIncreaseSegment(line, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalSegments(context.nativeContext, lastSeg, seg, {
      offsetX: offsetX,
      offsetY: offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(line, attribute, defaultAttribute), context.setStrokeStyle(line, attribute, offsetX, offsetY, defaultAttribute), context.stroke());
  }
};
DefaultIncrementalCanvasLineRender = __decorate$1k([injectable()], DefaultIncrementalCanvasLineRender);

var __decorate$1j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultIncrementalCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.numberType = AREA_NUMBER_TYPE;
  }
  drawShape(area, context, x, y, drawContext, params, fillCb) {
    if (area.incremental && drawContext.multiGraphicOptions) {
      const {
          startAtIdx: startAtIdx,
          length: length
        } = drawContext.multiGraphicOptions,
        {
          segments = []
        } = area.attribute;
      if (startAtIdx > segments.length) return;
      const areaAttribute = getTheme(area).area,
        {
          fill = areaAttribute.fill,
          fillOpacity = areaAttribute.fillOpacity,
          opacity = areaAttribute.opacity,
          visible = areaAttribute.visible
        } = area.attribute,
        fVisible = fillVisible(opacity, fillOpacity, fill),
        doFill = runFill(fill);
      if (!area.valid || !visible) return;
      if (!doFill) return;
      if (!fVisible && !fillCb) return;
      for (let i = startAtIdx; i < startAtIdx + length; i++) this.drawIncreaseSegment(area, context, segments[i - 1], segments[i], area.attribute.segments[i], [areaAttribute, area.attribute], x, y);
    } else super.drawShape(area, context, x, y, drawContext, params, fillCb);
  }
  drawIncreaseSegment(area, context, lastSeg, seg, attribute, defaultAttribute, offsetX, offsetY) {
    seg && (context.beginPath(), drawIncrementalAreaSegments(context.camera ? context : context.nativeContext, lastSeg, seg, {
      offsetX: offsetX,
      offsetY: offsetY
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(area, attribute, defaultAttribute), context.setCommonStyle(area, attribute, offsetX, offsetY, defaultAttribute), context.fill());
  }
};
DefaultIncrementalCanvasAreaRender = __decorate$1j([injectable()], DefaultIncrementalCanvasAreaRender);

var STATUS,
  __decorate$1i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$$ = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$F = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  },
  __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
!function (STATUS) {
  STATUS[STATUS.NORMAL = 0] = "NORMAL", STATUS[STATUS.STOP = 1] = "STOP";
}(STATUS || (STATUS = {}));
let DefaultIncrementalDrawContribution = class extends DefaultDrawContribution {
  constructor(contributions, lineRender, areaRender, drawItemInterceptorContributions) {
    super(contributions, drawItemInterceptorContributions), this.contributions = contributions, this.lineRender = lineRender, this.areaRender = areaRender, this.drawItemInterceptorContributions = drawItemInterceptorContributions, this.rendering = !1, this.currFrameStartAt = 0, this.currentIdx = 0, this.status = STATUS.NORMAL, this.checkingForDrawPromise = null, this.hooks = {
      completeDraw: new SyncHook([])
    }, this.defaultRenderMap.set(this.lineRender.numberType, this.lineRender), this.defaultRenderMap.set(this.areaRender.numberType, this.areaRender);
  }
  draw(renderService, drawContext) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (this.checkingForDrawPromise) return;
      this.lastRenderService = renderService, this.lastDrawContext = drawContext, this.checkingForDrawPromise = this.checkForDraw(drawContext);
      const skipDraw = yield this.checkingForDrawPromise;
      if (this.checkingForDrawPromise = null, skipDraw) return;
      this.currentRenderService = renderService;
      const {
        context: context,
        viewBox: viewBox
      } = drawContext;
      context && (context.inuse = !0, context.clearMatrix(), context.setTransformForCurrent(!0), context.save(), drawContext.restartIncremental && this.clearScreen(this.currentRenderService, context, drawContext), context.translate(viewBox.x1, viewBox.y1, !0), context.save(), renderService.renderTreeRoots.sort((a, b) => {
        var _a, _b;
        return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
      }).forEach(group => {
        this.renderGroup(group, drawContext);
      }), this.hooks.completeDraw.tap("top-draw", () => {
        context.restore(), context.restore(), context.draw(), context.inuse = !1, this.rendering = !1;
      }));
    });
  }
  _increaseRender(group, drawContext) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this.rendering = !0, yield this._renderIncrementalGroup(group, drawContext);
    });
  }
  _renderIncrementalGroup(group, drawContext) {
    return __awaiter$4(this, void 0, void 0, function* () {
      this.count = group.count, yield new Promise(resolve => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter$4(this, void 0, void 0, function* () {
            if (2 !== group.count) yield foreachAsync(group, DefaultAttribute.zIndex, (item, i) => {
              if (this.status === STATUS.STOP) return !0;
              if (item.isContainer) return !1;
              if (i < this.currentIdx) return !1;
              const frameTail = this.currFrameStartAt + group.incremental;
              return i < frameTail && (this.currentIdx = i + 1, this.renderItem(item, drawContext)), i === frameTail - 1 && (this.currFrameStartAt = this.currentIdx, this.waitToNextFrame());
            }), resolve(!1);else {
              const graphic = group.getChildAt(0);
              if (graphic.incremental && graphic.attribute.segments) for (graphic.incrementalAt || (graphic.incrementalAt = 0); graphic.incrementalAt < graphic.attribute.segments.length;) drawContext.multiGraphicOptions = {
                startAtIdx: graphic.incrementalAt,
                length: graphic.incremental
              }, this.renderItem(graphic, drawContext), graphic.incrementalAt += graphic.incremental, yield this.waitToNextFrame();else this.renderItem(graphic, drawContext);
              resolve(!1);
            }
          })
        });
      }), this.hooks.completeDraw.call();
    });
  }
  waitToNextFrame() {
    return __awaiter$4(this, void 0, void 0, function* () {
      return new Promise(resolve => {
        this.global.getRequestAnimationFrame()(() => {
          resolve(!1);
        });
      });
    });
  }
  checkForDraw(drawContext) {
    return __awaiter$4(this, void 0, void 0, function* () {
      let skip = this.rendering;
      return drawContext.restartIncremental && (skip = !1, yield this.forceStop(), this.resetToInit()), skip;
    });
  }
  forceStop() {
    return __awaiter$4(this, void 0, void 0, function* () {
      this.rendering && (this.status = STATUS.STOP, yield new Promise(resolve => {
        this.hooks.completeDraw.tap("stopCb", () => {
          this.status = STATUS.NORMAL, this.hooks.completeDraw.taps = this.hooks.completeDraw.taps.filter(item => "stopCb" !== item.name), resolve(!1);
        });
      }));
    });
  }
  resetToInit() {
    this.currFrameStartAt = 0, this.currentIdx = 0;
  }
  renderGroup(group, drawContext) {
    return __awaiter$4(this, void 0, void 0, function* () {
      if (!drawContext.break && !1 !== group.attribute.visibleAll) return group.incremental && drawContext.startAtId === group._uid ? (yield this._increaseRender(group, drawContext), void (drawContext.break = !0)) : void (yield new Promise(resolve => {
        this.renderItem(group, drawContext, {
          drawingCb: () => __awaiter$4(this, void 0, void 0, function* () {
            yield foreachAsync(group, DefaultAttribute.zIndex, item => __awaiter$4(this, void 0, void 0, function* () {
              drawContext.break || item.isContainer && (yield this.renderGroup(item, drawContext));
            })), resolve(!1);
          })
        });
      }));
    });
  }
};
DefaultIncrementalDrawContribution = __decorate$1i([injectable(), __param$F(0, multiInject(GraphicRender)), __param$F(1, inject(DefaultIncrementalCanvasLineRender)), __param$F(2, inject(DefaultIncrementalCanvasAreaRender)), __param$F(3, inject(ContributionProvider)), __param$F(3, named(DrawItemInterceptor)), __metadata$$("design:paramtypes", [Array, Object, Object, Object])], DefaultIncrementalDrawContribution);

var renderModule = new ContainerModule(bind => {
  bind(DefaultBaseBackgroundRenderContribution).toSelf().inSingletonScope(), bind(DefaultBaseTextureRenderContribution).toSelf().inSingletonScope(), bind(DrawContribution).to(DefaultDrawContribution), bind(IncrementalDrawContribution).to(DefaultIncrementalDrawContribution), bind(GroupRender).to(DefaultCanvasGroupRender).inSingletonScope(), bind(GraphicRender).toService(GroupRender), bindContributionProvider(bind, GroupRenderContribution), bind(DefaultBaseInteractiveRenderContribution).toSelf().inSingletonScope(), bindContributionProvider(bind, InteractiveSubRenderContribution), bindContributionProvider(bind, GraphicRender), bind(CommonDrawItemInterceptorContribution).toSelf().inSingletonScope(), bind(DrawItemInterceptor).toService(CommonDrawItemInterceptorContribution), bindContributionProvider(bind, DrawItemInterceptor);
});

function load(container) {
  container.load(renderModule);
}

function preLoadAllModule() {
  preLoadAllModule.__loaded || (preLoadAllModule.__loaded = !0, container.load(coreModule), container.load(graphicModule), container.load(renderModule$1), container.load(pickModule), container.load(pluginModule), load$1(container), load(container));
}
preLoadAllModule.__loaded = !1, preLoadAllModule();
const vglobal = container.get(VGlobal);
application.global = vglobal;
const graphicUtil = container.get(GraphicUtil);
application.graphicUtil = graphicUtil;
const transformUtil = container.get(TransformUtil);
application.transformUtil = transformUtil;
const graphicService = container.get(GraphicService);
application.graphicService = graphicService;
const layerService = container.get(LayerService);
application.layerService = layerService;

class AutoRenderPlugin {
  constructor() {
    this.name = "AutoRenderPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.handleChange = graphic => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === this.pluginService.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    };
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, this.handleChange), application.graphicService.hooks.onSetStage.tap(this.key, this.handleChange), application.graphicService.hooks.onRemove.tap(this.key, this.handleChange);
  }
  deactivate(context) {
    const filterByName = taps => taps.filter(item => item.name !== this.key);
    application.graphicService.hooks.onAttributeUpdate.taps = filterByName(application.graphicService.hooks.onAttributeUpdate.taps), application.graphicService.hooks.onSetStage.taps = filterByName(application.graphicService.hooks.onSetStage.taps), application.graphicService.hooks.onRemove.taps = filterByName(application.graphicService.hooks.onRemove.taps);
  }
}

class AutoRefreshPlugin {
  constructor() {
    this.name = "AutoRefreshPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.handleChange = graphic => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === this.pluginService.stage && null != graphic.stage && graphic.stage.renderNextFrame();
    };
  }
  activate(context) {
    this.pluginService = context, this.dpr = application.global.devicePixelRatio, this.refresh();
  }
  refresh() {
    this._refreshByMediaQuery() || this._refreshByRaf();
  }
  _refreshByRaf() {
    const raf = application.global.getRequestAnimationFrame();
    this.rafId = raf(() => {
      application.global.devicePixelRatio !== this.dpr && (this.dpr = application.global.devicePixelRatio, this.pluginService.stage.setDpr(this.dpr, !0)), this.refresh();
    });
  }
  _refreshByMediaQuery() {
    try {
      const mqString = `(resolution: ${window.devicePixelRatio}dppx)`,
        updatePixelRatio = () => {
          window.devicePixelRatio !== this.dpr && (this.dpr = window.devicePixelRatio, this.pluginService.stage.setDpr(this.dpr, !0));
        },
        dom = matchMedia(mqString);
      dom && dom.addEventListener("change", updatePixelRatio), this.autoRefreshCbs || (this.autoRefreshCbs = []), this.autoRefreshCbs.push(() => {
        dom && dom.removeEventListener("change", updatePixelRatio);
      });
    } catch (err) {
      return !1;
    }
    return !0;
  }
  deactivate(context) {
    var _a;
    const craf = application.global.getCancelAnimationFrame();
    craf && this.rafId && craf(this.rafId), null === (_a = this.autoRefreshCbs) || void 0 === _a || _a.forEach(cb => {
      cb();
    }), this.autoRefreshCbs = void 0;
  }
}

class IncrementalAutoRenderPlugin {
  constructor() {
    this.name = "IncrementalAutoRenderPlugin", this.activeEvent = "onRegister", this.nextFrameRenderGroupSet = new Set(), this.willNextFrameRender = !1, this.nextUserParams = {}, this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAddIncremental.tap(this.key, (graphic, group, stage) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage === context.stage && null != graphic.stage && (this.nextUserParams.startAtId = group._uid, this.renderNextFrame(group));
    }), application.graphicService.hooks.onClearIncremental.tap(this.key, (group, stage) => {
      group.stage === context.stage && null != group.stage && (this.nextUserParams.startAtId = group._uid, this.nextUserParams.restartIncremental = !0, this.renderNextFrame(group));
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAddIncremental.taps = application.graphicService.hooks.onAddIncremental.taps.filter(item => item.name !== this.key), application.graphicService.hooks.onClearIncremental.taps = application.graphicService.hooks.onClearIncremental.taps.filter(item => item.name !== this.key);
  }
  renderNextFrame(group) {
    this.nextFrameRenderGroupSet.add(group), this.willNextFrameRender || (this.willNextFrameRender = !0, application.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = !1;
    }));
  }
  _doRenderInThisFrame() {
    const stage = this.pluginService.stage;
    this.nextFrameRenderGroupSet.size && (this.nextFrameRenderGroupSet.forEach(group => {
      const layer = group.layer;
      if (!layer || !group.layer.subLayers) return;
      const subLayer = group.layer.subLayers.get(group._uid);
      subLayer && subLayer.drawContribution && subLayer.drawContribution.draw(stage.renderService, Object.assign({
        stage: stage,
        layer: layer,
        viewBox: stage.window.getViewBox(),
        transMatrix: stage.window.getViewBoxTransform(),
        clear: "transparent",
        renderService: stage.renderService,
        updateBounds: !1,
        startAtId: group._uid,
        context: subLayer.layer.getNativeHandler().getContext()
      }, this.nextUserParams));
    }), this.nextUserParams = {}, this.nextFrameRenderGroupSet.clear());
  }
}

const globalBounds = new AABBBounds();
class DirtyBoundsPlugin {
  constructor() {
    this.name = "DirtyBoundsPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid;
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, stage => {
      stage && stage === this.pluginService.stage && stage.dirtyBounds.clear();
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !graphic.shouldSelfChangeUpdateAABBBounds() || willUpdate && (globalBounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), stage.dirty(globalBounds, graphic.parent && graphic.parent.globalTransMatrix)));
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params, selfChange) => {
      stage && stage === this.pluginService.stage && stage.renderCount && (graphic.isContainer && !selfChange || stage.dirty(params.globalAABBBounds));
    }), application.graphicService.hooks.clearAABBBounds.tap(this.key, (graphic, stage, bounds) => {
      stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(bounds);
    }), application.graphicService.hooks.onRemove.tap(this.key, graphic => {
      const stage = graphic.stage;
      stage && stage === this.pluginService.stage && stage.renderCount && stage && stage.dirty(graphic.globalAABBBounds);
    });
  }
  deactivate(context) {
    application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(item => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter(item => item.name !== this.key), application.graphicService.hooks.clearAABBBounds.taps = application.graphicService.hooks.clearAABBBounds.taps.filter(item => item.name !== this.key), context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter(item => item.name !== this.key), application.graphicService.hooks.onRemove.taps = application.graphicService.hooks.onRemove.taps.filter(item => item.name !== this.key);
  }
}

const defaultTicker = new DefaultTicker();
defaultTicker.addTimeline(defaultTimeline);
defaultTicker.setFPS(60);

let _isBrowserEnv;
function initIsBrowserEnv() {
  if (null == _isBrowserEnv) try {
    const canvas = document.createElement("canvas"),
      ctx = canvas.getContext("2d");
    _isBrowserEnv = !!(window && canvas.getBoundingClientRect && requestAnimationFrame && window.devicePixelRatio && ctx && ctx.isPointInPath && ctx.isPointInStroke), _isBrowserEnv && (_isBrowserEnv = !!document.createElement);
  } catch (err) {
    _isBrowserEnv = !1;
  }
}
function isBrowserEnv() {
  initIsBrowserEnv();
  const env = application.global && application.global.env;
  return env ? "browser" === env : _isBrowserEnv;
}
function isNodeEnv() {
  initIsBrowserEnv();
  const env = application.global && application.global.env;
  return env ? "node" === env : !_isBrowserEnv;
}
function getCurrentEnv() {
  return isBrowserEnv() ? "browser" : "node";
}

class Factory {
  static registerPlugin(pluginKey, pluginClass) {
    Factory._pluginClasses[pluginKey] = pluginClass;
  }
  static getPlugin(pluginKey) {
    return Factory._pluginClasses[pluginKey];
  }
}
Factory._pluginClasses = {};

const DefaultConfig$1 = {
  WIDTH: 500,
  HEIGHT: 500,
  X: 0,
  Y: 0,
  BACKGROUND: "white"
};
class Stage extends Group {
  set viewBox(b) {
    this.window.setViewBox(b);
  }
  get viewBox() {
    return this.window.getViewBox();
  }
  get x() {
    return this.window.getViewBox().x1;
  }
  set x(x) {
    const b = this.window.getViewBox();
    b.translate(x - b.x1, 0), this.window.setViewBox(b);
  }
  get y() {
    return this.window.getViewBox().y1;
  }
  set y(y) {
    const b = this.window.getViewBox();
    b.translate(0, y - b.y1), this.window.setViewBox(b);
  }
  get width() {
    return this.window.width;
  }
  set width(w) {
    this.resize(w, this.height);
  }
  get viewWidth() {
    return this.window.getViewBox().width();
  }
  set viewWidth(w) {
    this.resizeView(w, this.viewHeight);
  }
  get viewHeight() {
    return this.window.getViewBox().height();
  }
  set viewHeight(h) {
    this.resizeView(this.viewWidth, h);
  }
  get height() {
    return this.window.height;
  }
  set height(h) {
    this.resize(this.width, h);
  }
  get dpr() {
    return this.window.dpr;
  }
  set dpr(r) {
    this.setDpr(r);
  }
  get background() {
    var _a;
    return null !== (_a = this._background) && void 0 !== _a ? _a : DefaultConfig$1.BACKGROUND;
  }
  set background(b) {
    this._background = b;
  }
  get defaultLayer() {
    return this.at(0);
  }
  get eventSystem() {
    return this._eventSystem;
  }
  constructor() {
    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _a;
    super({}), this.tickedBeforeRender = !0, this._onVisibleChange = visible => {
      if (!(this._skipRender < 0)) if (visible) {
        if (this.dirtyBounds) {
          const b = this.window.getViewBox();
          this.dirtyBounds.setValue(b.x1, b.y1, b.width(), b.height());
        }
        this._skipRender > 1 && this.renderNextFrame(), this._skipRender = 0;
      } else this._skipRender = 1;
    }, this.beforeRender = stage => {
      this._beforeRender && this._beforeRender(stage);
    }, this.afterRender = stage => {
      this.renderCount++, this._afterRender && this._afterRender(stage), this._afterNextRenderCbs && this._afterNextRenderCbs.forEach(cb => cb(stage)), this._afterNextRenderCbs = null, this.tickedBeforeRender = !1;
    }, this.afterTickCb = () => {
      var _a;
      this.tickedBeforeRender = !0, "performance" === (null === (_a = this.params.optimize) || void 0 === _a ? void 0 : _a.tickRenderMode) || "rendering" !== this.state && this.render();
    }, this.params = params, this.theme = new Theme(), this.hooks = {
      beforeRender: new SyncHook(["stage"]),
      afterRender: new SyncHook(["stage"])
    }, this.global = application.global, !this.global.env && isBrowserEnv() && this.global.setEnv("browser"), this.window = container.get(VWindow), this.renderService = container.get(RenderService), this.pluginService = container.get(PluginService), this.layerService = container.get(LayerService), this.pluginService.active(this, params), this.window.create({
      width: params.width,
      height: params.height,
      viewBox: params.viewBox,
      container: params.container,
      dpr: params.dpr || this.global.devicePixelRatio,
      canvasControled: !1 !== params.canvasControled,
      title: params.title || "",
      canvas: params.canvas
    }), this.state = "normal", this.renderCount = 0, this.tryInitEventSystem(), this._background = null !== (_a = params.background) && void 0 !== _a ? _a : DefaultConfig$1.BACKGROUND, this.appendChild(this.layerService.createLayer(this, {
      main: !0
    })), this.nextFrameRenderLayerSet = new Set(), this.willNextFrameRender = !1, this.stage = this, this.renderStyle = params.renderStyle, params.autoRender && this.enableAutoRender(), params.autoRefresh && this.enableAutoRefresh(), !1 === params.disableDirtyBounds && this.enableDirtyBounds(), params.enableHtmlAttribute && this.enableHtmlAttribute(params.enableHtmlAttribute), params.ReactDOM && this.enableReactAttribute(params.ReactDOM), params.enableLayout && this.enableLayout(), this.hooks.beforeRender.tap("constructor", this.beforeRender), this.hooks.afterRender.tap("constructor", this.afterRender), this._beforeRender = params.beforeRender, this._afterRender = params.afterRender, this.ticker = params.ticker || defaultTicker, this.supportInteractiveLayer = !1 !== params.interactiveLayer, this.timeline = new DefaultTimeline(), this.ticker.addTimeline(this.timeline), this.timeline.pause(), params.optimize || (params.optimize = {}), this.optmize(params.optimize), params.background && isString$1(this._background) && this._background.includes("/") && this.setAttributes({
      background: this._background
    }), this.ticker.on("afterTick", this.afterTickCb);
  }
  pauseRender() {
    let sr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
    this._skipRender = sr;
  }
  resumeRender() {
    this._skipRender = 0;
  }
  tryInitEventSystem() {
    this.global.supportEvent && !this._eventSystem && (this._eventSystem = new EventSystem(Object.assign({
      targetElement: this.window,
      resolution: this.window.dpr || this.global.devicePixelRatio,
      rootNode: this,
      global: this.global,
      supportsPointerEvents: this.params.supportsPointerEvents,
      supportsTouchEvents: this.params.supportsTouchEvents
    }, this.params.event)));
  }
  preventRender(prevent) {
    prevent ? this._skipRender = -1 / 0 : !1 !== this.params.optimize.skipRenderWithOutRange ? this._skipRender = this.window.isVisible() ? 0 : 1 : this._skipRender = 0;
  }
  optmize(params) {
    this.optmizeRender(params.skipRenderWithOutRange), this.params.optimize = params;
  }
  optmizeRender() {
    let skipRenderWithOutRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    skipRenderWithOutRange && (this._skipRender = this._skipRender < 0 ? this._skipRender : this.window.isVisible() ? 0 : 1, this.window.onVisibleChange(this._onVisibleChange));
  }
  getTimeline() {
    return this.timeline;
  }
  get3dOptions(options) {
    const {
      center = {
        x: this.width / 2,
        y: this.height / 2,
        z: 0,
        dx: 0,
        dy: 0,
        dz: 0
      },
      light = {},
      alpha = 0,
      beta = 0,
      camera: camera,
      fieldRatio = 1,
      fieldDepth: fieldDepth
    } = options;
    return Object.assign(Object.assign({}, options), {
      center: center,
      light: light,
      alpha: alpha,
      beta: beta,
      camera: camera,
      fieldRatio: fieldRatio,
      fieldDepth: fieldDepth
    });
  }
  set3dOptions(options) {
    var _a, _b, _d, _e, _f, _g;
    this.option3d = options;
    const options3d = this.get3dOptions(options),
      {
        light: light,
        center: center,
        camera: camera,
        alpha: alpha,
        beta: beta,
        fieldRatio: fieldRatio,
        fieldDepth: fieldDepth
      } = options3d,
      {
        dir = [1, 1, -1],
        color = "white",
        ambient: ambient
      } = light,
      centerX = (null !== (_a = center.x) && void 0 !== _a ? _a : this.width / 2) + (null !== (_b = center.dx) && void 0 !== _b ? _b : 0),
      centerY = (null !== (_d = center.y) && void 0 !== _d ? _d : this.height / 2) + (null !== (_e = center.dy) && void 0 !== _e ? _e : 0),
      centerVec3 = [centerX, centerY, (null !== (_f = center.z) && void 0 !== _f ? _f : 0) + (null !== (_g = center.dz) && void 0 !== _g ? _g : 0)];
    let cameraX = 0,
      cameraY = 0,
      cameraZ = 0;
    camera || (cameraX = Math.sin(alpha) + centerX, cameraY = Math.sin(beta) + centerY, cameraZ = Math.cos(alpha) * Math.cos(beta) * 1);
    const DirectionalLight = Factory.getPlugin("DirectionalLight");
    DirectionalLight && (this.light = new DirectionalLight(dir, color, ambient));
    const cameraParams = {
      left: 0,
      right: this.width,
      top: 0,
      bottom: this.height,
      fieldRatio: fieldRatio,
      fieldDepth: fieldDepth,
      viewParams: {
        pos: [cameraX, cameraY, cameraZ],
        center: centerVec3,
        up: [0, 1, 0]
      }
    };
    if (this.camera) this.camera.params = cameraParams;else {
      const OrthoCamera = Factory.getPlugin("OrthoCamera");
      OrthoCamera && (this.camera = new OrthoCamera(cameraParams));
    }
    options.enableView3dTransform && this.enableView3dTransform();
  }
  setBeforeRender(cb) {
    this._beforeRender = cb;
  }
  setAfterRender(cb) {
    this._afterRender = cb;
  }
  afterNextRender(cb) {
    this._afterNextRenderCbs || (this._afterNextRenderCbs = []), this._afterNextRenderCbs.push(cb);
  }
  enableView3dTransform() {
    if (this.view3dTranform) return;
    this.view3dTranform = !0;
    const ViewTransform3dPlugin = Factory.getPlugin("ViewTransform3dPlugin");
    ViewTransform3dPlugin && this.pluginService.register(new ViewTransform3dPlugin());
  }
  disableView3dTranform() {
    this.view3dTranform && (this.view3dTranform = !1, this.pluginService.findPluginsByName("ViewTransform3dPlugin").forEach(plugin => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableAutoRender() {
    this.autoRender || (this.autoRender = !0, this.pluginService.register(new AutoRenderPlugin()));
  }
  disableAutoRender() {
    this.autoRender && (this.autoRender = !1, this.pluginService.findPluginsByName("AutoRenderPlugin").forEach(plugin => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableAutoRefresh() {
    this.autoRefresh || (this.autoRefresh = !0, this.pluginService.register(new AutoRefreshPlugin()));
  }
  disableAutoRefresh() {
    this.autoRefresh && (this.autoRefresh = !1, this.pluginService.findPluginsByName("AutoRefreshPlugin").forEach(plugin => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableIncrementalAutoRender() {
    this.increaseAutoRender || (this.increaseAutoRender = !0, this.pluginService.register(new IncrementalAutoRenderPlugin()));
  }
  disableIncrementalAutoRender() {
    this.increaseAutoRender && (this.increaseAutoRender = !1, this.pluginService.findPluginsByName("IncrementalAutoRenderPlugin").forEach(plugin => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableDirtyBounds() {
    if (this.dirtyBounds) return;
    this.dirtyBounds = new Bounds();
    let plugin = this.pluginService.findPluginsByName("DirtyBoundsPlugin")[0];
    plugin ? plugin.activate(this.pluginService) : (plugin = new DirtyBoundsPlugin(), this.pluginService.register(plugin));
  }
  disableDirtyBounds() {
    this.dirtyBounds && (this.dirtyBounds = null, this.pluginService.findPluginsByName("DirtyBoundsPlugin").forEach(plugin => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableLayout() {
    if (this._enableLayout) return;
    this._enableLayout = !0;
    const FlexLayoutPlugin = Factory.getPlugin("FlexLayoutPlugin");
    FlexLayoutPlugin && this.pluginService.register(new FlexLayoutPlugin());
  }
  disableLayout() {
    this._enableLayout && (this._enableLayout = !1, this.pluginService.findPluginsByName("FlexLayoutPlugin").forEach(plugin => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableHtmlAttribute(container) {
    if (this.htmlAttribute) return;
    const HtmlAttributePlugin = Factory.getPlugin("HtmlAttributePlugin");
    HtmlAttributePlugin && (this.htmlAttribute = container, this.pluginService.register(new HtmlAttributePlugin()));
  }
  disableHtmlAttribute() {
    this.htmlAttribute && (this.htmlAttribute = !1, this.pluginService.findPluginsByName("HtmlAttributePlugin").forEach(plugin => {
      this.pluginService.unRegister(plugin);
    }));
  }
  enableReactAttribute(container) {
    if (this.reactAttribute) return;
    const ReactAttributePlugin = Factory.getPlugin("ReactAttributePlugin");
    ReactAttributePlugin && (this.reactAttribute = container, this.pluginService.register(new ReactAttributePlugin()));
  }
  disableReactAttribute() {
    this.reactAttribute && (this.reactAttribute = !1, this.pluginService.findPluginsByName("ReactAttributePlugin").forEach(plugin => {
      this.pluginService.unRegister(plugin);
    }));
  }
  getPluginsByName(name) {
    return this.pluginService.findPluginsByName(name);
  }
  tryUpdateAABBBounds() {
    const viewBox = this.window.getViewBox();
    return this._AABBBounds.setValue(viewBox.x1, viewBox.y1, viewBox.x2, viewBox.y2), this._AABBBounds;
  }
  combineLayer(ILayer1, ILayer2) {
    throw new Error("暂不支持");
  }
  createLayer(canvasId, layerMode) {
    if ("released" === this.releaseStatus) return;
    const layer = this.layerService.createLayer(this, {
      main: !1,
      layerMode: layerMode,
      canvasId: canvasId
    });
    return this.appendChild(layer), layer;
  }
  sortLayer(cb) {
    const children = this.children;
    children.sort(cb), this.removeAllChild(), children.forEach(c => {
      this.appendChild(c);
    });
  }
  removeLayer(ILayerId) {
    return this.removeChild(this.findChildByUid(ILayerId));
  }
  tryInitInteractiveLayer() {
    "released" !== this.releaseStatus && this.supportInteractiveLayer && !this.interactiveLayer && (this.interactiveLayer = this.createLayer(), this.interactiveLayer.name = "_builtin_interactive", this.interactiveLayer.attribute.pickable = !1, this.nextFrameRenderLayerSet.add(this.interactiveLayer));
  }
  clearViewBox(color) {
    this.window.clearViewBox(color);
  }
  render(layers, params) {
    if ("released" === this.releaseStatus) return;
    this.ticker.start(), this.timeline.resume();
    const state = this.state;
    this.state = "rendering", this.tickedBeforeRender || this.ticker.trySyncTickStatus(), this.layerService.prepareStageLayer(this), this._skipRender || (this.lastRenderparams = params, this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(this.children), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  combineLayersToWindow() {
    if ("harmony" === this.global.env) {
      const ctx = this.window.getContext().nativeContext;
      this.forEachChildren((layer, i) => {
        if (i > 0) {
          const image = layer.getNativeHandler().getContext().canvas.nativeCanvas.nativeCanvas._c.transferToImageBitmap();
          ctx.transferFromImageBitmap(image);
        }
      });
    }
  }
  renderNextFrame(layers, force) {
    this.nextFrameRenderLayerSet.size !== this.childrenCount && (layers || this).forEach(layer => {
      this.nextFrameRenderLayerSet.add(layer);
    }), this.willNextFrameRender || (this.willNextFrameRender = !0, this.global.getRequestAnimationFrame()(() => {
      this._doRenderInThisFrame(), this.willNextFrameRender = !1;
    }));
  }
  _doRenderInThisFrame() {
    if ("released" === this.releaseStatus) return;
    this.timeline.resume(), this.ticker.start();
    const state = this.state;
    this.state = "rendering", this.layerService.prepareStageLayer(this), this.nextFrameRenderLayerSet.size && !this._skipRender && (this.hooks.beforeRender.call(this), this._skipRender || (this.renderLayerList(Array.from(this.nextFrameRenderLayerSet.values()), this.lastRenderparams || {}), this.combineLayersToWindow(), this.nextFrameRenderLayerSet.clear()), this.hooks.afterRender.call(this)), this.state = state, this._skipRender && this._skipRender++;
  }
  renderLayerList(layerList, params) {
    const list = [];
    for (let i = 0; i < layerList.length; i++) {
      let l = layerList[i];
      "virtual" === l.layerMode && (l = l.getNativeHandler().mainHandler.layer), list.includes(l) || list.push(l);
    }
    list.forEach(layer => {
      layer.renderCount > this.renderCount || (layer.renderCount = this.renderCount + 1, layer === this.interactiveLayer && this.dirtyBounds && this.dirtyBounds.clear(), layer.render({
        renderService: this.renderService,
        background: layer === this.defaultLayer ? this.background : void 0,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
        viewBox: this.window.getViewBox(),
        transMatrix: this.window.getViewBoxTransform()
      }, Object.assign({
        renderStyle: this.renderStyle
      }, params)));
    }), this.interactiveLayer && !layerList.includes(this.interactiveLayer) && (this.dirtyBounds && this.dirtyBounds.clear(), this.interactiveLayer.render({
      renderService: this.renderService,
      updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty()),
      viewBox: this.window.getViewBox(),
      transMatrix: this.window.getViewBoxTransform()
    }, Object.assign({
      renderStyle: this.renderStyle
    }, params)));
  }
  resizeWindow(w, h) {
    let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    this.window.resize(w, h), rerender && this.render();
  }
  resize(w, h) {
    let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    "released" !== this.releaseStatus && (this.window.hasSubView() || this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.window.resize(w, h), this.forEachChildren(c => {
      c.resize(w, h);
    }), this.camera && this.option3d && this.set3dOptions(this.option3d), rerender && this.render());
  }
  resizeView(w, h) {
    let rerender = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    "released" !== this.releaseStatus && (this.viewBox.setValue(this.viewBox.x1, this.viewBox.y1, this.viewBox.x1 + w, this.viewBox.y1 + h), this.forEachChildren(c => {
      c.resizeView(w, h);
    }), this.camera && (this.camera.params = Object.assign(Object.assign({}, this.camera.params), {
      right: this.width,
      bottom: this.height
    })), rerender && this.render());
  }
  setViewBox(x, y, w, h, rerender) {
    let isRerender = !0;
    "object" == typeof x ? (this.viewBox.setValue(x.x1, x.y1, x.x2, x.y2), !1 === y && (isRerender = !1)) : (this.viewBox.setValue(x, y, x + w, y + h), !1 === rerender && (isRerender = !1)), this.forEachChildren(c => {
      c.resizeView(this.viewBox.width(), this.viewBox.height());
    }), isRerender && this.render();
  }
  setDpr(dpr) {
    let rerender = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    this.forEachChildren(c => {
      c.setDpr(dpr);
    }), rerender && this.render();
  }
  setOrigin(x, y) {
    throw new Error("暂不支持");
  }
  export(type) {
    throw new Error("暂不支持");
  }
  pick(x, y) {
    if ("released" === this.releaseStatus) return;
    const result = this.getPickerService().pick(this.children, new Point(x, y), {
      bounds: this.AABBBounds
    });
    return !(!(null == result ? void 0 : result.graphic) && !(null == result ? void 0 : result.group)) && result;
  }
  startAnimate(t) {
    throw new Error("暂不支持");
  }
  setToFrame(t) {
    throw new Error("暂不支持");
  }
  release() {
    super.release(), this.hooks.beforeRender.unTap("constructor", this.beforeRender), this.hooks.afterRender.unTap("constructor", this.afterRender), this.eventSystem && this.eventSystem.release(), this.layerService.releaseStage(this), this.pluginService.release(), this.forEach(layer => {
      layer.release();
    }), this.interactiveLayer && (this.interactiveLayer.forEachChildren(item => {
      item.setStage && item.setStage(null, null), this.interactiveLayer.removeChild(item);
    }), this.interactiveLayer.release()), this.window.release(), this.ticker.remTimeline(this.timeline), this.ticker.removeListener("afterTick", this.afterTickCb), this.renderService.renderTreeRoots = [];
  }
  setStage(stage) {}
  dirty(b, matrix) {
    "released" !== this.releaseStatus && (matrix && b.transformWithMatrix(matrix), this.dirtyBounds.empty() && this.dirtyBounds.setValue(b.x1, b.y1, b.x2, b.y2), this.dirtyBounds.union(b));
  }
  getLayer(name) {
    return this.children.filter(layer => layer.name === name)[0];
  }
  renderTo(window) {
    "released" !== this.releaseStatus && this.forEachChildren((layer, i) => {
      layer.drawTo(window, {
        renderService: this.renderService,
        viewBox: window.getViewBox(),
        transMatrix: window.getViewBoxTransform(),
        background: layer === this.defaultLayer ? this.background : void 0,
        clear: 0 === i,
        updateBounds: !(!this.dirtyBounds || this.dirtyBounds.empty())
      });
    });
  }
  renderToNewWindow() {
    let viewBox = arguments.length > 1 ? arguments[1] : undefined;
    if ("released" === this.releaseStatus) return;
    const window = container.get(VWindow),
      x1 = viewBox ? -viewBox.x1 : 0,
      y1 = viewBox ? -viewBox.y1 : 0,
      x2 = viewBox ? viewBox.x2 : this.viewWidth,
      y2 = viewBox ? viewBox.y2 : this.viewHeight,
      width = viewBox ? viewBox.width() : this.viewWidth,
      height = viewBox ? viewBox.height() : this.viewHeight;
    return window.create({
      viewBox: {
        x1: x1,
        y1: y1,
        x2: x2,
        y2: y2
      },
      width: width,
      height: height,
      dpr: this.window.dpr,
      canvasControled: !0,
      offscreen: !0,
      title: ""
    }), this.renderTo(window), window;
  }
  toCanvas() {
    let fullImage = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    let viewBox = arguments.length > 1 ? arguments[1] : undefined;
    if ("released" === this.releaseStatus) return;
    const c = this.renderToNewWindow(fullImage, viewBox).getNativeHandler();
    return c.nativeCanvas ? c.nativeCanvas : null;
  }
  setCursor(mode) {
    this._cursor = mode, this.eventSystem.setCursor(mode, "ignore");
  }
  getCursor() {
    return this._cursor;
  }
  eventPointTransform(e) {
    const point = this.global.mapToCanvasPoint(e, this.window.getContext().canvas.nativeCanvas);
    return this.stage.window.pointTransform(point.x, point.y);
  }
  pauseTriggerEvent() {
    this._eventSystem && this._eventSystem.pauseTriggerEvent();
  }
  resumeTriggerEvent() {
    this._eventSystem && this._eventSystem.resumeTriggerEvent();
  }
  getPickerService() {
    return this.pickerService || (this.pickerService = container.get(PickerService)), this.pickerService;
  }
}

function createStage(params) {
  return new Stage(params);
}

var __decorate$1h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$_ = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
const initMatrix = new Matrix(1, 0, 0, 1, 0, 0),
  globalPoint = {
    x: 0,
    y: 0
  };
let EmptyContext2d = class {
  get nativeContext() {
    return this.path;
  }
  constructor(canvas, dpr) {
    this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.path = new CustomPath2D(), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    throw new Error("不支持getCanvas");
  }
  getContext() {
    throw new Error("不支持getContext");
  }
  setTransformForCurrent() {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix = this.cloneMatrix(this.matrix));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m) {
    return matrixAllocate.allocateByObj(m);
  }
  clear() {
    this.save(), this.resetTransform(), this.restore();
  }
  restore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent());
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad) {
    let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy) {
    let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy) {
    let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py) {
    let setTransform = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;
    this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), setTransform && this.setTransformForCurrent();
  }
  setTransform(a, b, c, d, e, f) {
    let setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
    let dpr = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.dpr;
    this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix) {
    let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    let dpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dpr;
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform() {
    let setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    let dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a, b, c, d, e, f) {
    let setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
    this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y) {
    let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg) {
    let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y) {
    let setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
    this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y) {
    let setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
    this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.path.clear();
  }
  clip(path, fillRule) {}
  arc(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  }
  arcTo(x1, y1, x2, y2, radiusX) {
    this.path.arcTo(x1, y1, x2, y2, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.path.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.path.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {}
  lineTo(x, y) {
    this.path.lineTo(x, y);
  }
  moveTo(x, y) {
    this.path.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y) {
    this.path.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h) {
    this.path.rect(x, y, w, h);
  }
  createImageData(imageDataOrSw, sh) {
    return null;
  }
  createLinearGradient(x0, y0, x1, y1) {
    throw new Error("不支持createLinearGradient");
  }
  createPattern(image, repetition) {
    throw new Error("不支持createPattern");
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    throw new Error("不支持createRadialGradient");
  }
  createConicGradient(x, y, startAngle, endAngle) {
    return null;
  }
  fill(path, fillRule) {}
  fillRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  clearRect(x, y, w, h) {}
  fillText(text, x, y) {}
  getImageData(sx, sy, sw, sh) {
    return null;
  }
  getLineDash() {
    return [];
  }
  isPointInPath(x, y) {
    return this.matrix.transformPoint({
      x: x,
      y: y
    }, globalPoint), contain(this.path.commandList, globalPoint.x, globalPoint.y);
  }
  isPointInStroke(x, y) {
    if (!this.lineWidth) return !1;
    this.matrix.transformPoint({
      x: x,
      y: y
    }, globalPoint);
    const lineWidth = getScaledStroke(this, this.lineWidth, this.dpr);
    return containStroke(this.path.commandList, lineWidth, globalPoint.x, globalPoint.y);
  }
  measureText(text) {
    throw new Error("不支持measureText");
  }
  putImageData(imagedata, dx, dy) {
    throw new Error("不支持measureText");
  }
  setLineDash(segments) {}
  stroke(path) {}
  strokeRect(x, y, width, height) {
    this.path.rect(x, y, width, height);
  }
  strokeText(text, x, y) {}
  drawImage() {}
  setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {}
  _setCommonStyle(params, offsetX, offsetY, defaultParams) {}
  setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {}
  _setStrokeStyle(params, offsetX, offsetY, defaultParams) {}
  setTextStyleWithoutAlignBaseline(params, defaultParams) {}
  setTextStyle(params, defaultParams) {}
  draw() {}
  clearMatrix() {
    let setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    let dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
    this.setTransformFromMatrix(initMatrix, setTransform, dpr);
  }
  setClearMatrix(a, b, c, d, e, f) {
    this._clearMatrix.setValue(a, b, c, d, e, f);
  }
  onlyTranslate() {
    let dpr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dpr;
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release() {
    this.stack.forEach(m => matrixAllocate.free(m)), this.stack.length = 0;
  }
};
EmptyContext2d = __decorate$1h([injectable(), __metadata$_("design:paramtypes", [Object, Number])], EmptyContext2d);

const DefaultConfig = {
  WIDTH: 500,
  HEIGHT: 500,
  DPR: 1
};
class BaseCanvas {
  get displayWidth() {
    return this._pixelWidth / this._dpr;
  }
  get displayHeight() {
    return this._pixelHeight / this._dpr;
  }
  get id() {
    return this._id;
  }
  get x() {
    return this._x;
  }
  set x(_x) {
    this._x = _x;
  }
  get y() {
    return this._y;
  }
  set y(_y) {
    this._y = _y;
  }
  get nativeCanvas() {
    return this._nativeCanvas;
  }
  set nativeCanvas(nativeCanvas) {
    this._nativeCanvas = nativeCanvas;
  }
  get width() {
    return this._pixelWidth;
  }
  set width(width) {
    this._pixelWidth = width, this._displayWidth = width / (this._dpr || 1);
  }
  get height() {
    return this._pixelHeight;
  }
  set height(height) {
    this._pixelHeight = height, this._displayHeight = height / (this._dpr || 1);
  }
  getContext(str) {
    return this._context;
  }
  get visiable() {
    return this._visiable;
  }
  set visiable(visiable) {
    this._visiable = visiable, visiable ? this.show() : this.hide();
  }
  get dpr() {
    return this._dpr;
  }
  set dpr(dpr) {
    this._dpr = dpr, this.resize(this._displayWidth, this._displayHeight);
  }
  constructor(params) {
    var _a;
    const {
      nativeCanvas: nativeCanvas,
      width = DefaultConfig.WIDTH,
      height = DefaultConfig.HEIGHT,
      dpr = DefaultConfig.DPR,
      x: x,
      y: y,
      id: id,
      canvasControled = !0
    } = params;
    this._x = null != x ? x : 0, this._y = null != y ? y : 0, this._pixelWidth = width * dpr, this._pixelHeight = height * dpr, this._visiable = !1 !== params.visiable, this.controled = canvasControled, this._displayWidth = width, this._displayHeight = height, this._dpr = dpr, this._nativeCanvas = nativeCanvas, this._id = null !== (_a = nativeCanvas.id) && void 0 !== _a ? _a : id, id && (nativeCanvas.id = id), this.init(params);
  }
  getNativeCanvas() {
    return this._nativeCanvas;
  }
  hide() {}
  show() {}
  applyPosition() {}
  resetStyle(params) {}
  resize(width, height) {}
  toDataURL(mimeType, quality) {
    return "";
  }
  readPixels(x, y, w, h) {
    return this._context.getImageData(x, y, w, h);
  }
  convertToBlob(options) {
    throw new Error("暂未实现");
  }
  transferToImageBitmap() {
    throw new Error("暂未实现");
  }
  release() {
    this.controled && this._nativeCanvas.parentElement && this._nativeCanvas.parentElement.removeChild(this._nativeCanvas);
  }
}
BaseCanvas.env = "browser";

var __decorate$1g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
let BaseEnvContribution = class {
  configure(service) {
    service.env === this.type && service.setActiveEnvContribution(this);
  }
  getNativeAABBBounds(dom) {
    return new AABBBounds();
  }
  removeDom(dom) {
    return !1;
  }
  createDom(params) {
    return null;
  }
  updateDom(dom, params) {
    return !1;
  }
  getDynamicCanvasCount() {
    return 999;
  }
  getStaticCanvasCount() {
    return 999;
  }
  getElementById(str) {
    return document.getElementById(str);
  }
  getRootElement() {
    return document.body;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then(data => data.json());
    return jsonPromise.then(json => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then(data => data.arrayBuffer()).then(arrayBuffer => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadBlob(url) {
    return fetch(url).then(data => data.blob()).then(blob => ({
      data: blob,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  getElementTop(dom, baseWindow) {
    return 0;
  }
  getElementLeft(dom, baseWindow) {
    return 0;
  }
  getElementTopLeft(dom, baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
  loadFont(font, source, descriptors) {
    return __awaiter$3(this, void 0, void 0, function* () {
      return {
        loadState: "fail"
      };
    });
  }
  isMacOS() {
    return !1;
  }
  copyToClipBoard(text) {
    return Promise.resolve(null);
  }
};
BaseEnvContribution = __decorate$1g([injectable()], BaseEnvContribution);

var __decorate$1f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$Z = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let BaseWindowHandlerContribution = class {
  constructor() {
    this._uid = Generator.GenAutoIncrementId(), this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  onChange(cb) {
    this._onChangeCb = cb;
  }
  configure(window, global) {
    global.env === this.type && window.setWindowHandler(this);
  }
  release() {
    this.releaseWindow();
  }
  isVisible(bbox) {
    return !0;
  }
  onVisibleChange(cb) {}
  getTopLeft(baseWindow) {
    return {
      top: 0,
      left: 0
    };
  }
  setViewBox(vb) {
    this.viewBox.setValue(vb.x1, vb.y1, vb.x2, vb.y2);
  }
  getViewBox() {
    return this.viewBox;
  }
  setViewBoxTransform(a, b, c, d, e, f) {
    this.modelMatrix.setValue(a, b, c, d, e, f);
  }
  getViewBoxTransform() {
    return this.modelMatrix;
  }
};
BaseWindowHandlerContribution = __decorate$1f([injectable(), __metadata$Z("design:paramtypes", [])], BaseWindowHandlerContribution);

class DirectionalLight {
  constructor(dir, color) {
    let ambient = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .8;
    this.dir = dir, this.color = color, this.colorRgb = ColorStore.Get(color, ColorType.Color1), this.ambient = ambient;
    const length = sqrt(dir[0] * dir[0] + dir[1] * dir[1] + dir[2] * dir[2]);
    this.formatedDir = [dir[0] / length, dir[1] / length, dir[2] / length];
  }
  computeColor(normal, color) {
    const lightDir = this.formatedDir,
      brightness = min(max((normal[0] * lightDir[0] + normal[1] * lightDir[1] + normal[2] * lightDir[2]) * (1 - this.ambient / 2), 0) + this.ambient, 1);
    let colorArray;
    colorArray = isString$1(color) ? ColorStore.Get(color, ColorType.Color1) : color;
    const lightColorArray = this.colorRgb;
    return `rgb(${lightColorArray[0] * colorArray[0] * brightness}, ${lightColorArray[1] * colorArray[1] * brightness}, ${lightColorArray[2] * colorArray[2] * brightness})`;
  }
}
const registerDirectionalLight = () => {
  Factory.registerPlugin("DirectionalLight", DirectionalLight);
};

class OrthoCamera {
  set params(params) {
    this._params = Object.assign({}, params), this._projectionMatrixCached = this.forceGetProjectionMatrix(), this._viewMatrixCached = this.forceGetViewMatrix();
  }
  get params() {
    return Object.assign({}, this._params);
  }
  constructor(params) {
    this.params = params;
  }
  getViewMatrix() {
    return this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate()), this._viewMatrixCached;
  }
  forceGetViewMatrix() {
    this._viewMatrixCached || (this._viewMatrixCached = mat4Allocate.allocate());
    const {
      pos: pos,
      center: center,
      up: up
    } = this.params.viewParams;
    return lookAt(this._viewMatrixCached, pos, center, up), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._viewMatrixCached;
  }
  getProjectionMatrix() {
    return this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate()), this._projectionMatrixCached;
  }
  forceGetProjectionMatrix() {
    this._projectionMatrixCached || (this._projectionMatrixCached = mat4Allocate.allocate());
    const {
      left: left,
      top: top,
      right: right,
      bottom: bottom
    } = this._params;
    return ortho(this._projectionMatrixCached, left, right, bottom, top, 0, -2e6), this._vp || (this._vp = mat4Allocate.allocate()), this._vp = multiplyMat4Mat4(this._vp, this.getProjectionMatrix(), this.getViewMatrix()), this._projectionMatrixCached;
  }
  getField() {
    const {
      fieldRatio = .8,
      fieldDepth: fieldDepth,
      left: left,
      right: right
    } = this._params;
    return (null != fieldDepth ? fieldDepth : right - left) * fieldRatio;
  }
  getProjectionScale(z) {
    const field = this.getField();
    return field / (field + z);
  }
  view(x, y, z) {
    const outP = [0, 0, 0];
    return transformMat4(outP, [x, y, z], this._viewMatrixCached), outP;
  }
  vp(x, y, z) {
    const outP = [0, 0, 0],
      {
        pos: pos
      } = this._params.viewParams;
    transformMat4(outP, [x, y, z], this._viewMatrixCached), x = outP[0], y = outP[1], z = outP[2];
    const sizeProjection = this.getProjectionScale(z);
    return {
      x: x * sizeProjection + pos[0],
      y: y * sizeProjection + pos[1]
    };
  }
}
const registerOrthoCamera = () => {
  Factory.registerPlugin("OrthoCamera", OrthoCamera);
};

var __decorate$1e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$Y = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$E = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultPickService = class {
  constructor(pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.type = "default", this.global = application.global;
  }
  _init() {
    this.InterceptorContributions = this.pickItemInterceptorContributions.getContributions().sort((a, b) => a.order - b.order), this.pickerServiceInterceptorContributions = this.pickServiceInterceptorContributions.getContributions().sort((a, b) => a.order - b.order);
  }
  pick(graphics, point, params) {
    let result = {
      graphic: null,
      group: null
    };
    params.pickerService = this;
    const w = params.bounds.width(),
      h = params.bounds.height();
    if (!new AABBBounds().setValue(0, 0, w, h).containsPoint(point)) return result;
    this.pickContext && (this.pickContext.inuse = !0), params.pickContext = this.pickContext, this.pickContext && this.pickContext.clearMatrix(!0, 1);
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i = graphics.length - 1; i >= 0 && (result = graphics[i].isContainer ? this.pickGroup(graphics[i], point, parentMatrix, params) : this.pickItem(graphics[i], point, parentMatrix, params), !result.graphic); i--) group || (group = result.group);
    if (result.graphic || (result.group = group), this.pickContext && (this.pickContext.inuse = !1), this.pickerServiceInterceptorContributions.length) for (let i = 0; i < this.pickerServiceInterceptorContributions.length; i++) {
      const drawContribution = this.pickerServiceInterceptorContributions[i];
      drawContribution.afterPickItem && (result = drawContribution.afterPickItem(result, this, point, params, {
        parentMatrix: parentMatrix
      }));
    }
    return result;
  }
  containsPoint(graphic, point, params) {
    var _a;
    return !!(null === (_a = this.pickItem(graphic, point, null, null != params ? params : {
      pickContext: this.pickContext,
      pickerService: this
    })) || void 0 === _a ? void 0 : _a.graphic);
  }
  pickGroup(group, point, parentMatrix, params) {
    let result = {
      group: null,
      graphic: null
    };
    if (!1 === group.attribute.visibleAll) return result;
    const context = params.pickContext,
      lastMatrix = context.modelMatrix;
    if (context.camera) {
      const m = group.transMatrix,
        matrix = mat4Allocate.allocate();
      if (mat3Tomat4(matrix, m), lastMatrix) {
        if (matrix) {
          const m = mat4Allocate.allocate();
          context.modelMatrix = multiplyMat4Mat4(m, lastMatrix, matrix), mat4Allocate.free(matrix);
        }
      } else mat3Tomat4(matrix, group.globalTransMatrix), context.modelMatrix = matrix;
    }
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforePickItem) {
        const result = drawContribution.beforePickItem(group, this, point, params, {
          parentMatrix: parentMatrix
        });
        if (result) return context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result;
      }
    }
    const transMatrix = group.transMatrix,
      currentGroupMatrix = matrixAllocate.allocateByObj(parentMatrix),
      newPoint = new Point(point.x, point.y);
    currentGroupMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup && !group.stage.camera) return result;
    const pickedItem = this.pickItem(group, newPoint.clone(), parentMatrix, params);
    pickedItem && pickedItem.graphic && (result.graphic = pickedItem.graphic, result.params = pickedItem.params);
    const groupPicked = !1 !== group.attribute.pickable && insideGroup;
    return currentGroupMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), !1 === group.attribute.childrenPickable || pickedItem && pickedItem.graphic || foreach(group, DefaultAttribute.zIndex, graphic => {
      if (graphic.isContainer) {
        const newPoint = new Point(point.x, point.y),
          theme = getTheme(group).group,
          {
            scrollX = theme.scrollX,
            scrollY = theme.scrollY
          } = group.attribute;
        newPoint.x -= scrollX, newPoint.y -= scrollY, result = this.pickGroup(graphic, newPoint, currentGroupMatrix, params);
      } else {
        const newPoint = new Point(point.x, point.y);
        currentGroupMatrix.transformPoint(newPoint, newPoint);
        const theme = getTheme(group).group,
          {
            scrollX = theme.scrollX,
            scrollY = theme.scrollY
          } = group.attribute;
        newPoint.x -= scrollX, newPoint.y -= scrollY;
        const pickedItem = this.pickItem(graphic, newPoint, parentMatrix, params);
        pickedItem && pickedItem.graphic && (result.graphic = pickedItem.graphic, result.params = pickedItem.params);
      }
      return !!result.graphic || !!result.group;
    }, !0, !!context.camera), context.modelMatrix !== lastMatrix && mat4Allocate.free(context.modelMatrix), context.modelMatrix = lastMatrix, result.graphic || result.group || !groupPicked || group.stage.camera || (result.group = group), matrixAllocate.free(currentGroupMatrix), result;
  }
  selectPicker(graphic) {
    const picker = this.pickerMap.get(graphic.numberType);
    return picker || null;
  }
};
DefaultPickService = __decorate$1e([injectable(), __param$E(0, inject(ContributionProvider)), __param$E(0, named(PickItemInterceptor)), __param$E(1, inject(ContributionProvider)), __param$E(1, named(PickServiceInterceptor)), __metadata$Y("design:paramtypes", [Object, Object])], DefaultPickService);

var __decorate$1d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$X = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let DefaultGlobalPickerService = class {
  constructor() {
    this.global = application.global, this.global.hooks.onSetEnv.tap("global-picker-service", (lastEnv, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env);
  }
  configure(global, env) {}
  pick(graphics, point, params) {
    let result = {
      graphic: null,
      group: null
    };
    const parentMatrix = new Matrix(1, 0, 0, 1, 0, 0);
    let group;
    for (let i = 0; i < graphics.length; i++) {
      if (graphics[i].isContainer) result = this.pickGroup(graphics[i], point, parentMatrix, params);else {
        const data = this.pickItem(graphics[i], point, parentMatrix, params);
        data && (result.graphic = data.graphic, result.params = data.params);
      }
      if (result.graphic) break;
      group || (group = result.group);
    }
    if (result.graphic || (result.group = group), result.graphic) {
      let g = result.graphic;
      for (; g.parent;) g = g.parent;
      g.shadowHost && (result.params = {
        shadowTarget: result.graphic
      }, result.graphic = g.shadowHost);
    }
    return result;
  }
  containsPoint(graphic, point, params) {
    return !!this.pickItem(graphic, point, null, params);
  }
  pickGroup(group, point, parentMatrix, params) {
    let result = {
      group: null,
      graphic: null
    };
    if (!1 === group.attribute.visibleAll) return result;
    const transMatrix = group.transMatrix,
      newPoint = new Point(point.x, point.y);
    parentMatrix.transformPoint(newPoint, newPoint);
    const insideGroup = group.AABBBounds.containsPoint(newPoint);
    if (!insideGroup) return result;
    const groupPicked = !1 !== group.attribute.pickable && insideGroup;
    return parentMatrix.multiply(transMatrix.a, transMatrix.b, transMatrix.c, transMatrix.d, transMatrix.e, transMatrix.f), !1 !== group.attribute.childrenPickable && group.forEachChildren(graphic => {
      if (graphic.isContainer) result = this.pickGroup(graphic, point, parentMatrix, params);else {
        const newPoint = new Point(point.x, point.y);
        parentMatrix.transformPoint(newPoint, newPoint);
        const data = this.pickItem(graphic, newPoint, parentMatrix, params);
        data && (result.graphic = data.graphic, result.params = data.params);
      }
      return !!result.graphic || !!result.group;
    }), result.graphic || result.group || !groupPicked || (result.group = group), result;
  }
  pickItem(graphic, point, parentMatrix, params) {
    return !1 === graphic.attribute.pickable ? null : graphic.AABBBounds.containsPoint(point) ? {
      graphic: graphic
    } : null;
  }
};
DefaultGlobalPickerService = __decorate$1d([injectable(), __metadata$X("design:paramtypes", [])], DefaultGlobalPickerService);

function simplifyRadialDist(points, sqTolerance) {
  let deltaX,
    deltaY,
    lastX = points[0].x,
    lastY = points[0].y;
  const newPoints = [points[0]];
  for (let i = 1, len = points.length; i < len; i++) deltaX = points[i].x - lastX, deltaY = points[i].y - lastY, deltaX * deltaX + deltaY * deltaY > sqTolerance && (lastX = points[i].x, lastY = points[i].y, newPoints.push(points[i]));
  return points[points.length - 1].x === lastX && points[points.length - 1].y === lastY || newPoints.push(points[points.length - 1]), newPoints;
}
function flatten_simplify(points, tolerance, highestQuality) {
  if (points.length <= 10) return points;
  return points = highestQuality ? points : simplifyRadialDist(points, void 0 !== tolerance ? tolerance * tolerance : 1);
}

var __rest$1 = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
  }
  return t;
};
function getDefaultCharacterConfig(attribute) {
  const {
    fill = "black",
    stroke = !1,
    fontWeight = "normal",
    lineHeight: lineHeight,
    fontFamily = "Arial",
    textAlign: textAlign
  } = attribute;
  let {
    fontSize = 12
  } = attribute;
  return isFinite(fontSize) || (fontSize = 12), {
    fill: fill,
    stroke: stroke,
    fontSize: fontSize,
    fontWeight: fontWeight,
    fontFamily: fontFamily,
    lineHeight: lineHeight,
    textAlign: textAlign
  };
}
function findConfigIndexByCursorIdx(textConfig, cursorIndex) {
  if (cursorIndex < 0) return 0;
  const intCursorIndex = Math.round(cursorIndex);
  let tempCursorIndex = intCursorIndex,
    lineBreak = !1,
    configIdx = 0;
  for (configIdx = 0; configIdx < textConfig.length && tempCursorIndex >= 0; configIdx++) {
    "\n" === textConfig[configIdx].text ? (tempCursorIndex -= Number(lineBreak), lineBreak = !0) : (tempCursorIndex--, lineBreak = !1);
  }
  return tempCursorIndex >= 0 ? textConfig.length : (configIdx -= 1, cursorIndex > intCursorIndex && !lineBreak && (configIdx += 1), configIdx);
}
function findCursorIdxByConfigIndex(textConfig, configIndex) {
  var _a, _b, _c;
  let cursorIndex = 0;
  if (configIndex < 0) return -.1;
  let lastLineBreak = !1;
  for (let i = 0; i <= configIndex && i < textConfig.length; i++) {
    "\n" === textConfig[i].text ? (cursorIndex += Number(lastLineBreak), lastLineBreak = !0) : (cursorIndex++, lastLineBreak = !1);
  }
  if (cursorIndex = Math.max(cursorIndex - 1, 0), configIndex > textConfig.length - 1) return "\n" === (null === (_a = textConfig[textConfig.length - 1]) || void 0 === _a ? void 0 : _a.text) ? cursorIndex + .9 : cursorIndex + .1;
  const lineBreak = "\n" === (null === (_b = textConfig[configIndex]) || void 0 === _b ? void 0 : _b.text);
  if (configIndex >= textConfig.length - 1 && lineBreak) return cursorIndex + 1 - .1;
  return cursorIndex -= .1, lineBreak && "\n" !== (null === (_c = textConfig[configIndex - 1]) || void 0 === _c ? void 0 : _c.text) && (cursorIndex += .2), cursorIndex;
}
class EditModule {
  constructor(container) {
    this.handleFocusIn = () => {}, this.handleFocusOut = () => {}, this.handleKeyDown = e => {
      "Delete" !== e.key && "Backspace" !== e.key || this.handleInput({
        data: null,
        type: "Backspace"
      });
    }, this.handleCompositionStart = () => {
      this.isComposing = !0;
      const {
        textConfig = []
      } = this.currRt.attribute;
      if (this.composingConfigIdx = this.cursorIndex < 0 ? 0 : findConfigIndexByCursorIdx(textConfig, this.cursorIndex), this.cursorIndex < 0) {
        const config = textConfig[0];
        textConfig.unshift(Object.assign(Object.assign(Object.assign({
          fill: "black"
        }, getDefaultCharacterConfig(this.currRt.attribute)), config), {
          text: ""
        }));
      } else {
        const configIdx = this.composingConfigIdx,
          lastConfig = textConfig[configIdx] || textConfig[configIdx - 1];
        textConfig.splice(configIdx, 0, Object.assign(Object.assign(Object.assign({
          fill: "black"
        }, getDefaultCharacterConfig(this.currRt.attribute)), lastConfig), {
          text: ""
        }));
      }
    }, this.handleCompositionEnd = () => {
      this.isComposing = !1;
      const text = this.parseCompositionStr(this.composingConfigIdx);
      this.composingConfigIdx = -1, this.onChangeCbList.forEach(cb => {
        cb(text, this.isComposing, this.cursorIndex, this.currRt);
      });
    }, this.handleInput = ev => {
      if (!this.currRt) return;
      if ("historyUndo" === ev.inputType) return;
      const _a = this.currRt.attribute,
        {
          textConfig = []
        } = _a,
        rest = __rest$1(_a, ["textConfig"]);
      if ("Backspace" === ev.type && !textConfig.length) return;
      let str = ev.data;
      this.isComposing || "Backspace" === ev.type || str || (str = "\n"), this.selectionStartCursorIdx > this.cursorIndex && ([this.cursorIndex, this.selectionStartCursorIdx] = [this.selectionStartCursorIdx, this.cursorIndex]);
      const startIdx = findConfigIndexByCursorIdx(textConfig, this.selectionStartCursorIdx),
        endIdx = findConfigIndexByCursorIdx(textConfig, this.cursorIndex);
      let lastConfig = textConfig[this.isComposing ? this.composingConfigIdx : Math.max(startIdx - 1, 0)];
      lastConfig || (lastConfig = getDefaultCharacterConfig(rest));
      let nextConfig = lastConfig;
      startIdx !== endIdx && (textConfig.splice(startIdx, endIdx - startIdx), this.isComposing && (this.composingConfigIdx = startIdx));
      let nextConfigIdx = startIdx;
      if ("Backspace" !== ev.type || this.isComposing) this.isComposing || (nextConfig = Object.assign(Object.assign({
        fill: "black"
      }, lastConfig), {
        text: ""
      }), textConfig.splice(startIdx, 0, nextConfig), nextConfigIdx++), nextConfig.text = str, nextConfig.isComposing = this.isComposing;else if (startIdx === endIdx) {
        if (startIdx <= 0) return;
        textConfig.splice(startIdx - 1, 1), nextConfigIdx = Math.max(startIdx - 1, 0);
      }
      this.currRt.setAttributes({
        textConfig: textConfig
      });
      let cursorIndex = this.cursorIndex;
      str && str.length > 1 && !this.isComposing ? (this.parseCompositionStr(nextConfigIdx - 1), cursorIndex = this.cursorIndex) : (cursorIndex = findCursorIdxByConfigIndex(textConfig, nextConfigIdx), this.isComposing ? this.cursorIndex = this.selectionStartCursorIdx : this.cursorIndex = cursorIndex), this.isComposing ? this.onInputCbList.forEach(cb => {
        cb(str, this.isComposing, cursorIndex, this.currRt);
      }) : this.onChangeCbList.forEach(cb => {
        cb(str, this.isComposing, cursorIndex, this.currRt);
      });
    }, this.container = null != container ? container : document.body;
    const textAreaDom = document.createElement("textarea");
    textAreaDom.autocomplete = "off", textAreaDom.innerText = "", this.applyStyle(textAreaDom), this.container.append(textAreaDom), this.textAreaDom = textAreaDom, this.isComposing = !1, this.composingConfigIdx = -1, this.onInputCbList = [], this.onChangeCbList = [], this.onFocusInList = [], this.onFocusOutList = [];
  }
  onInput(cb) {
    this.onInputCbList.push(cb);
  }
  onChange(cb) {
    this.onChangeCbList.push(cb);
  }
  onFocusIn(cb) {
    this.onFocusInList.push(cb);
  }
  onFocusOut(cb) {
    this.onFocusOutList.push(cb);
  }
  applyStyle(textAreaDom) {
    textAreaDom.setAttribute("style", "width: 100px; height: 30px; left: 0; top: 0; position: absolute; z-index: -1; outline: none; resize: none; border: none; overflow: hidden; color: transparent; user-select: none; caret-color: transparent;background-color: transparent;"), textAreaDom.addEventListener("input", this.handleInput), textAreaDom.addEventListener("compositionstart", this.handleCompositionStart), textAreaDom.addEventListener("compositionend", this.handleCompositionEnd), textAreaDom.addEventListener("focusin", this.handleFocusIn), textAreaDom.addEventListener("focusout", this.handleFocusOut), application.global.addEventListener("keydown", this.handleKeyDown);
  }
  parseCompositionStr(configIdx) {
    var _a;
    const {
        textConfig = []
      } = this.currRt.attribute,
      lastConfig = null !== (_a = textConfig[configIdx]) && void 0 !== _a ? _a : {};
    textConfig.splice(configIdx, 1);
    const text = lastConfig.text,
      textList = text ? Array.from(text.toString()) : [];
    for (let i = 0; i < textList.length; i++) textConfig.splice(i + configIdx, 0, Object.assign(Object.assign({
      fill: "black"
    }, lastConfig), {
      isComposing: !1,
      text: textList[i]
    }));
    this.currRt.setAttributes({
      textConfig: textConfig
    });
    const nextConfigIdx = configIdx + textList.length;
    return this.cursorIndex = findCursorIdxByConfigIndex(textConfig, nextConfigIdx), text;
  }
  moveTo(x, y, rt, cursorIndex, selectionStartCursorIdx) {
    this.textAreaDom.style.left = `${x}px`, this.textAreaDom.style.top = `${y}px`, setTimeout(() => {
      this.textAreaDom.focus(), this.textAreaDom.setSelectionRange(0, 0);
    }), this.currRt = rt, this.cursorIndex = cursorIndex, this.selectionStartCursorIdx = selectionStartCursorIdx;
  }
  release() {
    this.textAreaDom.removeEventListener("input", this.handleInput), this.textAreaDom.removeEventListener("compositionstart", this.handleCompositionStart), this.textAreaDom.removeEventListener("compositionend", this.handleCompositionEnd), this.textAreaDom.addEventListener("focusin", this.handleFocusOut), this.textAreaDom.addEventListener("focusout", this.handleFocusOut), application.global.removeEventListener("keydown", this.handleKeyDown);
  }
}

class Selection {
  constructor(selectionStartCursorIdx, curCursorIdx, rt) {
    this.curCursorIdx = curCursorIdx, this.selectionStartCursorIdx = selectionStartCursorIdx, this.rt = rt;
  }
  isEmpty() {
    return this.selectionStartCursorIdx === this.curCursorIdx;
  }
  getSelectionPureText() {
    const minCursorIdx = Math.min(this.selectionStartCursorIdx, this.curCursorIdx),
      maxCursorIdx = Math.max(this.selectionStartCursorIdx, this.curCursorIdx);
    if (minCursorIdx === maxCursorIdx) return "";
    const config = this.rt.attribute.textConfig,
      startIdx = findConfigIndexByCursorIdx(config, Math.ceil(minCursorIdx)),
      endIdx = findConfigIndexByCursorIdx(config, Math.floor(maxCursorIdx));
    let str = "";
    for (let i = startIdx; i <= endIdx; i++) str += config[i].text;
    return str;
  }
  hasFormat(key) {
    return null != this.getFormat(key);
  }
  _getFormat(key, cursorIdx) {
    var _a;
    if (!this.rt) return null;
    let idx = Math.round(cursorIdx);
    const config = this.rt.attribute.textConfig;
    if (!config.length) return null;
    for (let i = 0; i < config.length; i++) if ("\n" !== config[i].text && (idx--, idx < 0)) return config[i][key];
    return null !== (_a = config[Math.min(idx, config.length - 1)][key]) && void 0 !== _a ? _a : this.rt.attribute[key];
  }
  getFormat(key) {
    let supportOutAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    return this.getAllFormat(key, supportOutAttr)[0];
  }
  getAllFormat(key) {
    let supportOutAttr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
    var _a, _b, _c, _d;
    const valSet = new Set(),
      minCursorIdx = Math.min(this.selectionStartCursorIdx, this.curCursorIdx),
      maxCursorIdx = Math.max(this.selectionStartCursorIdx, this.curCursorIdx);
    if (minCursorIdx === maxCursorIdx) return supportOutAttr ? [null !== (_a = this._getFormat(key, minCursorIdx)) && void 0 !== _a ? _a : (null === (_b = this.rt) || void 0 === _b ? void 0 : _b.attribute)[key]] : [this._getFormat(key, minCursorIdx)];
    for (let i = Math.ceil(minCursorIdx); i <= Math.floor(maxCursorIdx); i++) {
      const val = supportOutAttr ? null !== (_c = this._getFormat(key, i)) && void 0 !== _c ? _c : (null === (_d = this.rt) || void 0 === _d ? void 0 : _d.attribute)[key] : this._getFormat(key, i);
      val && valSet.add(val);
    }
    return Array.from(valSet.values());
  }
}
const FORMAT_TEXT_COMMAND = "FORMAT_TEXT_COMMAND";
const FORMAT_ALL_TEXT_COMMAND = "FORMAT_ALL_TEXT_COMMAND";
const FORMAT_ELEMENT_COMMAND = "FORMAT_ELEMENT_COMMAND";
class RichTextEditPlugin {
  static tryUpdateRichtext(richtext) {
    const cache = richtext.getFrameCache();
    if (!RichText.AllSingleCharacter(cache)) {
      const tc = RichText.TransformTextConfig2SingleCharacter(richtext.attribute.textConfig);
      richtext.setAttributes({
        textConfig: tc
      }), richtext.doUpdateFrameCache(tc);
    }
  }
  static CreateSelection(rt) {
    if (!rt) return null;
    const {
      textConfig = []
    } = rt.attribute;
    return new Selection(0, textConfig.length - 1, rt);
  }
  constructor() {
    this.name = "RichTextEditPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.editing = !1, this.focusing = !1, this.pointerDown = !1, this.formatTextCommandCb = (payload, p) => {
      const rt = p.currRt;
      if (!rt) return;
      const selectionData = p.getSelection();
      if (!selectionData) return;
      const {
          selectionStartCursorIdx: selectionStartCursorIdx,
          curCursorIdx: curCursorIdx
        } = selectionData,
        minCursorIdx = Math.min(selectionStartCursorIdx, curCursorIdx),
        maxCursorIdx = Math.max(selectionStartCursorIdx, curCursorIdx),
        minConfigIdx = findConfigIndexByCursorIdx(rt.attribute.textConfig, minCursorIdx),
        maxConfigIdx = findConfigIndexByCursorIdx(rt.attribute.textConfig, maxCursorIdx),
        config = rt.attribute.textConfig.slice(minConfigIdx, maxConfigIdx);
      this._formatTextCommand(payload, config, rt);
    }, this.formatAllTextCommandCb = (payload, p) => {
      const rt = p.currRt;
      if (!rt) return;
      const config = rt.attribute.textConfig;
      this._formatTextCommand(payload, config, rt);
    }, this.handleKeyDown = e => {
      this.currRt && this.editing && (this.copyToClipboard(e) || this.fullSelectionKeyHandler(e) || this.directKeyHandler(e));
    }, this.handleInput = (text, isComposing, cursorIdx, rt) => {
      this.currRt && (this.tryShowShadowPlaceholder(), this.tryShowInputBounds(), this.hideSelection(), this.updateCbs.forEach(cb => cb("input", this)));
    }, this.handleChange = (text, isComposing, cursorIdx, rt) => {
      if (!this.currRt) return;
      this.tryShowShadowPlaceholder(), this.tryShowInputBounds(), this.curCursorIdx = cursorIdx, this.selectionStartCursorIdx = cursorIdx;
      const p = this.computedCursorPosByCursorIdx(cursorIdx, rt);
      this.setCursorAndTextArea(p.x, p.y1, p.y2, rt), this.hideSelection(), this.updateCbs.forEach(cb => cb("change", this));
    }, this.handleFocusIn = () => {
      throw new Error("不会走到这里 handleFocusIn");
    }, this.handleFocusOut = () => {
      throw new Error("不会走到这里 handleFocusOut");
    }, this.handleMove = e => {
      this.currRt && !this.currRt.attribute.editable && this.deFocus(!0), this.isEditableRichtext(e) ? (this.handleEnter(), e.target.once("pointerleave", this.handleLeave, {
        capture: !0
      }), this.tryShowSelection(e, !1)) : this.handleLeave();
    }, this.handleEnter = () => {
      this.editing = !0, this.pluginService.stage.setCursor("text");
    }, this.handleLeave = () => {
      this.editing = !1, this.pluginService.stage.setCursor("default");
    }, this.handlePointerDown = e => {
      this.editing && this.isEditableRichtext(e) ? this.onFocus(e) : this.deFocus(!0), this.triggerRender(), this.pointerDown = !0, this.updateCbs.forEach(cb => cb(this.editing ? "onfocus" : "defocus", this));
    }, this.handlePointerUp = e => {
      this.pointerDown = !1;
    }, this.handleDBLClick = e => {
      this.editing && this.tryShowSelection(e, !0);
    }, this.commandCbs = new Map(), this.commandCbs.set(FORMAT_TEXT_COMMAND, [this.formatTextCommandCb]), this.commandCbs.set(FORMAT_ALL_TEXT_COMMAND, [this.formatAllTextCommandCb]), this.updateCbs = [], this.timeline = new DefaultTimeline(), this.ticker = new DefaultTicker([this.timeline]), this.deltaX = 0, this.deltaY = 0;
  }
  _formatTextCommand(payload, config, rt) {
    "bold" === payload ? config.forEach(item => item.fontWeight = "bold") : "italic" === payload ? config.forEach(item => item.fontStyle = "italic") : "underline" === payload ? config.forEach(item => item.underline = !0) : "lineThrough" === payload ? config.forEach(item => item.lineThrough = !0) : isObject$1(payload) && config.forEach(item => merge(item, payload)), rt.setAttributes(rt.attribute);
    const cache = rt.getFrameCache();
    cache && (this.selectionRangeByCursorIdx(this.selectionStartCursorIdx, this.curCursorIdx, cache), this.tryShowInputBounds());
  }
  dispatchCommand(command, payload) {
    const cbs = this.commandCbs.get(command);
    cbs && cbs.forEach(cb => cb(payload, this)), this.updateCbs.forEach(cb => cb("dispatch", this));
  }
  registerCommand(command, cb) {
    (this.commandCbs.get(command) || []).push(cb);
  }
  removeCommand(command, cb) {
    const cbs = this.commandCbs.get(command) || [],
      idx = cbs.indexOf(cb);
    idx > -1 && cbs.splice(idx, 1);
  }
  registerUpdateListener(cb) {
    (this.updateCbs || []).push(cb);
  }
  removeUpdateListener(cb) {
    const cbs = this.updateCbs || [],
      idx = cbs.indexOf(cb);
    idx > -1 && cbs.splice(idx, 1);
  }
  activate(context) {
    this.pluginService = context, this.editModule = new EditModule(), context.stage.on("pointermove", this.handleMove, {
      capture: !0
    }), context.stage.on("pointerdown", this.handlePointerDown, {
      capture: !0
    }), context.stage.on("pointerup", this.handlePointerUp, {
      capture: !0
    }), context.stage.on("pointerleave", this.handlePointerUp, {
      capture: !0
    }), context.stage.on("dblclick", this.handleDBLClick, {
      capture: !0
    }), application.global.addEventListener("keydown", this.handleKeyDown), this.editModule.onInput(this.handleInput), this.editModule.onChange(this.handleChange), this.editModule.onFocusOut(this.handleFocusOut);
  }
  copyToClipboard(e) {
    if (application.global.isMacOS() && e.metaKey && "c" === e.key || !application.global.isMacOS() && e.ctrlKey && "c" === e.key) {
      const text = this.getSelection().getSelectionPureText();
      return application.global.copyToClipBoard(text), e.preventDefault(), !0;
    }
    return !1;
  }
  selectionRange(startIdx, endIdx) {
    const currRt = this.currRt;
    if (!currRt) return;
    const cache = currRt.getFrameCache();
    if (!cache) return;
    const {
        lines: lines
      } = cache,
      totalCursorCount = lines.reduce((total, line) => total + line.paragraphs.length, 0) - 1;
    startIdx > endIdx && ([startIdx, endIdx] = [endIdx, startIdx]), startIdx = Math.min(Math.max(startIdx, -.1), totalCursorCount + .1), endIdx = Math.min(Math.max(endIdx, -.1), totalCursorCount + .1), this.selectionRangeByCursorIdx(startIdx, endIdx, cache);
  }
  selectionRangeByCursorIdx(startCursorIdx, endCursorIdx, cache) {
    this.curCursorIdx = endCursorIdx, this.selectionStartCursorIdx = startCursorIdx;
    const {
      x: x,
      y1: y1,
      y2: y2
    } = this.computedCursorPosByCursorIdx(this.selectionStartCursorIdx, this.currRt);
    this.startCursorPos = {
      x: x,
      y: (y1 + y2) / 2
    };
    const pos = this.computedCursorPosByCursorIdx(this.curCursorIdx, this.currRt);
    this.setCursorAndTextArea(pos.x, pos.y1, pos.y2, this.currRt), this._tryShowSelection(pos, cache);
  }
  fullSelection() {
    const currRt = this.currRt;
    if (!currRt) return;
    const cache = currRt.getFrameCache();
    if (!cache) return;
    const {
      lines: lines
    } = cache;
    if (!lines.length || !lines[0].paragraphs.length) return;
    const totalCursorCount = lines.reduce((total, line) => total + line.paragraphs.length, 0) - 1;
    this.selectionRange(-.1, totalCursorCount + .1);
  }
  fullSelectionKeyHandler(e) {
    return !!(application.global.isMacOS() && e.metaKey && "a" === e.key || !application.global.isMacOS() && e.ctrlKey && "a" === e.key) && (this.fullSelection(), e.preventDefault(), !0);
  }
  directKeyHandler(e) {
    if ("ArrowUp" !== e.key && "ArrowDown" !== e.key && "ArrowLeft" !== e.key && "ArrowRight" !== e.key) return !1;
    const cache = this.currRt.getFrameCache();
    if (!cache) return !1;
    let x = 0,
      y = 0;
    "ArrowUp" === e.key ? y = -1 : "ArrowDown" === e.key ? y = 1 : "ArrowLeft" === e.key ? x = -1 : "ArrowRight" === e.key && (x = 1);
    const {
        lineInfo: lineInfo,
        columnInfo: columnInfo
      } = this.getColumnByIndex(cache, Math.round(this.curCursorIdx)),
      {
        lines: lines
      } = cache,
      totalCursorCount = lines.reduce((total, line) => total + line.paragraphs.length, 0) - 1;
    if (x) {
      x > 0 && columnInfo === lineInfo.paragraphs[lineInfo.paragraphs.length - 2] && this.curCursorIdx < Math.round(this.curCursorIdx) ? this.curCursorIdx = this.curCursorIdx + .2 : x > 0 && columnInfo === lineInfo.paragraphs[lineInfo.paragraphs.length - 1] && this.curCursorIdx > Math.round(this.curCursorIdx) ? this.curCursorIdx = this.curCursorIdx + 1 - .2 : x < 0 && columnInfo === lineInfo.paragraphs[0] && this.curCursorIdx > Math.round(this.curCursorIdx) ? this.curCursorIdx = this.curCursorIdx - .2 : x < 0 && columnInfo === lineInfo.paragraphs[0] && this.curCursorIdx < Math.round(this.curCursorIdx) ? this.curCursorIdx = this.curCursorIdx - 1 + .2 : this.curCursorIdx += x, this.curCursorIdx < -.1 ? this.curCursorIdx = -.1 : this.curCursorIdx > totalCursorCount + .1 && (this.curCursorIdx = totalCursorCount + .1), this.selectionStartCursorIdx = this.curCursorIdx;
      const pos = this.computedCursorPosByCursorIdx(this.curCursorIdx, this.currRt);
      this.setCursorAndTextArea(pos.x, pos.y1, pos.y2, this.currRt), this.hideSelection();
    }
    if (y) {
      if (y > 0 && lineInfo === cache.lines[cache.lines.length - 1]) return;
      if (y < 0 && lineInfo === cache.lines[0]) return;
      const lineIdx = cache.lines.findIndex(item => item === lineInfo) + y;
      if (lineIdx < 0 || lineIdx >= cache.lines.length) return;
      const pos = this.computedCursorPosByCursorIdx(this.curCursorIdx, this.currRt),
        posX = pos.x;
      let posY = (pos.y1 + pos.y2) / 2;
      posY += y * lineInfo.height;
      const nextLineInfo = cache.lines[lineIdx],
        {
          columnInfo: columnInfo,
          delta: delta
        } = this.getColumnAndIndexByLinePoint(nextLineInfo, {
          x: posX,
          y: posY
        });
      if (!columnInfo) return;
      let cursorIdx = this.getColumnIndex(cache, columnInfo) + delta;
      const data = this.computedCursorPosByCursorIdx(cursorIdx, this.currRt);
      cursorIdx < -.1 ? cursorIdx = -.1 : cursorIdx > totalCursorCount + .1 && (cursorIdx = totalCursorCount + .1), this.curCursorIdx = cursorIdx, this.selectionStartCursorIdx = cursorIdx, this.setCursorAndTextArea(data.x, data.y1, data.y2, this.currRt);
    }
    return !0;
  }
  tryShowShadowPlaceholder() {
    if (!this.currRt) return;
    const shadowRoot = this.currRt.shadowRoot;
    if (shadowRoot) {
      const placeholder = shadowRoot.getElementsByType("richtext")[0];
      placeholder && shadowRoot.removeChild(placeholder);
    }
    const {
      textConfig: textConfig,
      editOptions = {}
    } = this.currRt.attribute;
    if (textConfig && textConfig.length) return;
    if (!editOptions || !editOptions.placeholder) return;
    const {
        placeholder: placeholder,
        placeholderColor = "rgba(0, 0, 0, 0.6)",
        placeholderFontFamily: placeholderFontFamily,
        placeholderFontSize: placeholderFontSize
      } = editOptions,
      shadow = this.getShadow(this.currRt),
      textConfigItem = Object.assign(Object.assign({}, getDefaultCharacterConfig(this.currRt.attribute)), {
        text: placeholder
      });
    placeholderColor && (textConfigItem.fill = placeholderColor), placeholderFontFamily && (textConfigItem.fontFamily = placeholderFontFamily), placeholderFontSize && (textConfigItem.fontSize = placeholderFontSize), this.shadowPlaceHolder = createRichText(Object.assign(Object.assign({}, this.currRt.attribute), {
      x: 0,
      y: 0,
      dx: -this.deltaX,
      dy: -this.deltaY,
      angle: 0,
      textConfig: [textConfigItem]
    })), shadow.add(this.shadowPlaceHolder);
  }
  getRichTextAABBBounds(rt) {
    const {
      attribute: attribute
    } = rt;
    return attribute.textConfig.length ? rt.AABBBounds : getRichTextBounds(Object.assign(Object.assign({}, this.shadowPlaceHolder.attribute), {
      x: attribute.x,
      y: attribute.y,
      textAlign: attribute.textAlign,
      boundsMode: "accurate"
    }));
  }
  tryShowInputBounds() {
    if (!this.currRt || !this.focusing) return;
    const {
        editOptions = {}
      } = this.currRt.attribute,
      {
        boundsStrokeWhenInput: boundsStrokeWhenInput
      } = editOptions;
    if (!editOptions || !boundsStrokeWhenInput) return;
    this.offsetShadowRoot();
    const b = this.getRichTextAABBBounds(this.currRt),
      height = b.height(),
      width = b.width();
    this.shadowBounds = this.shadowBounds || createRect({}), this.shadowBounds.setAttributes({
      x: 0,
      y: 0,
      width: width,
      height: height,
      fill: !1,
      stroke: boundsStrokeWhenInput,
      lineWidth: 1,
      zIndex: -1
    });
    const shadow = this.getShadow(this.currRt);
    this.addEditLineOrBgOrBounds(this.shadowBounds, shadow), this.offsetLineBgAndShadowBounds();
  }
  trySyncPlaceholderToTextConfig() {
    if (!this.currRt) return;
    const {
      textConfig: textConfig,
      editOptions: editOptions
    } = this.currRt.attribute;
    if (textConfig && textConfig.length) return;
    if (!(editOptions && editOptions.placeholder && editOptions.syncPlaceholderToTextConfig)) return;
    const {
      placeholder: placeholder
    } = editOptions;
    this.currRt.setAttributes({
      textConfig: [Object.assign({
        text: placeholder
      }, getDefaultCharacterConfig(this.currRt.attribute))]
    });
  }
  deactivate(context) {
    context.stage.off("pointermove", this.handleMove, {
      capture: !0
    }), context.stage.off("pointerdown", this.handlePointerDown, {
      capture: !0
    }), context.stage.off("pointerup", this.handlePointerUp, {
      capture: !0
    }), context.stage.off("pointerleave", this.handlePointerUp, {
      capture: !0
    }), context.stage.off("dblclick", this.handleDBLClick, {
      capture: !0
    }), application.global.addEventListener("keydown", this.handleKeyDown);
  }
  stopPropagation(e) {
    e.stopPropagation();
  }
  addEditLineOrBgOrBounds(graphic, shadowRoot) {
    let group = shadowRoot.getElementById("emptyBoundsContainer");
    group || (group = createGroup({
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      boundsMode: "empty"
    }), group.id = "emptyBoundsContainer", shadowRoot.add(group)), group.add(graphic);
  }
  removeEditLineOrBgOrBounds(graphic, shadowRoot) {
    const group = shadowRoot.getElementById("emptyBoundsContainer");
    group && group.removeChild(graphic);
  }
  onFocus(e, data) {
    this.updateCbs && this.updateCbs.forEach(cb => cb("beforeOnfocus", this)), this.deFocus(!1), this.focusing = !0, this.editing = !0;
    const target = e.target;
    if (!target || "richtext" !== target.type) return;
    this.currRt = target, RichTextEditPlugin.tryUpdateRichtext(target);
    const shadowRoot = this.getShadow(target),
      cache = target.getFrameCache();
    if (!cache) return;
    const {
      editOptions = {}
    } = this.currRt.attribute;
    if (editOptions.stopPropagation && target.addEventListener("*", this.stopPropagation), this.offsetShadowRoot(target), !this.editLine) {
      const line = createLine({
        x: 0,
        y: 0,
        lineWidth: 1,
        stroke: "black"
      });
      this.addAnimateToLine(line), this.editLine = line, this.ticker.start(!0);
      const g = createGroup({
        x: 0,
        y: 0,
        width: 0,
        height: 0
      });
      this.editBg = g, this.addEditLineOrBgOrBounds(this.editLine, shadowRoot), this.addEditLineOrBgOrBounds(this.editBg, shadowRoot);
    }
    if (data = data || this.computedCursorPosByEvent(e, cache)) {
      const {
        x: x,
        y1: y1,
        y2: y2,
        cursorIndex: cursorIndex
      } = data;
      this.startCursorPos = {
        x: x,
        y: (y1 + y2) / 2
      }, this.curCursorIdx = cursorIndex, this.selectionStartCursorIdx = cursorIndex, this.setCursorAndTextArea(x, y1, y2, target);
    } else {
      const x = 0,
        y1 = 0,
        y2 = getRichTextBounds(Object.assign(Object.assign({}, target.attribute), {
          textConfig: [{
            text: "a"
          }]
        })).height();
      this.startCursorPos = {
        x: x,
        y: (y1 + y2) / 2
      }, this.curCursorIdx = -.1, this.selectionStartCursorIdx = -.1, this.setCursorAndTextArea(x, y1, y2, target);
    }
    this.tryShowShadowPlaceholder(), this.tryShowInputBounds(), this.currRt.addUpdateBoundTag();
  }
  offsetShadowRoot(rt) {
    if (!(rt = rt || this.currRt)) return;
    const shadowRoot = this.getShadow(rt);
    if (!shadowRoot) return;
    const cache = rt.getFrameCache();
    cache && (this.computeGlobalDelta(cache), shadowRoot.setAttributes({
      shadowRootIdx: 1,
      pickable: !1,
      x: this.deltaX,
      y: this.deltaY
    }), this.shadowPlaceHolder && this.shadowPlaceHolder.setAttributes({
      dx: -this.deltaX,
      dy: -this.deltaY
    }));
  }
  offsetLineBgAndShadowBounds() {
    const rt = this.currRt,
      {
        textBaseline: textBaseline
      } = rt.attribute;
    let b,
      dy = 0,
      attr = rt.attribute;
    "middle" !== textBaseline && "bottom" !== textBaseline || (attr.textConfig.length || (attr = Object.assign(Object.assign({}, attr), {
      textConfig: [{
        text: "a"
      }]
    })), b = getRichTextBounds(attr)), "middle" === textBaseline ? dy = -b.height() / 2 : "bottom" === textBaseline && (dy = -b.height()), this.editLine && this.editLine.setAttributes({
      dy: dy
    }), this.editBg && this.editBg.setAttributes({
      dy: dy
    }), this.shadowBounds && this.shadowBounds.setAttributes({
      dy: dy
    });
  }
  deFocus() {
    let trulyDeFocus = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    this.editing = !1, this.updateCbs && this.updateCbs.forEach(cb => cb("beforeDefocus", this, {
      trulyDeFocus: trulyDeFocus
    }));
    const currRt = this.currRt;
    if (!currRt) return;
    const {
      editOptions = {}
    } = currRt.attribute;
    editOptions.stopPropagation && currRt.removeEventListener("*", this.stopPropagation), trulyDeFocus && (this.trySyncPlaceholderToTextConfig(), currRt.detachShadow()), this.currRt = null;
    const shadowRoot = this.getShadow(currRt);
    this.editLine && (this.removeEditLineOrBgOrBounds(this.editLine, shadowRoot), this.editLine.release(), this.editLine = null, this.removeEditLineOrBgOrBounds(this.editBg, shadowRoot), this.editBg.release(), this.editBg = null), trulyDeFocus && (this.shadowBounds && (this.removeEditLineOrBgOrBounds(this.shadowBounds, shadowRoot), this.shadowBounds.release(), this.shadowBounds = null), this.shadowPlaceHolder && (this.shadowPlaceHolder.parent && this.shadowPlaceHolder.parent.removeChild(this.shadowPlaceHolder), this.shadowPlaceHolder.release(), this.shadowPlaceHolder = null)), this.focusing = !1, currRt.removeEventListener("pointerleave", this.handleLeave);
  }
  addAnimateToLine(line) {
    line.setAttributes({
      opacity: 1
    }), line.animates && line.animates.forEach(animate => {
      animate.stop(), animate.release();
    });
    line.animate({
      timeline: this.timeline
    }).to({
      opacity: 1
    }, 10, "linear").wait(700).to({
      opacity: 0
    }, 10, "linear").wait(700).loop(1 / 0);
  }
  tryShowSelection(e, dblclick) {
    const cache = e.target.getFrameCache();
    if (cache && this.editBg && this.startCursorPos) if (dblclick) {
      const currCursorData = this.computedCursorPosByEvent(e, cache);
      if (!currCursorData) return;
      const lineInfo = currCursorData.lineInfo,
        columnIndex = lineInfo.paragraphs.findIndex(item => item === currCursorData.columnInfo);
      if (columnIndex < 0) return;
      const str = lineInfo.paragraphs.reduce((str, item) => str + item.text, "");
      let idx = 0;
      for (let i = 0; i < cache.lines.length; i++) {
        const line = cache.lines[i];
        if (line === lineInfo) break;
        idx += line.paragraphs.length;
      }
      const {
        startIdx: startIdx,
        endIdx: endIdx
      } = getWordStartEndIdx(str, columnIndex);
      this.selectionRange(idx + startIdx - .1, idx + endIdx - .1);
    } else if (this.pointerDown) {
      const currCursorData = this.computedCursorPosByEvent(e, cache);
      if (!currCursorData) return;
      this.curCursorIdx = currCursorData.cursorIndex, this._tryShowSelection(currCursorData, cache);
    }
  }
  _tryShowSelection(currCursorData, cache) {
    let startCursorPos = this.startCursorPos,
      endCursorPos = {
        x: currCursorData.x,
        y: (currCursorData.y1 + currCursorData.y2) / 2
      },
      line0Info = this.getLineByPoint(cache, startCursorPos),
      line1Info = this.getLineByPoint(cache, endCursorPos);
    if ((startCursorPos.y > endCursorPos.y || startCursorPos.y === endCursorPos.y && startCursorPos.x > endCursorPos.x) && ([startCursorPos, endCursorPos] = [endCursorPos, startCursorPos], [line1Info, line0Info] = [line0Info, line1Info]), this.hideSelection(), line0Info === line1Info) this.editBg.setAttributes({
      x: startCursorPos.x,
      y: line0Info.top,
      width: endCursorPos.x - startCursorPos.x,
      height: line0Info.height,
      fill: "#336df4",
      fillOpacity: .2
    });else {
      this.editBg.setAttributes({
        x: 0,
        y: line0Info.top,
        width: 0,
        height: 0
      });
      const startIdx = cache.lines.findIndex(item => item === line0Info),
        endIdx = cache.lines.findIndex(item => item === line1Info);
      let y = 0;
      for (let i = startIdx; i <= endIdx; i++) {
        const line = cache.lines[i];
        if (i === startIdx) {
          const p = line.paragraphs[line.paragraphs.length - 1];
          this.editBg.add(createRect({
            x: startCursorPos.x,
            y: y,
            width: p.left + p.width - startCursorPos.x,
            height: line.height,
            fill: "#336df4",
            fillOpacity: .2
          }));
        } else if (i === endIdx) {
          const p = line.paragraphs[0];
          this.editBg.add(createRect({
            x: p.left,
            y: y,
            width: endCursorPos.x - p.left,
            height: line.height,
            fill: "#336df4",
            fillOpacity: .2
          }));
        } else {
          const p0 = line.paragraphs[0],
            p1 = line.paragraphs[line.paragraphs.length - 1];
          this.editBg.add(createRect({
            x: p0.left,
            y: y,
            width: p1.left + p1.width - p0.left,
            height: line.height,
            fill: "#336df4",
            fillOpacity: .2
          }));
        }
        y += line.height;
      }
    }
    this.setCursorAndTextArea(currCursorData.x, currCursorData.y1, currCursorData.y2, this.currRt), this.triggerRender(), this.updateCbs.forEach(cb => cb("selection", this));
  }
  hideSelection() {
    this.editBg && (this.editBg.removeAllChild(), this.editBg.setAttributes({
      fill: "transparent"
    }));
  }
  getShadow(rt) {
    const sr = rt.shadowRoot || rt.attachShadow();
    return sr.setAttributes({
      width: 0,
      height: 0
    }), sr;
  }
  getLineByPoint(cache, p1) {
    let lineInfo = cache.lines[0];
    for (let i = 0; i < cache.lines.length && !(lineInfo.top <= p1.y && lineInfo.top + lineInfo.height >= p1.y); i++) lineInfo = cache.lines[i + 1];
    return lineInfo;
  }
  getColumnAndIndexByLinePoint(lineInfo, p1) {
    let columnInfo = lineInfo.paragraphs[0],
      delta = 0;
    if (lineInfo.paragraphs.length) {
      const start = lineInfo.paragraphs[0],
        end = lineInfo.paragraphs[lineInfo.paragraphs.length - 1];
      p1.x <= start.left ? (delta = -.1, columnInfo = start) : p1.x >= end.left + end.width && (delta = .1, columnInfo = end);
    }
    if (!delta) for (let i = 0; i < lineInfo.paragraphs.length; i++) if (columnInfo = lineInfo.paragraphs[i], columnInfo.left <= p1.x && columnInfo.left + columnInfo.width >= p1.x) {
      delta = p1.x > columnInfo.left + columnInfo.width / 2 ? .1 : -.1;
      break;
    }
    return {
      columnInfo: columnInfo,
      delta: delta
    };
  }
  getColumnIndex(cache, cInfo) {
    let inputIndex = -1;
    for (let i = 0; i < cache.lines.length; i++) {
      const line = cache.lines[i];
      for (let j = 0; j < line.paragraphs.length; j++) if (inputIndex++, cInfo === line.paragraphs[j]) return inputIndex;
    }
    return -1;
  }
  isRichtext(e) {
    return !(!e.target || "richtext" !== e.target.type);
  }
  isEditableRichtext(e) {
    return this.isRichtext(e) && !!e.target.attribute.editable;
  }
  triggerRender() {
    this.pluginService.stage.renderNextFrame();
  }
  computeGlobalDelta(cache) {
    this.deltaX = 0, this.deltaY = 0, 0 === cache.lines.length && this.shadowPlaceHolder && (cache = this.shadowPlaceHolder.getFrameCache());
    const height = cache.height,
      actualHeight = cache.actualHeight,
      width = cache.lines.reduce((w, item) => Math.max(w, item.actualWidth), 0);
    "center" === cache.globalAlign ? this.deltaX = -width / 2 : "right" === cache.globalAlign && (this.deltaX = -width), "middle" === cache.verticalDirection ? this.deltaY = height / 2 - actualHeight / 2 : "bottom" === cache.verticalDirection && (this.deltaY = height - actualHeight);
  }
  getEventPosition(e) {
    const p = this.pluginService.stage.eventPointTransform(e),
      p1 = {
        x: 0,
        y: 0
      };
    e.target.globalTransMatrix.transformPoint(p, p1), p1.x -= this.deltaX, p1.y -= this.deltaY;
    const rt = this.currRt,
      {
        textBaseline: textBaseline
      } = rt.attribute;
    let dy = 0;
    if ("middle" === textBaseline) {
      dy = getRichTextBounds(rt.attribute).height() / 2;
    } else if ("bottom" === textBaseline) {
      dy = getRichTextBounds(rt.attribute).height();
    }
    return p1.y += dy, p1;
  }
  setCursorAndTextArea(x, y1, y2, rt) {
    this.editLine.setAttributes({
      points: [{
        x: x,
        y: y1
      }, {
        x: x,
        y: y2
      }]
    }), this.addAnimateToLine(this.editLine);
    const out = {
      x: 0,
      y: 0
    };
    rt.globalTransMatrix.getInverse().transformPoint({
      x: x,
      y: y1
    }, out);
    const {
      left: left,
      top: top
    } = this.pluginService.stage.window.getBoundingClientRect();
    out.x += left, out.y += top, this.offsetLineBgAndShadowBounds(), this.offsetShadowRoot(), this.editModule.moveTo(out.x, out.y, rt, this.curCursorIdx, this.selectionStartCursorIdx);
  }
  computedCursorPosByEvent(e, cache) {
    const p1 = this.getEventPosition(e),
      lineInfo = this.getLineByPoint(cache, p1);
    if (!lineInfo) return;
    const {
      columnInfo: columnInfo,
      delta: delta
    } = this.getColumnAndIndexByLinePoint(lineInfo, p1);
    if (!columnInfo) return;
    const y1 = lineInfo.top,
      y2 = lineInfo.top + lineInfo.height;
    let cursorIndex = this.getColumnIndex(cache, columnInfo);
    cursorIndex += delta;
    return {
      x: columnInfo.left + (delta > 0 ? columnInfo.width : 0),
      y1: y1,
      y2: y2,
      cursorIndex: cursorIndex,
      lineInfo: lineInfo,
      columnInfo: columnInfo
    };
  }
  computedCursorPosByCursorIdx(cursorIdx, rt) {
    var _a, _b, _c;
    const idx = Math.round(cursorIdx),
      leftRight = cursorIdx - idx,
      cache = rt.getFrameCache(),
      column = this.getColumnByIndex(cache, idx),
      height = null !== (_a = rt.attribute.fontSize) && void 0 !== _a ? _a : null === (_c = null === (_b = rt.attribute.textConfig) || void 0 === _b ? void 0 : _b[0]) || void 0 === _c ? void 0 : _c.fontSize;
    if (!column) {
      if (!cache.lines.length) {
        return {
          x: 0,
          y1: 0,
          y2: getRichTextBounds(Object.assign(Object.assign({}, rt.attribute), {
            textConfig: [{
              text: "a"
            }]
          })).height()
        };
      }
      return {
        x: 0,
        y1: 0,
        y2: height
      };
    }
    const {
        lineInfo: lineInfo,
        columnInfo: columnInfo
      } = column,
      y1 = lineInfo.top,
      y2 = lineInfo.top + lineInfo.height;
    return {
      x: columnInfo.left + (leftRight < 0 ? 0 : columnInfo.width),
      y1: y1,
      y2: y2,
      lineInfo: lineInfo,
      columnInfo: columnInfo
    };
  }
  getColumnByIndex(cache, index) {
    for (let i = 0, inputIndex = 0; i < cache.lines.length; i++) {
      const lineInfo = cache.lines[i];
      for (let j = 0; j < lineInfo.paragraphs.length; j++) {
        const columnInfo = lineInfo.paragraphs[j];
        if (inputIndex === index) return {
          lineInfo: lineInfo,
          columnInfo: columnInfo
        };
        inputIndex++;
      }
    }
    return null;
  }
  release() {
    this.deactivate(this.pluginService), this.editModule.release();
  }
  getSelection() {
    let defaultAll = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    return this.currRt ? null != this.selectionStartCursorIdx && null != this.curCursorIdx ? new Selection(this.selectionStartCursorIdx, this.curCursorIdx, this.currRt) : defaultAll ? RichTextEditPlugin.CreateSelection(this.currRt) : null : null;
  }
  forceFocus(params) {
    const {
      target: target,
      e: e,
      cursorIndex: cursorIndex
    } = params;
    target && (this.currRt = target, e ? this._forceFocusByEvent(e) : this._forceFocusByCursorIndex(null != cursorIndex ? cursorIndex : -.1));
  }
  _forceFocusByEvent(e) {
    this.handleEnter(), this.handlePointerDown(e), this.handlePointerUp(e);
  }
  _forceFocusByCursorIndex(cursorIndex) {
    const richtext = this.currRt;
    if (!richtext) return;
    let x = 0,
      y1 = 0,
      y2 = 2,
      lineInfo = null,
      columnInfo = null;
    const data = this.computedCursorPosByCursorIdx(cursorIndex, richtext);
    x = data.x, y1 = data.y1, y2 = data.y2, lineInfo = data.lineInfo, columnInfo = data.columnInfo, this.onFocus({
      target: this.currRt
    }, {
      x: x,
      y1: y1,
      y2: y2,
      cursorIndex: cursorIndex,
      lineInfo: lineInfo,
      columnInfo: columnInfo
    });
  }
}

class DefaultGraphicAllocate {
  constructor() {
    this.pools = [];
  }
  free(d) {
    this.pools.push(d);
  }
  get length() {
    return this.pools.length;
  }
  release() {
    this.pools = [];
  }
}
class DefaultRectAllocate extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.rect(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(rect) {
    if (!this.pools.length) return application.graphicService.creator.rect(rect.attribute);
    const g = this.pools.pop();
    return g.initAttributes(rect.attribute), g;
  }
}
const defaultRectAllocate = new DefaultRectAllocate();
class DefaultArcAllocate extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.arc(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(arc) {
    if (!this.pools.length) return application.graphicService.creator.arc(arc.attribute);
    const g = this.pools.pop();
    return g.initAttributes(arc.attribute), g;
  }
}
const defaultArcAllocate = new DefaultArcAllocate();
class DefaultAreaAllocate extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.area(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(area) {
    if (!this.pools.length) return application.graphicService.creator.area(area.attribute);
    const g = this.pools.pop();
    return g.initAttributes(area.attribute), g;
  }
}
const defaultAreaAllocate = new DefaultAreaAllocate();
class DefaultCircleAllocate extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.circle(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(area) {
    if (!this.pools.length) return application.graphicService.creator.circle(area.attribute);
    const g = this.pools.pop();
    return g.initAttributes(area.attribute), g;
  }
}
const defaultCircleAllocate = new DefaultCircleAllocate();
class DefaultLineAllocate extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.line(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(line) {
    if (!this.pools.length) return application.graphicService.creator.line(line.attribute);
    const g = this.pools.pop();
    return g.initAttributes(line.attribute), g;
  }
}
const defaultLineAllocate = new DefaultLineAllocate();
class DefaultPathAllocate extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.path(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(path) {
    if (!this.pools.length) return application.graphicService.creator.path(path.attribute);
    const g = this.pools.pop();
    return g.initAttributes(path.attribute), g;
  }
}
const defaultPathAllocate = new DefaultPathAllocate();
class DefaultSymbolAllocate extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.symbol(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(symbol) {
    if (!this.pools.length) return application.graphicService.creator.symbol(symbol.attribute);
    const g = this.pools.pop();
    return g.initAttributes(symbol.attribute), g;
  }
}
const defaultSymbolAllocate = new DefaultSymbolAllocate();
class DefaultTextAllocate extends DefaultGraphicAllocate {
  allocate(attribute) {
    if (!this.pools.length) return application.graphicService.creator.text(attribute);
    const g = this.pools.pop();
    return g.initAttributes(attribute), g;
  }
  allocateByObj(text) {
    if (!this.pools.length) return application.graphicService.creator.text(text.attribute);
    const g = this.pools.pop();
    return g.initAttributes(text.attribute), g;
  }
}
const defaultTextAllocate = new DefaultTextAllocate();
class DefaultGraphicMemoryManager {
  constructor() {
    this.map = {
      text: defaultTextAllocate,
      symbol: defaultSymbolAllocate
    };
  }
  gc(g) {
    g.isContainer ? g.forEachChildren(i => this.gc(i)) : this.gcItem(g);
  }
  gcItem(g) {
    const allocate = this.map[g.type];
    allocate && allocate.free(g);
  }
}
const defaultGraphicMemoryManager = new DefaultGraphicMemoryManager();

let loadArcModule = !1;
const arcModule = new ContainerModule(bind => {
  loadArcModule || (loadArcModule = !0, bind(DefaultCanvasArcRender).toSelf().inSingletonScope(), bind(ArcRender).to(DefaultCanvasArcRender).inSingletonScope(), bind(GraphicRender).toService(ArcRender), bind(ArcRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ArcRenderContribution));
});

let loadRectModule = !1;
const rectModule = new ContainerModule(bind => {
  loadRectModule || (loadRectModule = !0, bind(DefaultCanvasRectRender).toSelf().inSingletonScope(), bind(RectRender).to(DefaultCanvasRectRender).inSingletonScope(), bind(GraphicRender).toService(RectRender), bind(SplitRectAfterRenderContribution).toSelf(), bind(SplitRectBeforeRenderContribution).toSelf(), bind(RectRenderContribution).toService(SplitRectAfterRenderContribution), bind(RectRenderContribution).toService(SplitRectBeforeRenderContribution), bind(RectRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, RectRenderContribution));
});

let loadLineModule = !1;
const lineModule = new ContainerModule(bind => {
  loadLineModule || (loadLineModule = !0, bind(DefaultCanvasLineRender).toSelf().inSingletonScope(), bind(DefaultIncrementalCanvasLineRender).toSelf().inSingletonScope(), bind(LineRender).to(DefaultCanvasLineRender).inSingletonScope(), bind(GraphicRender).toService(LineRender));
});

let loadAreaModule = !1;
const areaModule = new ContainerModule(bind => {
  loadAreaModule || (loadAreaModule = !0, bind(DefaultCanvasAreaRender).toSelf().inSingletonScope(), bind(AreaRender).to(DefaultCanvasAreaRender).inSingletonScope(), bind(GraphicRender).toService(AreaRender), bind(AreaRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, AreaRenderContribution), bind(DefaultIncrementalCanvasAreaRender).toSelf().inSingletonScope());
});

let loadSymbolModule = !1;
const symbolModule = new ContainerModule(bind => {
  loadSymbolModule || (loadSymbolModule = !0, bind(DefaultCanvasSymbolRender).toSelf().inSingletonScope(), bind(SymbolRender).to(DefaultCanvasSymbolRender).inSingletonScope(), bind(GraphicRender).toService(SymbolRender), bind(SymbolRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, SymbolRenderContribution));
});

let loadCircleModule = !1;
const circleModule = new ContainerModule(bind => {
  loadCircleModule || (loadCircleModule = !0, bind(DefaultCanvasCircleRender).toSelf().inSingletonScope(), bind(CircleRender).to(DefaultCanvasCircleRender).inSingletonScope(), bind(GraphicRender).toService(CircleRender), bind(CircleRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, CircleRenderContribution));
});

let loadTextModule = !1;
const textModule = new ContainerModule(bind => {
  loadTextModule || (loadTextModule = !0, bind(TextRender).to(DefaultCanvasTextRender).inSingletonScope(), bind(GraphicRender).toService(TextRender), bind(TextRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, TextRenderContribution));
});

let loadPathModule = !1;
const pathModule = new ContainerModule(bind => {
  loadPathModule || (loadPathModule = !0, bind(DefaultCanvasPathRender).toSelf().inSingletonScope(), bind(PathRender).to(DefaultCanvasPathRender).inSingletonScope(), bind(GraphicRender).toService(PathRender), bind(PathRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PathRenderContribution));
});

let loadPolygonModule = !1;
const polygonModule = new ContainerModule(bind => {
  loadPolygonModule || (loadPolygonModule = !0, bind(PolygonRender).to(DefaultCanvasPolygonRender).inSingletonScope(), bind(GraphicRender).toService(PolygonRender), bind(PolygonRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, PolygonRenderContribution));
});

var __decorate$1c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultCanvasGlyphRender = class {
  constructor() {
    this.numberType = GLYPH_NUMBER_TYPE;
  }
  drawShape(glyph, context, x, y, drawContext, params, fillCb, strokeCb) {
    drawContext.drawContribution && glyph.getSubGraphic().forEach(item => {
      const renderer = drawContext.drawContribution.getRenderContribution(item);
      renderer && renderer.drawShape && renderer.drawShape(item, context, x, y, drawContext, params, fillCb, strokeCb);
    });
  }
  draw(glyph, renderService, drawContext, params) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    if (context.highPerformanceSave(), !drawContext.drawContribution) return;
    const glyphTheme = getTheme(glyph),
      subGraphic = glyph.getSubGraphic();
    subGraphic.length && subGraphic.forEach(g => {
      drawContext.drawContribution.renderItem(g, drawContext, {
        theme: glyphTheme
      });
    }), context.highPerformanceRestore();
  }
};
DefaultCanvasGlyphRender = __decorate$1c([injectable()], DefaultCanvasGlyphRender);

let loadGlyphModule = !1;
const glyphModule = new ContainerModule(bind => {
  loadGlyphModule || (loadGlyphModule = !0, bind(GlyphRender).to(DefaultCanvasGlyphRender).inSingletonScope(), bind(GraphicRender).toService(GlyphRender));
});

var __decorate$1b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$W = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let DefaultCanvasRichTextRender = class extends BaseRender {
  constructor() {
    super(), this.numberType = RICHTEXT_NUMBER_TYPE, this.builtinContributions = [defaultTextBackgroundRenderContribution], this.init();
  }
  drawShape(richtext, context, x, y, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext,
      {
        strokeOpacity = richtextAttribute.strokeOpacity,
        opacity = richtextAttribute.opacity,
        fillOpacity = richtextAttribute.fillOpacity,
        visible = richtextAttribute.visible
      } = richtext.attribute;
    if (!richtext.valid || !visible) return;
    const fVisible = fillVisible(opacity, fillOpacity, !0),
      sVisible = fillVisible(opacity, strokeOpacity, !0);
    if (!fVisible) return;
    context.setShadowBlendStyle && context.setShadowBlendStyle(richtext, richtext.attribute, richtextAttribute), context.translate(x, y), this.beforeRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
    richtext.getFrameCache().draw(context, this.drawIcon), this.afterRenderStep(richtext, context, x, y, fVisible, sVisible, fVisible, sVisible, richtextAttribute, drawContext);
  }
  drawIcon(icon, context, x, y, baseline) {
    var _a;
    const richtextIconAttribute = getTheme(icon).richtextIcon,
      {
        width = richtextIconAttribute.width,
        height = richtextIconAttribute.height,
        opacity = richtextIconAttribute.opacity,
        image: url,
        backgroundFill = richtextIconAttribute.backgroundFill,
        backgroundFillOpacity = richtextIconAttribute.backgroundFillOpacity,
        backgroundStroke = richtextIconAttribute.backgroundStroke,
        backgroundStrokeOpacity = richtextIconAttribute.backgroundStrokeOpacity,
        backgroundRadius = richtextIconAttribute.backgroundRadius,
        margin: margin
      } = icon.attribute,
      {
        backgroundWidth = width,
        backgroundHeight = height
      } = icon.attribute;
    if (margin && (x += icon._marginArray[3], y += icon._marginArray[0]), icon._hovered) {
      const expandX = (backgroundWidth - width) / 2,
        expandY = (backgroundHeight - height) / 2;
      0 === backgroundRadius ? (context.beginPath(), context.rect(x - expandX, y - expandY, backgroundWidth, backgroundHeight)) : (context.beginPath(), createRectPath(context, x - expandX, y - expandY, backgroundWidth, backgroundHeight, backgroundRadius, !0)), backgroundFill && (context.globalAlpha = backgroundFillOpacity, context.fillStyle = backgroundFill, context.fill()), backgroundStroke && (context.globalAlpha = backgroundStrokeOpacity, context.strokeStyle = backgroundStroke, context.stroke());
    }
    const res = url && (null === (_a = null == icon ? void 0 : icon.resources) || void 0 === _a ? void 0 : _a.get(url));
    res && "success" === res.state && (context.globalAlpha = opacity, context.drawImage(res.data, x, y, width, height));
  }
  draw(richtext, renderService, drawContext) {
    const richtextAttribute = getTheme(richtext).richtext;
    this._draw(richtext, richtextAttribute, !1, drawContext);
  }
};
DefaultCanvasRichTextRender = __decorate$1b([injectable(), __metadata$W("design:paramtypes", [])], DefaultCanvasRichTextRender);

let loadRichtextModule = !1;
const richtextModule = new ContainerModule(bind => {
  loadRichtextModule || (loadRichtextModule = !0, bind(RichTextRender).to(DefaultCanvasRichTextRender).inSingletonScope(), bind(GraphicRender).toService(RichTextRender));
});

let loadImageModule = !1;
const imageModule = new ContainerModule(bind => {
  loadImageModule || (loadImageModule = !0, bind(ImageRender).to(DefaultCanvasImageRender).inSingletonScope(), bind(GraphicRender).toService(ImageRender), bind(ImageRenderContribution).toService(DefaultBaseInteractiveRenderContribution), bindContributionProvider(bind, ImageRenderContribution));
});

class Base3dRender extends BaseRender {
  stroke(x, y, z, face3d, context) {
    const vertices = face3d.vertices;
    face3d.edges.forEach(edge => {
      const p1 = vertices[edge[0]],
        v1 = {
          x: x + p1[0],
          y: y + p1[1],
          z: z + p1[2]
        },
        p2 = vertices[edge[1]],
        v2 = {
          x: x + p2[0],
          y: y + p2[1],
          z: z + p2[2]
        };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.stroke();
    });
  }
  fill(x, y, z, face3d, faces, fillColor, context, light, graphic3d, graphic3dAttribute, fillCb) {
    const rgbArray = ColorStore.Get(fillColor, ColorType.Color255),
      vertices = face3d.vertices,
      viewdVerticesZ = vertices.map(v => context.view(v[0], v[1], v[2])[2]),
      sortFace = [];
    face3d.polygons.forEach((p, i) => {
      if (faces && !faces[i]) return;
      sortFace.push({
        faceIdx: i,
        polygon: p
      });
      const {
          polygon: polygon
        } = p,
        z1 = viewdVerticesZ[polygon[0]],
        z2 = viewdVerticesZ[polygon[1]],
        z3 = viewdVerticesZ[polygon[2]],
        z4 = viewdVerticesZ[polygon[3]];
      p.ave_z = z1 + z2 + z3 + z4;
    }), sortFace.sort((a, b) => b.polygon.ave_z - a.polygon.ave_z), sortFace.forEach(item => {
      const {
          polygon: polygon,
          normal: normal
        } = item.polygon,
        p1 = vertices[polygon[0]],
        p2 = vertices[polygon[1]],
        p3 = vertices[polygon[2]],
        p4 = vertices[polygon[3]],
        v1 = {
          x: x + p1[0],
          y: y + p1[1],
          z: z + p1[2]
        },
        v2 = {
          x: x + p2[0],
          y: y + p2[1],
          z: z + p2[2]
        },
        v3 = {
          x: x + p3[0],
          y: y + p3[1],
          z: z + p3[2]
        },
        v4 = {
          x: x + p4[0],
          y: y + p4[1],
          z: z + p4[2]
        };
      context.beginPath(), context.moveTo(v1.x, v1.y, v1.z), context.lineTo(v2.x, v2.y, v2.z), context.lineTo(v3.x, v3.y, v3.z), context.lineTo(v4.x, v4.y, v4.z), context.closePath(), fillCb ? fillCb(context, graphic3d && graphic3d.attribute, graphic3dAttribute) : (context.fillStyle = light ? light.computeColor(normal, rgbArray) : fillColor, context.fill());
    });
  }
}

var __decorate$1a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultCanvasRect3dRender = class extends Base3dRender {
  constructor() {
    super(...arguments), this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE;
  }
  drawShape(rect, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a;
    const rectAttribute = getTheme(rect, null == params ? void 0 : params.theme).rect,
      {
        fill = rectAttribute.fill,
        stroke = rectAttribute.stroke,
        x1: x1,
        y1: y1,
        x: originX,
        y: originY,
        opacity = rectAttribute.opacity,
        fillOpacity = rectAttribute.fillOpacity,
        lineWidth = rectAttribute.lineWidth,
        strokeOpacity = rectAttribute.strokeOpacity,
        visible = rectAttribute.visible
      } = rect.attribute;
    let {
      width: width,
      height: height
    } = rect.attribute;
    width = (null != width ? width : x1 - originX) || 0, height = (null != height ? height : y1 - originY) || 0;
    const z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
      fVisible = rectFillVisible(opacity, fillOpacity, width, height, fill),
      sVisible = rectStrokeVisible(opacity, strokeOpacity, width, height),
      doFill = runFill(fill),
      doStroke = runStroke(stroke, lineWidth);
    if (!rect.valid || !visible) return;
    if (!doFill && !doStroke) return;
    if (!(fVisible || sVisible || fillCb || strokeCb)) return;
    const {
        light: light
      } = drawContext.stage || {},
      face3d = rect.findFace();
    if (!1 !== fill) {
      context.setCommonStyle(rect, rect.attribute, x, y, rectAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, null, fc, context, light, null, null, fillCb);
    }
    !1 !== stroke && (context.setStrokeStyle(rect, rect.attribute, x, y, rectAttribute), this.stroke(x, y, z, face3d, context));
  }
  draw(rect, renderService, drawContext) {
    const rectAttribute = getTheme(rect).rect;
    this._draw(rect, rectAttribute, !1, drawContext);
  }
};
DefaultCanvasRect3dRender = __decorate$1a([injectable()], DefaultCanvasRect3dRender);

let loadRect3dModule = !1;
const rect3dModule = new ContainerModule(bind => {
  loadRect3dModule || (loadRect3dModule = !0, bind(Rect3DRender).to(DefaultCanvasRect3dRender).inSingletonScope(), bind(GraphicRender).toService(Rect3DRender));
});

var __decorate$19 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function drawArcPath(arc, context, cx, cy, z, outerRadius, innerRadius) {
  const {
      startAngle: startAngle,
      endAngle: endAngle
    } = arc.getParsedAngle(),
    deltaAngle = abs(endAngle - startAngle),
    clockwise = endAngle > startAngle;
  let collapsedToLine = !1;
  if (outerRadius < innerRadius) {
    const temp = outerRadius;
    outerRadius = innerRadius, innerRadius = temp;
  }
  if (outerRadius <= epsilon) context.moveTo(cx, cy, z);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + outerRadius * cos(startAngle), cy + outerRadius * sin(startAngle), z), context.arc(cx, cy, outerRadius, startAngle, endAngle, !clockwise, z), innerRadius > epsilon && (context.moveTo(cx + innerRadius * cos(endAngle), cy + innerRadius * sin(endAngle), z), context.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise, z));else {
    const {
        outerDeltaAngle: outerDeltaAngle,
        innerDeltaAngle: innerDeltaAngle,
        outerStartAngle: outerStartAngle,
        outerEndAngle: outerEndAngle,
        innerEndAngle: innerEndAngle,
        innerStartAngle: innerStartAngle
      } = arc.getParsePadAngle(startAngle, endAngle),
      xors = outerRadius * cos(outerStartAngle),
      yors = outerRadius * sin(outerStartAngle),
      xire = innerRadius * cos(innerEndAngle),
      yire = innerRadius * sin(innerEndAngle);
    outerDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z), context.arc(cx, cy, outerRadius, outerStartAngle, outerEndAngle, !clockwise, z)), !(innerRadius > epsilon) || innerDeltaAngle < .001 ? (context.lineTo(cx + xire, cy + yire, z), collapsedToLine = !0) : (context.lineTo(cx + xire, cy + yire, z), context.arc(cx, cy, innerRadius, innerEndAngle, innerStartAngle, clockwise, z));
  }
  return context.closePath(), collapsedToLine;
}
function drawInnerOuterArcPath(arc, context, cx, cy, z1, z2, radius, getParsePadAngle) {
  const {
      startAngle: startAngle,
      endAngle: endAngle
    } = arc.getParsedAngle(),
    deltaAngle = abs(endAngle - startAngle),
    clockwise = endAngle > startAngle;
  let collapsedToLine = !1;
  if (radius <= epsilon) context.moveTo(cx, cy, z1);else if (deltaAngle >= pi2 - epsilon) context.moveTo(cx + radius * cos(startAngle), cy + radius * sin(startAngle), z1), context.arc(cx, cy, radius, startAngle, endAngle, !clockwise, z1), context.lineTo(cx + radius * cos(endAngle), cy + radius * sin(endAngle), z2), context.arc(cx, cy, radius, endAngle, startAngle, clockwise, z2);else {
    const {
        innerouterDeltaAngle: innerouterDeltaAngle,
        innerouterStartAngle: innerouterStartAngle,
        innerouterEndAngle: innerouterEndAngle
      } = getParsePadAngle(startAngle, endAngle),
      xors = radius * cos(innerouterStartAngle),
      yors = radius * sin(innerouterStartAngle),
      xore = radius * cos(innerouterEndAngle),
      yore = radius * sin(innerouterEndAngle);
    innerouterDeltaAngle < .001 ? collapsedToLine = !0 : (context.moveTo(cx + xors, cy + yors, z1), context.arc(cx, cy, radius, innerouterStartAngle, innerouterEndAngle, !clockwise, z1), context.lineTo(cx + xore, cy + yore, z2), context.arc(cx, cy, radius, innerouterEndAngle, innerouterStartAngle, clockwise, z2));
  }
  return context.closePath(), collapsedToLine;
}
let DefaultCanvasArc3DRender = class extends BaseRender {
  constructor() {
    super(...arguments), this.numberType = ARC3D_NUMBER_TYPE;
  }
  drawShape(arc, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a;
    const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc,
      {
        fill = arcAttribute.fill
      } = arc.attribute,
      data = this.valid(arc, arcAttribute, fillCb, strokeCb);
    if (!data) return;
    const {
        fVisible: fVisible,
        sVisible: sVisible,
        doFill: doFill,
        doStroke: doStroke
      } = data,
      z = null !== (_a = this.z) && void 0 !== _a ? _a : 0,
      {
        outerPadding = arcAttribute.outerPadding,
        innerPadding = arcAttribute.innerPadding,
        height = 10
      } = arc.attribute;
    let {
      outerRadius = arcAttribute.outerRadius,
      innerRadius = arcAttribute.innerRadius
    } = arc.attribute;
    outerRadius += outerPadding, innerRadius -= innerPadding;
    const rgbArray = ColorStore.Get(fill, ColorType.Color255),
      {
        light: light
      } = drawContext.stage || {},
      face = drawContext.hack_pieFace,
      z_face = {
        top: z,
        bottom: z + height
      },
      n_face = {
        top: [0, 1, 0],
        bottom: [0, -1, 0],
        outside: [1, 0, -1],
        inside: [1, 0, -1]
      };
    "bottom" === face || "top" === face ? (context.beginPath(), drawArcPath(arc, context, x, y, z_face[face], outerRadius, innerRadius), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke()))) : "outside" !== face && "inside" !== face || ("inside" === face && (context.save(), context.beginPath(), context.arc(x, y, innerRadius, 0, pi2, !0, z_face.top), context.clip()), context.beginPath(), drawInnerOuterArcPath(arc, context, x, y, z_face.top, z_face.bottom, "outside" === face ? outerRadius : innerRadius, (startAngle, endAngle) => {
      const {
        outerDeltaAngle: outerDeltaAngle,
        innerDeltaAngle: innerDeltaAngle,
        outerStartAngle: outerStartAngle,
        outerEndAngle: outerEndAngle,
        innerEndAngle: innerEndAngle,
        innerStartAngle: innerStartAngle
      } = arc.getParsePadAngle(startAngle, endAngle);
      return "outside" === face ? {
        innerouterDeltaAngle: outerDeltaAngle,
        innerouterEndAngle: outerEndAngle,
        innerouterStartAngle: outerStartAngle
      } : {
        innerouterDeltaAngle: innerDeltaAngle,
        innerouterEndAngle: innerEndAngle,
        innerouterStartAngle: innerStartAngle
      };
    }), context.setShadowBlendStyle && context.setShadowBlendStyle(arc, arc.attribute, arcAttribute), doFill && (fillCb ? fillCb(context, arc.attribute, arcAttribute) : fVisible && (context.setCommonStyle(arc, arc.attribute, x, y, arcAttribute), context.fillStyle = light ? light.computeColor(n_face[face], rgbArray) : fill, context.fill())), doStroke && (strokeCb ? strokeCb(context, arc.attribute, arcAttribute) : sVisible && (context.setStrokeStyle(arc, arc.attribute, x, y, arcAttribute), context.stroke())), "inside" === face && context.restore());
  }
  draw(arc, renderService, drawContext, params) {
    const arcAttribute = getTheme(arc, null == params ? void 0 : params.theme).arc;
    this._draw(arc, arcAttribute, !1, drawContext, params);
  }
};
DefaultCanvasArc3DRender = __decorate$19([injectable()], DefaultCanvasArc3DRender);

let loadArc3dModule = !1;
const arc3dModule = new ContainerModule(bind => {
  loadArc3dModule || (loadArc3dModule = !0, bind(Arc3dRender).to(DefaultCanvasArc3DRender).inSingletonScope(), bind(GraphicRender).toService(Arc3dRender));
});

var __decorate$18 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultCanvasPyramid3dRender = class extends Base3dRender {
  constructor() {
    super(...arguments), this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE;
  }
  drawShape(pyramid3d, context, x, y, drawContext, params, fillCb, strokeCb) {
    var _a;
    const pyramidAttribute = getTheme(pyramid3d, null == params ? void 0 : params.theme).polygon,
      {
        fill = pyramidAttribute.fill,
        stroke = pyramidAttribute.stroke,
        face = [!0, !0, !0, !0, !0, !0]
      } = pyramid3d.attribute,
      z = null !== (_a = this.z) && void 0 !== _a ? _a : 0;
    if (!this.valid(pyramid3d, pyramidAttribute, fillCb, strokeCb)) return;
    const {
        light: light
      } = drawContext.stage || {},
      face3d = pyramid3d.findFace();
    if (!1 !== fill) {
      context.setCommonStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute);
      let fc = fill;
      "string" != typeof fc && (fc = "black"), this.fill(x, y, z, face3d, face, fc, context, light, pyramid3d, pyramidAttribute, fillCb);
    }
    !1 !== stroke && (context.setStrokeStyle(pyramid3d, pyramid3d.attribute, x, y, pyramidAttribute), this.stroke(x, y, z, face3d, context));
  }
  draw(pyramid3d, renderService, drawContext) {
    const pyramid3dAttribute = getTheme(pyramid3d).polygon;
    this._draw(pyramid3d, pyramid3dAttribute, !1, drawContext);
  }
};
DefaultCanvasPyramid3dRender = __decorate$18([injectable()], DefaultCanvasPyramid3dRender);

let loadPyramid3dModule = !1;
const pyramid3dModule = new ContainerModule(bind => {
  loadPyramid3dModule || (loadPyramid3dModule = !0, bind(Pyramid3dRender).to(DefaultCanvasPyramid3dRender).inSingletonScope(), bind(GraphicRender).toService(Pyramid3dRender));
});

function registerArcGraphic() {
  graphicCreator.RegisterGraphicCreator("arc", createArc);
}

function registerArc3dGraphic() {
  graphicCreator.RegisterGraphicCreator("arc3d", createArc3d);
}

function registerAreaGraphic() {
  graphicCreator.RegisterGraphicCreator("area", createArea);
}

function registerCircleGraphic() {
  graphicCreator.RegisterGraphicCreator("circle", createCircle);
}

function registerGlyphGraphic() {
  graphicCreator.RegisterGraphicCreator("glyph", createGlyph);
}

function registerGroupGraphic() {
  graphicCreator.RegisterGraphicCreator("group", createGroup);
}

function registerImageGraphic() {
  graphicCreator.RegisterGraphicCreator("image", createImage);
}

function registerLineGraphic() {
  graphicCreator.RegisterGraphicCreator("line", createLine);
}

function registerPathGraphic() {
  graphicCreator.RegisterGraphicCreator("path", createPath);
}

function registerPolygonGraphic() {
  graphicCreator.RegisterGraphicCreator("polygon", createPolygon);
}

function registerPyramid3dGraphic() {
  graphicCreator.RegisterGraphicCreator("pyramid3d", createPyramid3d);
}

function registerRectGraphic() {
  graphicCreator.RegisterGraphicCreator("rect", createRect);
}

function registerRect3dGraphic() {
  graphicCreator.RegisterGraphicCreator("rect3d", createRect3d);
}

function registerRichtextGraphic() {
  graphicCreator.RegisterGraphicCreator("richtext", createRichText);
}

function registerSymbolGraphic() {
  graphicCreator.RegisterGraphicCreator("symbol", createSymbol);
}

function registerTextGraphic() {
  graphicCreator.RegisterGraphicCreator("text", createText);
}

function registerShadowRootGraphic() {
  graphicCreator.RegisterGraphicCreator("shadowRoot", createShadowRoot);
}

function registerWrapTextGraphic() {
  graphicCreator.RegisterGraphicCreator("wrapText", createWrapText);
}

class HtmlAttributePlugin {
  constructor() {
    this.name = "HtmlAttributePlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.htmlMap = {}, this.renderId = 0, this.onWheel = ev => {
      try {
        const newEvent = new ev.constructor(ev.type, ev);
        this.pluginService.stage.window.getContext().getCanvas().nativeCanvas.dispatchEvent(newEvent);
      } catch (err) {
        return;
      }
    };
  }
  activate(context) {
    this.pluginService = context, context.stage.hooks.afterRender.tap(this.key, stage => {
      stage && stage === this.pluginService.stage && this.drawHTML([...context.stage.getChildren()]);
    });
  }
  deactivate(context) {
    context.stage.hooks.afterRender.taps = context.stage.hooks.afterRender.taps.filter(item => item.name !== this.key), application.graphicService.hooks.onRemove.unTap(this.key), application.graphicService.hooks.onRelease.unTap(this.key), this.release();
  }
  getWrapContainer(stage, userContainer, domParams) {
    let nativeContainer;
    return nativeContainer = userContainer ? "string" == typeof userContainer ? application.global.getElementById(userContainer) : userContainer : stage.window.getContainer(), {
      wrapContainer: application.global.createDom(Object.assign({
        tagName: "div",
        parent: nativeContainer
      }, domParams)),
      nativeContainer: nativeContainer
    };
  }
  parseDefaultStyleFromGraphic(graphic) {
    const attrs = "text" === graphic.type && graphic.attribute ? graphic.attribute : getTheme(graphic).text;
    return textAttributesToStyle(attrs);
  }
  getTransformOfText(graphic) {
    const textTheme = getTheme(graphic).text,
      {
        textAlign = textTheme.textAlign,
        textBaseline = textTheme.textBaseline
      } = graphic.attribute,
      cssAttrs = graphic.globalTransMatrix.toTransformAttrs(),
      {
        rotateDeg: rotateDeg,
        scaleX: scaleX,
        scaleY: scaleY
      } = cssAttrs,
      translateMap = {
        left: "0",
        start: "0",
        end: "-100%",
        center: "-50%",
        right: "-100%",
        top: "0",
        middle: "-50%",
        bottom: "-100%",
        alphabetic: "-79%"
      },
      originMap = {
        left: "0",
        start: "0",
        end: "100%",
        center: "50%",
        right: "100%",
        top: "0",
        middle: "50%",
        bottom: "100%",
        alphabetic: "79%"
      };
    return {
      textAlign: textAlign,
      transform: `translate(${translateMap[textAlign]},${translateMap[textBaseline]}) rotate(${rotateDeg}deg) scaleX(${scaleX}) scaleY(${scaleY})`,
      transformOrigin: `${originMap[textAlign]} ${originMap[textBaseline]}`
    };
  }
  updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, options) {
    const {
      pointerEvents: pointerEvents,
      penetrateEventList = []
    } = options;
    let calculateStyle = this.parseDefaultStyleFromGraphic(graphic);
    calculateStyle.display = !1 !== graphic.attribute.visible ? "block" : "none", calculateStyle.pointerEvents = !0 === pointerEvents ? "all" : pointerEvents || "none", "none" !== calculateStyle.pointerEvents && (this.removeWrapContainerEventListener(wrapContainer), penetrateEventList.forEach(event => {
      "wheel" === event && wrapContainer.addEventListener("wheel", this.onWheel);
    })), wrapContainer.style.position || (wrapContainer.style.position = "absolute", nativeContainer.style.position = "relative");
    let left = 0,
      top = 0;
    const b = graphic.globalAABBBounds;
    let anchorType = options.anchorType;
    if (isNil$1(anchorType) && (anchorType = "text" === graphic.type ? "position" : "boundsLeftTop"), "boundsLeftTop" === anchorType && (anchorType = "top-left"), "position" === anchorType || b.empty()) {
      const matrix = graphic.globalTransMatrix;
      left = matrix.e, top = matrix.f;
    } else {
      const anchor = calculateAnchorOfBounds(b, anchorType);
      left = anchor.x, top = anchor.y;
    }
    const containerTL = application.global.getElementTopLeft(nativeContainer, !1),
      windowTL = stage.window.getTopLeft(!1),
      viewBox = stage.viewBox,
      offsetX = left + windowTL.left - containerTL.left + viewBox.x1,
      offsetTop = top + windowTL.top - containerTL.top + viewBox.y1;
    if (calculateStyle.left = `${offsetX}px`, calculateStyle.top = `${offsetTop}px`, "text" === graphic.type && "position" === anchorType && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), this.getTransformOfText(graphic))), isFunction$1(options.style)) {
      const userStyle = options.style({
        top: offsetTop,
        left: offsetX,
        width: b.width(),
        height: b.height()
      }, graphic, wrapContainer);
      userStyle && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), userStyle));
    } else isObject$1(options.style) ? calculateStyle = Object.assign(Object.assign({}, calculateStyle), options.style) : isString$1(options.style) && options.style && (calculateStyle = Object.assign(Object.assign({}, calculateStyle), styleStringToObject(options.style)));
    application.global.updateDom(wrapContainer, {
      width: options.width,
      height: options.height,
      style: calculateStyle
    });
  }
  clearCacheContainer() {
    this.htmlMap && Object.keys(this.htmlMap).forEach(key => {
      this.htmlMap[key] && this.htmlMap[key].renderId !== this.renderId && this.removeElement(key);
    }), this.renderId += 1;
  }
  drawHTML(layers) {
    "browser" === application.global.env && (layers.sort((a, b) => {
      var _a, _b;
      return (null !== (_a = a.attribute.zIndex) && void 0 !== _a ? _a : DefaultAttribute.zIndex) - (null !== (_b = b.attribute.zIndex) && void 0 !== _b ? _b : DefaultAttribute.zIndex);
    }).forEach(group => {
      this.renderGroupHTML(group);
    }), this.clearCacheContainer());
  }
  renderGroupHTML(group) {
    this.renderGraphicHTML(group), group.forEachChildren(g => {
      g.isContainer ? this.renderGroupHTML(g) : this.renderGraphicHTML(g);
    });
  }
  removeElement(id) {
    if (!this.htmlMap || !this.htmlMap[id]) return;
    const {
      wrapContainer: wrapContainer
    } = this.htmlMap[id];
    wrapContainer && application.global.removeDom(wrapContainer), this.htmlMap[id] = null;
  }
  removeWrapContainerEventListener(wrapContainer) {
    wrapContainer.removeEventListener("wheel", this.onWheel);
  }
  renderGraphicHTML(graphic) {
    var _a;
    const {
      html: html
    } = graphic.attribute;
    if (!html) return;
    const stage = graphic.stage;
    if (!stage) return;
    const {
      dom: dom,
      container: container
    } = html;
    if (!dom) return;
    const id = isNil$1(html.id) ? `${null !== (_a = graphic.id) && void 0 !== _a ? _a : graphic._uid}_react` : html.id;
    if (this.htmlMap && this.htmlMap[id] && container && container !== this.htmlMap[id].container && this.removeElement(id), this.htmlMap && this.htmlMap[id]) "string" == typeof dom ? this.htmlMap[id].wrapContainer.innerHTML = dom : dom !== this.htmlMap[id].wrapContainer.firstChild && (this.htmlMap[id].wrapContainer.removeChild(this.htmlMap[id].wrapContainer.firstChild), this.htmlMap[id].wrapContainer.appendChild(dom));else {
      const {
        wrapContainer: wrapContainer,
        nativeContainer: nativeContainer
      } = this.getWrapContainer(stage, container);
      wrapContainer && ("string" == typeof dom ? wrapContainer.innerHTML = dom : wrapContainer.appendChild(dom), this.htmlMap || (this.htmlMap = {}), this.htmlMap[id] = {
        wrapContainer: wrapContainer,
        nativeContainer: nativeContainer,
        container: container,
        renderId: this.renderId
      });
    }
    if (!this.htmlMap || !this.htmlMap[id]) return;
    const {
      wrapContainer: wrapContainer,
      nativeContainer: nativeContainer
    } = this.htmlMap[id];
    this.updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, html), this.htmlMap[id].renderId = this.renderId;
  }
  release() {
    "browser" === application.global.env && this.removeAllDom(this.pluginService.stage.defaultLayer);
  }
  removeAllDom(g) {
    this.htmlMap && (Object.keys(this.htmlMap).forEach(key => {
      this.removeElement(key);
    }), this.htmlMap = null);
  }
}
const registerHtmlAttributePlugin = () => {
  Factory.registerPlugin("HtmlAttributePlugin", HtmlAttributePlugin);
};

class ReactAttributePlugin extends HtmlAttributePlugin {
  constructor() {
    super(...arguments), this.name = "ReactAttributePlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.htmlMap = {};
  }
  removeElement(id) {
    if (!this.htmlMap || !this.htmlMap[id]) return;
    const {
      root: root,
      wrapContainer: wrapContainer,
      unmount: unmount
    } = this.htmlMap[id];
    if (root) {
      application.global.getRequestAnimationFrame()(() => {
        root.unmount();
      });
    } else unmount && unmount();
    wrapContainer && application.global.removeDom(wrapContainer), this.htmlMap[id] = null;
  }
  renderGraphicHTML(graphic) {
    var _a;
    const {
      react: react
    } = graphic.attribute;
    if (!react) return;
    const stage = graphic.stage;
    if (!stage) return;
    const ReactDOM = stage.params.ReactDOM,
      {
        element: element,
        container: container
      } = react;
    if (!element || !ReactDOM || !ReactDOM.createRoot && !ReactDOM.render) return;
    const id = isNil$1(react.id) ? `${null !== (_a = graphic.id) && void 0 !== _a ? _a : graphic._uid}_react` : react.id;
    if (this.htmlMap && this.htmlMap[id] && container && container !== this.htmlMap[id].container && this.removeElement(id), this.htmlMap && this.htmlMap[id]) ReactDOM.createRoot ? this.htmlMap[id].root.render(element) : ReactDOM.render(element, this.htmlMap[id].wrapContainer);else {
      const {
        wrapContainer: wrapContainer,
        nativeContainer: nativeContainer
      } = this.getWrapContainer(stage, container);
      if (wrapContainer) if (this.htmlMap || (this.htmlMap = {}), ReactDOM.createRoot) {
        const root = ReactDOM.createRoot(wrapContainer);
        root.render(element), this.htmlMap[id] = {
          root: root,
          wrapContainer: wrapContainer,
          nativeContainer: nativeContainer,
          container: container,
          renderId: this.renderId
        };
      } else ReactDOM.render(element, wrapContainer), this.htmlMap[id] = {
        wrapContainer: wrapContainer,
        nativeContainer: nativeContainer,
        container: container,
        renderId: this.renderId,
        unmount: () => {
          ReactDOM.unmountComponentAtNode(wrapContainer);
        }
      };
    }
    if (!this.htmlMap || !this.htmlMap[id]) return;
    const {
      wrapContainer: wrapContainer,
      nativeContainer: nativeContainer
    } = this.htmlMap[id];
    this.updateStyleOfWrapContainer(graphic, stage, wrapContainer, nativeContainer, react), this.htmlMap[id].renderId = this.renderId;
  }
}
const registerReactAttributePlugin = () => {
  Factory.registerPlugin("ReactAttributePlugin", ReactAttributePlugin);
};

class ViewTransform3dPlugin {
  constructor() {
    this.name = "ViewTransform3dPlugin", this.activeEvent = "onRegister", this._uid = Generator.GenAutoIncrementId(), this.key = this.name + this._uid, this.onMouseDown = e => {
      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !0, this.pageX = e.page.x, this.pageY = e.page.y);
    }, this.onMouseUp = e => {
      this.option3d || (this.option3d = this.pluginService.stage.option3d), this.option3d && (this.mousedown = !1);
    }, this.onMouseMove = e => {
      var _a, _b;
      const stage = this.pluginService.stage;
      if (this.option3d || (this.option3d = stage.option3d), this.option3d && this.mousedown) if (this.pageX && this.pageY) {
        const deltaX = e.page.x - this.pageX,
          deltaY = e.page.y - this.pageY;
        this.pageX = e.page.x, this.pageY = e.page.y;
        const angle1 = deltaX / 100,
          angle2 = deltaY / 100;
        this.option3d.alpha = (null !== (_a = this.option3d.alpha) && void 0 !== _a ? _a : 0) + angle1, this.option3d.beta = (null !== (_b = this.option3d.beta) && void 0 !== _b ? _b : 0) + angle2, stage.set3dOptions(this.option3d), stage.renderNextFrame();
      } else this.pageX = e.page.x, this.pageY = e.page.y;
    };
  }
  activate(context) {
    this.pluginService = context;
    const stage = context.stage;
    this.option3d = stage.option3d, stage.addEventListener("mousedown", this.onMouseDown), stage.addEventListener("mouseup", this.onMouseUp), stage.addEventListener("mousemove", this.onMouseMove);
  }
  deactivate(context) {
    const stage = context.stage;
    stage.removeEventListener("mousedown", this.onMouseDown), stage.removeEventListener("mouseup", this.onMouseUp), stage.removeEventListener("mousemove", this.onMouseMove);
  }
}
const registerViewTransform3dPlugin = () => {
  Factory.registerPlugin("ViewTransform3dPlugin", ViewTransform3dPlugin);
};

const _tempBounds = new AABBBounds();
class FlexLayoutPlugin {
  constructor() {
    this.name = "FlexLayoutPlugin", this.activeEvent = "onRegister", this.id = Generator.GenAutoIncrementId(), this.key = this.name + this.id, this.tempBounds = new AABBBounds();
  }
  pauseLayout(p) {
    this.pause = p;
  }
  tryLayoutChildren(graphic) {
    graphic.firstChild && this.tryLayout(graphic.firstChild);
  }
  tryLayout(graphic) {
    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    if (this.pause) return;
    const p = graphic.parent;
    if (!(force || p && graphic.needUpdateLayout())) return;
    const theme = getTheme(p).group,
      {
        display = theme.display
      } = p.attribute;
    if ("flex" !== display) return;
    const {
        flexDirection = theme.flexDirection,
        flexWrap = theme.flexWrap,
        alignItems = theme.alignItems,
        clip = theme.clip
      } = p.attribute,
      {
        alignContent = null != alignItems ? alignItems : theme.alignContent
      } = p.attribute;
    let {
      width: width,
      height: height,
      justifyContent = theme.justifyContent
    } = p.attribute;
    const children = p.getChildren();
    if (null == width || null == height) {
      let childrenWidth = 0,
        childrenHeight = 0,
        boundsLegal = 0;
      if (children.forEach(child => {
        const bounds = this.getAABBBounds(child);
        bounds.empty() || ("column" === flexDirection || "column-reverse" === flexDirection ? (childrenHeight += bounds.height(), childrenWidth = Math.max(childrenWidth, bounds.width())) : (childrenWidth += bounds.width(), childrenHeight = Math.max(childrenHeight, bounds.height())), boundsLegal += bounds.x1, boundsLegal += bounds.y1, boundsLegal += bounds.x2, boundsLegal += bounds.y2);
      }), !isFinite(boundsLegal)) return;
      width = childrenWidth, height = childrenHeight;
    }
    null == p.attribute.width ? p.attribute.width = width : width = p.attribute.width, null == p.attribute.height ? p.attribute.height = height : height = p.attribute.height, this.tempBounds.copy(p._AABBBounds);
    const result = {
        main: {
          len: width,
          field: "x"
        },
        cross: {
          len: height,
          field: "y"
        }
      },
      main = result.main,
      cross = result.cross;
    "column" !== flexDirection && "column-reverse" !== flexDirection || (main.len = height, cross.len = width, main.field = "y", cross.field = "x"), "row-reverse" !== flexDirection && "column-reverse" !== flexDirection || ("flex-start" === justifyContent ? justifyContent = "flex-end" : "flex-end" === justifyContent ? justifyContent = "flex-start" : children.reverse());
    let mainLen = 0,
      crossLen = 0;
    const mianLenArray = [];
    children.forEach(c => {
      const b = this.getAABBBounds(c);
      if (b.empty()) return;
      const ml = "x" === main.field ? b.width() : b.height(),
        cl = "x" === cross.field ? b.width() : b.height();
      mianLenArray.push({
        mainLen: ml,
        crossLen: cl
      }), mainLen += ml, crossLen = Math.max(crossLen, cl);
    });
    const mainList = [];
    if (mainLen > main.len && "wrap" === flexWrap) {
      let tempMainL = 0,
        tempCrossL = 0;
      mianLenArray.forEach((_ref, i) => {
        let {
          mainLen: mainLen,
          crossLen: crossLen
        } = _ref;
        tempMainL + mainLen > main.len ? 0 === tempMainL ? (mainList.push({
          idx: i,
          mainLen: tempMainL + mainLen,
          crossLen: crossLen
        }), tempMainL = 0, tempCrossL = 0) : (mainList.push({
          idx: i - 1,
          mainLen: tempMainL,
          crossLen: tempCrossL
        }), tempMainL = mainLen, tempCrossL = crossLen) : (tempMainL += mainLen, tempCrossL = Math.max(tempCrossL, crossLen));
      }), mainList.push({
        idx: mianLenArray.length - 1,
        mainLen: tempMainL,
        crossLen: tempCrossL
      });
    } else mainList.push({
      idx: mianLenArray.length - 1,
      mainLen: mainLen,
      crossLen: crossLen
    });
    let lastIdx = 0;
    if (mainList.forEach(s => {
      this.layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, s), lastIdx = s.idx + 1;
    }), crossLen = mainList.reduce((a, b) => a + b.crossLen, 0), 1 === mainList.length) {
      const anchorPosMap = {
        "flex-start": 0,
        "flex-end": cross.len,
        center: cross.len / 2
      };
      this.layoutCross(children, alignItems, cross, anchorPosMap, mianLenArray, mainList[0], 0);
    } else if ("flex-start" === alignContent) {
      lastIdx = 0;
      let anchorPos = 0;
      mainList.forEach((s, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s.crossLen,
          center: anchorPos + s.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen;
      });
    } else if ("center" === alignContent) {
      lastIdx = 0;
      let anchorPos = Math.max(0, (cross.len - crossLen) / 2);
      mainList.forEach((s, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s.crossLen,
          center: anchorPos + s.crossLen / 2
        };
        this.layoutCross(children, "center", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen;
      });
    } else if ("space-around" === alignContent) {
      lastIdx = 0;
      const padding = Math.max(0, (cross.len - crossLen) / mainList.length / 2);
      let anchorPos = padding;
      mainList.forEach((s, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s.crossLen,
          center: anchorPos + s.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen + 2 * padding;
      });
    } else if ("space-between" === alignContent) {
      lastIdx = 0;
      const padding = Math.max(0, (cross.len - crossLen) / (2 * mainList.length - 2));
      let anchorPos = 0;
      mainList.forEach((s, i) => {
        const anchorPosMap = {
          "flex-start": anchorPos,
          "flex-end": anchorPos + s.crossLen,
          center: anchorPos + s.crossLen / 2
        };
        this.layoutCross(children, "flex-start", cross, anchorPosMap, mianLenArray, mainList[i], lastIdx), lastIdx = s.idx + 1, anchorPos += s.crossLen + 2 * padding;
      });
    }
    children.forEach((child, idx) => {
      child.addUpdateBoundTag(), child.addUpdatePositionTag(), child.clearUpdateLayoutTag();
    }), p.addUpdateLayoutTag();
    const b = this.getAABBBounds(p);
    clip || this.tempBounds.equals(b) || this.tryLayout(p, !1);
  }
  getAABBBounds(graphic) {
    this.skipBoundsTrigger = !0;
    const b = graphic.AABBBounds;
    return this.skipBoundsTrigger = !1, b;
  }
  updateChildPos(posBaseLeftTop, lastP, lastBP) {
    return posBaseLeftTop + (null != lastP ? lastP : 0) - lastBP;
  }
  layoutMain(p, children, justifyContent, main, mianLenArray, lastIdx, currSeg) {
    if ("flex-start" === justifyContent) {
      let pos = 0;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field),
          b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
      }
    } else if ("flex-end" === justifyContent) {
      let pos = main.len;
      for (let i = currSeg.idx; i >= lastIdx; i--) {
        pos -= mianLenArray[i].mainLen;
        const posBaseLeftTop = pos + getPadding(children[i], main.field),
          b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`]));
      }
    } else if ("space-around" === justifyContent) {
      if (currSeg.mainLen >= main.len) {
        let pos = 0;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const posBaseLeftTop = pos + getPadding(children[i], main.field),
            b = this.getAABBBounds(children[i]);
          !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
        }
      } else {
        const size = currSeg.idx - lastIdx + 1,
          padding = (main.len - currSeg.mainLen) / size / 2;
        let pos = padding;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const posBaseLeftTop = pos + getPadding(children[i], main.field),
            b = this.getAABBBounds(children[i]);
          !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen + 2 * padding;
        }
      }
    } else if ("space-between" === justifyContent) {
      if (currSeg.mainLen >= main.len) {
        let pos = 0;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const posBaseLeftTop = pos + getPadding(children[i], main.field),
            b = this.getAABBBounds(children[i]);
          !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
        }
      } else {
        const size = currSeg.idx - lastIdx + 1,
          padding = (main.len - currSeg.mainLen) / (2 * size - 2);
        let pos = 0;
        for (let i = lastIdx; i <= currSeg.idx; i++) {
          const posBaseLeftTop = pos + getPadding(children[i], main.field),
            b = this.getAABBBounds(children[i]);
          !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen + 2 * padding;
        }
      }
    } else if ("center" === justifyContent) {
      let pos = (main.len - currSeg.mainLen) / 2;
      for (let i = lastIdx; i <= currSeg.idx; i++) {
        const posBaseLeftTop = pos + getPadding(children[i], main.field),
          b = this.getAABBBounds(children[i]);
        !b.empty() && (children[i].attribute[main.field] = this.updateChildPos(posBaseLeftTop, children[i].attribute[main.field], b[`${main.field}1`])), pos += mianLenArray[i].mainLen;
      }
    }
  }
  layoutCross(children, alignItem, cross, anchorPosMap, lenArray, currSeg, lastIdx) {
    var _a;
    for (let i = lastIdx; i <= currSeg.idx; i++) {
      const child = children[i];
      let {
        alignSelf: alignSelf
      } = child.attribute;
      alignSelf && "auto" !== alignSelf || (alignSelf = alignItem);
      const b = this.getAABBBounds(child),
        anchorPos = null !== (_a = anchorPosMap[alignSelf]) && void 0 !== _a ? _a : anchorPosMap["flex-start"];
      "flex-end" === alignSelf ? !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`])) : "center" === alignSelf ? !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos - lenArray[i].crossLen / 2 + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`])) : !b.empty() && (child.attribute[cross.field] = this.updateChildPos(anchorPos + getPadding(child, cross.field), child.attribute[cross.field], b[`${cross.field}1`]));
    }
  }
  activate(context) {
    this.pluginService = context, application.graphicService.hooks.onAttributeUpdate.tap(this.key, graphic => {
      graphic.glyphHost && (graphic = graphic.glyphHost), graphic.stage && graphic.stage === this.pluginService.stage && this.tryLayout(graphic, !1);
    }), application.graphicService.hooks.beforeUpdateAABBBounds.tap(this.key, (graphic, stage, willUpdate, bounds) => {
      graphic.glyphHost && (graphic = graphic.glyphHost), stage && stage === this.pluginService.stage && graphic.isContainer && !this.skipBoundsTrigger && _tempBounds.copy(bounds);
    }), application.graphicService.hooks.afterUpdateAABBBounds.tap(this.key, (graphic, stage, bounds, params, selfChange) => {
      stage && stage === this.pluginService.stage && graphic.isContainer && !this.skipBoundsTrigger && (_tempBounds.equals(bounds) || this.tryLayout(graphic, !1));
    }), application.graphicService.hooks.onSetStage.tap(this.key, graphic => {
      graphic.glyphHost && (graphic = graphic.glyphHost), this.tryLayout(graphic, !1);
    });
  }
  deactivate(context) {
    application.graphicService.hooks.onAttributeUpdate.taps = application.graphicService.hooks.onAttributeUpdate.taps.filter(item => item.name !== this.key), application.graphicService.hooks.beforeUpdateAABBBounds.taps = application.graphicService.hooks.beforeUpdateAABBBounds.taps.filter(item => item.name !== this.key), application.graphicService.hooks.afterUpdateAABBBounds.taps = application.graphicService.hooks.afterUpdateAABBBounds.taps.filter(item => item.name !== this.key), application.graphicService.hooks.onSetStage.taps = application.graphicService.hooks.onSetStage.taps.filter(item => item.name !== this.key);
  }
}
function getPadding(graphic, field) {
  return 0;
}
const registerFlexLayoutPlugin = () => {
  Factory.registerPlugin("FlexLayoutPlugin", FlexLayoutPlugin);
};

function generatorPathEasingFunc(path) {
  const customPath = new CustomPath2D();
  return customPath.setCtx(new CurveContext(customPath)), customPath.fromString(path, 0, 0, 1, 1), x => customPath.getYAt(x);
}

function t(t, e, s) {
  if (t && t.length) {
    const [n, a] = e,
      o = Math.PI / 180 * s,
      h = Math.cos(o),
      r = Math.sin(o);
    t.forEach(t => {
      const [e, s] = t;
      t[0] = (e - n) * h - (s - a) * r + n, t[1] = (e - n) * r + (s - a) * h + a;
    });
  }
}
function e(t) {
  const e = t[0],
    s = t[1];
  return Math.sqrt(Math.pow(e[0] - s[0], 2) + Math.pow(e[1] - s[1], 2));
}
function s(e, s) {
  const n = s.hachureAngle + 90;
  let a = s.hachureGap;
  a < 0 && (a = 4 * s.strokeWidth), a = Math.max(a, .1);
  const o = [0, 0];
  if (n) for (const s of e) t(s, o, n);
  const h = function (t, e) {
    const s = [];
    for (const e of t) {
      const t = [...e];
      t[0].join(",") !== t[t.length - 1].join(",") && t.push([t[0][0], t[0][1]]), t.length > 2 && s.push(t);
    }
    const n = [];
    e = Math.max(e, .1);
    const a = [];
    for (const t of s) for (let e = 0; e < t.length - 1; e++) {
      const s = t[e],
        n = t[e + 1];
      if (s[1] !== n[1]) {
        const t = Math.min(s[1], n[1]);
        a.push({
          ymin: t,
          ymax: Math.max(s[1], n[1]),
          x: t === s[1] ? s[0] : n[0],
          islope: (n[0] - s[0]) / (n[1] - s[1])
        });
      }
    }
    if (a.sort((t, e) => t.ymin < e.ymin ? -1 : t.ymin > e.ymin ? 1 : t.x < e.x ? -1 : t.x > e.x ? 1 : t.ymax === e.ymax ? 0 : (t.ymax - e.ymax) / Math.abs(t.ymax - e.ymax)), !a.length) return n;
    let o = [],
      h = a[0].ymin;
    for (; o.length || a.length;) {
      if (a.length) {
        let t = -1;
        for (let e = 0; e < a.length && !(a[e].ymin > h); e++) t = e;
        a.splice(0, t + 1).forEach(t => {
          o.push({
            s: h,
            edge: t
          });
        });
      }
      if (o = o.filter(t => !(t.edge.ymax <= h)), o.sort((t, e) => t.edge.x === e.edge.x ? 0 : (t.edge.x - e.edge.x) / Math.abs(t.edge.x - e.edge.x)), o.length > 1) for (let t = 0; t < o.length; t += 2) {
        const e = t + 1;
        if (e >= o.length) break;
        const s = o[t].edge,
          a = o[e].edge;
        n.push([[Math.round(s.x), h], [Math.round(a.x), h]]);
      }
      h += e, o.forEach(t => {
        t.edge.x = t.edge.x + e * t.edge.islope;
      });
    }
    return n;
  }(e, a);
  if (n) {
    for (const s of e) t(s, o, -n);
    !function (e, s, n) {
      const a = [];
      e.forEach(t => a.push(...t)), t(a, s, n);
    }(h, o, -n);
  }
  return h;
}
class n {
  constructor(t) {
    this.helper = t;
  }
  fillPolygons(t, e) {
    return this._fillPolygons(t, e);
  }
  _fillPolygons(t, e) {
    const n = s(t, e);
    return {
      type: "fillSketch",
      ops: this.renderLines(n, e)
    };
  }
  renderLines(t, e) {
    const s = [];
    for (const n of t) s.push(...this.helper.doubleLineOps(n[0][0], n[0][1], n[1][0], n[1][1], e));
    return s;
  }
}
class a extends n {
  fillPolygons(t, n) {
    let a = n.hachureGap;
    a < 0 && (a = 4 * n.strokeWidth), a = Math.max(a, .1);
    const o = s(t, Object.assign({}, n, {
        hachureGap: a
      })),
      h = Math.PI / 180 * n.hachureAngle,
      r = [],
      i = .5 * a * Math.cos(h),
      c = .5 * a * Math.sin(h);
    for (const [t, s] of o) e([t, s]) && r.push([[t[0] - i, t[1] + c], [...s]], [[t[0] + i, t[1] - c], [...s]]);
    return {
      type: "fillSketch",
      ops: this.renderLines(r, n)
    };
  }
}
class o extends n {
  fillPolygons(t, e) {
    const s = this._fillPolygons(t, e),
      n = Object.assign({}, e, {
        hachureAngle: e.hachureAngle + 90
      }),
      a = this._fillPolygons(t, n);
    return s.ops = s.ops.concat(a.ops), s;
  }
}
class h {
  constructor(t) {
    this.helper = t;
  }
  fillPolygons(t, e) {
    const n = s(t, e = Object.assign({}, e, {
      hachureAngle: 0
    }));
    return this.dotsOnLines(n, e);
  }
  dotsOnLines(t, s) {
    const n = [];
    let a = s.hachureGap;
    a < 0 && (a = 4 * s.strokeWidth), a = Math.max(a, .1);
    let o = s.fillWeight;
    o < 0 && (o = s.strokeWidth / 2);
    const h = a / 4;
    for (const r of t) {
      const t = e(r),
        i = t / a,
        c = Math.ceil(i) - 1,
        l = t - c * a,
        u = (r[0][0] + r[1][0]) / 2 - a / 4,
        p = Math.min(r[0][1], r[1][1]);
      for (let t = 0; t < c; t++) {
        const e = p + l + t * a,
          r = u - h + 2 * Math.random() * h,
          i = e - h + 2 * Math.random() * h,
          c = this.helper.ellipse(r, i, o, o, s);
        n.push(...c.ops);
      }
    }
    return {
      type: "fillSketch",
      ops: n
    };
  }
}
class r {
  constructor(t) {
    this.helper = t;
  }
  fillPolygons(t, e) {
    const n = s(t, e);
    return {
      type: "fillSketch",
      ops: this.dashedLine(n, e)
    };
  }
  dashedLine(t, s) {
    const n = s.dashOffset < 0 ? s.hachureGap < 0 ? 4 * s.strokeWidth : s.hachureGap : s.dashOffset,
      a = s.dashGap < 0 ? s.hachureGap < 0 ? 4 * s.strokeWidth : s.hachureGap : s.dashGap,
      o = [];
    return t.forEach(t => {
      const h = e(t),
        r = Math.floor(h / (n + a)),
        i = (h + a - r * (n + a)) / 2;
      let c = t[0],
        l = t[1];
      c[0] > l[0] && (c = t[1], l = t[0]);
      const u = Math.atan((l[1] - c[1]) / (l[0] - c[0]));
      for (let t = 0; t < r; t++) {
        const e = t * (n + a),
          h = e + n,
          r = [c[0] + e * Math.cos(u) + i * Math.cos(u), c[1] + e * Math.sin(u) + i * Math.sin(u)],
          l = [c[0] + h * Math.cos(u) + i * Math.cos(u), c[1] + h * Math.sin(u) + i * Math.sin(u)];
        o.push(...this.helper.doubleLineOps(r[0], r[1], l[0], l[1], s));
      }
    }), o;
  }
}
class i {
  constructor(t) {
    this.helper = t;
  }
  fillPolygons(t, e) {
    const n = e.hachureGap < 0 ? 4 * e.strokeWidth : e.hachureGap,
      a = e.zigzagOffset < 0 ? n : e.zigzagOffset,
      o = s(t, e = Object.assign({}, e, {
        hachureGap: n + a
      }));
    return {
      type: "fillSketch",
      ops: this.zigzagLines(o, a, e)
    };
  }
  zigzagLines(t, s, n) {
    const a = [];
    return t.forEach(t => {
      const o = e(t),
        h = Math.round(o / (2 * s));
      let r = t[0],
        i = t[1];
      r[0] > i[0] && (r = t[1], i = t[0]);
      const c = Math.atan((i[1] - r[1]) / (i[0] - r[0]));
      for (let t = 0; t < h; t++) {
        const e = 2 * t * s,
          o = 2 * (t + 1) * s,
          h = Math.sqrt(2 * Math.pow(s, 2)),
          i = [r[0] + e * Math.cos(c), r[1] + e * Math.sin(c)],
          l = [r[0] + o * Math.cos(c), r[1] + o * Math.sin(c)],
          u = [i[0] + h * Math.cos(c + Math.PI / 4), i[1] + h * Math.sin(c + Math.PI / 4)];
        a.push(...this.helper.doubleLineOps(i[0], i[1], u[0], u[1], n), ...this.helper.doubleLineOps(u[0], u[1], l[0], l[1], n));
      }
    }), a;
  }
}
const c = {};
class l {
  constructor(t) {
    this.seed = t;
  }
  next() {
    return this.seed ? (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31 : Math.random();
  }
}
const u = {
  A: 7,
  a: 7,
  C: 6,
  c: 6,
  H: 1,
  h: 1,
  L: 2,
  l: 2,
  M: 2,
  m: 2,
  Q: 4,
  q: 4,
  S: 4,
  s: 4,
  T: 2,
  t: 2,
  V: 1,
  v: 1,
  Z: 0,
  z: 0
};
function p(t, e) {
  return t.type === e;
}
function f(t) {
  const e = [],
    s = function (t) {
      const e = new Array();
      for (; "" !== t;) if (t.match(/^([ \t\r\n,]+)/)) t = t.substr(RegExp.$1.length);else if (t.match(/^([aAcChHlLmMqQsStTvVzZ])/)) e[e.length] = {
        type: 0,
        text: RegExp.$1
      }, t = t.substr(RegExp.$1.length);else {
        if (!t.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) return [];
        e[e.length] = {
          type: 1,
          text: `${parseFloat(RegExp.$1)}`
        }, t = t.substr(RegExp.$1.length);
      }
      return e[e.length] = {
        type: 2,
        text: ""
      }, e;
    }(t);
  let n = "BOD",
    a = 0,
    o = s[a];
  for (; !p(o, 2);) {
    let h = 0;
    const r = [];
    if ("BOD" === n) {
      if ("M" !== o.text && "m" !== o.text) return f("M0,0" + t);
      a++, h = u[o.text], n = o.text;
    } else p(o, 1) ? h = u[n] : (a++, h = u[o.text], n = o.text);
    if (!(a + h < s.length)) throw new Error("Path data ended short");
    for (let t = a; t < a + h; t++) {
      const e = s[t];
      if (!p(e, 1)) throw new Error("Param not a number: " + n + "," + e.text);
      r[r.length] = +e.text;
    }
    if ("number" != typeof u[n]) throw new Error("Bad segment: " + n);
    {
      const t = {
        key: n,
        data: r
      };
      e.push(t), a += h, o = s[a], "M" === n && (n = "L"), "m" === n && (n = "l");
    }
  }
  return e;
}
function d(t) {
  let e = 0,
    s = 0,
    n = 0,
    a = 0;
  const o = [];
  for (const {
    key: h,
    data: r
  } of t) switch (h) {
    case "M":
      o.push({
        key: "M",
        data: [...r]
      }), [e, s] = r, [n, a] = r;
      break;
    case "m":
      e += r[0], s += r[1], o.push({
        key: "M",
        data: [e, s]
      }), n = e, a = s;
      break;
    case "L":
      o.push({
        key: "L",
        data: [...r]
      }), [e, s] = r;
      break;
    case "l":
      e += r[0], s += r[1], o.push({
        key: "L",
        data: [e, s]
      });
      break;
    case "C":
      o.push({
        key: "C",
        data: [...r]
      }), e = r[4], s = r[5];
      break;
    case "c":
      {
        const t = r.map((t, n) => n % 2 ? t + s : t + e);
        o.push({
          key: "C",
          data: t
        }), e = t[4], s = t[5];
        break;
      }
    case "Q":
      o.push({
        key: "Q",
        data: [...r]
      }), e = r[2], s = r[3];
      break;
    case "q":
      {
        const t = r.map((t, n) => n % 2 ? t + s : t + e);
        o.push({
          key: "Q",
          data: t
        }), e = t[2], s = t[3];
        break;
      }
    case "A":
      o.push({
        key: "A",
        data: [...r]
      }), e = r[5], s = r[6];
      break;
    case "a":
      e += r[5], s += r[6], o.push({
        key: "A",
        data: [r[0], r[1], r[2], r[3], r[4], e, s]
      });
      break;
    case "H":
      o.push({
        key: "H",
        data: [...r]
      }), e = r[0];
      break;
    case "h":
      e += r[0], o.push({
        key: "H",
        data: [e]
      });
      break;
    case "V":
      o.push({
        key: "V",
        data: [...r]
      }), s = r[0];
      break;
    case "v":
      s += r[0], o.push({
        key: "V",
        data: [s]
      });
      break;
    case "S":
      o.push({
        key: "S",
        data: [...r]
      }), e = r[2], s = r[3];
      break;
    case "s":
      {
        const t = r.map((t, n) => n % 2 ? t + s : t + e);
        o.push({
          key: "S",
          data: t
        }), e = t[2], s = t[3];
        break;
      }
    case "T":
      o.push({
        key: "T",
        data: [...r]
      }), e = r[0], s = r[1];
      break;
    case "t":
      e += r[0], s += r[1], o.push({
        key: "T",
        data: [e, s]
      });
      break;
    case "Z":
    case "z":
      o.push({
        key: "Z",
        data: []
      }), e = n, s = a;
  }
  return o;
}
function g(t) {
  const e = [];
  let s = "",
    n = 0,
    a = 0,
    o = 0,
    h = 0,
    r = 0,
    i = 0;
  for (const {
    key: c,
    data: l
  } of t) {
    switch (c) {
      case "M":
        e.push({
          key: "M",
          data: [...l]
        }), [n, a] = l, [o, h] = l;
        break;
      case "C":
        e.push({
          key: "C",
          data: [...l]
        }), n = l[4], a = l[5], r = l[2], i = l[3];
        break;
      case "L":
        e.push({
          key: "L",
          data: [...l]
        }), [n, a] = l;
        break;
      case "H":
        n = l[0], e.push({
          key: "L",
          data: [n, a]
        });
        break;
      case "V":
        a = l[0], e.push({
          key: "L",
          data: [n, a]
        });
        break;
      case "S":
        {
          let t = 0,
            o = 0;
          "C" === s || "S" === s ? (t = n + (n - r), o = a + (a - i)) : (t = n, o = a), e.push({
            key: "C",
            data: [t, o, ...l]
          }), r = l[0], i = l[1], n = l[2], a = l[3];
          break;
        }
      case "T":
        {
          const [t, o] = l;
          let h = 0,
            c = 0;
          "Q" === s || "T" === s ? (h = n + (n - r), c = a + (a - i)) : (h = n, c = a);
          const u = n + 2 * (h - n) / 3,
            p = a + 2 * (c - a) / 3,
            f = t + 2 * (h - t) / 3,
            d = o + 2 * (c - o) / 3;
          e.push({
            key: "C",
            data: [u, p, f, d, t, o]
          }), r = h, i = c, n = t, a = o;
          break;
        }
      case "Q":
        {
          const [t, s, o, h] = l,
            c = n + 2 * (t - n) / 3,
            u = a + 2 * (s - a) / 3,
            p = o + 2 * (t - o) / 3,
            f = h + 2 * (s - h) / 3;
          e.push({
            key: "C",
            data: [c, u, p, f, o, h]
          }), r = t, i = s, n = o, a = h;
          break;
        }
      case "A":
        {
          const t = Math.abs(l[0]),
            s = Math.abs(l[1]),
            o = l[2],
            h = l[3],
            r = l[4],
            i = l[5],
            c = l[6];
          if (0 === t || 0 === s) e.push({
            key: "C",
            data: [n, a, i, c, i, c]
          }), n = i, a = c;else if (n !== i || a !== c) {
            k(n, a, i, c, t, s, o, h, r).forEach(function (t) {
              e.push({
                key: "C",
                data: t
              });
            }), n = i, a = c;
          }
          break;
        }
      case "Z":
        e.push({
          key: "Z",
          data: []
        }), n = o, a = h;
    }
    s = c;
  }
  return e;
}
function M(t, e, s) {
  return [t * Math.cos(s) - e * Math.sin(s), t * Math.sin(s) + e * Math.cos(s)];
}
function k(t, e, s, n, a, o, h, r, i, c) {
  const l = (u = h, Math.PI * u / 180);
  var u;
  let p = [],
    f = 0,
    d = 0,
    g = 0,
    b = 0;
  if (c) [f, d, g, b] = c;else {
    [t, e] = M(t, e, -l), [s, n] = M(s, n, -l);
    const h = (t - s) / 2,
      c = (e - n) / 2;
    let u = h * h / (a * a) + c * c / (o * o);
    u > 1 && (u = Math.sqrt(u), a *= u, o *= u);
    const p = a * a,
      k = o * o,
      y = p * k - p * c * c - k * h * h,
      m = p * c * c + k * h * h,
      w = (r === i ? -1 : 1) * Math.sqrt(Math.abs(y / m));
    g = w * a * c / o + (t + s) / 2, b = w * -o * h / a + (e + n) / 2, f = Math.asin(parseFloat(((e - b) / o).toFixed(9))), d = Math.asin(parseFloat(((n - b) / o).toFixed(9))), t < g && (f = Math.PI - f), s < g && (d = Math.PI - d), f < 0 && (f = 2 * Math.PI + f), d < 0 && (d = 2 * Math.PI + d), i && f > d && (f -= 2 * Math.PI), !i && d > f && (d -= 2 * Math.PI);
  }
  let y = d - f;
  if (Math.abs(y) > 120 * Math.PI / 180) {
    const t = d,
      e = s,
      r = n;
    d = i && d > f ? f + 120 * Math.PI / 180 * 1 : f + 120 * Math.PI / 180 * -1, p = k(s = g + a * Math.cos(d), n = b + o * Math.sin(d), e, r, a, o, h, 0, i, [d, t, g, b]);
  }
  y = d - f;
  const m = Math.cos(f),
    w = Math.sin(f),
    x = Math.cos(d),
    P = Math.sin(d),
    v = Math.tan(y / 4),
    O = 4 / 3 * a * v,
    S = 4 / 3 * o * v,
    L = [t, e],
    T = [t + O * w, e - S * m],
    D = [s + O * P, n - S * x],
    A = [s, n];
  if (T[0] = 2 * L[0] - T[0], T[1] = 2 * L[1] - T[1], c) return [T, D, A].concat(p);
  {
    p = [T, D, A].concat(p);
    const t = [];
    for (let e = 0; e < p.length; e += 3) {
      const s = M(p[e][0], p[e][1], l),
        n = M(p[e + 1][0], p[e + 1][1], l),
        a = M(p[e + 2][0], p[e + 2][1], l);
      t.push([s[0], s[1], n[0], n[1], a[0], a[1]]);
    }
    return t;
  }
}
const b = {
  randOffset: function (t, e) {
    return A(t, e);
  },
  randOffsetWithRange: function (t, e, s) {
    return D(t, e, s);
  },
  ellipse: function (t, e, s, n, a) {
    const o = P(s, n, a);
    return v(t, e, a, o).opset;
  },
  doubleLineOps: function (t, e, s, n, a) {
    return I(t, e, s, n, a, !0);
  }
};
function y(t, e, s, n, a) {
  return {
    type: "path",
    ops: I(t, e, s, n, a)
  };
}
function m$2(t, e, s) {
  const n = (t || []).length;
  if (n > 2) {
    const a = [];
    for (let e = 0; e < n - 1; e++) a.push(...I(t[e][0], t[e][1], t[e + 1][0], t[e + 1][1], s));
    return e && a.push(...I(t[n - 1][0], t[n - 1][1], t[0][0], t[0][1], s)), {
      type: "path",
      ops: a
    };
  }
  return 2 === n ? y(t[0][0], t[0][1], t[1][0], t[1][1], s) : {
    type: "path",
    ops: []
  };
}
function w(t, e, s, n, a) {
  return function (t, e) {
    return m$2(t, !0, e);
  }([[t, e], [t + s, e], [t + s, e + n], [t, e + n]], a);
}
function x(t, e) {
  let s = _(t, 1 * (1 + .2 * e.roughness), e);
  if (!e.disableMultiStroke) {
    const n = _(t, 1.5 * (1 + .22 * e.roughness), function (t) {
      const e = Object.assign({}, t);
      e.randomizer = void 0, t.seed && (e.seed = t.seed + 1);
      return e;
    }(e));
    s = s.concat(n);
  }
  return {
    type: "path",
    ops: s
  };
}
function P(t, e, s) {
  const n = Math.sqrt(2 * Math.PI * Math.sqrt((Math.pow(t / 2, 2) + Math.pow(e / 2, 2)) / 2)),
    a = Math.ceil(Math.max(s.curveStepCount, s.curveStepCount / Math.sqrt(200) * n)),
    o = 2 * Math.PI / a;
  let h = Math.abs(t / 2),
    r = Math.abs(e / 2);
  const i = 1 - s.curveFitting;
  return h += A(h * i, s), r += A(r * i, s), {
    increment: o,
    rx: h,
    ry: r
  };
}
function v(t, e, s, n) {
  const [a, o] = z(n.increment, t, e, n.rx, n.ry, 1, n.increment * D(.1, D(.4, 1, s), s), s);
  let h = W(a, null, s);
  if (!s.disableMultiStroke && 0 !== s.roughness) {
    const [a] = z(n.increment, t, e, n.rx, n.ry, 1.5, 0, s),
      o = W(a, null, s);
    h = h.concat(o);
  }
  return {
    estimatedPoints: o,
    opset: {
      type: "path",
      ops: h
    }
  };
}
function O(t, e, s, n, a, o, h, r, i) {
  const c = t,
    l = e;
  let u = Math.abs(s / 2),
    p = Math.abs(n / 2);
  u += A(.01 * u, i), p += A(.01 * p, i);
  let f = a,
    d = o;
  for (; f < 0;) f += 2 * Math.PI, d += 2 * Math.PI;
  d - f > 2 * Math.PI && (f = 0, d = 2 * Math.PI);
  const g = 2 * Math.PI / i.curveStepCount,
    M = Math.min(g / 2, (d - f) / 2),
    k = E(M, c, l, u, p, f, d, 1, i);
  if (!i.disableMultiStroke) {
    const t = E(M, c, l, u, p, f, d, 1.5, i);
    k.push(...t);
  }
  return h && (r ? k.push(...I(c, l, c + u * Math.cos(f), l + p * Math.sin(f), i), ...I(c, l, c + u * Math.cos(d), l + p * Math.sin(d), i)) : k.push({
    op: "lineTo",
    data: [c, l]
  }, {
    op: "lineTo",
    data: [c + u * Math.cos(f), l + p * Math.sin(f)]
  })), {
    type: "path",
    ops: k
  };
}
function S(t, e) {
  const s = [];
  for (const n of t) if (n.length) {
    const t = e.maxRandomnessOffset || 0,
      a = n.length;
    if (a > 2) {
      s.push({
        op: "move",
        data: [n[0][0] + A(t, e), n[0][1] + A(t, e)]
      });
      for (let o = 1; o < a; o++) s.push({
        op: "lineTo",
        data: [n[o][0] + A(t, e), n[o][1] + A(t, e)]
      });
    }
  }
  return {
    type: "fillPath",
    ops: s
  };
}
function L(t, e) {
  return function (t, e) {
    let s = t.fillStyle || "hachure";
    if (!c[s]) switch (s) {
      case "zigzag":
        c[s] || (c[s] = new a(e));
        break;
      case "cross-hatch":
        c[s] || (c[s] = new o(e));
        break;
      case "dots":
        c[s] || (c[s] = new h(e));
        break;
      case "dashed":
        c[s] || (c[s] = new r(e));
        break;
      case "zigzag-line":
        c[s] || (c[s] = new i(e));
        break;
      case "hachure":
      default:
        s = "hachure", c[s] || (c[s] = new n(e));
    }
    return c[s];
  }(e, b).fillPolygons(t, e);
}
function T(t) {
  return t.randomizer || (t.randomizer = new l(t.seed || 0)), t.randomizer.next();
}
function D(t, e, s) {
  let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
  return s.roughness * n * (T(s) * (e - t) + t);
}
function A(t, e) {
  let s = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
  return D(-t, t, e, s);
}
function I(t, e, s, n, a) {
  let o = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : !1;
  const h = o ? a.disableMultiStrokeFill : a.disableMultiStroke,
    r = C(t, e, s, n, a, !0, !1);
  if (h) return r;
  const i = C(t, e, s, n, a, !0, !0);
  return r.concat(i);
}
function C(t, e, s, n, a, o, h) {
  const r = Math.pow(t - s, 2) + Math.pow(e - n, 2),
    i = Math.sqrt(r);
  let c = 1;
  c = i < 200 ? 1 : i > 500 ? .4 : -.0016668 * i + 1.233334;
  let l = a.maxRandomnessOffset || 0;
  l * l * 100 > r && (l = i / 10);
  const u = l / 2,
    p = .2 + .2 * T(a);
  let f = a.bowing * a.maxRandomnessOffset * (n - e) / 200,
    d = a.bowing * a.maxRandomnessOffset * (t - s) / 200;
  f = A(f, a, c), d = A(d, a, c);
  const g = [],
    M = () => A(u, a, c),
    k = () => A(l, a, c),
    b = a.preserveVertices;
  return o && (h ? g.push({
    op: "move",
    data: [t + (b ? 0 : M()), e + (b ? 0 : M())]
  }) : g.push({
    op: "move",
    data: [t + (b ? 0 : A(l, a, c)), e + (b ? 0 : A(l, a, c))]
  })), h ? g.push({
    op: "bcurveTo",
    data: [f + t + (s - t) * p + M(), d + e + (n - e) * p + M(), f + t + 2 * (s - t) * p + M(), d + e + 2 * (n - e) * p + M(), s + (b ? 0 : M()), n + (b ? 0 : M())]
  }) : g.push({
    op: "bcurveTo",
    data: [f + t + (s - t) * p + k(), d + e + (n - e) * p + k(), f + t + 2 * (s - t) * p + k(), d + e + 2 * (n - e) * p + k(), s + (b ? 0 : k()), n + (b ? 0 : k())]
  }), g;
}
function _(t, e, s) {
  const n = [];
  n.push([t[0][0] + A(e, s), t[0][1] + A(e, s)]), n.push([t[0][0] + A(e, s), t[0][1] + A(e, s)]);
  for (let a = 1; a < t.length; a++) n.push([t[a][0] + A(e, s), t[a][1] + A(e, s)]), a === t.length - 1 && n.push([t[a][0] + A(e, s), t[a][1] + A(e, s)]);
  return W(n, null, s);
}
function W(t, e, s) {
  const n = t.length,
    a = [];
  if (n > 3) {
    const o = [],
      h = 1 - s.curveTightness;
    a.push({
      op: "move",
      data: [t[1][0], t[1][1]]
    });
    for (let e = 1; e + 2 < n; e++) {
      const s = t[e];
      o[0] = [s[0], s[1]], o[1] = [s[0] + (h * t[e + 1][0] - h * t[e - 1][0]) / 6, s[1] + (h * t[e + 1][1] - h * t[e - 1][1]) / 6], o[2] = [t[e + 1][0] + (h * t[e][0] - h * t[e + 2][0]) / 6, t[e + 1][1] + (h * t[e][1] - h * t[e + 2][1]) / 6], o[3] = [t[e + 1][0], t[e + 1][1]], a.push({
        op: "bcurveTo",
        data: [o[1][0], o[1][1], o[2][0], o[2][1], o[3][0], o[3][1]]
      });
    }
    if (e && 2 === e.length) {
      const t = s.maxRandomnessOffset;
      a.push({
        op: "lineTo",
        data: [e[0] + A(t, s), e[1] + A(t, s)]
      });
    }
  } else 3 === n ? (a.push({
    op: "move",
    data: [t[1][0], t[1][1]]
  }), a.push({
    op: "bcurveTo",
    data: [t[1][0], t[1][1], t[2][0], t[2][1], t[2][0], t[2][1]]
  })) : 2 === n && a.push(...I(t[0][0], t[0][1], t[1][0], t[1][1], s));
  return a;
}
function z(t, e, s, n, a, o, h, r) {
  const i = [],
    c = [];
  if (0 === r.roughness) {
    t /= 4, c.push([e + n * Math.cos(-t), s + a * Math.sin(-t)]);
    for (let o = 0; o <= 2 * Math.PI; o += t) {
      const t = [e + n * Math.cos(o), s + a * Math.sin(o)];
      i.push(t), c.push(t);
    }
    c.push([e + n * Math.cos(0), s + a * Math.sin(0)]), c.push([e + n * Math.cos(t), s + a * Math.sin(t)]);
  } else {
    const l = A(.5, r) - Math.PI / 2;
    c.push([A(o, r) + e + .9 * n * Math.cos(l - t), A(o, r) + s + .9 * a * Math.sin(l - t)]);
    const u = 2 * Math.PI + l - .01;
    for (let h = l; h < u; h += t) {
      const t = [A(o, r) + e + n * Math.cos(h), A(o, r) + s + a * Math.sin(h)];
      i.push(t), c.push(t);
    }
    c.push([A(o, r) + e + n * Math.cos(l + 2 * Math.PI + .5 * h), A(o, r) + s + a * Math.sin(l + 2 * Math.PI + .5 * h)]), c.push([A(o, r) + e + .98 * n * Math.cos(l + h), A(o, r) + s + .98 * a * Math.sin(l + h)]), c.push([A(o, r) + e + .9 * n * Math.cos(l + .5 * h), A(o, r) + s + .9 * a * Math.sin(l + .5 * h)]);
  }
  return [c, i];
}
function E(t, e, s, n, a, o, h, r, i) {
  const c = o + A(.1, i),
    l = [];
  l.push([A(r, i) + e + .9 * n * Math.cos(c - t), A(r, i) + s + .9 * a * Math.sin(c - t)]);
  for (let o = c; o <= h; o += t) l.push([A(r, i) + e + n * Math.cos(o), A(r, i) + s + a * Math.sin(o)]);
  return l.push([e + n * Math.cos(h), s + a * Math.sin(h)]), l.push([e + n * Math.cos(h), s + a * Math.sin(h)]), W(l, null, i);
}
function $(t, e, s, n, a, o, h, r) {
  const i = [],
    c = [r.maxRandomnessOffset || 1, (r.maxRandomnessOffset || 1) + .3];
  let l = [0, 0];
  const u = r.disableMultiStroke ? 1 : 2,
    p = r.preserveVertices;
  for (let f = 0; f < u; f++) 0 === f ? i.push({
    op: "move",
    data: [h[0], h[1]]
  }) : i.push({
    op: "move",
    data: [h[0] + (p ? 0 : A(c[0], r)), h[1] + (p ? 0 : A(c[0], r))]
  }), l = p ? [a, o] : [a + A(c[f], r), o + A(c[f], r)], i.push({
    op: "bcurveTo",
    data: [t + A(c[f], r), e + A(c[f], r), s + A(c[f], r), n + A(c[f], r), l[0], l[1]]
  });
  return i;
}
function G(t) {
  return [...t];
}
function R(t, e) {
  return Math.pow(t[0] - e[0], 2) + Math.pow(t[1] - e[1], 2);
}
function q(t, e, s) {
  const n = R(e, s);
  if (0 === n) return R(t, e);
  let a = ((t[0] - e[0]) * (s[0] - e[0]) + (t[1] - e[1]) * (s[1] - e[1])) / n;
  return a = Math.max(0, Math.min(1, a)), R(t, j(e, s, a));
}
function j(t, e, s) {
  return [t[0] + (e[0] - t[0]) * s, t[1] + (e[1] - t[1]) * s];
}
function F(t, e, s, n) {
  const a = n || [];
  if (function (t, e) {
    const s = t[e + 0],
      n = t[e + 1],
      a = t[e + 2],
      o = t[e + 3];
    let h = 3 * n[0] - 2 * s[0] - o[0];
    h *= h;
    let r = 3 * n[1] - 2 * s[1] - o[1];
    r *= r;
    let i = 3 * a[0] - 2 * o[0] - s[0];
    i *= i;
    let c = 3 * a[1] - 2 * o[1] - s[1];
    return c *= c, h < i && (h = i), r < c && (r = c), h + r;
  }(t, e) < s) {
    const s = t[e + 0];
    if (a.length) {
      (o = a[a.length - 1], h = s, Math.sqrt(R(o, h))) > 1 && a.push(s);
    } else a.push(s);
    a.push(t[e + 3]);
  } else {
    const n = .5,
      o = t[e + 0],
      h = t[e + 1],
      r = t[e + 2],
      i = t[e + 3],
      c = j(o, h, n),
      l = j(h, r, n),
      u = j(r, i, n),
      p = j(c, l, n),
      f = j(l, u, n),
      d = j(p, f, n);
    F([o, c, p, d], 0, s, a), F([d, f, u, i], 0, s, a);
  }
  var o, h;
  return a;
}
function V(t, e) {
  return Z(t, 0, t.length, e);
}
function Z(t, e, s, n, a) {
  const o = a || [],
    h = t[e],
    r = t[s - 1];
  let i = 0,
    c = 1;
  for (let n = e + 1; n < s - 1; ++n) {
    const e = q(t[n], h, r);
    e > i && (i = e, c = n);
  }
  return Math.sqrt(i) > n ? (Z(t, e, c + 1, n, o), Z(t, c, s, n, o)) : (o.length || o.push(h), o.push(r)), o;
}
function Q(t) {
  let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : .15;
  let s = arguments.length > 2 ? arguments[2] : undefined;
  const n = [],
    a = (t.length - 1) / 3;
  for (let s = 0; s < a; s++) {
    F(t, 3 * s, e, n);
  }
  return s && s > 0 ? Z(n, 0, n.length, s) : n;
}
const H = "none";
class N {
  constructor(t) {
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: "#000",
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: .95,
      curveStepCount: 9,
      fillStyle: "hachure",
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: !1,
      disableMultiStrokeFill: !1,
      preserveVertices: !1
    }, this.config = t || {}, this.config.options && (this.defaultOptions = this._o(this.config.options));
  }
  static newSeed() {
    return Math.floor(Math.random() * 2 ** 31);
  }
  _o(t) {
    return t ? Object.assign({}, this.defaultOptions, t) : this.defaultOptions;
  }
  _d(t, e, s) {
    return {
      shape: t,
      sets: e || [],
      options: s || this.defaultOptions
    };
  }
  line(t, e, s, n, a) {
    const o = this._o(a);
    return this._d("line", [y(t, e, s, n, o)], o);
  }
  rectangle(t, e, s, n, a) {
    const o = this._o(a),
      h = [],
      r = w(t, e, s, n, o);
    if (o.fill) {
      const a = [[t, e], [t + s, e], [t + s, e + n], [t, e + n]];
      "solid" === o.fillStyle ? h.push(S([a], o)) : h.push(L([a], o));
    }
    return o.stroke !== H && h.push(r), this._d("rectangle", h, o);
  }
  ellipse(t, e, s, n, a) {
    const o = this._o(a),
      h = [],
      r = P(s, n, o),
      i = v(t, e, o, r);
    if (o.fill) if ("solid" === o.fillStyle) {
      const s = v(t, e, o, r).opset;
      s.type = "fillPath", h.push(s);
    } else h.push(L([i.estimatedPoints], o));
    return o.stroke !== H && h.push(i.opset), this._d("ellipse", h, o);
  }
  circle(t, e, s, n) {
    const a = this.ellipse(t, e, s, s, n);
    return a.shape = "circle", a;
  }
  linearPath(t, e) {
    const s = this._o(e);
    return this._d("linearPath", [m$2(t, !1, s)], s);
  }
  arc(t, e, s, n, a, o) {
    let h = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
    let r = arguments.length > 7 ? arguments[7] : undefined;
    const i = this._o(r),
      c = [],
      l = O(t, e, s, n, a, o, h, !0, i);
    if (h && i.fill) if ("solid" === i.fillStyle) {
      const h = Object.assign({}, i);
      h.disableMultiStroke = !0;
      const r = O(t, e, s, n, a, o, !0, !1, h);
      r.type = "fillPath", c.push(r);
    } else c.push(function (t, e, s, n, a, o, h) {
      const r = t,
        i = e;
      let c = Math.abs(s / 2),
        l = Math.abs(n / 2);
      c += A(.01 * c, h), l += A(.01 * l, h);
      let u = a,
        p = o;
      for (; u < 0;) u += 2 * Math.PI, p += 2 * Math.PI;
      p - u > 2 * Math.PI && (u = 0, p = 2 * Math.PI);
      const f = (p - u) / h.curveStepCount,
        d = [];
      for (let t = u; t <= p; t += f) d.push([r + c * Math.cos(t), i + l * Math.sin(t)]);
      return d.push([r + c * Math.cos(p), i + l * Math.sin(p)]), d.push([r, i]), L([d], h);
    }(t, e, s, n, a, o, i));
    return i.stroke !== H && c.push(l), this._d("arc", c, i);
  }
  curve(t, e) {
    const s = this._o(e),
      n = [],
      a = x(t, s);
    if (s.fill && s.fill !== H && t.length >= 3) {
      const e = Q(function (t) {
        let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        const s = t.length;
        if (s < 3) throw new Error("A curve must have at least three points.");
        const n = [];
        if (3 === s) n.push(G(t[0]), G(t[1]), G(t[2]), G(t[2]));else {
          const s = [];
          s.push(t[0], t[0]);
          for (let e = 1; e < t.length; e++) s.push(t[e]), e === t.length - 1 && s.push(t[e]);
          const a = [],
            o = 1 - e;
          n.push(G(s[0]));
          for (let t = 1; t + 2 < s.length; t++) {
            const e = s[t];
            a[0] = [e[0], e[1]], a[1] = [e[0] + (o * s[t + 1][0] - o * s[t - 1][0]) / 6, e[1] + (o * s[t + 1][1] - o * s[t - 1][1]) / 6], a[2] = [s[t + 1][0] + (o * s[t][0] - o * s[t + 2][0]) / 6, s[t + 1][1] + (o * s[t][1] - o * s[t + 2][1]) / 6], a[3] = [s[t + 1][0], s[t + 1][1]], n.push(a[1], a[2], a[3]);
          }
        }
        return n;
      }(t), 10, (1 + s.roughness) / 2);
      "solid" === s.fillStyle ? n.push(S([e], s)) : n.push(L([e], s));
    }
    return s.stroke !== H && n.push(a), this._d("curve", n, s);
  }
  polygon(t, e) {
    const s = this._o(e),
      n = [],
      a = m$2(t, !0, s);
    return s.fill && ("solid" === s.fillStyle ? n.push(S([t], s)) : n.push(L([t], s))), s.stroke !== H && n.push(a), this._d("polygon", n, s);
  }
  path(t, e) {
    const s = this._o(e),
      n = [];
    if (!t) return this._d("path", n, s);
    t = (t || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const a = s.fill && "transparent" !== s.fill && s.fill !== H,
      o = s.stroke !== H,
      h = !!(s.simplification && s.simplification < 1),
      r = function (t, e, s) {
        const n = g(d(f(t))),
          a = [];
        let o = [],
          h = [0, 0],
          r = [];
        const i = () => {
            r.length >= 4 && o.push(...Q(r, e)), r = [];
          },
          c = () => {
            i(), o.length && (a.push(o), o = []);
          };
        for (const {
          key: t,
          data: e
        } of n) switch (t) {
          case "M":
            c(), h = [e[0], e[1]], o.push(h);
            break;
          case "L":
            i(), o.push([e[0], e[1]]);
            break;
          case "C":
            if (!r.length) {
              const t = o.length ? o[o.length - 1] : h;
              r.push([t[0], t[1]]);
            }
            r.push([e[0], e[1]]), r.push([e[2], e[3]]), r.push([e[4], e[5]]);
            break;
          case "Z":
            i(), o.push([h[0], h[1]]);
        }
        if (c(), !s) return a;
        const l = [];
        for (const t of a) {
          const e = V(t, s);
          e.length && l.push(e);
        }
        return l;
      }(t, 1, h ? 4 - 4 * s.simplification : (1 + s.roughness) / 2);
    return a && ("solid" === s.fillStyle ? n.push(S(r, s)) : n.push(L(r, s))), o && (h ? r.forEach(t => {
      n.push(m$2(t, !1, s));
    }) : n.push(function (t, e) {
      const s = g(d(f(t))),
        n = [];
      let a = [0, 0],
        o = [0, 0];
      for (const {
        key: t,
        data: h
      } of s) switch (t) {
        case "M":
          {
            const t = 1 * (e.maxRandomnessOffset || 0),
              s = e.preserveVertices;
            n.push({
              op: "move",
              data: h.map(n => n + (s ? 0 : A(t, e)))
            }), o = [h[0], h[1]], a = [h[0], h[1]];
            break;
          }
        case "L":
          n.push(...I(o[0], o[1], h[0], h[1], e)), o = [h[0], h[1]];
          break;
        case "C":
          {
            const [t, s, a, r, i, c] = h;
            n.push(...$(t, s, a, r, i, c, o, e)), o = [i, c];
            break;
          }
        case "Z":
          n.push(...I(o[0], o[1], a[0], a[1], e)), o = [a[0], a[1]];
      }
      return {
        type: "path",
        ops: n
      };
    }(t, s))), this._d("path", n, s);
  }
  opsToPath(t, e) {
    let s = "";
    for (const n of t.ops) {
      const t = "number" == typeof e && e >= 0 ? n.data.map(t => +t.toFixed(e)) : n.data;
      switch (n.op) {
        case "move":
          s += `M${t[0]} ${t[1]} `;
          break;
        case "bcurveTo":
          s += `C${t[0]} ${t[1]}, ${t[2]} ${t[3]}, ${t[4]} ${t[5]} `;
          break;
        case "lineTo":
          s += `L${t[0]} ${t[1]} `;
      }
    }
    return s.trim();
  }
  toPaths(t) {
    const e = t.sets || [],
      s = t.options || this.defaultOptions,
      n = [];
    for (const t of e) {
      let e = null;
      switch (t.type) {
        case "path":
          e = {
            d: this.opsToPath(t),
            stroke: s.stroke,
            strokeWidth: s.strokeWidth,
            fill: H
          };
          break;
        case "fillPath":
          e = {
            d: this.opsToPath(t),
            stroke: H,
            strokeWidth: 0,
            fill: s.fill || H
          };
          break;
        case "fillSketch":
          e = this.fillSketch(t, s);
      }
      e && n.push(e);
    }
    return n;
  }
  fillSketch(t, e) {
    let s = e.fillWeight;
    return s < 0 && (s = e.strokeWidth / 2), {
      d: this.opsToPath(t),
      stroke: e.fill || H,
      strokeWidth: s,
      fill: H
    };
  }
}
class B {
  constructor(t, e) {
    this.canvas = t, this.ctx = this.canvas.getContext("2d"), this.gen = new N(e);
  }
  draw(t) {
    const e = t.sets || [],
      s = t.options || this.getDefaultOptions(),
      n = this.ctx,
      a = t.options.fixedDecimalPlaceDigits;
    for (const o of e) switch (o.type) {
      case "path":
        n.save(), n.strokeStyle = "none" === s.stroke ? "transparent" : s.stroke, n.lineWidth = s.strokeWidth, s.strokeLineDash && n.setLineDash(s.strokeLineDash), s.strokeLineDashOffset && (n.lineDashOffset = s.strokeLineDashOffset), this._drawToContext(n, o, a), n.restore();
        break;
      case "fillPath":
        {
          n.save(), n.fillStyle = s.fill || "";
          const e = "curve" === t.shape || "polygon" === t.shape || "path" === t.shape ? "evenodd" : "nonzero";
          this._drawToContext(n, o, a, e), n.restore();
          break;
        }
      case "fillSketch":
        this.fillSketch(n, o, s);
    }
  }
  fillSketch(t, e, s) {
    let n = s.fillWeight;
    n < 0 && (n = s.strokeWidth / 2), t.save(), s.fillLineDash && t.setLineDash(s.fillLineDash), s.fillLineDashOffset && (t.lineDashOffset = s.fillLineDashOffset), t.strokeStyle = s.fill || "", t.lineWidth = n, this._drawToContext(t, e, s.fixedDecimalPlaceDigits), t.restore();
  }
  _drawToContext(t, e, s) {
    let n = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "nonzero";
    t.beginPath();
    for (const n of e.ops) {
      const e = "number" == typeof s && s >= 0 ? n.data.map(t => +t.toFixed(s)) : n.data;
      switch (n.op) {
        case "move":
          t.moveTo(e[0], e[1]);
          break;
        case "bcurveTo":
          t.bezierCurveTo(e[0], e[1], e[2], e[3], e[4], e[5]);
          break;
        case "lineTo":
          t.lineTo(e[0], e[1]);
      }
    }
    "fillPath" === e.type ? t.fill(n) : t.stroke();
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(t, e, s, n, a) {
    const o = this.gen.line(t, e, s, n, a);
    return this.draw(o), o;
  }
  rectangle(t, e, s, n, a) {
    const o = this.gen.rectangle(t, e, s, n, a);
    return this.draw(o), o;
  }
  ellipse(t, e, s, n, a) {
    const o = this.gen.ellipse(t, e, s, n, a);
    return this.draw(o), o;
  }
  circle(t, e, s, n) {
    const a = this.gen.circle(t, e, s, n);
    return this.draw(a), a;
  }
  linearPath(t, e) {
    const s = this.gen.linearPath(t, e);
    return this.draw(s), s;
  }
  polygon(t, e) {
    const s = this.gen.polygon(t, e);
    return this.draw(s), s;
  }
  arc(t, e, s, n, a, o) {
    let h = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
    let r = arguments.length > 7 ? arguments[7] : undefined;
    const i = this.gen.arc(t, e, s, n, a, o, h, r);
    return this.draw(i), i;
  }
  curve(t, e) {
    const s = this.gen.curve(t, e);
    return this.draw(s), s;
  }
  path(t, e) {
    const s = this.gen.path(t, e);
    return this.draw(s), s;
  }
}
const J = "http://www.w3.org/2000/svg";
class K {
  constructor(t, e) {
    this.svg = t, this.gen = new N(e);
  }
  draw(t) {
    const e = t.sets || [],
      s = t.options || this.getDefaultOptions(),
      n = this.svg.ownerDocument || window.document,
      a = n.createElementNS(J, "g"),
      o = t.options.fixedDecimalPlaceDigits;
    for (const h of e) {
      let e = null;
      switch (h.type) {
        case "path":
          e = n.createElementNS(J, "path"), e.setAttribute("d", this.opsToPath(h, o)), e.setAttribute("stroke", s.stroke), e.setAttribute("stroke-width", s.strokeWidth + ""), e.setAttribute("fill", "none"), s.strokeLineDash && e.setAttribute("stroke-dasharray", s.strokeLineDash.join(" ").trim()), s.strokeLineDashOffset && e.setAttribute("stroke-dashoffset", `${s.strokeLineDashOffset}`);
          break;
        case "fillPath":
          e = n.createElementNS(J, "path"), e.setAttribute("d", this.opsToPath(h, o)), e.setAttribute("stroke", "none"), e.setAttribute("stroke-width", "0"), e.setAttribute("fill", s.fill || ""), "curve" !== t.shape && "polygon" !== t.shape || e.setAttribute("fill-rule", "evenodd");
          break;
        case "fillSketch":
          e = this.fillSketch(n, h, s);
      }
      e && a.appendChild(e);
    }
    return a;
  }
  fillSketch(t, e, s) {
    let n = s.fillWeight;
    n < 0 && (n = s.strokeWidth / 2);
    const a = t.createElementNS(J, "path");
    return a.setAttribute("d", this.opsToPath(e, s.fixedDecimalPlaceDigits)), a.setAttribute("stroke", s.fill || ""), a.setAttribute("stroke-width", n + ""), a.setAttribute("fill", "none"), s.fillLineDash && a.setAttribute("stroke-dasharray", s.fillLineDash.join(" ").trim()), s.fillLineDashOffset && a.setAttribute("stroke-dashoffset", `${s.fillLineDashOffset}`), a;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(t, e) {
    return this.gen.opsToPath(t, e);
  }
  line(t, e, s, n, a) {
    const o = this.gen.line(t, e, s, n, a);
    return this.draw(o);
  }
  rectangle(t, e, s, n, a) {
    const o = this.gen.rectangle(t, e, s, n, a);
    return this.draw(o);
  }
  ellipse(t, e, s, n, a) {
    const o = this.gen.ellipse(t, e, s, n, a);
    return this.draw(o);
  }
  circle(t, e, s, n) {
    const a = this.gen.circle(t, e, s, n);
    return this.draw(a);
  }
  linearPath(t, e) {
    const s = this.gen.linearPath(t, e);
    return this.draw(s);
  }
  polygon(t, e) {
    const s = this.gen.polygon(t, e);
    return this.draw(s);
  }
  arc(t, e, s, n, a, o) {
    let h = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !1;
    let r = arguments.length > 7 ? arguments[7] : undefined;
    const i = this.gen.arc(t, e, s, n, a, o, h, r);
    return this.draw(i);
  }
  curve(t, e) {
    const s = this.gen.curve(t, e);
    return this.draw(s);
  }
  path(t, e) {
    const s = this.gen.path(t, e);
    return this.draw(s);
  }
}
var U = {
  canvas: (t, e) => new B(t, e),
  svg: (t, e) => new K(t, e),
  generator: t => new N(t),
  newSeed: () => N.newSeed()
};

const defaultRouthThemeSpec = {
  maxRandomnessOffset: 3,
  roughness: 1,
  bowing: 1,
  curveFitting: .95,
  curveTightness: void 0,
  curveStepCount: 9,
  fillStyle: "hachure",
  fillWeight: void 0,
  hachureAngle: 60,
  hachureGap: 6,
  simplification: 0,
  dashOffset: void 0,
  dashGap: void 0,
  zigzagOffset: void 0,
  seed: 1,
  fillLineDash: void 0,
  fillLineDashOffset: void 0,
  disableMultiStroke: !1,
  disableMultiStrokeFill: !1,
  preserveVertices: !0,
  fixedDecimalPlaceDigits: void 0
};

class RoughBaseRender {
  drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb);
  }
}

var __decorate$17 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$V = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$D = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let RoughCanvasArcRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
  draw(arc, renderService, drawContext, params) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas,
      rc = U.canvas(canvas);
    context.highPerformanceSave();
    const arcAttribute = arc.getGraphicTheme();
    let {
      x = arcAttribute.x,
      y = arcAttribute.y
    } = arc.attribute;
    if (arc.transMatrix.onlyTranslate()) {
      const {
        dx = arcAttribute.dx,
        dy = arcAttribute.dy
      } = arc.attribute;
      x += dx, y += dy, context.setTransformForCurrent();
    } else x = 0, y = 0, context.transformFromMatrix(arc.transMatrix, !0);
    const customPath = new CustomPath2D(),
      {
        fill = arcAttribute.fill,
        stroke = arcAttribute.stroke,
        lineWidth = arcAttribute.lineWidth,
        outerRadius = arcAttribute.outerRadius,
        innerRadius = arcAttribute.innerRadius,
        maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset,
        roughness = defaultRouthThemeSpec.roughness,
        bowing = defaultRouthThemeSpec.bowing,
        curveFitting = defaultRouthThemeSpec.curveFitting,
        curveTightness = defaultRouthThemeSpec.curveTightness,
        curveStepCount = defaultRouthThemeSpec.curveStepCount,
        fillStyle = defaultRouthThemeSpec.fillStyle,
        fillWeight = defaultRouthThemeSpec.fillWeight,
        hachureAngle = defaultRouthThemeSpec.hachureAngle,
        hachureGap = defaultRouthThemeSpec.hachureGap,
        simplification = defaultRouthThemeSpec.simplification,
        dashOffset = defaultRouthThemeSpec.dashOffset,
        dashGap = defaultRouthThemeSpec.dashGap,
        zigzagOffset = defaultRouthThemeSpec.zigzagOffset,
        seed = defaultRouthThemeSpec.seed,
        fillLineDash = defaultRouthThemeSpec.fillLineDash,
        fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset,
        disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke,
        disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill,
        preserveVertices = defaultRouthThemeSpec.preserveVertices,
        fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits
      } = arc.attribute;
    drawArcPath$1(arc, customPath, x, y, outerRadius, innerRadius), rc.path(customPath.toString(), {
      fill: fill || void 0,
      stroke: stroke || void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset: maxRandomnessOffset,
      roughness: roughness,
      bowing: bowing,
      curveFitting: curveFitting,
      curveTightness: curveTightness,
      curveStepCount: curveStepCount,
      fillStyle: fillStyle,
      fillWeight: fillWeight,
      hachureAngle: hachureAngle,
      hachureGap: hachureGap,
      simplification: simplification,
      dashOffset: dashOffset,
      dashGap: dashGap,
      zigzagOffset: zigzagOffset,
      seed: seed,
      fillLineDash: fillLineDash,
      fillLineDashOffset: fillLineDashOffset,
      disableMultiStroke: disableMultiStroke,
      disableMultiStrokeFill: disableMultiStrokeFill,
      preserveVertices: preserveVertices,
      fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasArcRender = __decorate$17([injectable(), __param$D(0, inject(DefaultCanvasArcRender)), __metadata$V("design:paramtypes", [Object])], RoughCanvasArcRender);

var __decorate$16 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RoughCanvasAreaRender = class extends DefaultCanvasAreaRender {
  constructor() {
    super(...arguments), this.style = "rough";
  }
  drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb) {
    if (fillCb) return super.drawSegmentItem(context, cache, fill, fillOpacity, stroke, strokeOpacity, attribute, defaultAttribute, clipRange, offsetX, offsetY, offsetZ, area, drawContext, fillCb);
    context.highPerformanceSave();
    const canvas = context.canvas.nativeCanvas,
      rc = U.canvas(canvas, {}),
      customPath = new CustomPath2D();
    drawAreaSegments(customPath, cache, clipRange, {
      offsetX: offsetX,
      offsetY: offsetY
    });
    const {
      maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset,
      roughness = defaultRouthThemeSpec.roughness,
      bowing = defaultRouthThemeSpec.bowing,
      curveFitting = defaultRouthThemeSpec.curveFitting,
      curveTightness = defaultRouthThemeSpec.curveTightness,
      curveStepCount = defaultRouthThemeSpec.curveStepCount,
      fillStyle = defaultRouthThemeSpec.fillStyle,
      fillWeight = defaultRouthThemeSpec.fillWeight,
      hachureAngle = defaultRouthThemeSpec.hachureAngle,
      hachureGap = defaultRouthThemeSpec.hachureGap,
      simplification = defaultRouthThemeSpec.simplification,
      dashOffset = defaultRouthThemeSpec.dashOffset,
      dashGap = defaultRouthThemeSpec.dashGap,
      zigzagOffset = defaultRouthThemeSpec.zigzagOffset,
      seed = defaultRouthThemeSpec.seed,
      fillLineDash = defaultRouthThemeSpec.fillLineDash,
      fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset,
      disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke,
      disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill,
      preserveVertices = defaultRouthThemeSpec.preserveVertices,
      fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits
    } = attribute;
    let {
      fill: fillColor,
      stroke: strokeColor,
      lineWidth: lineWidth
    } = attribute;
    return Array.isArray(defaultAttribute) ? defaultAttribute.forEach(item => {
      fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
    }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
      fill: fill ? fillColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset: maxRandomnessOffset,
      roughness: roughness,
      bowing: bowing,
      curveFitting: curveFitting,
      curveTightness: curveTightness,
      curveStepCount: curveStepCount,
      fillStyle: fillStyle,
      fillWeight: fillWeight,
      hachureAngle: hachureAngle,
      hachureGap: hachureGap,
      simplification: simplification,
      dashOffset: dashOffset,
      dashGap: dashGap,
      zigzagOffset: zigzagOffset,
      seed: seed,
      fillLineDash: fillLineDash,
      fillLineDashOffset: fillLineDashOffset,
      disableMultiStroke: disableMultiStroke,
      disableMultiStrokeFill: disableMultiStrokeFill,
      preserveVertices: preserveVertices,
      fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
    }), context.highPerformanceRestore(), !1;
  }
};
RoughCanvasAreaRender = __decorate$16([injectable()], RoughCanvasAreaRender);

var __decorate$15 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$U = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$C = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let RoughCanvasCircleRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
  draw(circle, renderService, drawContext, params) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas,
      rc = U.canvas(canvas, {}),
      circleAttribute = circle.getGraphicTheme();
    let {
      x = circleAttribute.x,
      y = circleAttribute.y
    } = circle.attribute;
    circle.transMatrix.onlyTranslate() ? context.onlyTranslate() || context.clearMatrix() : (x = 0, y = 0, context.transformFromMatrix(circle.transMatrix, !0));
    const {
      radius = circleAttribute.radius,
      fill = circleAttribute.fill,
      stroke = circleAttribute.stroke,
      lineWidth = circleAttribute.lineWidth
    } = circle.attribute;
    rc.circle(x, y, radius, {
      fill: fill || void 0,
      stroke: stroke || void 0,
      strokeWidth: lineWidth,
      fillStyle: "zigzag",
      roughness: .5
    });
  }
};
RoughCanvasCircleRender = __decorate$15([injectable(), __param$C(0, inject(DefaultCanvasCircleRender)), __metadata$U("design:paramtypes", [Object])], RoughCanvasCircleRender);

var __decorate$14 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let RoughCanvasLineRender = class extends DefaultCanvasLineRender {
  constructor() {
    super(...arguments), this.style = "rough";
  }
  drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb) {
    if (fillCb || strokeCb) return super.drawSegmentItem(context, cache, fill, stroke, fillOpacity, strokeOpacity, attribute, defaultAttribute, clipRange, clipRangeByDimension, offsetX, offsetY, line, fillCb, strokeCb);
    context.highPerformanceSave();
    const canvas = context.canvas.nativeCanvas,
      rc = U.canvas(canvas, {}),
      customPath = new CustomPath2D();
    drawSegments(context.camera ? context : context.nativeContext, cache, clipRange, clipRangeByDimension, {
      offsetX: offsetX,
      offsetY: offsetY
    });
    const {
      maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset,
      roughness = defaultRouthThemeSpec.roughness,
      bowing = defaultRouthThemeSpec.bowing,
      curveFitting = defaultRouthThemeSpec.curveFitting,
      curveTightness = defaultRouthThemeSpec.curveTightness,
      curveStepCount = defaultRouthThemeSpec.curveStepCount,
      fillStyle = defaultRouthThemeSpec.fillStyle,
      fillWeight = defaultRouthThemeSpec.fillWeight,
      hachureAngle = defaultRouthThemeSpec.hachureAngle,
      hachureGap = defaultRouthThemeSpec.hachureGap,
      simplification = defaultRouthThemeSpec.simplification,
      dashOffset = defaultRouthThemeSpec.dashOffset,
      dashGap = defaultRouthThemeSpec.dashGap,
      zigzagOffset = defaultRouthThemeSpec.zigzagOffset,
      seed = defaultRouthThemeSpec.seed,
      fillLineDash = defaultRouthThemeSpec.fillLineDash,
      fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset,
      disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke,
      disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill,
      preserveVertices = defaultRouthThemeSpec.preserveVertices,
      fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits
    } = attribute;
    let {
      fill: fillColor,
      stroke: strokeColor,
      lineWidth: lineWidth
    } = attribute;
    return Array.isArray(defaultAttribute) ? defaultAttribute.forEach(item => {
      fillColor = null != fillColor ? fillColor : item.fill, strokeColor = null != strokeColor ? strokeColor : item.stroke, lineWidth = null != lineWidth ? lineWidth : item.lineWidth;
    }) : (fillColor = null != fillColor ? fillColor : defaultAttribute.fill, strokeColor = null != strokeColor ? strokeColor : defaultAttribute.stroke, lineWidth = null != lineWidth ? lineWidth : defaultAttribute.lineWidth), rc.path(customPath.toString(), {
      fill: fill ? fillColor : void 0,
      stroke: stroke ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset: maxRandomnessOffset,
      roughness: roughness,
      bowing: bowing,
      curveFitting: curveFitting,
      curveTightness: curveTightness,
      curveStepCount: curveStepCount,
      fillStyle: fillStyle,
      fillWeight: fillWeight,
      hachureAngle: hachureAngle,
      hachureGap: hachureGap,
      simplification: simplification,
      dashOffset: dashOffset,
      dashGap: dashGap,
      zigzagOffset: zigzagOffset,
      seed: seed,
      fillLineDash: fillLineDash,
      fillLineDashOffset: fillLineDashOffset,
      disableMultiStroke: disableMultiStroke,
      disableMultiStrokeFill: disableMultiStrokeFill,
      preserveVertices: preserveVertices,
      fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
    }), context.highPerformanceRestore(), !1;
  }
};
RoughCanvasLineRender = __decorate$14([injectable()], RoughCanvasLineRender);

var __decorate$13 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$T = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$B = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let RoughCanvasPathRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
  draw(path, renderService, drawContext, params) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas,
      rc = U.canvas(canvas, {});
    context.highPerformanceSave();
    const pathAttribute = path.getGraphicTheme();
    context.transformFromMatrix(path.transMatrix, !0);
    const {
      fill = pathAttribute.fill,
      stroke = pathAttribute.stroke,
      lineWidth = pathAttribute.lineWidth,
      path: p = pathAttribute.path,
      maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset,
      roughness = defaultRouthThemeSpec.roughness,
      bowing = defaultRouthThemeSpec.bowing,
      curveFitting = defaultRouthThemeSpec.curveFitting,
      curveTightness = defaultRouthThemeSpec.curveTightness,
      curveStepCount = defaultRouthThemeSpec.curveStepCount,
      fillStyle = defaultRouthThemeSpec.fillStyle,
      fillWeight = defaultRouthThemeSpec.fillWeight,
      hachureAngle = defaultRouthThemeSpec.hachureAngle,
      hachureGap = defaultRouthThemeSpec.hachureGap,
      simplification = defaultRouthThemeSpec.simplification,
      dashOffset = defaultRouthThemeSpec.dashOffset,
      dashGap = defaultRouthThemeSpec.dashGap,
      zigzagOffset = defaultRouthThemeSpec.zigzagOffset,
      seed = defaultRouthThemeSpec.seed,
      fillLineDash = defaultRouthThemeSpec.fillLineDash,
      fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset,
      disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke,
      disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill,
      preserveVertices = defaultRouthThemeSpec.preserveVertices,
      fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits
    } = path.attribute;
    "string" == typeof p && rc.path(p, {
      fill: fill || void 0,
      stroke: stroke || void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset: maxRandomnessOffset,
      roughness: roughness,
      bowing: bowing,
      curveFitting: curveFitting,
      curveTightness: curveTightness,
      curveStepCount: curveStepCount,
      fillStyle: fillStyle,
      fillWeight: fillWeight,
      hachureAngle: hachureAngle,
      hachureGap: hachureGap,
      simplification: simplification,
      dashOffset: dashOffset,
      dashGap: dashGap,
      zigzagOffset: zigzagOffset,
      seed: seed,
      fillLineDash: fillLineDash,
      fillLineDashOffset: fillLineDashOffset,
      disableMultiStroke: disableMultiStroke,
      disableMultiStrokeFill: disableMultiStrokeFill,
      preserveVertices: preserveVertices,
      fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasPathRender = __decorate$13([injectable(), __param$B(0, inject(DefaultCanvasPathRender)), __metadata$T("design:paramtypes", [Object])], RoughCanvasPathRender);

var __decorate$12 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$S = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$A = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let RoughCanvasRectRender = class extends RoughBaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.style = "rough", this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  draw(rect, renderService, drawContext, params) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas,
      rc = U.canvas(canvas);
    context.highPerformanceSave();
    const rectAttribute = rect.getGraphicTheme();
    let {
      x = rectAttribute.x,
      y = rectAttribute.y
    } = rect.attribute;
    if (rect.transMatrix.onlyTranslate()) {
      const {
        dx = rectAttribute.dx,
        dy = rectAttribute.dy
      } = rect.attribute;
      x += dx, y += dy, context.setTransformForCurrent();
    } else x = 0, y = 0, context.transformFromMatrix(rect.transMatrix, !0);
    const {
      fill = rectAttribute.fill,
      stroke = rectAttribute.stroke,
      fillColor = rectAttribute.fill,
      strokeColor = rectAttribute.stroke,
      x1: x1,
      y1: y1,
      lineWidth = rectAttribute.lineWidth,
      maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset,
      roughness = defaultRouthThemeSpec.roughness,
      bowing = defaultRouthThemeSpec.bowing,
      curveFitting = defaultRouthThemeSpec.curveFitting,
      curveTightness = defaultRouthThemeSpec.curveTightness,
      curveStepCount = defaultRouthThemeSpec.curveStepCount,
      fillStyle = defaultRouthThemeSpec.fillStyle,
      fillWeight = defaultRouthThemeSpec.fillWeight,
      hachureAngle = defaultRouthThemeSpec.hachureAngle,
      hachureGap = defaultRouthThemeSpec.hachureGap,
      simplification = defaultRouthThemeSpec.simplification,
      dashOffset = defaultRouthThemeSpec.dashOffset,
      dashGap = defaultRouthThemeSpec.dashGap,
      zigzagOffset = defaultRouthThemeSpec.zigzagOffset,
      seed = defaultRouthThemeSpec.seed,
      fillLineDash = defaultRouthThemeSpec.fillLineDash,
      fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset,
      disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke,
      disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill,
      preserveVertices = defaultRouthThemeSpec.preserveVertices,
      fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits
    } = rect.attribute;
    let {
      width = rectAttribute.width,
      height = rectAttribute.height
    } = rect.attribute;
    width = (null != width ? width : x1 - x) || 0, height = (null != height ? height : y1 - y) || 0, rc.rectangle(x, y, width, height, {
      fill: fill ? fillColor : void 0,
      stroke: stroke ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset: maxRandomnessOffset,
      roughness: roughness,
      bowing: bowing,
      curveFitting: curveFitting,
      curveTightness: curveTightness,
      curveStepCount: curveStepCount,
      fillStyle: fillStyle,
      fillWeight: fillWeight,
      hachureAngle: hachureAngle,
      hachureGap: hachureGap,
      simplification: simplification,
      dashOffset: dashOffset,
      dashGap: dashGap,
      zigzagOffset: zigzagOffset,
      seed: seed,
      fillLineDash: fillLineDash,
      fillLineDashOffset: fillLineDashOffset,
      disableMultiStroke: disableMultiStroke,
      disableMultiStrokeFill: disableMultiStrokeFill,
      preserveVertices: preserveVertices,
      fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
};
RoughCanvasRectRender = __decorate$12([injectable(), __param$A(0, inject(DefaultCanvasRectRender)), __metadata$S("design:paramtypes", [Object])], RoughCanvasRectRender);

var __decorate$11 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$R = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$z = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let RoughCanvasSymbolRender = class extends BaseRender {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE, this.style = "rough";
  }
  draw(symbol, renderService, drawContext, params) {
    const {
      context: context
    } = drawContext;
    if (!context) return;
    const canvas = context.canvas.nativeCanvas,
      rc = U.canvas(canvas);
    context.highPerformanceSave();
    const symbolAttribute = symbol.getGraphicTheme(),
      data = this.transform(symbol, symbolAttribute, context),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data,
      parsedPath = symbol.getParsedPath();
    if (!parsedPath) return;
    const {
      fill = symbolAttribute.fill,
      stroke = symbolAttribute.stroke,
      fillColor = symbolAttribute.fill,
      strokeColor = symbolAttribute.stroke,
      size = symbolAttribute.size,
      lineWidth = symbolAttribute.lineWidth,
      maxRandomnessOffset = defaultRouthThemeSpec.maxRandomnessOffset,
      roughness = defaultRouthThemeSpec.roughness,
      bowing = defaultRouthThemeSpec.bowing,
      curveFitting = defaultRouthThemeSpec.curveFitting,
      curveTightness = defaultRouthThemeSpec.curveTightness,
      curveStepCount = defaultRouthThemeSpec.curveStepCount,
      fillStyle = defaultRouthThemeSpec.fillStyle,
      fillWeight = defaultRouthThemeSpec.fillWeight,
      hachureAngle = defaultRouthThemeSpec.hachureAngle,
      hachureGap = defaultRouthThemeSpec.hachureGap,
      simplification = defaultRouthThemeSpec.simplification,
      dashOffset = defaultRouthThemeSpec.dashOffset,
      dashGap = defaultRouthThemeSpec.dashGap,
      zigzagOffset = defaultRouthThemeSpec.zigzagOffset,
      seed = defaultRouthThemeSpec.seed,
      fillLineDash = defaultRouthThemeSpec.fillLineDash,
      fillLineDashOffset = defaultRouthThemeSpec.fillLineDashOffset,
      disableMultiStroke = defaultRouthThemeSpec.disableMultiStroke,
      disableMultiStrokeFill = defaultRouthThemeSpec.disableMultiStrokeFill,
      preserveVertices = defaultRouthThemeSpec.preserveVertices,
      fixedDecimalPlaceDigits = defaultRouthThemeSpec.fixedDecimalPlaceDigits
    } = symbol.attribute;
    let svgPath = "";
    if (parsedPath.drawToSvgPath) svgPath = parsedPath.drawToSvgPath(size, x, y);else {
      const customPath = new CustomPath2D();
      parsedPath.draw(customPath, size, x, y) && customPath.closePath(), svgPath = customPath.toString();
    }
    rc.path(svgPath, {
      fill: fill ? fillColor : void 0,
      stroke: stroke ? strokeColor : void 0,
      strokeWidth: lineWidth,
      maxRandomnessOffset: maxRandomnessOffset,
      roughness: roughness,
      bowing: bowing,
      curveFitting: curveFitting,
      curveTightness: curveTightness,
      curveStepCount: curveStepCount,
      fillStyle: fillStyle,
      fillWeight: fillWeight,
      hachureAngle: hachureAngle,
      hachureGap: hachureGap,
      simplification: simplification,
      dashOffset: dashOffset,
      dashGap: dashGap,
      zigzagOffset: zigzagOffset,
      seed: seed,
      fillLineDash: fillLineDash,
      fillLineDashOffset: fillLineDashOffset,
      disableMultiStroke: disableMultiStroke,
      disableMultiStrokeFill: disableMultiStrokeFill,
      preserveVertices: preserveVertices,
      fixedDecimalPlaceDigits: fixedDecimalPlaceDigits
    }), context.highPerformanceRestore();
  }
  drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb) {
    if (this.canvasRenderer.drawShape) return this.canvasRenderer.drawShape(graphic, ctx, x, y, drawContext, params, fillCb, strokeCb);
  }
};
RoughCanvasSymbolRender = __decorate$11([injectable(), __param$z(0, inject(DefaultCanvasSymbolRender)), __metadata$R("design:paramtypes", [Object])], RoughCanvasSymbolRender);

var _roughModule = new ContainerModule(bind => {
  bind(RoughCanvasCircleRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasCircleRender), bind(RoughCanvasRectRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasRectRender), bind(RoughCanvasPathRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasPathRender), bind(RoughCanvasSymbolRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasSymbolRender), bind(RoughCanvasLineRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasLineRender), bind(RoughCanvasAreaRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasAreaRender), bind(RoughCanvasArcRender).toSelf().inSingletonScope(), bind(GraphicRender).to(RoughCanvasArcRender);
});

const MathPickerContribution = Symbol.for("MathPickerContribution");
const MathArcPicker = Symbol.for("MathArcPicker");
const MathAreaPicker = Symbol.for("MathAreaPicker");
const MathCirclePicker = Symbol.for("MathCirclePicker");
const MathImagePicker = Symbol.for("MathImagePicker");
const MathLinePicker = Symbol.for("MathLinePicker");
const MathPathPicker = Symbol.for("MathPathPicker");
const MathRectPicker = Symbol.for("MathRectPicker");
const MathSymbolPicker = Symbol.for("MathSymbolPicker");
const MathTextPicker = Symbol.for("MathTextPicker");
const MathPolygonPicker = Symbol.for("MathPolygonPicker");
const MathGlyphPicker = Symbol.for("MathGlyphPicker");
const CanvasArcPicker = Symbol.for("CanvasArcPicker");
const CanvasArc3dPicker = Symbol.for("CanvasArc3dPicker");
const CanvasAreaPicker = Symbol.for("CanvasAreaPicker");
const CanvasCirclePicker = Symbol.for("CanvasCirclePicker");
const CanvasImagePicker = Symbol.for("CanvasImagePicker");
const CanvasGifImagePicker = Symbol.for("CanvasGifImagePicker");
const CanvasLinePicker = Symbol.for("CanvasLinePicker");
const CanvasLottiePicker = Symbol.for("CanvasLottiePicker");
const CanvasPathPicker = Symbol.for("CanvasPathPicker");
const CanvasRectPicker = Symbol.for("CanvasRectPicker");
const CanvasRect3dPicker = Symbol.for("CanvasRect3dPicker");
const CanvasSymbolPicker = Symbol.for("CanvasSymbolPicker");
const CanvasTextPicker = Symbol.for("CanvasTextPicker");
const CanvasPolygonPicker = Symbol.for("CanvasPolygonPicker");
const CanvasPyramid3dPicker = Symbol.for("CanvasPyramid3dPicker");
const CanvasRichTextPicker = Symbol.for("CanvasRichTextPicker");
const CanvasGlyphPicker = Symbol.for("CanvasGlyphPicker");
const CanvasGroupPicker = Symbol.for("CanvasGroupPicker");
const CanvasPickerContribution = Symbol.for("CanvasPickerContribution");

const REACT_TO_CANOPUS_EVENTS = {
  onPointerDown: "pointerdown",
  onPointerUp: "pointerup",
  onPointerUpOutside: "pointerupoutside",
  onPointerTap: "pointertap",
  onPointerOver: "pointerover",
  onPointerMove: "pointermove",
  onPointerEnter: "pointerenter",
  onPointerLeave: "pointerleave",
  onPointerOut: "pointerout",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onMouseUpOutside: "mouseupoutside",
  onMouseMove: "mousemove",
  onMouseOver: "mouseover",
  onMouseOut: "mouseout",
  onMouseEnter: "mouseenter",
  onMouseLeave: "mouseleave",
  onPinch: "pinch",
  onPinchStart: "pinchstart",
  onPinchEnd: "pinchend",
  onPan: "pan",
  onPanStart: "panstart",
  onPanEnd: "panend",
  onDrag: "drag",
  onDragStart: "dragstart",
  onDragEnter: "dragenter",
  onDragLeave: "dragleave",
  onDragOver: "dragover",
  onDragEnd: "dragend",
  onRightDown: "rightdown",
  onRightUp: "rightup",
  onRightUpOutside: "rightupoutside",
  onTouchStart: "touchstart",
  onTouchEnd: "touchend",
  onTouchEndOutside: "touchendoutside",
  onTouchMove: "touchmove",
  onTouchCancel: "touchcancel",
  onPress: "press",
  onPressUp: "pressup",
  onPressEnd: "pressend",
  onSwipe: "swipe",
  onDrop: "drop",
  onWeel: "wheel",
  onClick: "click",
  onDblClick: "dblclick"
};
const REACT_TO_CANOPUS_EVENTS_LIST = Object.keys(REACT_TO_CANOPUS_EVENTS);
function VArc(params) {
  return graphicCreator.arc(params ? params.attribute : {});
}
function VArc3d(params) {
  return graphicCreator.arc3d(params ? params.attribute : {});
}
function VArea(params) {
  return graphicCreator.area(params ? params.attribute : {});
}
function VCircle(params) {
  return graphicCreator.circle(params ? params.attribute : {});
}
function VGroup(params) {
  return graphicCreator.group(params ? params.attribute : {});
}
function VGlyph(params) {
  return graphicCreator.glyph(params ? params.attribute : {});
}
function VImage(params) {
  return graphicCreator.image(params ? params.attribute : {});
}
function VLine(params) {
  return graphicCreator.line(params ? params.attribute : {});
}
function VPath(params) {
  return graphicCreator.path(params ? params.attribute : {});
}
function VPolygon(params) {
  return graphicCreator.polygon(params ? params.attribute : {});
}
function VPyramid3d(params) {
  return graphicCreator.pyramid3d(params ? params.attribute : {});
}
function VRect(params) {
  return graphicCreator.rect(params ? params.attribute : {});
}
function VRect3d(params) {
  return graphicCreator.rect3d(params ? params.attribute : {});
}
function VSymbol(params) {
  return graphicCreator.symbol(params ? params.attribute : {});
}
function VText(params) {
  return graphicCreator.text(params ? params.attribute : {});
}
function VRichText(params) {
  return graphicCreator.richtext(params ? params.attribute : {});
}
VRichText.Text = function (params) {
  return Object.assign({
    type: "rich/text"
  }, params);
}, VRichText.Image = function (params) {
  return Object.assign({
    type: "rich/image"
  }, params);
};

var __rest = undefined && undefined.__rest || function (s, e) {
  var t = {};
  for (var p in s) Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0 && (t[p] = s[p]);
  if (null != s && "function" == typeof Object.getOwnPropertySymbols) {
    var i = 0;
    for (p = Object.getOwnPropertySymbols(s); i < p.length; i++) e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]) && (t[p[i]] = s[p[i]]);
  }
  return t;
};
function flatten(list, out) {
  if (isArray$1(list)) return list.forEach(i => flatten(i, out));
  out.push(list);
}
function jsx(type, config) {
  const _a = config || {},
    {
      key: key,
      name: name,
      id: id,
      attribute: attribute,
      stateProxy: stateProxy,
      animation: animation,
      timeline: timeline
    } = _a,
    props = __rest(_a, ["key", "name", "id", "attribute", "stateProxy", "animation", "timeline"]);
  let c = type;
  isString$1(type) && (c = graphicCreator[type]);
  const childrenList = [];
  for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    children[_key - 2] = arguments[_key];
  }
  children.length && flatten(1 === children.length ? children[0] : children, childrenList);
  const g = "Group" === c.name ? new c(attribute) : c(config);
  if (parseToGraphic$1(g, childrenList, props), stateProxy && (g.stateProxy = stateProxy), name && (g.name = name), isArray$1(animation)) {
    const animate = g.animate();
    timeline && animate.setTimeline(timeline), animation.forEach(item => {
      animate[item[0]](...item.slice(1));
    });
  }
  return g;
}
function parseToGraphic$1(g, childrenList, props) {
  let out,
    isGraphic = !1;
  switch (g.type) {
    case "richtext":
    case "rich/image":
      break;
    case "rich/text":
      out = g.attribute || {}, childrenList[0] && (out.text = childrenList[0]);
      break;
    default:
      isGraphic = !0;
  }
  isGraphic ? (childrenList.forEach(c => {
    c && g.add(c);
  }), Object.keys(props).forEach(k => {
    const en = REACT_TO_CANOPUS_EVENTS[k];
    en && g.on(en, props[k]);
  })) : "richtext" === g.type && (g.attribute.textConfig = childrenList.map(item => item.attribute).filter(item => item));
}
const Fragment = Group;

function decodeReactDom(dom) {
  if (!dom || !dom.$$typeof) return dom;
  const type = dom.type,
    {
      attribute: attribute,
      children: children,
      stateProxy: stateProxy,
      id: id,
      name: name
    } = dom.props,
    g = type({
      attribute: attribute
    }),
    out = parseToGraphic(g, dom.props, children);
  return out || (stateProxy && (g.stateProxy = stateProxy), g.id = id, g.name = name, parseChildren(children, g), g);
}
function parseChildren(children, g) {
  isArray$1(children) ? children.forEach(item => {
    if (isArray$1(item)) parseChildren(item, g);else {
      const c = decodeReactDom(item);
      c && c.type && g.add(c);
    }
  }) : children && g.add(decodeReactDom(children));
}
function parseToGraphic(g, props, childrenList) {
  let out,
    isGraphic = !1;
  switch (g.type) {
    case "richtext":
      break;
    case "rich/text":
      out = g.attribute || {}, childrenList && (out.text = childrenList), g.attribute = out;
      break;
    case "rich/image":
      out = g.attribute || {};
      break;
    default:
      isGraphic = !0;
  }
  return isGraphic ? Object.keys(props).forEach(k => {
    const en = REACT_TO_CANOPUS_EVENTS[k];
    en && g.on(en, props[k]);
  }) : "richtext" === g.type && (g.attribute.textConfig = childrenList.map(item => decodeReactDom(item)).filter(item => item)), out;
}

class DragNDrop {
  constructor(rootNode) {
    this.onPointerDown = event => {
      const target = event.target,
        rootNode = this.rootNode,
        isRoot = target === rootNode;
      if (target && !isRoot) {
        let currentDroppable,
          dragstartTriggered = !1;
        function handlePointerMove(moveEvent) {
          if (dragstartTriggered || (moveEvent.type = "dragstart", null == target || target.dispatchEvent(moveEvent), dragstartTriggered = !0), moveEvent.type = "drag", null == target || target.dispatchEvent(moveEvent), !isRoot) {
            target.attribute.pickable = !1;
            const elemBelow = (null == rootNode ? void 0 : rootNode.pick(moveEvent.global.x, moveEvent.global.y)).graphic;
            target.attribute.pickable = !0, currentDroppable !== elemBelow && (currentDroppable && (moveEvent.type = "dragleave", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)), elemBelow && (moveEvent.type = "dragenter", moveEvent.target = elemBelow, elemBelow.dispatchEvent(moveEvent)), currentDroppable = elemBelow, currentDroppable && (moveEvent.type = "dragover", moveEvent.target = currentDroppable, currentDroppable.dispatchEvent(moveEvent)));
          }
        }
        null == rootNode || rootNode.addEventListener("pointermove", handlePointerMove);
        const stopDragging = function () {
          dragstartTriggered && (currentDroppable && (event.type = "drop", event.target = currentDroppable, currentDroppable.dispatchEvent(event)), event.type = "dragend", target.dispatchEvent(event), dragstartTriggered = !1), null == rootNode || rootNode.removeEventListener("pointermove", handlePointerMove);
        };
        target.addEventListener("pointerup", stopDragging, {
          once: !0
        }), target.addEventListener("pointerupoutside", stopDragging, {
          once: !0
        });
      }
    }, this.rootNode = rootNode, this.initEvents();
  }
  initEvents() {
    var _a;
    null === (_a = this.rootNode) || void 0 === _a || _a.addEventListener("pointerdown", this.onPointerDown);
  }
  removeEvents() {
    var _a;
    null === (_a = this.rootNode) || void 0 === _a || _a.removeEventListener("pointerdown", this.onPointerDown);
  }
  release() {
    this.removeEvents(), this.rootNode = null;
  }
}

const calcDirection = (start, end) => {
    const xDistance = end.x - start.x,
      yDistance = end.y - start.y;
    return Math.abs(xDistance) > Math.abs(yDistance) ? xDistance > 0 ? "right" : "left" : yDistance > 0 ? "down" : "up";
  },
  calcDistance = (point1, point2) => {
    const xDistance = Math.abs(point2.x - point1.x),
      yDistance = Math.abs(point2.y - point1.y);
    return Math.sqrt(xDistance * xDistance + yDistance * yDistance);
  },
  getCenter = points => {
    const pointersLength = points.length;
    if (1 === pointersLength) return {
      x: Math.round(points[0].x),
      y: Math.round(points[0].y)
    };
    let x = 0,
      y = 0,
      i = 0;
    for (; i < pointersLength;) x += points[i].x, y += points[i].y, i++;
    return {
      x: Math.round(x / pointersLength),
      y: Math.round(y / pointersLength)
    };
  };
class Gesture extends EventEmitter {
  constructor(element) {
    let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    super(), this.cachedEvents = [], this.startPoints = [], this.processEvent = {}, this.throttleTimer = 0, this.emitThrottles = [], this.lastTapTarget = null, this.onStart = ev => {
      this.startTime = clock.now();
      const {
        cachedEvents: cachedEvents,
        startPoints: startPoints
      } = this;
      ev && cachedEvents.push(ev.clone()), startPoints.length = cachedEvents.length;
      for (let i = 0; i < cachedEvents.length; i++) {
        const {
            x: x,
            y: y
          } = cachedEvents[i],
          point = {
            x: x,
            y: y
          };
        startPoints[i] = point;
      }
      if (1 !== startPoints.length) this.startDistance = calcDistance(startPoints[0], startPoints[1]), this.center = getCenter([startPoints[0], startPoints[1]]);else {
        const event = cachedEvents[0];
        this.pressTimeout = setTimeout(() => {
          event.direction = "none", event.deltaX = 0, event.deltaY = 0, event.points = startPoints, this.triggerStartEvent("press", event), this.triggerEvent("press", event), this.eventType = "press", this.direction = "none", this.pressTimeout = null;
        }, this.config.press.time);
      }
    }, this.onMove = ev => {
      this.clearPressTimeout();
      const {
        startPoints: startPoints,
        cachedEvents: cachedEvents
      } = this;
      if (!startPoints.length) return;
      const moveEvent = ev.clone(),
        {
          x: x,
          y: y,
          pointerId: pointerId
        } = moveEvent;
      for (let i = 0, len = cachedEvents.length; i < len; i++) if (pointerId === cachedEvents[i].pointerId) {
        cachedEvents[i] = moveEvent;
        break;
      }
      const point = {
          x: x,
          y: y
        },
        points = cachedEvents.map(cachedEvent => ({
          x: cachedEvent.x,
          y: cachedEvent.y
        })),
        now = clock.now();
      if (this.prevMoveTime = this.lastMoveTime, this.prevMovePoint = this.lastMovePoint, this.lastMoveTime = now, this.lastMovePoint = point, 1 === startPoints.length) {
        const startPoint = startPoints[0],
          deltaX = x - startPoint.x,
          deltaY = y - startPoint.y,
          direction = this.direction || calcDirection(startPoint, point);
        this.direction = direction;
        const eventType = this.getEventType(point);
        return moveEvent.direction = direction, moveEvent.deltaX = deltaX, moveEvent.deltaY = deltaY, moveEvent.points = points, this.triggerStartEvent(eventType, moveEvent), void this.triggerEvent(eventType, moveEvent);
      }
      const {
          startDistance: startDistance
        } = this,
        currentDistance = calcDistance(points[0], points[1]);
      moveEvent.scale = currentDistance / startDistance, moveEvent.center = this.center, moveEvent.points = points, this.triggerStartEvent("pinch", moveEvent), this.triggerEvent("pinch", moveEvent);
    }, this.onEnd = ev => {
      const endEvent = ev.clone(),
        {
          cachedEvents: cachedEvents,
          startPoints: startPoints
        } = this,
        points = cachedEvents.map(ev => ({
          x: ev.x,
          y: ev.y
        }));
      if (endEvent.points = points, this.triggerEndEvent(endEvent), 1 === cachedEvents.length) {
        const now = clock.now(),
          lastMoveTime = this.lastMoveTime;
        if (now - lastMoveTime < 100) {
          const intervalTime = lastMoveTime - (this.prevMoveTime || this.startTime);
          if (intervalTime > 0) {
            const prevMovePoint = this.prevMovePoint || startPoints[0],
              lastMovePoint = this.lastMovePoint || startPoints[0],
              distance = calcDistance(prevMovePoint, lastMovePoint),
              velocity = distance / intervalTime;
            if (velocity > this.config.swipe.velocity && distance > this.config.swipe.threshold) return endEvent.velocity = velocity, endEvent.direction = calcDirection(prevMovePoint, lastMovePoint), this.triggerEvent("swipe", endEvent), this.cachedEvents = [], this.startPoints = [], void this.reset();
          }
        }
        now - this.startTime < this.config.press.time && (now - this.lastTapTime < this.config.tap.interval && ev.target === this.lastTapTarget ? this.tapCount++ : this.tapCount = 1, this.lastTapTime = now, this.lastTapTarget = ev.target, 1 === this.tapCount ? this.triggerEvent("tap", endEvent) : 2 === this.tapCount && (this.triggerEvent("doubletap", endEvent), this.tapCount = 0));
      }
      for (let i = 0, len = cachedEvents.length; i < len; i++) if (cachedEvents[i].pointerId === endEvent.pointerId) {
        cachedEvents.splice(i, 1), startPoints.splice(i, 1);
        break;
      }
      this.reset(), cachedEvents.length > 0 && this.onStart();
    }, this.element = element, this.tapCount = 0, this.lastTapTime = 0, this.config = {
      press: {
        time: null !== (_b = null === (_a = null == config ? void 0 : config.press) || void 0 === _a ? void 0 : _a.time) && void 0 !== _b ? _b : 251,
        threshold: null !== (_d = null === (_c = null == config ? void 0 : config.press) || void 0 === _c ? void 0 : _c.threshold) && void 0 !== _d ? _d : 9
      },
      swipe: {
        threshold: null !== (_f = null === (_e = null == config ? void 0 : config.swipe) || void 0 === _e ? void 0 : _e.threshold) && void 0 !== _f ? _f : 10,
        velocity: null !== (_h = null === (_g = null == config ? void 0 : config.swipe) || void 0 === _g ? void 0 : _g.velocity) && void 0 !== _h ? _h : .3
      },
      tap: {
        interval: null !== (_k = null === (_j = null == config ? void 0 : config.tap) || void 0 === _j ? void 0 : _j.interval) && void 0 !== _k ? _k : 300
      }
    }, this.initEvents();
  }
  initEvents() {
    const {
      element: element
    } = this;
    element && (element.addEventListener("pointerdown", this.onStart), element.addEventListener("pointermove", this.onMove), element.addEventListener("pointerup", this.onEnd), element.addEventListener("pointerleave", this.onEnd), element.addEventListener("pointerupoutside", this.onEnd));
  }
  removeEvents() {
    const {
      element: element
    } = this;
    element && (element.removeEventListener("pointerdown", this.onStart), element.removeEventListener("pointermove", this.onMove), element.removeEventListener("pointerup", this.onEnd), element.removeEventListener("pointerleave", this.onEnd), element.removeEventListener("pointerupoutside", this.onEnd));
  }
  release() {
    this.removeEvents(), this.element = null;
  }
  getEventType(point) {
    const {
      eventType: eventType,
      startTime: startTime,
      startPoints: startPoints
    } = this;
    if ("press" === eventType) return eventType;
    let type;
    return type = clock.now() - startTime > this.config.press.time && calcDistance(startPoints[0], point) < this.config.press.threshold ? "press" : "pan", this.eventType = type, type;
  }
  enable(eventType) {
    this.processEvent[eventType] = !0;
  }
  isProcess(eventType) {
    return this.processEvent[eventType];
  }
  pushEvent(type, ev) {
    const {
        emitThrottles: emitThrottles
      } = this,
      newEvent = {
        type: type,
        ev: ev
      };
    for (let i = 0, len = emitThrottles.length; i < len; i++) if (emitThrottles[i].type === type) return void emitThrottles.splice(i, 1, newEvent);
    emitThrottles.push(newEvent);
  }
  clearPressTimeout() {
    this.pressTimeout && (clearTimeout(this.pressTimeout), this.pressTimeout = null);
  }
  reset() {
    this.clearPressTimeout(), this.startTime = 0, this.startDistance = 0, this.direction = null, this.eventType = null, this.prevMoveTime = 0, this.prevMovePoint = null, this.lastMoveTime = 0, this.lastMovePoint = null;
  }
  triggerEvent(type, ev) {
    this.pushEvent(type, ev);
    const {
      throttleTimer: throttleTimer,
      emitThrottles: emitThrottles
    } = this;
    throttleTimer || (this.throttleTimer = application.global.getRequestAnimationFrame()(() => {
      application.global.getCancelAnimationFrame()(this.throttleTimer), this.throttleTimer = null;
      for (let i = 0, len = emitThrottles.length; i < len; i++) {
        const {
          type: type,
          ev: ev
        } = emitThrottles[i];
        this.emitEvent(type, ev);
      }
      this.emitThrottles.length = 0;
    }));
  }
  triggerStartEvent(type, ev) {
    this.isProcess(type) || (this.enable(type), this.triggerEvent(`${type}start`, ev));
  }
  triggerEndEvent(ev) {
    const processEvent = this.processEvent;
    Object.keys(processEvent).forEach(type => {
      this.triggerEvent(`${type}end`, ev), "press" === type && this.triggerEvent(`${type}up`, ev), delete processEvent[type];
    });
  }
  emitEvent(type, e) {
    if (!this.element) return;
    const listeners = this.element._events[WILDCARD];
    if (listeners) if ("fn" in listeners) listeners.fn.call(listeners.context, e, type);else for (let i = 0, j = listeners.length; i < j && !e.propagationImmediatelyStopped; i++) listeners[i].fn.call(listeners[i].context, e, type);
    this.emit(type, e);
  }
}

var __decorate$10 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$Q = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
const outP = [0, 0, 0],
  addArcToBezierPath = (bezierPath, startAngle, endAngle, cx, cy, rx, ry, clockwise) => {
    if (clockwise) for (; endAngle > startAngle;) endAngle -= pi2;else for (; endAngle < startAngle;) endAngle += pi2;
    const step = pi / 3 * (endAngle > startAngle ? 1 : -1);
    let sa = startAngle,
      ea = sa;
    for (; ea !== endAngle;) {
      ea = step > 0 ? Math.min(ea + step, endAngle) : Math.max(ea + step, endAngle);
      const delta = Math.abs(ea - sa),
        len = 4 * Math.tan(delta / 4) / 3,
        dir = ea < sa ? -1 : 1,
        c1 = Math.cos(sa),
        s1 = Math.sin(sa),
        c2 = Math.cos(ea),
        s2 = Math.sin(ea),
        x1 = c1 * rx + cx,
        y1 = s1 * ry + cy,
        x4 = c2 * rx + cx,
        y4 = s2 * ry + cy,
        hx = rx * len * dir,
        hy = ry * len * dir;
      bezierPath.push([x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4]), sa = ea;
    }
  };
let BrowserContext2d = class {
  set fillStyle(d) {
    this.nativeContext.fillStyle = d;
  }
  get fillStyle() {
    return this.nativeContext.fillStyle;
  }
  set font(d) {
    this.nativeContext.font = d;
  }
  get font() {
    return this.nativeContext.font;
  }
  set globalAlpha(d) {
    this.nativeContext.globalAlpha = d * this.baseGlobalAlpha;
  }
  get globalAlpha() {
    return this.nativeContext.globalAlpha;
  }
  set lineCap(d) {
    this.nativeContext.lineCap = d;
  }
  get lineCap() {
    return this.nativeContext.lineCap;
  }
  set lineDashOffset(d) {
    this.nativeContext.lineDashOffset = d;
  }
  get lineDashOffset() {
    return this.nativeContext.lineDashOffset;
  }
  set lineJoin(d) {
    this.nativeContext.lineJoin = d;
  }
  get lineJoin() {
    return this.nativeContext.lineJoin;
  }
  set lineWidth(d) {
    this.nativeContext.lineWidth = d;
  }
  get lineWidth() {
    return this.nativeContext.lineWidth;
  }
  set miterLimit(d) {
    this.nativeContext.miterLimit = d;
  }
  get miterLimit() {
    return this.nativeContext.miterLimit;
  }
  set shadowBlur(d) {
    this.nativeContext.shadowBlur = d;
  }
  get shadowBlur() {
    return this.nativeContext.shadowBlur;
  }
  set shadowColor(d) {
    this.nativeContext.shadowColor = d;
  }
  get shadowColor() {
    return this.nativeContext.shadowColor;
  }
  set shadowOffsetX(d) {
    this.nativeContext.shadowOffsetX = d;
  }
  get shadowOffsetX() {
    return this.nativeContext.shadowOffsetX;
  }
  set shadowOffsetY(d) {
    this.nativeContext.shadowOffsetY = d;
  }
  get shadowOffsetY() {
    return this.nativeContext.shadowOffsetY;
  }
  set strokeStyle(d) {
    this.nativeContext.strokeStyle = d;
  }
  get strokeStyle() {
    return this.nativeContext.strokeStyle;
  }
  set textAlign(d) {
    this.nativeContext.textAlign = d;
  }
  get textAlign() {
    return this.nativeContext.textAlign;
  }
  set textBaseline(d) {
    this.nativeContext.textBaseline = d;
  }
  get textBaseline() {
    return this.nativeContext.textBaseline;
  }
  get inuse() {
    return !!this._inuse;
  }
  set inuse(use) {
    use !== !!this._inuse && (this._inuse = use, use ? (this.nativeContext.save(), this.reset()) : this.nativeContext.restore());
  }
  constructor(canvas, dpr) {
    this.fillAttributes = Object.assign(Object.assign({}, DefaultFillStyle), {
      opacity: 1
    }), this.strokeAttributes = Object.assign(Object.assign({}, DefaultStrokeStyle), {
      opacity: 1
    }), this.textAttributes = Object.assign(Object.assign({}, DefaultTextStyle), {
      opacity: 1
    }), this._clearShadowStyle = !1, this._clearFilterStyle = !1, this._clearGlobalCompositeOperationStyle = !1;
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context) throw new Error("发生错误，获取2d上下文失败");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = dpr, this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this._clearMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.baseGlobalAlpha = 1;
  }
  reset() {
    this.stack.length && Logger.getInstance().warn("可能存在bug，matrix没有清空"), this.matrix.setValue(1, 0, 0, 1, 0, 0), this.applyedMatrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack.length = 0, this.nativeContext.setTransform(1, 0, 0, 1, 0, 0);
  }
  getCanvas() {
    return this.canvas;
  }
  getContext() {
    return this.nativeContext;
  }
  setTransformForCurrent() {
    let force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !1;
    !force && this.applyedMatrix.equalToMatrix(this.matrix) || (this.applyedMatrix.setValue(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f), this.nativeContext.setTransform(this.matrix.a, this.matrix.b, this.matrix.c, this.matrix.d, this.matrix.e, this.matrix.f));
  }
  get currentMatrix() {
    return this.matrix;
  }
  cloneMatrix(m) {
    return matrixAllocate.allocateByObj(m);
  }
  clear() {
    this.save(), this.resetTransform(), this.nativeContext.clearRect(0, 0, this.canvas.width, this.canvas.height), this.restore();
  }
  restore() {
    this.nativeContext.restore(), this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop(), this.setTransformForCurrent(!0));
  }
  highPerformanceRestore() {
    this.stack.length > 0 && (matrixAllocate.free(this.matrix), this.matrix = this.stack.pop());
  }
  rotate(rad) {
    let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    this.matrix.rotate(rad), setTransform && this.setTransformForCurrent();
  }
  save() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix), this.nativeContext.save();
  }
  highPerformanceSave() {
    const matrix = this.cloneMatrix(this.matrix);
    this.stack.push(matrix);
  }
  scale(sx, sy) {
    let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    this.matrix.scale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  setScale(sx, sy) {
    let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    this.matrix.setScale(sx, sy), setTransform && this.setTransformForCurrent();
  }
  scalePoint(sx, sy, px, py) {
    let setTransform = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : !0;
    this.translate(px, py, !1), this.scale(sx, sy, !1), this.translate(-px, -py, !1), setTransform && this.setTransformForCurrent();
  }
  setTransform(a, b, c, d, e, f) {
    let setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
    let dpr = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : this.dpr;
    this.matrix.setValue(dpr * a, dpr * b, dpr * c, dpr * d, dpr * e, dpr * f), setTransform && this.setTransformForCurrent();
  }
  setTransformFromMatrix(matrix) {
    let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    let dpr = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.dpr;
    this.matrix.setValue(matrix.a * dpr, matrix.b * dpr, matrix.c * dpr, matrix.d * dpr, matrix.e * dpr, matrix.f * dpr), setTransform && this.setTransformForCurrent();
  }
  resetTransform() {
    let setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    let dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
    this.setTransform(dpr, 0, 0, dpr, 0, 0), setTransform && this.setTransformForCurrent();
  }
  transform(a, b, c, d, e, f) {
    let setTransform = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : !0;
    this.matrix.multiply(a, b, c, d, e, f), setTransform && this.setTransformForCurrent();
  }
  transformFromMatrix(matrix, setTransform) {
    this.matrix.multiply(matrix.a, matrix.b, matrix.c, matrix.d, matrix.e, matrix.f), setTransform && this.setTransformForCurrent();
  }
  translate(x, y) {
    let setTransform = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !0;
    this.matrix.translate(x, y), setTransform && this.setTransformForCurrent();
  }
  rotateDegrees(deg) {
    let setTransform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
    const rad = deg * Math.PI / 180;
    this.rotate(rad, setTransform);
  }
  rotateAbout(rad, x, y) {
    let setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
    this.translate(x, y, !1), this.rotate(rad, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
  }
  rotateDegreesAbout(deg, x, y) {
    let setTransform = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !0;
    this.translate(x, y, !1), this.rotateDegrees(deg, !1), this.translate(-x, -y, !1), setTransform && this.setTransformForCurrent();
  }
  beginPath() {
    this.disableBeginPath || this.nativeContext.beginPath();
  }
  clip(path, fillRule) {
    path ? "string" == typeof path ? this.nativeContext.clip(path) : this.nativeContext.clip(path, fillRule) : this.nativeContext.clip();
  }
  arc(x, y, radius, startAngle, endAngle, anticlockwise, z) {
    if (z = z || 0, this.camera) {
      const arr = [];
      addArcToBezierPath(arr, startAngle, endAngle, x, y, radius, radius, anticlockwise);
      for (let i = 0; i < arr.length; ++i) {
        const bez = arr[i];
        this.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5], z);
      }
    } else this.nativeContext.arc(x, y, Math.max(0, radius), startAngle, endAngle, anticlockwise);
  }
  arcTo(x1, y1, x2, y2, radiusX) {
    this.nativeContext.arcTo(x1, y1, x2, y2, radiusX);
  }
  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y, z) {
    if (z = z || 0, this.camera) {
      let cp1z = z,
        cp2z = z;
      this.modelMatrix && (transformMat4(outP, [cp1x, cp1y, z], this.modelMatrix), cp1x = outP[0], cp1y = outP[1], cp1z = outP[2], transformMat4(outP, [cp2x, cp2y, z], this.modelMatrix), cp2x = outP[0], cp2y = outP[1], cp2z = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      let data = this.camera.vp(x, y, z);
      x = data.x, y = data.y, data = this.camera.vp(cp1x, cp1y, cp1z), cp1x = data.x, cp1y = data.y, data = this.camera.vp(cp2x, cp2y, cp2z), cp2x = data.x, cp2y = data.y;
    }
    this.nativeContext.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  }
  closePath() {
    this.nativeContext.closePath();
  }
  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
    null == anticlockwise ? this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle) : this.nativeContext.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  }
  lineTo(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.lineTo(x, y);
  }
  moveTo(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.moveTo(x, y);
  }
  quadraticCurveTo(cpx, cpy, x, y, z) {
    if (z = z || 0, this.camera) {
      let cpz = z;
      this.modelMatrix && (transformMat4(outP, [cpx, cpy, z], this.modelMatrix), cpx = outP[0], cpy = outP[1], cpz = outP[2], transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      let data = this.camera.vp(x, y, z);
      x = data.x, y = data.y, data = this.camera.vp(cpx, cpy, cpz), cpx = data.x, cpy = data.y;
    }
    this.nativeContext.quadraticCurveTo(cpx, cpy, x, y);
  }
  rect(x, y, w, h, z) {
    z = z || 0, this.camera ? (this.moveTo(x, y, z), this.lineTo(x + w, y, z), this.lineTo(x + w, y + h, z), this.lineTo(x, y + h, z), this.closePath()) : this.nativeContext.rect(x, y, w, h);
  }
  createImageData() {
    const a = arguments;
    return 2 === a.length ? this.nativeContext.createImageData(a[0], a[1]) : 1 === a.length ? this.nativeContext.createImageData(a[0]) : null;
  }
  createLinearGradient(x0, y0, x1, y1) {
    return isFinite(x0 + y0 + x1 + y1) || (x0 = 0, y0 = 0, x1 = 0, y1 = 0), this.nativeContext.createLinearGradient(x0, y0, x1, y1);
  }
  createPattern(image, repetition) {
    return 0 === image.width || 0 === image.height ? null : this.nativeContext.createPattern(image, repetition);
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this.nativeContext.createRadialGradient(x0, y0, r0, x1, y1, r1);
  }
  createConicGradient(x, y, startAngle, endAngle) {
    let pattern,
      edit = !1;
    const ctx = this;
    return {
      stops: [],
      addColorStop(offset, color) {
        this.stops.push([offset, color]), edit = !0;
      },
      GetPattern(minW, minH, deltaAngle) {
        return edit && (deltaAngle || (deltaAngle = endAngle - startAngle), pattern = createConicalGradient(ctx, this.stops, x, y, deltaAngle, startAngle, endAngle, minW, minH), edit = !1), pattern;
      }
    };
  }
  fill(path, fillRule) {
    this.disableFill || (path ? this.nativeContext.fill(path) : this.nativeContext.fill());
  }
  fillRect(x, y, width, height) {
    this.nativeContext.fillRect(x, y, width, height);
  }
  clearRect(x, y, w, h) {
    this.nativeContext.clearRect(x, y, w, h);
  }
  project(x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    return {
      x: x,
      y: y
    };
  }
  view(x, y, z) {
    return z = z || 0, this.camera ? (this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]), this.camera.view(x, y, z)) : [x, y, z];
  }
  fillText(text, x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.fillText(text, x, y);
  }
  getImageData(sx, sy, sw, sh) {
    return this.nativeContext.getImageData(sx, sy, sw, sh);
  }
  getLineDash() {
    return this.nativeContext.getLineDash();
  }
  isPointInPath(x, y) {
    return this.nativeContext.isPointInPath(x, y);
  }
  isPointInStroke(x, y) {
    return this.nativeContext.isPointInStroke(x, y);
  }
  measureText(text) {
    let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : application.global.measureTextMethod;
    var _a, _b;
    if (!method || "native" === method) return this.nativeContext.measureText(text);
    this.mathTextMeasure || (this.mathTextMeasure = application.graphicUtil.createTextMeasureInstance({}, {}, () => this.canvas.nativeCanvas));
    const fontFamily = null !== (_a = this.fontFamily) && void 0 !== _a ? _a : DefaultTextStyle.fontFamily,
      fontSize = null !== (_b = this.fontSize) && void 0 !== _b ? _b : DefaultTextStyle.fontSize;
    return this.mathTextMeasure.textSpec.fontFamily === fontFamily && this.mathTextMeasure.textSpec.fontSize === fontSize || (this.mathTextMeasure.textSpec.fontFamily = fontFamily, this.mathTextMeasure.textSpec.fontSize = fontSize, this.mathTextMeasure._numberCharSize = null, this.mathTextMeasure._fullCharSize = null, this.mathTextMeasure._letterCharSize = null, this.mathTextMeasure._specialCharSizeMap = {}), this.mathTextMeasure.measure(text, method);
  }
  putImageData(imagedata, dx, dy) {
    this.nativeContext.putImageData(imagedata, dx, dy);
  }
  setLineDash(segments) {
    const a = arguments,
      _context = this.nativeContext;
    this.nativeContext.setLineDash ? a[0] && _context.setLineDash(a[0]) : "mozDash" in _context ? _context.mozDash = a[0] : "webkitLineDash" in _context && (_context.webkitLineDash = a[0]);
  }
  stroke(path) {
    this.disableStroke || (path ? this.nativeContext.stroke(path) : this.nativeContext.stroke());
  }
  strokeRect(x, y, width, height) {
    this.nativeContext.strokeRect(x, y, width, height);
  }
  strokeText(text, x, y, z) {
    if (z = z || 0, this.camera) {
      this.modelMatrix && (transformMat4(outP, [x, y, z], this.modelMatrix), x = outP[0], y = outP[1], z = outP[2]);
      const data = this.camera.vp(x, y, z);
      x = data.x, y = data.y;
    }
    this.nativeContext.strokeText(text, x, y);
  }
  drawImage() {
    const _context = this.nativeContext,
      a = arguments;
    3 === a.length ? _context.drawImage(a[0], a[1], a[2]) : 5 === a.length ? _context.drawImage(a[0], a[1], a[2], a[3], a[4]) : 9 === a.length && _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setCommonStyle(params, attribute, offsetX, offsetY, dp);
    }
    return this._setCommonStyle(params, attribute, offsetX, offsetY, defaultParams);
  }
  _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const {
      fillOpacity = defaultParams.fillOpacity,
      opacity = defaultParams.opacity,
      fill = defaultParams.fill
    } = attribute;
    _context.globalAlpha = fillOpacity * opacity * this.baseGlobalAlpha, fillOpacity > 1e-12 && opacity > 1e-12 && (_context.fillStyle = createColor(this, fill, params, offsetX, offsetY));
  }
  setShadowBlendStyle(params, attribute, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setShadowBlendStyle(params, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setShadowBlendStyle(params, attribute, dp);
    }
    return this._setShadowBlendStyle(params, attribute, defaultParams);
  }
  _setShadowBlendStyle(params, attribute, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const {
      opacity = defaultParams.opacity,
      shadowBlur = defaultParams.shadowBlur,
      shadowColor = defaultParams.shadowColor,
      shadowOffsetX = defaultParams.shadowOffsetX,
      shadowOffsetY = defaultParams.shadowOffsetY,
      blur = defaultParams.blur,
      filter = defaultParams.filter,
      globalCompositeOperation = defaultParams.globalCompositeOperation
    } = attribute;
    opacity <= 1e-12 || (shadowBlur || shadowOffsetX || shadowOffsetY ? (_context.shadowBlur = shadowBlur * this.dpr, _context.shadowColor = shadowColor, _context.shadowOffsetX = shadowOffsetX * this.dpr, _context.shadowOffsetY = shadowOffsetY * this.dpr, this._clearShadowStyle = !0) : this._clearShadowStyle && (_context.shadowBlur = 0, _context.shadowOffsetX = 0, _context.shadowOffsetY = 0), blur ? (_context.filter = `blur(${blur}px)`, this._clearFilterStyle = !0) : filter ? (_context.filter = filter, this._clearFilterStyle = !0) : this._clearFilterStyle && (_context.filter = "blur(0px)", this._clearFilterStyle = !1), globalCompositeOperation ? (_context.globalCompositeOperation = globalCompositeOperation, this._clearGlobalCompositeOperationStyle = !0) : this._clearGlobalCompositeOperationStyle && (_context.globalCompositeOperation = "source-over", this._clearGlobalCompositeOperationStyle = !1));
  }
  setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
    if (Array.isArray(defaultParams)) {
      if (defaultParams.length <= 1) return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams[0]);
      const dp = Object.create(defaultParams[0]);
      return defaultParams.forEach((p, i) => {
        0 !== i && Object.assign(dp, p);
      }), this._setStrokeStyle(params, attribute, offsetX, offsetY, dp);
    }
    return this._setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams);
  }
  _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const {
      strokeOpacity = defaultParams.strokeOpacity,
      opacity = defaultParams.opacity
    } = attribute;
    if (_context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, strokeOpacity > 1e-12 && opacity > 1e-12) {
      const {
        lineWidth = defaultParams.lineWidth,
        stroke = defaultParams.stroke,
        lineJoin = defaultParams.lineJoin,
        lineDash = defaultParams.lineDash,
        lineDashOffset = defaultParams.lineDashOffset,
        lineCap = defaultParams.lineCap,
        miterLimit = defaultParams.miterLimit,
        keepStrokeScale = defaultParams.keepStrokeScale
      } = attribute;
      _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke, params, offsetX, offsetY), _context.lineJoin = lineJoin, lineDash && (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  setTextStyleWithoutAlignBaseline(params, defaultParams, z) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    const {
      scaleIn3d = defaultParams.scaleIn3d
    } = params;
    params.font ? _context.font = params.font : _context.font = getContextFont(params, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z));
    const {
      fontFamily = defaultParams.fontFamily,
      fontSize = defaultParams.fontSize
    } = params;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
  }
  setTextStyle(params, defaultParams, z) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = getContextFont(params, defaultParams, this.camera && this.camera.getProjectionScale(z));
    const {
      fontFamily = defaultParams.fontFamily,
      fontSize = defaultParams.fontSize
    } = params;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
  }
  draw() {}
  clearMatrix() {
    let setTransform = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : !0;
    let dpr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.dpr;
    this.setTransformFromMatrix(this._clearMatrix, setTransform, dpr);
  }
  setClearMatrix(a, b, c, d, e, f) {
    this._clearMatrix.setValue(a, b, c, d, e, f);
  }
  onlyTranslate() {
    let dpr = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.dpr;
    return this.matrix.a === dpr && 0 === this.matrix.b && 0 === this.matrix.c && this.matrix.d === dpr;
  }
  release() {
    this.stack.forEach(m => matrixAllocate.free(m)), this.stack.length = 0;
  }
};
BrowserContext2d.env = "browser", BrowserContext2d = __decorate$10([injectable(), __metadata$Q("design:paramtypes", [Object, Number])], BrowserContext2d);

var __decorate$$ = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$P = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let BrowserCanvas = class extends BaseCanvas {
  constructor(params) {
    super(params);
  }
  init(params) {
    const {
      container: container
    } = params;
    if ("string" == typeof container) {
      const _c = application.global.getElementById(container);
      _c && (this._container = _c);
    } else this._container = container;
    this._context = new BrowserContext2d(this, this._dpr), this.initStyle();
  }
  initStyle() {
    if (!this.controled) return;
    const {
      nativeCanvas: nativeCanvas
    } = this;
    nativeCanvas.width = this._pixelWidth, nativeCanvas.height = this._pixelHeight;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, this._x, this._y, this._displayWidth, this._displayHeight), this._container && this._container.appendChild(nativeCanvas), this.visiable || this.hide();
  }
  hide() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "none");
  }
  show() {
    this._nativeCanvas && (this._nativeCanvas.style.display = "block");
  }
  applyPosition() {
    const canvas = this._nativeCanvas;
    canvas.style.position = "absolute", canvas.style.top = `${this._y}px`, canvas.style.left = `${this._x}px`;
  }
  resetStyle(params) {
    if (!this.controled) return;
    const {
        width = this._displayWidth,
        height = this._displayHeight,
        dpr = this._dpr,
        x = this._x,
        y = this._y
      } = params,
      {
        nativeCanvas: nativeCanvas
      } = this;
    nativeCanvas.width = width * dpr, nativeCanvas.height = height * dpr;
    !nativeCanvas.style || this.setCanvasStyle(nativeCanvas, x, y, width, height), params.id && (nativeCanvas.id = params.id), this.visiable || this.hide();
  }
  setCanvasStyle(canvas, x, y, w, h) {
    this.controled && (canvas.style.width = `${w}px`, canvas.style.height = `${h}px`);
  }
  toDataURL(mimeType, quality) {
    return "image/jpeg" === mimeType ? this._nativeCanvas.toDataURL(mimeType, quality) : "image/png" === mimeType ? this._nativeCanvas.toDataURL(mimeType) : this._nativeCanvas.toDataURL(mimeType, quality);
  }
  resize(width, height) {
    if (!this.controled) return;
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.style && (this._nativeCanvas.style.width = `${width}px`, this._nativeCanvas.style.height = `${height}px`), this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight;
    this._context.dpr = this._dpr;
  }
};
BrowserCanvas.env = "browser", BrowserCanvas = __decorate$$([injectable(), __metadata$P("design:paramtypes", [Object])], BrowserCanvas);

function createModule(CanvasConstructor, ContextConstructor) {
  return new ContainerModule(bind => {
    bind(CanvasFactory).toDynamicValue(() => params => new CanvasConstructor(params)).whenTargetNamed(CanvasConstructor.env), bind(Context2dFactory).toDynamicValue(() => (params, dpr) => new ContextConstructor(params, dpr)).whenTargetNamed(ContextConstructor.env);
  });
}

const browserCanvasModule = createModule(BrowserCanvas, BrowserContext2d);

var __decorate$_ = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$O = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$y = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPickerService = class extends DefaultPickService {
  constructor(contributions, drawContribution, pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    super(pickItemInterceptorContributions, pickServiceInterceptorContributions), this.contributions = contributions, this.drawContribution = drawContribution, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.global.hooks.onSetEnv.tap("canvas-picker-service", (_, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach(item => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global, env) {
    this.pickCanvas = canvasAllocate.shareCanvas(), this.pickContext = this.pickCanvas.getContext("2d");
  }
  pickItem(graphic, point, parentMatrix, params) {
    if (!1 === graphic.attribute.pickable) return null;
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.beforePickItem) {
        const ret = drawContribution.beforePickItem(graphic, this, point, params, {
          parentMatrix: parentMatrix
        });
        if (ret) return ret;
      }
    }
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker) return null;
    const pd = picker.contains(graphic, point, params),
      g = pd ? graphic : null,
      data = {
        graphic: g,
        params: pd
      };
    if (g) return data;
    if (this.InterceptorContributions.length) for (let i = 0; i < this.InterceptorContributions.length; i++) {
      const drawContribution = this.InterceptorContributions[i];
      if (drawContribution.afterPickItem) {
        const ret = drawContribution.afterPickItem(graphic, this, point, params, {
          parentMatrix: parentMatrix
        });
        if (ret) return ret;
      }
    }
    return data;
  }
};
DefaultCanvasPickerService = __decorate$_([injectable(), __param$y(0, inject(ContributionProvider)), __param$y(0, named(CanvasPickerContribution)), __param$y(1, inject(DrawContribution)), __param$y(2, inject(ContributionProvider)), __param$y(2, named(PickItemInterceptor)), __param$y(3, inject(ContributionProvider)), __param$y(3, named(PickServiceInterceptor)), __metadata$O("design:paramtypes", [Object, Object, Object, Object])], DefaultCanvasPickerService);

var __decorate$Z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultCanvasGroupPicker = class {
  constructor() {
    this.type = "group", this.numberType = GROUP_NUMBER_TYPE;
  }
  contains(group, point, params) {
    return !1;
  }
};
DefaultCanvasGroupPicker = __decorate$Z([injectable()], DefaultCanvasGroupPicker);

const m$1 = new ContainerModule((bind, unbind, isBound, rebind) => {
  m$1.__vloaded || (m$1.__vloaded = !0, bind(CanvasGroupPicker).to(DefaultCanvasGroupPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGroupPicker), bindContributionProvider(bind, CanvasPickerContribution));
});
m$1.__vloaded = !1;
var canvasModule = m$1;

const canvasPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultCanvasPickerService) || bind(DefaultCanvasPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultCanvasPickerService) : bind(PickerService).toService(DefaultCanvasPickerService);
});
function loadCanvasPicker(c) {
  c.load(canvasModule), c.load(canvasPickerModule);
}

var BrowserWindowHandlerContribution_1,
  __decorate$Y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$N = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = class extends BaseWindowHandlerContribution {
  get container() {
    return this.canvas.nativeCanvas.parentElement;
  }
  static GenerateCanvasId() {
    return `${BrowserWindowHandlerContribution_1.idprefix}_${BrowserWindowHandlerContribution_1.prefix_count++}`;
  }
  constructor() {
    super(), this.type = "browser", this._canvasIsIntersecting = !0, this.global = application.global, this.viewBox = new AABBBounds(), this.modelMatrix = new Matrix(1, 0, 0, 1, 0, 0);
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return this.canvas.nativeCanvas.getBoundingClientRect();
  }
  createWindow(params) {
    params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params), this.postInit();
  }
  postInit() {
    if (this.global.optimizeVisible) try {
      this.observerCanvas();
    } catch (err) {
      console.error("发生错误，该环境不存在IntersectionObserver");
    }
  }
  isElementVisible(el) {
    const rect = el.getBoundingClientRect(),
      vWidth = window.innerWidth || document.documentElement.clientWidth,
      vHeight = window.innerHeight || document.documentElement.clientHeight;
    return !(rect.right < 0 || rect.bottom < 0 || rect.left > vWidth || rect.top > vHeight);
  }
  observerCanvas() {
    this._canvasIsIntersecting = this.isElementVisible(this.canvas.nativeCanvas);
    const observer = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        this._canvasIsIntersecting !== entry.isIntersecting ? (this._canvasIsIntersecting = entry.isIntersecting, this._onVisibleChangeCb && this._onVisibleChangeCb(entry.isIntersecting)) : this._canvasIsIntersecting = entry.isIntersecting;
      });
    });
    observer && observer.observe(this.canvas.nativeCanvas);
  }
  createWindowByConfig(params) {
    const nativeCanvas = this.global.createCanvas({
      width: params.width,
      height: params.height
    });
    let container;
    if (container = "string" == typeof params.container ? this.global.getElementById(params.container) : params.container ? params.container : this.global.getRootElement(), !container) throw new Error("发生错误，containerId可能传入有误");
    params.offscreen ? container = null : container.appendChild(nativeCanvas);
    const options = {
      width: params.width,
      height: params.height,
      dpr: params.dpr,
      nativeCanvas: nativeCanvas,
      container: container,
      id: BrowserWindowHandlerContribution_1.GenerateCanvasId(),
      canvasControled: !0
    };
    this.canvas = new BrowserCanvas(options);
  }
  createWindowByCanvas(params) {
    var _a;
    let canvas;
    if ("string" == typeof params.canvas) {
      if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params.canvas;
    if (!canvas) throw new Error("发生错误，传入的canvas不正确");
    let width = params.width,
      height = params.height;
    if (null == width || null == height || !params.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params.dpr;
    if (null == dpr) {
      dpr = null !== (_a = canvas.getContext("2d").pixelRatio) && void 0 !== _a ? _a : canvas.width / width;
    }
    this.canvas = new BrowserCanvas({
      width: width,
      height: height,
      dpr: dpr,
      nativeCanvas: canvas,
      canvasControled: params.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return this.canvas.nativeCanvas.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return this.canvas.nativeCanvas.dispatchEvent(event);
  }
  getStyle() {
    var _a;
    return null !== (_a = this.canvas.nativeCanvas.style) && void 0 !== _a ? _a : {};
  }
  setStyle(style) {
    this.canvas.nativeCanvas.style = style;
  }
  getBoundingClientRect() {
    const c = this.canvas.nativeCanvas,
      wh = this.getWH();
    return c.parentElement ? this.canvas.nativeCanvas.getBoundingClientRect() : {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox,
      context = this.getContext(),
      dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
  isVisible(bbox) {
    return this._canvasIsIntersecting;
  }
  onVisibleChange(cb) {
    this._onVisibleChangeCb = cb;
  }
  getTopLeft(baseWindow) {
    return this.global.getElementTopLeft(this.canvas.nativeCanvas, baseWindow);
  }
};
BrowserWindowHandlerContribution.env = "browser", BrowserWindowHandlerContribution.idprefix = "visactor_window", BrowserWindowHandlerContribution.prefix_count = 0, BrowserWindowHandlerContribution = BrowserWindowHandlerContribution_1 = __decorate$Y([injectable(), __metadata$N("design:paramtypes", [])], BrowserWindowHandlerContribution);
const browserWindowModule = new ContainerModule(bind => {
  bind(BrowserWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(BrowserWindowHandlerContribution)).whenTargetNamed(BrowserWindowHandlerContribution.env);
});

var __decorate$X = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$M = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
class DynamicB {
  get x1() {
    return this.dom.getBoundingClientRect().left;
  }
  get x2() {
    return this.dom.getBoundingClientRect().right;
  }
  get y1() {
    return this.dom.getBoundingClientRect().top;
  }
  get y2() {
    return this.dom.getBoundingClientRect().bottom;
  }
  get width() {
    return this.dom.getBoundingClientRect().width;
  }
  get height() {
    return this.dom.getBoundingClientRect().height;
  }
  constructor(dom) {
    this.dom = dom;
  }
}
function createImageElement$1(src) {
  let isSvg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  const img = document.createElement("img");
  if (application.global.isImageAnonymous && (img.crossOrigin = "anonymous"), isSvg) {
    const data = new Blob([src], {
      type: "image/svg+xml"
    });
    src = window.URL.createObjectURL(data);
  }
  if (img.src = src, img.complete) return Promise.resolve(img);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("加载失败"));
    };
  });
}
let BrowserEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "browser", this.supportEvent = !0;
    try {
      this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsTouchEvents = !1, this.supportsPointerEvents = !1, this.supportsPointerEvents = !1;
    }
    this.applyStyles = !0;
  }
  mapToCanvasPoint(nativeEvent, domElement) {
    var _a, _b;
    let clientX = 0,
      clientY = 0,
      offsetX = 0,
      offsetY = 0;
    if (nativeEvent.changedTouches) {
      const data = null !== (_a = nativeEvent.changedTouches[0]) && void 0 !== _a ? _a : {};
      clientX = data.clientX || 0, clientY = data.clientY || 0, offsetX = clientX, offsetY = clientY;
    } else clientX = nativeEvent.clientX || 0, clientY = nativeEvent.clientY || 0, offsetX = nativeEvent.offsetX || 0, offsetY = nativeEvent.offsetY || 0;
    if (domElement) {
      const x = clientX,
        y = clientY,
        rect = domElement.getBoundingClientRect(),
        nativeCanvas = null === (_b = domElement.getNativeHandler) || void 0 === _b ? void 0 : _b.call(domElement).nativeCanvas;
      let scaleX, scaleY;
      return nativeCanvas && (scaleX = rect.width / nativeCanvas.offsetWidth, scaleY = rect.height / nativeCanvas.offsetHeight), {
        x: (x - rect.left) / (isValidNumber$1(scaleX) ? scaleX : 1),
        y: (y - rect.top) / (isValidNumber$1(scaleY) ? scaleY : 1)
      };
    }
    return {
      x: offsetX,
      y: offsetY
    };
  }
  getNativeAABBBounds(_dom) {
    let dom = _dom;
    if ("string" == typeof _dom && (dom = new DOMParser().parseFromString(_dom, "text/html").firstChild, dom.lastChild && (dom = dom.lastChild.firstChild)), dom.getBoundingClientRect) {
      const b = dom.getBoundingClientRect();
      return new DynamicB(b);
    }
    return new AABBBounds();
  }
  removeDom(dom) {
    return dom.parentElement.removeChild(dom), !0;
  }
  updateDom(dom, params) {
    const {
      width: width,
      height: height,
      style: style
    } = params;
    return style && (isString$1(style) ? dom.setAttribute("style", style) : Object.keys(style).forEach(k => {
      dom.style[k] = style[k];
    })), null != width && (dom.style.width = `${width}px`), null != height && (dom.style.height = `${height}px`), !0;
  }
  createDom(params) {
    const {
        tagName = "div",
        parent: parent
      } = params,
      element = document.createElement(tagName);
    if (this.updateDom(element, params), parent) {
      const pd = isString$1(parent) ? this.getElementById(parent) : parent;
      pd && pd.appendChild && pd.appendChild(element);
    }
    return element;
  }
  loadImage(url) {
    return createImageElement$1(url, !1).then(img => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return createImageElement$1(url, !0).then(img => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  createCanvas(params) {
    var _a, _b;
    const canvas = document.createElement("canvas");
    params.id && (canvas.id = null !== (_a = params.id) && void 0 !== _a ? _a : Generator.GenAutoIncrementId().toString());
    const dpr = null !== (_b = params.dpr) && void 0 !== _b ? _b : window.devicePixelRatio;
    return params.width && params.height && (canvas.style.width = `${params.width}px`, canvas.style.height = `${params.height}px`, canvas.width = params.width * dpr, canvas.height = params.height * dpr), canvas;
  }
  createOffscreenCanvas(params) {
    var _a;
    const dpr = null !== (_a = params.dpr) && void 0 !== _a ? _a : window.devicePixelRatio;
    return new OffscreenCanvas(params.width * dpr, params.height * dpr);
  }
  releaseCanvas(canvas) {
    let c;
    c = "string" == typeof canvas ? document.getElementById(canvas) : canvas, c && c.parentElement && c.parentElement.removeChild(c);
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getRequestAnimationFrame() {
    return window.requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return window.cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return document.addEventListener(type, listener, options);
  }
  removeEventListener(type, listener, options) {
    return document.removeEventListener(type, listener, options);
  }
  dispatchEvent(event) {
    return document.dispatchEvent(event);
  }
  getElementById(str) {
    return document.getElementById(str);
  }
  getRootElement() {
    return document.body;
  }
  getDocument() {
    return document;
  }
  release() {}
  getElementTop(element, baseWindow) {
    let actualTop = element.offsetTop,
      current = element.offsetParent;
    for (; null !== current;) actualTop += current.offsetTop, current = current.offsetParent;
    return actualTop;
  }
  getElementLeft(element, baseWindow) {
    let actualLeft = element.offsetLeft,
      current = element.offsetParent;
    for (; null !== current;) actualLeft += current.offsetLeft, current = current.offsetParent;
    return actualLeft;
  }
  getElementTopLeft(element, baseWindow) {
    let actualTop = element.offsetTop,
      actualLeft = element.offsetLeft,
      current = element.offsetParent;
    for (; null !== current;) actualTop += current.offsetTop, actualLeft += current.offsetLeft, current = current.offsetParent;
    return {
      top: actualTop,
      left: actualLeft
    };
  }
  loadFont(font, source, descriptors) {
    return __awaiter$2(this, void 0, void 0, function* () {
      return new FontFace(font, isString$1(source) ? `url(${source})` : source, descriptors).load().then(function (loadedFont) {
        return document.fonts.add(loadedFont), {
          loadState: "success"
        };
      }).catch(function (error) {
        return console.error("Failed to load font:", error), {
          loadState: "fail"
        };
      });
    });
  }
  isMacOS() {
    if (void 0 === this._isMacOS) try {
      this._isMacOS = navigator.platform.toUpperCase().indexOf("MAC") >= 0;
    } catch (err) {
      this._isMacOS = !1;
    }
    return this._isMacOS;
  }
  copyToClipBoard(text) {
    return navigator.clipboard.writeText(text).then(() => {}).catch(err => {});
  }
};
BrowserEnvContribution = __decorate$X([injectable(), __metadata$M("design:paramtypes", [])], BrowserEnvContribution);

const browserEnvModule = new ContainerModule(bind => {
  browserEnvModule.isBrowserBound || (browserEnvModule.isBrowserBound = !0, bind(BrowserEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(BrowserEnvContribution));
});
browserEnvModule.isBrowserBound = !1;
function loadBrowserEnv(container) {
  let loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
  loadBrowserEnv.__loaded || (loadBrowserEnv.__loaded = !0, container.load(browserEnvModule), container.load(browserCanvasModule), container.load(browserWindowModule), loadPicker && loadCanvasPicker(container));
}
loadBrowserEnv.__loaded = !1;
function initBrowserEnv() {
  loadBrowserEnv(container);
}

var __decorate$W = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let FeishuContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  getImageData(sx, sy, sw, sh) {
    return new Promise((resolve, reject) => {
      var _a;
      try {
        tt.canvasGetImageData({
          canvasId: null !== (_a = this.canvas.nativeCanvas.id) && void 0 !== _a ? _a : this.canvas.id,
          x: sx,
          y: sy,
          width: sw,
          height: sh,
          success(res) {
            resolve(res);
          }
        });
      } catch (err) {
        reject(err);
      }
    });
  }
  draw() {
    const _context = this.nativeContext;
    _context.draw && (this.drawPromise = new Promise(resolve => {
      _context.draw(!0, () => {
        this.drawPromise = null, resolve(null);
      });
    }));
  }
  createPattern(image, repetition) {
    return null;
  }
};
FeishuContext2d.env = "feishu", FeishuContext2d = __decorate$W([injectable()], FeishuContext2d);

var __decorate$V = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$L = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let FeishuCanvas = class extends BaseCanvas {
  constructor(params) {
    super(params);
  }
  init() {
    this._context = new FeishuContext2d(this, this._dpr);
  }
  release() {}
};
FeishuCanvas.env = "feishu", FeishuCanvas = __decorate$V([injectable(), __metadata$L("design:paramtypes", [Object])], FeishuCanvas);

const feishuCanvasModule = createModule(FeishuCanvas, FeishuContext2d);

var __decorate$U = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$K = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$x = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let MiniAppEventManager$5 = class MiniAppEventManager {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex(f => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
let FeishuWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "feishu", this.eventManager = new MiniAppEventManager$5();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params) {
    params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
  }
  createWindowByConfig(params) {
    const nativeCanvas = this.global.createCanvas({
        width: params.width,
        height: params.height
      }),
      options = {
        width: params.width,
        height: params.height,
        dpr: params.dpr,
        nativeCanvas: nativeCanvas,
        id: Generator.GenAutoIncrementId().toString(),
        canvasControled: !1
      };
    this.canvas = new FeishuCanvas(options);
  }
  createWindowByCanvas(params) {
    let canvas;
    if ("string" == typeof params.canvas) {
      if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params.canvas;
    let width = params.width,
      height = params.height;
    if (null == width || null == height || !params.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new FeishuCanvas({
      width: width,
      height: height,
      dpr: dpr,
      nativeCanvas: canvas,
      canvasControled: params.canvasControled
    });
  }
  releaseWindow() {}
  resizeWindow(width, height) {}
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const {
      type: type
    } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(f => {
      f(event);
    }), !0);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {}
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox,
      context = this.getContext(),
      dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
FeishuWindowHandlerContribution.env = "feishu", FeishuWindowHandlerContribution = __decorate$U([injectable(), __param$x(0, inject(VGlobal)), __metadata$K("design:paramtypes", [Object])], FeishuWindowHandlerContribution);
const feishuWindowModule = new ContainerModule(bind => {
  bind(FeishuWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(FeishuWindowHandlerContribution)).whenTargetNamed(FeishuWindowHandlerContribution.env);
});

var __decorate$T = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$J = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$w = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathPickerService = class extends DefaultPickService {
  constructor(contributions, pickItemInterceptorContributions, pickServiceInterceptorContributions) {
    super(pickItemInterceptorContributions, pickServiceInterceptorContributions), this.contributions = contributions, this.pickItemInterceptorContributions = pickItemInterceptorContributions, this.pickServiceInterceptorContributions = pickServiceInterceptorContributions, this.global.hooks.onSetEnv.tap("math-picker-service", (lastEnv, env, global) => {
      this.configure(global, env);
    }), this.configure(this.global, this.global.env), this.pickerMap = new Map(), this.init();
  }
  init() {
    this.contributions.getContributions().forEach(item => {
      this.pickerMap.set(item.numberType, item);
    }), super._init();
  }
  configure(global, env) {
    this.pickContext = new EmptyContext2d(null, 1);
  }
  pickItem(graphic, point, parentMatrix, params) {
    if (!1 === graphic.attribute.pickable) return null;
    const picker = this.pickerMap.get(graphic.numberType);
    if (!picker) return null;
    const pd = picker.contains(graphic, point, params),
      g = pd ? graphic : null;
    return g ? {
      graphic: g,
      params: pd
    } : null;
  }
};
DefaultMathPickerService = __decorate$T([injectable(), __param$w(0, inject(ContributionProvider)), __param$w(0, named(MathPickerContribution)), __param$w(1, inject(ContributionProvider)), __param$w(1, named(PickItemInterceptor)), __param$w(2, inject(ContributionProvider)), __param$w(2, named(PickServiceInterceptor)), __metadata$J("design:paramtypes", [Object, Object, Object])], DefaultMathPickerService);

const m = new ContainerModule(bind => {
  m.__vloaded || (m.__vloaded = !0, bindContributionProvider(bind, MathPickerContribution));
});
m.__vloaded = !1;
var mathModule = m;

class PickerBase {
  contains(graphic, point, params) {
    if (!graphic.AABBBounds.containsPoint(point)) return !1;
    if ("imprecise" === graphic.attribute.pickMode) return !0;
    if (!this.canvasRenderer) return !0;
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const attribute = graphic.getGraphicTheme();
    pickContext.highPerformanceSave();
    let {
      x = attribute.x,
      y = attribute.y
    } = graphic.attribute;
    if (graphic.transMatrix.onlyTranslate()) {
      const point = graphic.getOffsetXY(attribute);
      x += point.x, y += point.y, pickContext.setTransformForCurrent();
    } else x = 0, y = 0, pickContext.transformFromMatrix(graphic.transMatrix, !0);
    let picked = !1,
      _final = !1;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, (context, arcAttribute, themeAttribute, final) => !(!picked && !_final) || (picked = context.isPointInPath(point.x, point.y), _final = final || _final, picked), (context, arcAttribute, themeAttribute, final) => {
      if (picked || _final) return !0;
      const lineWidth = arcAttribute.lineWidth || themeAttribute.lineWidth,
        pickStrokeBuffer = arcAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
        keepStrokeScale = arcAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), _final = final || _final, picked;
    }), pickContext.highPerformanceRestore(), picked;
  }
}

var __decorate$S = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$I = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$v = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathArcPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
};
DefaultMathArcPicker = __decorate$S([injectable(), __param$v(0, inject(ArcRender)), __metadata$I("design:paramtypes", [Object])], DefaultMathArcPicker);

let loadArcPick$1 = !1;
const arcMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick$1 || (loadArcPick$1 = !0, bind(MathArcPicker).to(DefaultMathArcPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathArcPicker));
});

var __decorate$R = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$H = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$u = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathAreaPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
};
DefaultMathAreaPicker = __decorate$R([injectable(), __param$u(0, inject(AreaRender)), __metadata$H("design:paramtypes", [Object])], DefaultMathAreaPicker);

let loadAreaPick$1 = !1;
const areaMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick$1 || (loadAreaPick$1 = !0, bind(MathAreaPicker).to(DefaultMathAreaPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathAreaPicker));
});

var __decorate$Q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$G = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$t = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathCirclePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
};
DefaultMathCirclePicker = __decorate$Q([injectable(), __param$t(0, inject(CircleRender)), __metadata$G("design:paramtypes", [Object])], DefaultMathCirclePicker);

let loadCirclePick$1 = !1;
const circleMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick$1 || (loadCirclePick$1 = !0, bind(MathCirclePicker).to(DefaultMathCirclePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathCirclePicker));
});

class GlyphPickerBase {
  constructor() {
    this.type = "glyph", this.numberType = GLYPH_NUMBER_TYPE;
  }
  contains(glyph, point, params) {
    if (!glyph.AABBBounds.containsPoint(point)) return !1;
    if ("imprecise" === glyph.attribute.pickMode) return !0;
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const pickerService = null == params ? void 0 : params.pickerService;
    if (pickerService) {
      let picked = !1;
      return glyph.getSubGraphic().forEach(g => {
        if (picked) return;
        const data = pickerService.pickItem(g, point, null, params);
        picked = !(!data || !data.graphic);
      }), picked;
    }
    return !1;
  }
}

var __decorate$P = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$F = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$s = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathGlyphPicker = class extends GlyphPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultMathGlyphPicker = __decorate$P([injectable(), __param$s(0, inject(GlyphRender)), __metadata$F("design:paramtypes", [Object])], DefaultMathGlyphPicker);

let loadGlyphPick$1 = !1;
const glyphMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick$1 || (loadGlyphPick$1 = !0, bind(MathGlyphPicker).to(DefaultMathGlyphPicker).inSingletonScope(), bind(DefaultMathGlyphPicker).toService(MathGlyphPicker));
});

var __decorate$O = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultMathImagePicker = class {
  constructor() {
    this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
  contains(image, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    return !!pickContext && !!image.AABBBounds.containsPoint(point);
  }
};
DefaultMathImagePicker = __decorate$O([injectable()], DefaultMathImagePicker);

let loadImagePick$1 = !1;
const imageMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick$1 || (loadImagePick$1 = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

var __decorate$N = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$E = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$r = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathLinePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
};
DefaultMathLinePicker = __decorate$N([injectable(), __param$r(0, inject(LineRender)), __metadata$E("design:paramtypes", [Object])], DefaultMathLinePicker);

let loadLinePick$1 = !1;
const lineMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick$1 || (loadLinePick$1 = !0, bind(MathLinePicker).to(DefaultMathLinePicker).inSingletonScope(), bind(MathPickerContribution).toService(MathLinePicker));
});

var __decorate$M = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$D = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$q = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathPolygonPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
};
DefaultMathPolygonPicker = __decorate$M([injectable(), __param$q(0, inject(PolygonRender)), __metadata$D("design:paramtypes", [Object])], DefaultMathPolygonPicker);

let loadPolygonPick$1 = !1;
const polygonMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick$1 || (loadPolygonPick$1 = !0, bind(MathPolygonPicker).to(DefaultMathPolygonPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPolygonPicker));
});

var __decorate$L = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$C = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$p = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathPathPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
};
DefaultMathPathPicker = __decorate$L([injectable(), __param$p(0, inject(PathRender)), __metadata$C("design:paramtypes", [Object])], DefaultMathPathPicker);

let loadPathPick$1 = !1;
const pathMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick$1 || (loadPathPick$1 = !0, bind(MathPathPicker).to(DefaultMathPathPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathPathPicker));
});

const _bounds = new AABBBounds();
class RectPickerBase {
  constructor() {
    this.type = "rect", this.numberType = RECT_NUMBER_TYPE;
  }
  contains(rect, point, params) {
    if (!rect.AABBBounds.containsPoint(point)) return !1;
    if ("imprecise" === rect.attribute.pickMode) return !0;
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const rectAttribute = rect.getGraphicTheme(),
      {
        cornerRadius = rectAttribute.cornerRadius
      } = rect.attribute;
    let {
      x = rectAttribute.x,
      y = rectAttribute.y
    } = rect.attribute;
    pickContext.highPerformanceSave();
    let onlyTranslate = !0;
    if (rect.transMatrix.onlyTranslate()) {
      const point = rect.getOffsetXY(rectAttribute);
      x += point.x, y += point.y, pickContext.setTransformForCurrent();
    } else x = 0, y = 0, onlyTranslate = !1, pickContext.transformFromMatrix(rect.transMatrix, !0);
    let picked = !0;
    if (!onlyTranslate || rect.shadowRoot || isNumber$1(cornerRadius, !0) && 0 !== cornerRadius || isArray$1(cornerRadius) && cornerRadius.some(num => 0 !== num)) picked = !1, this.canvasRenderer.drawShape(rect, pickContext, x, y, {}, null, (context, rectAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(point.x, point.y), picked), (context, rectAttribute, themeAttribute) => {
      if (picked) return !0;
      const lineWidth = rectAttribute.lineWidth || themeAttribute.lineWidth,
        pickStrokeBuffer = rectAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
        keepStrokeScale = rectAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(point.x, point.y), picked;
    });else {
      const {
        fill = rectAttribute.fill,
        stroke = rectAttribute.stroke,
        lineWidth = rectAttribute.lineWidth
      } = rect.attribute;
      if (fill) picked = !0;else if (stroke) {
        const bounds = rect.AABBBounds;
        _bounds.setValue(bounds.x1, bounds.y1, bounds.x2, bounds.y2), _bounds.expand(-lineWidth / 2), picked = !_bounds.containsPoint(point);
      }
    }
    return pickContext.highPerformanceRestore(), picked;
  }
}

var __decorate$K = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$B = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$o = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathRectPicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultMathRectPicker = __decorate$K([injectable(), __param$o(0, inject(RectRender)), __metadata$B("design:paramtypes", [Object])], DefaultMathRectPicker);

let loadRectPick$1 = !1;
const rectMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick$1 || (loadRectPick$1 = !0, bind(MathRectPicker).to(DefaultMathRectPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathRectPicker));
});

let loadRichTextPick = !1;
const richTextMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichTextPick || (loadRichTextPick = !0, bind(MathImagePicker).to(DefaultMathImagePicker).inSingletonScope(), bind(DefaultMathImagePicker).toService(MathImagePicker));
});

var __decorate$J = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$A = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$n = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultMathSymbolPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
};
DefaultMathSymbolPicker = __decorate$J([injectable(), __param$n(0, inject(SymbolRender)), __metadata$A("design:paramtypes", [Object])], DefaultMathSymbolPicker);

let loadSymbolPick$1 = !1;
const symbolMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick$1 || (loadSymbolPick$1 = !0, bind(MathSymbolPicker).to(DefaultMathSymbolPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathSymbolPicker));
});

var __decorate$I = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultMathTextPicker = class {
  constructor() {
    this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text, point, params) {
    return !!text.AABBBounds.containsPoint(point);
  }
};
DefaultMathTextPicker = __decorate$I([injectable()], DefaultMathTextPicker);

let loadTextPick$1 = !1;
const textMathPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick$1 || (loadTextPick$1 = !0, bind(MathTextPicker).to(DefaultMathTextPicker).inSingletonScope(), bind(MathPickerContribution).toService(MathTextPicker));
});

const mathPickerModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  isBound(DefaultMathPickerService) || bind(DefaultMathPickerService).toSelf().inSingletonScope(), isBound(PickerService) ? rebind(PickerService).toService(DefaultMathPickerService) : bind(PickerService).toService(DefaultMathPickerService);
});
function loadMathPicker(c) {
  c.load(mathModule), c.load(mathPickerModule), c.load(arcMathPickModule), c.load(areaMathPickModule), c.load(circleMathPickModule), c.load(glyphMathPickModule), c.load(imageMathPickModule), c.load(lineMathPickModule), c.load(polygonMathPickModule), c.load(pathMathPickModule), c.load(rectMathPickModule), c.load(richTextMathPickModule), c.load(symbolMathPickModule), c.load(textMathPickModule);
}

class CanvasWrapDisableWH {
  get width() {
    return this._w * this.dpr;
  }
  set width(w) {}
  get height() {
    return this._h * this.dpr;
  }
  set height(h) {}
  get offsetWidth() {
    return this._w;
  }
  set offsetWidth(w) {}
  get offsetHeight() {
    return this._h;
  }
  set offsetHeight(h) {}
  constructor(nativeCanvas, ctx, dpr, w, h, id) {
    this.nativeCanvas = nativeCanvas, this.ctx = ctx, this._w = w, this._h = h, this.id = id, nativeCanvas.id = id, this.dpr = dpr;
  }
  getContext() {
    return this.ctx;
  }
  getBoundingClientRect() {
    return {
      width: this._w,
      height: this._h
    };
  }
}
class CanvasWrapEnableWH {
  get width() {
    return this._w * this.dpr;
  }
  set width(w) {
    this._w = w / this.dpr, this.nativeCanvas.width = w;
  }
  get height() {
    return this._h * this.dpr;
  }
  set height(h) {
    this._h = h / this.dpr, this.nativeCanvas.height = h;
  }
  get offsetWidth() {
    return this._w;
  }
  set offsetWidth(w) {
    this._w = w, this.nativeCanvas.width = w * this.dpr;
  }
  get offsetHeight() {
    return this._h;
  }
  set offsetHeight(h) {
    this._h = h, this.nativeCanvas.height = h * this.dpr;
  }
  constructor(nativeCanvas, ctx, dpr, w, h, id) {
    this.nativeCanvas = nativeCanvas, this.ctx = ctx, this._w = w, this._h = h, this.id = id, nativeCanvas.id = id, this.dpr = dpr;
  }
  getContext() {
    return this.ctx;
  }
  getBoundingClientRect() {
    return {
      width: this._w,
      height: this._h
    };
  }
}

var __decorate$H = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$z = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
function makeUpCanvas$4(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, pixelRatio) {
  const dpr = null != pixelRatio ? pixelRatio : tt.getSystemInfoSync().pixelRatio;
  canvasIdLists.forEach((id, i) => {
    const ctx = tt.createCanvasContext(id),
      canvas = new CanvasWrapDisableWH(ctx.canvas || {}, ctx, dpr, domref.width, domref.height, id);
    ctx.canvas = canvas, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas);
  });
}
let FeishuEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "feishu", this.supportEvent = !0, this.canvasMap = new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = !0;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
    }
    this.applyStyles = !0;
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  configure(service, params) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas$4(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.pixelRatio));
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params) {
    const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result;
  }
  createOffscreenCanvas(params) {}
  releaseCanvas(canvas) {}
  getDevicePixelRatio() {
    return tt.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function (callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return h => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release() {}
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
FeishuEnvContribution = __decorate$H([injectable(), __metadata$z("design:paramtypes", [])], FeishuEnvContribution);

const feishuEnvModule = new ContainerModule(bind => {
  feishuEnvModule.isFeishuBound || (feishuEnvModule.isFeishuBound = !0, bind(FeishuEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(FeishuEnvContribution));
});
feishuEnvModule.isFeishuBound = !1;
function loadFeishuEnv(container) {
  let loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
  loadFeishuEnv.__loaded || (loadFeishuEnv.__loaded = !0, container.load(feishuEnvModule), container.load(feishuCanvasModule), container.load(feishuWindowModule), loadPicker && loadMathPicker(container));
}
loadFeishuEnv.__loaded = !1;
function initFeishuEnv() {
  loadFeishuEnv(container);
}

var __decorate$G = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let LynxContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  setLineDash(segments) {
    const a = arguments,
      _context = this.nativeContext;
    if (this.nativeContext.setLineDash) {
      const lineDash = a[0];
      if (0 === lineDash[0] && 0 === lineDash[1]) return;
      lineDash && _context.setLineDash(lineDash);
    }
  }
  _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const {
      strokeOpacity = defaultParams.strokeOpacity,
      opacity = defaultParams.opacity
    } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const {
        lineWidth = defaultParams.lineWidth,
        stroke = defaultParams.stroke,
        lineJoin = defaultParams.lineJoin,
        lineDash = defaultParams.lineDash,
        lineCap = defaultParams.lineCap,
        miterLimit = defaultParams.miterLimit,
        keepStrokeScale = defaultParams.keepStrokeScale,
        lineDashOffset = defaultParams.lineDashOffset
      } = attribute;
      _context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke, params, offsetX, offsetY), _context.lineJoin = lineJoin, 0 === lineDash[0] && 0 === lineDash[1] || !lineDash || (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  measureText(text) {
    let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : application.global.measureTextMethod;
    this.setTransform(1, 0, 0, 1, 0, 0, !0, application.global.devicePixelRatio);
    return {
      width: super.measureText(text, method).width,
      fontBoundingBoxDescent: void 0,
      fontBoundingBoxAscent: void 0,
      actualBoundingBoxAscent: void 0,
      actualBoundingBoxDescent: void 0
    };
  }
  createPattern(image, repetition) {
    return null;
  }
  draw() {
    const _context = this.nativeContext;
    _context.draw && (this.drawPromise = new Promise(resolve => {
      _context.draw(!0, () => {
        this.drawPromise = null, resolve(null);
      });
    }));
  }
};
LynxContext2d.env = "lynx", LynxContext2d = __decorate$G([injectable()], LynxContext2d);

var __decorate$F = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$y = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let LynxCanvas = class extends BaseCanvas {
  constructor(params) {
    super(params);
  }
  init() {
    this._context = new LynxContext2d(this, this._dpr);
  }
  resize(width, height) {
    this._pixelWidth = width * this._dpr, this._pixelHeight = height * this._dpr, this._displayWidth = width, this._displayHeight = height, this._nativeCanvas.width = this._pixelWidth, this._nativeCanvas.height = this._pixelHeight, this._nativeCanvas.nativeCanvas && (this._nativeCanvas.nativeCanvas.width = this._pixelWidth, this._nativeCanvas.nativeCanvas.height = this._pixelHeight);
    this._context.dpr = this._dpr;
  }
  release() {}
};
LynxCanvas.env = "lynx", LynxCanvas = __decorate$F([injectable(), __metadata$y("design:paramtypes", [Object])], LynxCanvas);

var __decorate$E = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$x = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$m = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let MiniAppEventManager$4 = class MiniAppEventManager {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex(f => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
let LynxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "lynx", this.eventManager = new MiniAppEventManager$4();
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params) {
    params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
  }
  createWindowByConfig(params) {
    const nativeCanvas = this.global.createCanvas({
        width: params.width,
        height: params.height
      }),
      options = {
        width: params.width,
        height: params.height,
        dpr: params.dpr,
        nativeCanvas: nativeCanvas,
        id: Generator.GenAutoIncrementId().toString(),
        canvasControled: !1
      };
    this.canvas = new LynxCanvas(options);
  }
  createWindowByCanvas(params) {
    let canvas;
    if ("string" == typeof params.canvas) {
      if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params.canvas;
    let width = params.width,
      height = params.height;
    if (null == width || null == height || !params.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new LynxCanvas({
      width: width,
      height: height,
      dpr: dpr,
      nativeCanvas: canvas,
      canvasControled: params.canvasControled
    });
  }
  releaseWindow() {}
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const {
      type: type
    } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(f => {
      f(event);
    }), !0);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {}
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox,
      context = this.getContext(),
      dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
LynxWindowHandlerContribution.env = "lynx", LynxWindowHandlerContribution = __decorate$E([injectable(), __param$m(0, inject(VGlobal)), __metadata$x("design:paramtypes", [Object])], LynxWindowHandlerContribution);
const lynxWindowModule = new ContainerModule(bind => {
  bind(LynxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(LynxWindowHandlerContribution)).whenTargetNamed(LynxWindowHandlerContribution.env);
});

const lynxCanvasModule = createModule(LynxCanvas, LynxContext2d);

var __decorate$D = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$w = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let ng = !1;
try {
  ng = !!lynx.createCanvasNG;
} catch (err) {}
function makeUpCanvas$3(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, offscreen, pixelRatio) {
  const dpr = null != pixelRatio ? pixelRatio : SystemInfo.pixelRatio;
  if (canvasIdLists.forEach((id, i) => {
    let _canvas;
    offscreen ? _canvas = lynx.createOffscreenCanvas() : (_canvas = ng ? lynx.createCanvasNG(id) : lynx.createCanvas(id), ng && _canvas.attachToCanvasView(id)), _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
    const ctx = _canvas.getContext("2d"),
      canvas = new CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
    canvasMap.set(id, canvas), i > freeCanvasIdx && freeCanvasList.push(canvas);
  }), !freeCanvasList.length && lynx.createOffscreenCanvas) {
    const _canvas = lynx.createOffscreenCanvas();
    _canvas.width = domref.width * dpr, _canvas.height = domref.height * dpr;
    const ctx = _canvas.getContext("2d"),
      id = Math.random().toString(),
      canvas = new CanvasWrapEnableWH(_canvas, ctx, dpr, domref.width, domref.height, id);
    canvasMap.set(id, canvas), freeCanvasList.push(canvas);
  }
}
function createImageElement(src) {
  let isSvg = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;
  if (isSvg) return Promise.reject();
  const img = lynx.createImage(src);
  return new Promise((resolve, reject) => {
    img.onload = () => {
      resolve(img);
    }, img.onerror = () => {
      reject(new Error("加载失败"));
    };
  });
}
let LynxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "lynx", this.supportEvent = !0, this.canvasMap = new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = !0;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
    }
    this.applyStyles = !0;
  }
  configure(service, params) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas$3(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, !!params.offscreen, params.pixelRatio));
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  loadImage(url) {
    return createImageElement(url, !1).then(img => ({
      data: img,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params) {
    const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result;
  }
  createOffscreenCanvas(params) {}
  releaseCanvas(canvas) {}
  getDevicePixelRatio() {
    return SystemInfo.pixelRatio;
  }
  getRequestAnimationFrame() {
    return function (callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return h => {
      rafBasedSto.clear(h);
    };
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release() {}
};
LynxEnvContribution = __decorate$D([injectable(), __metadata$w("design:paramtypes", [])], LynxEnvContribution);

const lynxEnvModule = new ContainerModule(bind => {
  lynxEnvModule.isLynxBound || (lynxEnvModule.isLynxBound = !0, bind(LynxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(LynxEnvContribution));
});
lynxEnvModule.isLynxBound = !1;
function loadLynxEnv(container) {
  let loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
  loadLynxEnv.__loaded || (loadLynxEnv.__loaded = !0, container.load(lynxEnvModule), container.load(lynxCanvasModule), container.load(lynxWindowModule), loadPicker && loadMathPicker(container));
}
loadLynxEnv.__loaded = !1;
function initLynxEnv() {
  loadLynxEnv(container);
}

var __decorate$C = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$v = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let NodeContext2d = class extends BrowserContext2d {
  constructor(canvas, dpr) {
    super(canvas, dpr);
    const context = canvas.nativeCanvas.getContext("2d");
    if (!context) throw new Error("发生错误，获取2d上下文失败");
    this.nativeContext = context, this.canvas = canvas, this.matrix = new Matrix(1, 0, 0, 1, 0, 0), this.stack = [], this.dpr = null != dpr ? dpr : 1;
  }
  release() {}
};
NodeContext2d.env = "node", NodeContext2d = __decorate$C([injectable(), __metadata$v("design:paramtypes", [Object, Number])], NodeContext2d);

var __decorate$B = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$u = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let NodeCanvas = class extends BaseCanvas {
  constructor(params) {
    super(params);
  }
  init() {
    this._context = new NodeContext2d(this, this._dpr), this.nativeCanvas.width = this._pixelWidth, this.nativeCanvas.height = this._pixelHeight;
  }
  release() {
    this._nativeCanvas.release && isFunction$1(this._nativeCanvas.release) && this._nativeCanvas.release();
  }
};
NodeCanvas.env = "node", NodeCanvas = __decorate$B([injectable(), __metadata$u("design:paramtypes", [Object])], NodeCanvas);

const nodeCanvasModule = createModule(NodeCanvas, NodeContext2d);

var __decorate$A = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$t = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$l = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let NodeWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "node";
  }
  getTitle() {
    return "";
  }
  getWH() {
    return {
      width: this.canvas.displayWidth,
      height: this.canvas.displayHeight
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params) {
    params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
  }
  createWindowByConfig(params) {
    const nativeCanvas = this.global.createCanvas({
        width: params.width,
        height: params.height
      }),
      options = {
        width: params.width,
        height: params.height,
        dpr: params.dpr,
        nativeCanvas: nativeCanvas,
        id: Generator.GenAutoIncrementId().toString(),
        canvasControled: !0
      };
    this.canvas = new NodeCanvas(options);
  }
  createWindowByCanvas(params) {
    var _a;
    const canvas = params.canvas,
      dpr = null !== (_a = params.dpr) && void 0 !== _a ? _a : 1;
    let width = params.width,
      height = params.height;
    null != width && null != height && params.canvasControled || (width = canvas.width / dpr, height = canvas.height / dpr), this.canvas = new NodeCanvas({
      width: width,
      height: height,
      dpr: dpr,
      nativeCanvas: canvas,
      canvasControled: params.canvasControled
    });
  }
  releaseWindow() {
    this.canvas.release();
  }
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  getImageBuffer() {
    let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "image/png";
    return this.canvas.nativeCanvas.toBuffer(type);
  }
  addEventListener(type, listener, options) {}
  dispatchEvent(event) {
    return !0;
  }
  removeEventListener(type, listener, options) {}
  getStyle() {}
  setStyle(style) {}
  getBoundingClientRect() {
    return null;
  }
  clearViewBox(color) {}
};
NodeWindowHandlerContribution.env = "node", NodeWindowHandlerContribution = __decorate$A([injectable(), __param$l(0, inject(VGlobal)), __metadata$t("design:paramtypes", [Object])], NodeWindowHandlerContribution);
const nodeWindowModule = new ContainerModule(bind => {
  bind(NodeWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(NodeWindowHandlerContribution)).whenTargetNamed(NodeWindowHandlerContribution.env);
});

var __decorate$z = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let NodeEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(...arguments), this.type = "node", this._lastTime = 0, this.supportEvent = !1;
  }
  configure(service, pkg) {
    service.env === this.type && (service.setActiveEnvContribution(this), this.pkg = pkg);
  }
  getDynamicCanvasCount() {
    return 0;
  }
  getStaticCanvasCount() {
    return 999;
  }
  loadJson(url) {
    const jsonPromise = fetch(url).then(data => data.json());
    return jsonPromise.then(json => ({
      data: json,
      state: "success"
    })).catch(() => ({
      data: null,
      state: "fail"
    })), jsonPromise;
  }
  loadArrayBuffer(url) {
    return fetch(url).then(data => data.arrayBuffer()).then(arrayBuffer => ({
      data: arrayBuffer,
      loadState: "success"
    })).catch(() => ({
      data: null,
      loadState: "fail"
    }));
  }
  loadImage(url) {
    const {
      loadImage: loadImage
    } = this.pkg;
    return loadImage ? loadImage(url).then(image => ({
      loadState: image ? "success" : "fail",
      data: image
    })).catch(() => ({
      loadState: "fail",
      data: null
    })) : Promise.reject(new Error("node-canvas loadImage could not be found!"));
  }
  loadSvg(svgStr) {
    const Resvg = this.pkg.Resvg;
    if (!Resvg) return Promise.reject(new Error("@resvg/resvg-js svgParser could not be found!"));
    const pngData = new Resvg(svgStr).render().asPng();
    return this.loadImage(pngData);
  }
  createCanvas(params) {
    return this.pkg.createCanvas(params.width, params.height);
  }
  releaseCanvas(canvas) {}
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return function (callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return h => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {}
  removeEventListener(type, listener, options) {}
  getElementById(str) {
    return null;
  }
  getRootElement() {
    return null;
  }
  dispatchEvent(event) {}
  release() {}
  createOffscreenCanvas(params) {}
};
NodeEnvContribution = __decorate$z([injectable()], NodeEnvContribution);

const nodeEnvModule = new ContainerModule(bind => {
  nodeEnvModule.isNodeBound || (nodeEnvModule.isNodeBound = !0, bind(NodeEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(NodeEnvContribution));
});
nodeEnvModule.isNodeBound = !1;
function loadNodeEnv(container) {
  loadNodeEnv.__loaded || (loadNodeEnv.__loaded = !0, container.load(nodeEnvModule), container.load(nodeCanvasModule), container.load(nodeWindowModule));
}
loadNodeEnv.__loaded = !1;
function initNodeEnv() {
  loadNodeEnv(container);
}

var __decorate$y = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TaroContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.setGlobalAlpha(ga), this._globalAlpha = ga;
  }
  draw() {
    this.nativeContext.draw();
  }
  strokeText(text, x, y) {}
  _setCommonStyle(params, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.fillAttributes);
    const {
      fillOpacity = defaultParams.fillOpacity,
      opacity = defaultParams.opacity,
      fill = defaultParams.fill
    } = attribute;
    fillOpacity > 1e-12 && opacity > 1e-12 && (_context.setGlobalAlpha(fillOpacity * opacity), _context.setFillStyle(createColor(this, fill, params, offsetX, offsetY)));
  }
  _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const {
      strokeOpacity = defaultParams.strokeOpacity,
      opacity = defaultParams.opacity
    } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const {
        lineWidth = defaultParams.lineWidth,
        stroke = defaultParams.stroke,
        lineJoin = defaultParams.lineJoin,
        lineDash = defaultParams.lineDash,
        lineDashOffset = defaultParams.lineDashOffset,
        lineCap = defaultParams.lineCap,
        miterLimit = defaultParams.miterLimit,
        keepStrokeScale = defaultParams.keepStrokeScale
      } = attribute;
      _context.setGlobalAlpha(strokeOpacity * opacity), _context.setLineWidth(keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr)), _context.setStrokeStyle(createColor(this, stroke, params, offsetX, offsetY)), _context.setLineJoin(lineJoin), lineDash && (_context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.setLineCap(lineCap), _context.setMiterLimit(miterLimit);
    }
  }
  setTextStyleWithoutAlignBaseline(params, defaultParams) {
    var _a;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = getContextFont(params, defaultParams), _context.setFontSize(null !== (_a = params.fontSize) && void 0 !== _a ? _a : defaultParams.fontSize);
  }
  setTextStyle(params, defaultParams) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes), params.font ? _context.font = params.font : _context.font = getContextFont(params, defaultParams), _context.setTextAlign(null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign), _context.setTextBaseline(null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline);
  }
  createConicGradient(x, y, startAngle, endAngle) {
    return null;
  }
  createPattern(image, repetition) {
    return null;
  }
  getImageData(sx, sy, sw, sh) {
    const ctx = this.nativeContext,
      taro = ctx.taro;
    if (ctx && taro) return !ctx.getImageData && taro.canvasGetImageData ? new Promise((resolve, reject) => {
      try {
        taro.canvasGetImageData({
          canvasId: this.canvas.nativeCanvas.id,
          sx: sx,
          sy: sy,
          sw: sw,
          sh: sh,
          success(res) {
            resolve(res);
          }
        });
      } catch (err) {
        reject(err);
      }
    }) : void 0;
  }
  createRadialGradient(x0, y0, r0, x1, y1, r1) {
    return this.nativeContext.createCircularGradient && this.nativeContext.createCircularGradient(x0, y0, r0, x1, y1, r1);
  }
};
TaroContext2d.env = "taro", TaroContext2d = __decorate$y([injectable()], TaroContext2d);

var __decorate$x = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$s = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let TaroCanvas = class extends BaseCanvas {
  constructor(params) {
    super(params);
  }
  init() {
    this._context = new TaroContext2d(this, this._dpr);
  }
  release() {}
};
TaroCanvas.env = "taro", TaroCanvas = __decorate$x([injectable(), __metadata$s("design:paramtypes", [Object])], TaroCanvas);

const taroCanvasModule = createModule(TaroCanvas, TaroContext2d);

var __decorate$w = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$r = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$k = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let MiniAppEventManager$3 = class MiniAppEventManager {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex(f => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
let TaroWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "taro", this.eventManager = new MiniAppEventManager$3();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params) {
    params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
  }
  createWindowByConfig(params) {
    const nativeCanvas = this.global.createCanvas({
        width: params.width,
        height: params.height
      }),
      options = {
        width: params.width,
        height: params.height,
        dpr: params.dpr,
        nativeCanvas: nativeCanvas,
        id: Generator.GenAutoIncrementId().toString(),
        canvasControled: !1
      };
    this.canvas = new TaroCanvas(options);
  }
  createWindowByCanvas(params) {
    let canvas;
    if ("string" == typeof params.canvas) {
      if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params.canvas;
    let width = params.width,
      height = params.height;
    if (null == width || null == height || !params.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new TaroCanvas({
      width: width,
      height: height,
      dpr: dpr,
      nativeCanvas: canvas,
      canvasControled: params.canvasControled
    });
  }
  releaseWindow() {}
  resizeWindow(width, height) {}
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const {
      type: type
    } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches.length > 0 && (event.changedTouches.forEach((d, i) => {
      event.changedTouches[i] = Object.assign(Object.assign({}, event.changedTouches[i]), {
        offsetX: d.x,
        offsetY: d.y
      });
    }), event.offsetX = event.changedTouches[0].offsetX, event.offsetY = event.changedTouches[0].offsetY), event.touches.length > 0 && event.touches.forEach((d, i) => {
      event.touches[i] = Object.assign(Object.assign({}, event.touches[i]), {
        offsetX: d.x,
        offsetY: d.y
      });
    }), event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(f => {
      f(event);
    }), !0);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {}
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox,
      context = this.getContext(),
      dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
TaroWindowHandlerContribution.env = "taro", TaroWindowHandlerContribution = __decorate$w([injectable(), __param$k(0, inject(VGlobal)), __metadata$r("design:paramtypes", [Object])], TaroWindowHandlerContribution);
const taroWindowModule = new ContainerModule(bind => {
  bind(TaroWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(TaroWindowHandlerContribution)).whenTargetNamed(TaroWindowHandlerContribution.env);
});

var __decorate$v = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$q = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
function makeUpCanvas$2(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, taro, dpr) {
  canvasIdLists.forEach((id, i) => {
    const ctx = taro.createCanvasContext(id),
      canvas = new CanvasWrapDisableWH(ctx.canvas || {}, ctx, dpr, domref.width, domref.height, id);
    return ctx.canvas = canvas, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), canvas;
  });
}
let TaroEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "taro", this.supportEvent = !0, this.canvasMap = new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = !0;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
    }
    this.applyStyles = !0;
  }
  getDynamicCanvasCount() {
    return this.freeCanvasList.length;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
  configure(service, params) {
    service.env === this.type && (service.setActiveEnvContribution(this), makeUpCanvas$2(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.taro, params.pixelRatio), this.taro = params.taro, this.pixelRatio = params.pixelRatio);
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(svgStr) {
    const _window = window || globalThis;
    if (_window.DOMParser) {
      const svg = new _window.DOMParser().parseFromString(svgStr, "image/svg+xml").children[0],
        data = new XMLSerializer().serializeToString(svg),
        url = `data:image/svg+xml;charset=utf-8,${encodeURIComponent(data)}`;
      return Promise.resolve({
        data: url,
        loadState: "success"
      });
    }
    if (_window.Blob) {
      const data = new _window.Blob([svgStr], {
          type: "image/svg+xml"
        }),
        url = _window.URL.createObjectURL(data);
      return Promise.resolve({
        data: url,
        loadState: "success"
      });
    }
    return Promise.reject();
  }
  createCanvas(params) {
    const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result;
  }
  createOffscreenCanvas(params) {}
  releaseCanvas(canvas) {}
  getDevicePixelRatio() {
    return this.pixelRatio;
  }
  getRequestAnimationFrame() {
    return requestAnimationFrame;
  }
  getCancelAnimationFrame() {
    return cancelAnimationFrame;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release() {}
};
TaroEnvContribution = __decorate$v([injectable(), __metadata$q("design:paramtypes", [])], TaroEnvContribution);

const taroEnvModule = new ContainerModule(bind => {
  taroEnvModule.isTaroBound || (taroEnvModule.isTaroBound = !0, bind(TaroEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TaroEnvContribution));
});
taroEnvModule.isTaroBound = !1;
function loadTaroEnv(container) {
  let loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
  loadTaroEnv.__loaded || (loadTaroEnv.__loaded = !0, container.load(taroEnvModule), container.load(taroCanvasModule), container.load(taroWindowModule), loadPicker && loadMathPicker(container));
}
loadTaroEnv.__loaded = !1;
function initTaroEnv() {
  loadTaroEnv(container);
}

var __decorate$u = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let WxContext2d = class extends BrowserContext2d {
  draw() {}
  createPattern(image, repetition) {
    return null;
  }
};
WxContext2d.env = "wx", WxContext2d = __decorate$u([injectable()], WxContext2d);

var __decorate$t = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$p = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let WxCanvas = class extends BaseCanvas {
  constructor(params) {
    super(params);
  }
  init() {
    this._context = new WxContext2d(this, this._dpr);
  }
  release() {}
};
WxCanvas.env = "wx", WxCanvas = __decorate$t([injectable(), __metadata$p("design:paramtypes", [Object])], WxCanvas);

const wxCanvasModule = createModule(WxCanvas, WxContext2d);

var __decorate$s = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$o = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$j = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let MiniAppEventManager$2 = class MiniAppEventManager {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex(f => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
let WxWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "wx", this.eventManager = new MiniAppEventManager$2();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params) {
    params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
  }
  createWindowByConfig(params) {
    const nativeCanvas = this.global.createCanvas({
        width: params.width,
        height: params.height
      }),
      options = {
        width: params.width,
        height: params.height,
        dpr: params.dpr,
        nativeCanvas: nativeCanvas,
        id: Generator.GenAutoIncrementId().toString(),
        canvasControled: !1
      };
    this.canvas = new WxCanvas(options);
  }
  createWindowByCanvas(params) {
    let canvas;
    if ("string" == typeof params.canvas) {
      if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params.canvas;
    let width = params.width,
      height = params.height;
    if (null == width || null == height || !params.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new WxCanvas({
      width: width,
      height: height,
      dpr: dpr,
      nativeCanvas: canvas,
      canvasControled: params.canvasControled
    });
  }
  releaseWindow() {}
  resizeWindow(width, height) {}
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    var _a, _b, _c, _d;
    const {
      type: type
    } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = null !== (_a = event.changedTouches[0].x) && void 0 !== _a ? _a : event.changedTouches[0].pageX, event.changedTouches[0].clientX = null !== (_b = event.changedTouches[0].x) && void 0 !== _b ? _b : event.changedTouches[0].pageX, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = null !== (_c = event.changedTouches[0].y) && void 0 !== _c ? _c : event.changedTouches[0].pageY, event.changedTouches[0].clientY = null !== (_d = event.changedTouches[0].y) && void 0 !== _d ? _d : event.changedTouches[0].pageY), event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(f => {
      f(event);
    }), !0);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {}
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox,
      context = this.getContext(),
      dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
WxWindowHandlerContribution.env = "wx", WxWindowHandlerContribution = __decorate$s([injectable(), __param$j(0, inject(VGlobal)), __metadata$o("design:paramtypes", [Object])], WxWindowHandlerContribution);
const wxWindowModule = new ContainerModule(bind => {
  bind(WxWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(WxWindowHandlerContribution)).whenTargetNamed(WxWindowHandlerContribution.env);
});

var __decorate$r = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$n = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
function makeUpCanvas$1(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component, forceUpdate) {
  return __awaiter$1(this, void 0, void 0, function* () {
    const dpr = wx.getSystemInfoSync().pixelRatio;
    for (let i = 0; i < canvasIdLists.length; i++) {
      const id = canvasIdLists[i];
      !forceUpdate && canvasMap.has(id) || (yield new Promise(resolve => {
        let data = wx.createSelectorQuery();
        component && (data = data.in(component)), data.select(`#${id}`).fields({
          node: !0,
          size: !0
        }).exec(res => {
          if (!res[0]) return;
          const canvas = res[0].node,
            width = res[0].width,
            height = res[0].height;
          canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
        });
      }));
    }
  });
}
let WxEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "wx", this.supportEvent = !0, this.canvasMap = new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = !0;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
    }
    this.applyStyles = !0;
  }
  configure(service, params) {
    if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas$1(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.component, params.forceUpdate).then(() => {});
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params) {
    const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result;
  }
  createOffscreenCanvas(params) {}
  releaseCanvas(canvas) {}
  getDevicePixelRatio() {
    return wx.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function (callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return h => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release() {}
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
WxEnvContribution = __decorate$r([injectable(), __metadata$n("design:paramtypes", [])], WxEnvContribution);

const wxEnvModule = new ContainerModule(bind => {
  wxEnvModule._isWxBound || (wxEnvModule._isWxBound = !0, bind(WxEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(WxEnvContribution));
});
wxEnvModule._isWxBound = !1;
function loadWxEnv(container) {
  let loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
  loadWxEnv.__loaded || (loadWxEnv.__loaded = !0, container.load(wxEnvModule), container.load(wxCanvasModule), container.load(wxWindowModule), loadPicker && loadMathPicker(container));
}
loadWxEnv.__loaded = !1;
function initWxEnv() {
  loadWxEnv(container);
}

function loadAllEnv(container) {
  loadAllModule(container);
}
function loadAllModule(container) {
  loadAllModule.__loaded || (loadAllModule.__loaded = !0, loadBrowserEnv(container, !1), loadFeishuEnv(container, !1), loadLynxEnv(container, !1), loadNodeEnv(container), loadTaroEnv(container, !1), loadWxEnv(container, !1), loadCanvasPicker(container), vglobal.hooks.onSetEnv.tap("loadMathPicker", (lastEnv, env) => {
    "browser" !== env && loadMathPicker(container);
  }));
}
loadAllModule.__loaded = !1;
function initAllEnv() {
  loadAllEnv(container);
}

var __decorate$q = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let TTContext2d = class extends FeishuContext2d {};
TTContext2d.env = "tt", TTContext2d = __decorate$q([injectable()], TTContext2d);

var __decorate$p = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$m = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let TTCanvas = class extends BaseCanvas {
  constructor(params) {
    super(params);
  }
  init() {
    this._context = new TTContext2d(this, this._dpr);
  }
  release() {}
};
TTCanvas.env = "tt", TTCanvas = __decorate$p([injectable(), __metadata$m("design:paramtypes", [Object])], TTCanvas);

const ttCanvasModule = createModule(TTCanvas, TTContext2d);

var __decorate$o = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$l = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$i = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let MiniAppEventManager$1 = class MiniAppEventManager {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex(f => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
};
let TTWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "tt", this.eventManager = new MiniAppEventManager$1();
  }
  getTitle() {
    return this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params) {
    params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
  }
  createWindowByConfig(params) {
    const nativeCanvas = this.global.createCanvas({
        width: params.width,
        height: params.height
      }),
      options = {
        width: params.width,
        height: params.height,
        dpr: params.dpr,
        nativeCanvas: nativeCanvas,
        id: Generator.GenAutoIncrementId().toString(),
        canvasControled: !1
      };
    this.canvas = new TTCanvas(options);
  }
  createWindowByCanvas(params) {
    let canvas;
    if ("string" == typeof params.canvas) {
      if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params.canvas;
    let width = params.width,
      height = params.height;
    if (null == width || null == height || !params.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    let dpr = params.dpr;
    null == dpr && (dpr = canvas.width / width), this.canvas = new TTCanvas({
      width: width,
      height: height,
      dpr: dpr,
      nativeCanvas: canvas,
      canvasControled: params.canvasControled
    });
  }
  releaseWindow() {}
  resizeWindow(width, height) {}
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const {
      type: type
    } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(f => {
      f(event);
    }), !0);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {}
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox,
      context = this.getContext(),
      dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
TTWindowHandlerContribution.env = "tt", TTWindowHandlerContribution = __decorate$o([injectable(), __param$i(0, inject(VGlobal)), __metadata$l("design:paramtypes", [Object])], TTWindowHandlerContribution);
const ttWindowModule = new ContainerModule(bind => {
  bind(TTWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(TTWindowHandlerContribution)).whenTargetNamed(TTWindowHandlerContribution.env);
});

var __decorate$n = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$k = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator.throw(value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        var value;
        result.done ? resolve(result.value) : (value = result.value, value instanceof P ? value : new P(function (resolve) {
          resolve(value);
        })).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
function makeUpCanvas(domref, canvasIdLists, canvasMap, freeCanvasIdx, freeCanvasList, component) {
  return __awaiter(this, void 0, void 0, function* () {
    const dpr = tt.getSystemInfoSync().pixelRatio;
    for (let i = 0; i < canvasIdLists.length; i++) {
      const id = canvasIdLists[i];
      yield new Promise(resolve => {
        let data = tt.createSelectorQuery();
        component && (data = data.in(component)), data.select(`#${id}`).node().exec(res => {
          const canvas = res[0].node,
            width = canvas.width,
            height = canvas.height;
          canvas.width = width * dpr, canvas.height = height * dpr, canvasMap.set(id, canvas), i >= freeCanvasIdx && freeCanvasList.push(canvas), resolve(null);
        });
      });
    }
  });
}
let TTEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "tt", this.supportEvent = !0, this.canvasMap = new Map(), this.freeCanvasList = [], this.canvasIdx = 0, this.supportsTouchEvents = !0;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
    }
    this.applyStyles = !0;
  }
  configure(service, params) {
    if (service.env === this.type) return service.setActiveEnvContribution(this), makeUpCanvas(params.domref, params.canvasIdLists, this.canvasMap, params.freeCanvasIdx, this.freeCanvasList, params.component).then(() => {});
  }
  loadImage(url) {
    return Promise.resolve({
      data: url,
      loadState: "success"
    });
  }
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params) {
    const result = this.freeCanvasList[this.canvasIdx] || this.freeCanvasList[this.freeCanvasList.length - 1];
    return this.canvasIdx++, result;
  }
  createOffscreenCanvas(params) {}
  releaseCanvas(canvas) {}
  getDevicePixelRatio() {
    return tt.getSystemInfoSync().pixelRatio;
  }
  getRequestAnimationFrame() {
    return function (callback) {
      return rafBasedSto.call(callback);
    };
  }
  getCancelAnimationFrame() {
    return h => {
      rafBasedSto.clear(h);
    };
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return this.canvasMap.get(str);
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release() {}
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
};
TTEnvContribution = __decorate$n([injectable(), __metadata$k("design:paramtypes", [])], TTEnvContribution);

const ttEnvModule = new ContainerModule(bind => {
  ttEnvModule.isTTBound || (ttEnvModule.isTTBound = !0, bind(TTEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(TTEnvContribution));
});
ttEnvModule.isTTBound = !1;
function loadTTEnv(container) {
  let loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
  loadTTEnv.__loaded || (loadTTEnv.__loaded = !0, container.load(ttEnvModule), container.load(ttCanvasModule), container.load(ttWindowModule), loadPicker && loadMathPicker(container));
}
loadTTEnv.__loaded = !1;
function initTTEnv() {
  loadTTEnv(container);
}

var __decorate$m = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let HarmonyContext2d = class extends BrowserContext2d {
  get globalAlpha() {
    return this._globalAlpha;
  }
  set globalAlpha(ga) {
    this.nativeContext.globalAlpha = ga * this.baseGlobalAlpha, this._globalAlpha = ga * this.baseGlobalAlpha;
  }
  setLineDash(segments) {
    const a = arguments,
      _context = this.nativeContext;
    if (this.nativeContext.setLineDash) {
      const lineDash = a[0];
      if (0 === lineDash[0] && 0 === lineDash[1]) return;
      lineDash && _context.setLineDash(lineDash);
    }
  }
  _setStrokeStyle(params, attribute, offsetX, offsetY, defaultParams) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.strokeAttributes);
    const {
      strokeOpacity = defaultParams.strokeOpacity,
      opacity = defaultParams.opacity
    } = attribute;
    if (strokeOpacity > 1e-12 && opacity > 1e-12) {
      const {
        lineWidth = defaultParams.lineWidth,
        stroke = defaultParams.stroke,
        lineJoin = defaultParams.lineJoin,
        lineDash = defaultParams.lineDash,
        lineCap = defaultParams.lineCap,
        miterLimit = defaultParams.miterLimit,
        keepStrokeScale = defaultParams.keepStrokeScale,
        lineDashOffset = defaultParams.lineDashOffset
      } = attribute;
      _context.globalAlpha = strokeOpacity * opacity * this.baseGlobalAlpha, _context.lineWidth = keepStrokeScale ? lineWidth : getScaledStroke(this, lineWidth, this.dpr), _context.strokeStyle = createColor(this, stroke, params, offsetX, offsetY), _context.lineJoin = lineJoin, 0 === lineDash[0] && 0 === lineDash[1] || (lineDash && _context.setLineDash(lineDash), _context.lineDashOffset = lineDashOffset), _context.lineCap = lineCap, _context.miterLimit = miterLimit;
    }
  }
  measureText(text) {
    let method = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : application.global.measureTextMethod;
    this.setTransform(1, 0, 0, 1, 0, 0, !0, application.global.devicePixelRatio);
    return super.measureText(text, method);
  }
  setTextStyleWithoutAlignBaseline(params, defaultParams, z) {
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    const {
      scaleIn3d = defaultParams.scaleIn3d
    } = params;
    let font = "";
    font = params.font ? params.font : getContextFont(params, defaultParams, scaleIn3d && this.camera && this.camera.getProjectionScale(z)), _context.font = (font || "").replace("px", "vp");
    const {
      fontFamily = defaultParams.fontFamily,
      fontSize = defaultParams.fontSize
    } = params;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = "left", _context.textBaseline = "alphabetic";
  }
  setTextStyle(params, defaultParams, z) {
    var _a, _b;
    const _context = this.nativeContext;
    defaultParams || (defaultParams = this.textAttributes);
    let font = "";
    font = params.font ? params.font : getContextFont(params, defaultParams, this.camera && this.camera.getProjectionScale(z)), _context.font = (font || "").replace("px", "vp");
    const {
      fontFamily = defaultParams.fontFamily,
      fontSize = defaultParams.fontSize
    } = params;
    this.fontFamily = fontFamily, this.fontSize = fontSize, _context.textAlign = null !== (_a = params.textAlign) && void 0 !== _a ? _a : defaultParams.textAlign, _context.textBaseline = null !== (_b = params.textBaseline) && void 0 !== _b ? _b : defaultParams.textBaseline;
  }
  createPattern(image, repetition) {
    return null;
  }
  drawImage() {
    const _context = this.nativeContext,
      a = arguments;
    a[0].drawImage && (a[0] = a[0].transferToImageBitmap()), 3 === a.length ? _context.drawImage(a[0], a[1], a[2]) : 5 === a.length ? _context.drawImage(a[0], a[1], a[2], a[3], a[4]) : 9 === a.length && _context.drawImage(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8]);
  }
  draw() {}
};
HarmonyContext2d.env = "harmony", HarmonyContext2d = __decorate$m([injectable()], HarmonyContext2d);

var __decorate$l = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$j = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
let HarmonyCanvas = class extends BaseCanvas {
  constructor(params) {
    super(params);
  }
  init() {
    this._context = new HarmonyContext2d(this, this._dpr);
  }
  resize(width, height) {}
  release() {}
};
HarmonyCanvas.env = "harmony", HarmonyCanvas = __decorate$l([injectable(), __metadata$j("design:paramtypes", [Object])], HarmonyCanvas);

var __decorate$k = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$i = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$h = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
class MiniAppEventManager {
  constructor() {
    this.cache = {};
  }
  addEventListener(type, func) {
    type && func && (this.cache[type] = this.cache[type] || {
      listener: []
    }, this.cache[type].listener.push(func));
  }
  removeEventListener(type, func) {
    if (!type || !func) return;
    if (!this.cache[type]) return;
    const index = this.cache[type].listener.findIndex(f => f === func);
    index >= 0 && this.cache[type].listener.splice(index, 1);
  }
  cleanEvent() {
    this.cache = {};
  }
}
let HarmonyWindowHandlerContribution = class extends BaseWindowHandlerContribution {
  get container() {
    return null;
  }
  constructor(global) {
    super(), this.global = global, this.type = "harmony", this.eventManager = new MiniAppEventManager();
  }
  getTitle() {
    return this.canvas.id && this.canvas.id.toString();
  }
  getWH() {
    return {
      width: this.canvas.width / (this.canvas.dpr || 1),
      height: this.canvas.height / (this.canvas.dpr || 1)
    };
  }
  getXY() {
    return {
      x: 0,
      y: 0
    };
  }
  createWindow(params) {
    params.canvas ? this.createWindowByCanvas(params) : this.createWindowByConfig(params);
  }
  createWindowByConfig(params) {
    const nativeCanvas = this.global.createCanvas({
        width: params.width,
        height: params.height
      }),
      options = {
        width: params.width,
        height: params.height,
        dpr: params.dpr,
        nativeCanvas: nativeCanvas,
        id: Generator.GenAutoIncrementId().toString(),
        canvasControled: !1
      };
    this.canvas = new HarmonyCanvas(options);
  }
  createWindowByCanvas(params) {
    let canvas;
    if ("string" == typeof params.canvas) {
      if (canvas = this.global.getElementById(params.canvas), !canvas) throw new Error("canvasId 参数不正确，请确认canvas存在并插入dom");
    } else canvas = params.canvas;
    let width = params.width,
      height = params.height;
    if (null == width || null == height || !params.canvasControled) {
      const data = canvas.getBoundingClientRect();
      width = data.width, height = data.height;
    }
    this.canvas = new HarmonyCanvas({
      width: width,
      height: height,
      dpr: 1,
      nativeCanvas: canvas,
      canvasControled: params.canvasControled
    });
  }
  releaseWindow() {}
  resizeWindow(width, height) {
    this.canvas.resize(width, height);
  }
  setDpr(dpr) {
    this.canvas.dpr = dpr;
  }
  getContext() {
    return this.canvas.getContext();
  }
  getNativeHandler() {
    return this.canvas;
  }
  getDpr() {
    return this.canvas.dpr;
  }
  addEventListener(type, listener) {
    this.eventManager.addEventListener(type, listener);
  }
  removeEventListener(type, listener) {
    this.eventManager.removeEventListener(type, listener);
  }
  dispatchEvent(event) {
    const {
      type: type
    } = event;
    return !!this.eventManager.cache[type] && (event.changedTouches && event.changedTouches[0] && (event.offsetX = event.changedTouches[0].x, event.changedTouches[0].offsetX = event.changedTouches[0].x, event.changedTouches[0].clientX = event.changedTouches[0].x, event.offsetY = event.changedTouches[0].y, event.changedTouches[0].offsetY = event.changedTouches[0].y, event.changedTouches[0].clientY = event.changedTouches[0].y), event.preventDefault = () => {}, event.stopPropagation = () => {}, this.eventManager.cache[type].listener && this.eventManager.cache[type].listener.forEach(f => {
      f(event);
    }), !0);
  }
  getStyle() {
    return {};
  }
  setStyle(style) {}
  getBoundingClientRect() {
    const wh = this.getWH();
    return {
      x: 0,
      y: 0,
      width: wh.width,
      height: wh.height,
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  clearViewBox(color) {
    const vb = this.viewBox,
      context = this.getContext(),
      dpr = this.getDpr();
    context.nativeContext.save(), context.nativeContext.setTransform(dpr, 0, 0, dpr, 0, 0), context.clearRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1), color && (context.fillStyle = color, context.fillRect(vb.x1, vb.y1, vb.x2 - vb.x1, vb.y2 - vb.y1)), context.nativeContext.restore();
  }
};
HarmonyWindowHandlerContribution.env = "harmony", HarmonyWindowHandlerContribution = __decorate$k([injectable(), __param$h(0, inject(VGlobal)), __metadata$i("design:paramtypes", [Object])], HarmonyWindowHandlerContribution);
const harmonyWindowModule = new ContainerModule(bind => {
  bind(HarmonyWindowHandlerContribution).toSelf(), bind(WindowHandlerContribution).toDynamicValue(ctx => ctx.container.get(HarmonyWindowHandlerContribution)).whenTargetNamed(HarmonyWindowHandlerContribution.env);
});

const harmonyCanvasModule = createModule(HarmonyCanvas, HarmonyContext2d);

var __decorate$j = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$h = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  };
function createCanvas(width, height, id) {
  const _c = new OffscreenCanvas(width, height),
    context = _c.getContext("2d");
  return new CanvasWrapDisableWH({
    width: width,
    height: height,
    context: context,
    _c: _c,
    getBoundingClientRect: () => ({
      width: width,
      height: height
    }),
    getContext: () => context
  }, context, 1, width, height, id);
}
let HarmonyEnvContribution = class extends BaseEnvContribution {
  constructor() {
    super(), this.type = "harmony", this.supportEvent = !0, this.supportsTouchEvents = !0;
    try {
      this.supportsPointerEvents = !!globalThis.PointerEvent, this.supportsMouseEvents = !!globalThis.MouseEvent;
    } catch (err) {
      this.supportsPointerEvents = !1, this.supportsMouseEvents = !1;
    }
    this.applyStyles = !0, this.rafSTO = new RafBasedSTO(0);
  }
  configure(service, params) {
    service.env === this.type && service.setActiveEnvContribution(this);
  }
  getDynamicCanvasCount() {
    return 9999;
  }
  getStaticCanvasCount() {
    return 9999;
  }
  loadImage(url) {}
  loadSvg(url) {
    return Promise.reject();
  }
  createCanvas(params) {
    return createCanvas(params.width, params.height, params.id);
  }
  createOffscreenCanvas(params) {}
  releaseCanvas(canvas) {}
  getDevicePixelRatio() {
    return 1;
  }
  getRequestAnimationFrame() {
    return callback => this.rafSTO.call(callback);
  }
  getCancelAnimationFrame() {
    return h => {
      this.rafSTO.clear(h);
    };
  }
  mapToCanvasPoint(event) {
    var _a;
    return null === (_a = null == event ? void 0 : event.type) || void 0 === _a || _a.startsWith("mouse"), event;
  }
  addEventListener(type, listener, options) {
    return null;
  }
  removeEventListener(type, listener, options) {
    return null;
  }
  dispatchEvent(event) {
    return null;
  }
  getElementById(str) {
    return null;
  }
  getRootElement() {
    return null;
  }
  getDocument() {
    return null;
  }
  release() {}
};
HarmonyEnvContribution = __decorate$j([injectable(), __metadata$h("design:paramtypes", [])], HarmonyEnvContribution);

const harmonyEnvModule = new ContainerModule(bind => {
  harmonyEnvModule.isHarmonyBound || (harmonyEnvModule.isHarmonyBound = !0, bind(HarmonyEnvContribution).toSelf().inSingletonScope(), bind(EnvContribution).toService(HarmonyEnvContribution));
});
harmonyEnvModule.isHarmonyBound = !1;
function loadHarmonyEnv(container) {
  let loadPicker = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !0;
  loadHarmonyEnv.__loaded || (loadHarmonyEnv.__loaded = !0, container.load(harmonyEnvModule), container.load(harmonyCanvasModule), container.load(harmonyWindowModule), loadPicker && loadMathPicker(container));
}
loadHarmonyEnv.__loaded = !1;
function initHarmonyEnv() {
  loadHarmonyEnv(container);
}

var __decorate$i = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$g = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$g = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasArcPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc", this.numberType = ARC_NUMBER_TYPE;
  }
};
DefaultCanvasArcPicker = __decorate$i([injectable(), __param$g(0, inject(ArcRender)), __metadata$g("design:paramtypes", [Object])], DefaultCanvasArcPicker);

let loadArcPick = !1;
const arcCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArcPick || (loadArcPick = !0, bind(CanvasArcPicker).to(DefaultCanvasArcPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArcPicker));
});

var __decorate$h = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$f = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$f = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasRectPicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasRectPicker = __decorate$h([injectable(), __param$f(0, inject(RectRender)), __metadata$f("design:paramtypes", [Object])], DefaultCanvasRectPicker);

let loadRectPick = !1;
const rectCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRectPick || (loadRectPick = !0, bind(CanvasRectPicker).to(DefaultCanvasRectPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRectPicker));
});

class BaseLinePicker extends BaseRender {
  contains(graphic, point, params) {
    if (!graphic.AABBBounds.containsPoint(point)) return !1;
    if ("imprecise" === graphic.attribute.pickMode) return !0;
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    pickContext.highPerformanceSave();
    const lineAttribute = graphic.getGraphicTheme(),
      data = this.transform(graphic, lineAttribute, pickContext),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    let pickPoint = point;
    if (pickContext.camera) {
      pickPoint = point.clone();
      const globalMatrix = graphic.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = !1;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, {}, null, context => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, lineAttribute, themeAttribute) => {
      if (picked) return !0;
      const lineWidth = lineAttribute.lineWidth || themeAttribute.lineWidth,
        pickStrokeBuffer = lineAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
        keepStrokeScale = lineAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
}

var __decorate$g = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$e = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$e = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasLinePicker = class extends BaseLinePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "line", this.numberType = LINE_NUMBER_TYPE;
  }
};
DefaultCanvasLinePicker = __decorate$g([injectable(), __param$e(0, inject(LineRender)), __metadata$e("design:paramtypes", [Object])], DefaultCanvasLinePicker);

let loadLinePick = !1;
const lineCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLinePick || (loadLinePick = !0, bind(CanvasLinePicker).to(DefaultCanvasLinePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLinePicker));
});

var __decorate$f = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$d = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$d = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasAreaPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "area", this.numberType = AREA_NUMBER_TYPE;
  }
};
DefaultCanvasAreaPicker = __decorate$f([injectable(), __param$d(0, inject(AreaRender)), __metadata$d("design:paramtypes", [Object])], DefaultCanvasAreaPicker);

let loadAreaPick = !1;
const areaCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadAreaPick || (loadAreaPick = !0, bind(CanvasAreaPicker).to(DefaultCanvasAreaPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasAreaPicker));
});

class Base3dPicker extends BaseRender {
  contains(graphic, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const attribute = graphic.getGraphicTheme();
    pickContext.highPerformanceSave();
    const data = this.transform(graphic, attribute, pickContext),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    let pickPoint = point;
    if (pickContext.camera) {
      pickPoint = point.clone();
      const globalMatrix = graphic.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = !1;
    return this.canvasRenderer.drawShape(graphic, pickContext, x, y, params, null, (context, arc3dAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked)), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
}

var __decorate$e = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$c = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$c = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasSymbolPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "symbol", this.numberType = SYMBOL_NUMBER_TYPE;
  }
  contains(symbol, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const parsedPath = symbol.getParsedPath();
    if (!pickContext.camera) {
      if (!symbol.AABBBounds.containsPoint(point)) return !1;
      if (parsedPath.isSvg || "imprecise" === symbol.attribute.pickMode) return !0;
    }
    pickContext.highPerformanceSave();
    const symbolAttribute = symbol.getGraphicTheme(),
      data = this.transform(symbol, symbolAttribute, pickContext),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    let pickPoint = point;
    if (pickContext.camera) {
      pickPoint = point.clone();
      const globalMatrix = symbol.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
    }
    this.canvasRenderer.z = z;
    let picked = !1;
    return this.canvasRenderer.drawShape(symbol, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => !!picked || (picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked), (context, symbolAttribute, themeAttribute) => {
      if (picked) return !0;
      const lineWidth = symbolAttribute.lineWidth || themeAttribute.lineWidth,
        pickStrokeBuffer = symbolAttribute.pickStrokeBuffer || themeAttribute.pickStrokeBuffer,
        keepStrokeScale = symbolAttribute.keepStrokeScale || themeAttribute.keepStrokeScale;
      return pickContext.lineWidth = keepStrokeScale ? lineWidth + pickStrokeBuffer : getScaledStroke(pickContext, lineWidth + pickStrokeBuffer, pickContext.dpr), picked = context.isPointInStroke(pickPoint.x, pickPoint.y), picked;
    }), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasSymbolPicker = __decorate$e([injectable(), __param$c(0, inject(SymbolRender)), __metadata$c("design:paramtypes", [Object])], DefaultCanvasSymbolPicker);

let loadSymbolPick = !1;
const symbolCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadSymbolPick || (loadSymbolPick = !0, bind(CanvasSymbolPicker).to(DefaultCanvasSymbolPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasSymbolPicker));
});

var __decorate$d = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$b = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$b = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasCirclePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "circle", this.numberType = CIRCLE_NUMBER_TYPE;
  }
};
DefaultCanvasCirclePicker = __decorate$d([injectable(), __param$b(0, inject(CircleRender)), __metadata$b("design:paramtypes", [Object])], DefaultCanvasCirclePicker);

let loadCirclePick = !1;
const circleCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadCirclePick || (loadCirclePick = !0, bind(CanvasCirclePicker).to(DefaultCanvasCirclePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasCirclePicker));
});

var __decorate$c = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$a = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$a = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasTextPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "text", this.numberType = TEXT_NUMBER_TYPE;
  }
  contains(text, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    if (!pickContext) return !1;
    const bounds = text.AABBBounds;
    if (!pickContext.camera) return !!bounds.containsPoint(point);
    pickContext.highPerformanceSave();
    const textAttribute = text.getGraphicTheme(),
      {
        keepDirIn3d = textAttribute.keepDirIn3d
      } = text.attribute,
      computed3dMatrix = !keepDirIn3d,
      data = this.transform(text, textAttribute, pickContext, computed3dMatrix),
      {
        x: x,
        y: y,
        z: z,
        lastModelMatrix: lastModelMatrix
      } = data;
    this.canvasRenderer.z = z;
    let pickPoint = point;
    if (pickContext.camera) {
      pickPoint = point.clone();
      const globalMatrix = text.parent.globalTransMatrix;
      pickPoint.x = globalMatrix.a * point.x + globalMatrix.c * point.y + globalMatrix.e, pickPoint.y = globalMatrix.b * point.x + globalMatrix.d * point.y + globalMatrix.f;
    }
    let picked = !1;
    return this.canvasRenderer.drawShape(text, pickContext, x, y, {}, null, (context, symbolAttribute, themeAttribute) => {
      if (picked) return !0;
      const {
          fontSize = textAttribute.fontSize,
          textBaseline = textAttribute.textBaseline,
          textAlign = textAttribute.textAlign
        } = text.attribute,
        bounds = text.AABBBounds,
        height = bounds.height(),
        width = bounds.width(),
        offsetY = textLayoutOffsetY(textBaseline, height, fontSize),
        offsetX = textDrawOffsetX(textAlign, width);
      return context.rect(offsetX + x, offsetY + y, width, height, z), picked = context.isPointInPath(pickPoint.x, pickPoint.y), picked;
    }, (context, symbolAttribute, themeAttribute) => picked), this.canvasRenderer.z = 0, pickContext.modelMatrix !== lastModelMatrix && mat4Allocate.free(pickContext.modelMatrix), pickContext.modelMatrix = lastModelMatrix, pickContext.highPerformanceRestore(), picked;
  }
};
DefaultCanvasTextPicker = __decorate$c([injectable(), __param$a(0, inject(TextRender)), __metadata$a("design:paramtypes", [Object])], DefaultCanvasTextPicker);

let loadTextPick = !1;
const textCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadTextPick || (loadTextPick = !0, bind(CanvasTextPicker).to(DefaultCanvasTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasTextPicker));
});

var __decorate$b = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$9 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$9 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPathPicker = class extends BaseLinePicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "path", this.numberType = PATH_NUMBER_TYPE;
  }
};
DefaultCanvasPathPicker = __decorate$b([injectable(), __param$9(0, inject(PathRender)), __metadata$9("design:paramtypes", [Object])], DefaultCanvasPathPicker);

let loadPathPick = !1;
const pathCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPathPick || (loadPathPick = !0, bind(CanvasPathPicker).to(DefaultCanvasPathPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPathPicker));
});

var __decorate$a = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$8 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$8 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPolygonPicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "polygon", this.numberType = POLYGON_NUMBER_TYPE;
  }
};
DefaultCanvasPolygonPicker = __decorate$a([injectable(), __param$8(0, inject(PolygonRender)), __metadata$8("design:paramtypes", [Object])], DefaultCanvasPolygonPicker);

let loadPolygonPick = !1;
const polygonCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPolygonPick || (loadPolygonPick = !0, bind(CanvasPolygonPicker).to(DefaultCanvasPolygonPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPolygonPicker));
});

var __decorate$9 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$7 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$7 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasGlyphPicker = class extends GlyphPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasGlyphPicker = __decorate$9([injectable(), __param$7(0, inject(GlyphRender)), __metadata$7("design:paramtypes", [Object])], DefaultCanvasGlyphPicker);

let loadGlyphPick = !1;
const glyphCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGlyphPick || (loadGlyphPick = !0, bind(CanvasGlyphPicker).to(DefaultCanvasGlyphPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGlyphPicker));
});

var __decorate$8 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$6 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$6 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasRichTextPicker = class {
  constructor(canvasRenderer) {
    this.canvasRenderer = canvasRenderer, this.type = "richtext", this.numberType = RICHTEXT_NUMBER_TYPE;
  }
  contains(richtext, point, params) {
    return !!richtext.AABBBounds.containsPoint(point);
  }
};
DefaultCanvasRichTextPicker = __decorate$8([injectable(), __param$6(0, inject(RichTextRender)), __metadata$6("design:paramtypes", [Object])], DefaultCanvasRichTextPicker);

let loadRichtextPick = !1;
const richtextCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRichtextPick || (loadRichtextPick = !0, bind(CanvasRichTextPicker).to(DefaultCanvasRichTextPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRichTextPicker));
});

var __decorate$7 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$5 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$5 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasImagePicker = class extends PickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "image", this.numberType = IMAGE_NUMBER_TYPE;
  }
};
DefaultCanvasImagePicker = __decorate$7([injectable(), __param$5(0, inject(ImageRender)), __metadata$5("design:paramtypes", [Object])], DefaultCanvasImagePicker);

let loadImagePick = !1;
const imageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadImagePick || (loadImagePick = !0, bind(CanvasImagePicker).to(DefaultCanvasImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasImagePicker));
});

var __decorate$6 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$4 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$4 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasRect3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "rect3d", this.numberType = RECT3D_NUMBER_TYPE, this.themeType = "rect";
  }
};
DefaultCanvasRect3dPicker = __decorate$6([injectable(), __param$4(0, inject(Rect3DRender)), __metadata$4("design:paramtypes", [Object])], DefaultCanvasRect3dPicker);

let loadRect3dPick = !1;
const rect3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadRect3dPick || (loadRect3dPick = !0, bind(CanvasRect3dPicker).to(DefaultCanvasRect3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasRect3dPicker));
});

var __decorate$5 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$3 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$3 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasArc3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "arc3d", this.numberType = ARC3D_NUMBER_TYPE, this.themeType = "arc";
  }
};
DefaultCanvasArc3dPicker = __decorate$5([injectable(), __param$3(0, inject(Arc3dRender)), __metadata$3("design:paramtypes", [Object])], DefaultCanvasArc3dPicker);

let loadArc3dPick = !1;
const arc3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadArc3dPick || (loadArc3dPick = !0, bind(CanvasArc3dPicker).to(DefaultCanvasArc3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasArc3dPicker));
});

var __decorate$4 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$2 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$2 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasPyramid3dPicker = class extends Base3dPicker {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer, this.type = "pyramid3d", this.numberType = PYRAMID3D_NUMBER_TYPE, this.themeType = "polygon";
  }
};
DefaultCanvasPyramid3dPicker = __decorate$4([injectable(), __param$2(0, inject(Pyramid3dRender)), __metadata$2("design:paramtypes", [Object])], DefaultCanvasPyramid3dPicker);

let loadPyramid3dPick = !1;
const pyramid3dCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadPyramid3dPick || (loadPyramid3dPick = !0, bind(CanvasPyramid3dPicker).to(DefaultCanvasPyramid3dPicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasPyramid3dPicker));
});

var lib$1 = {};

var gif = {};

var lib = {};

Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.loop = lib.conditional = lib.parse = void 0;
var parse = function parse(stream, schema) {
  var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var parent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : result;
  if (Array.isArray(schema)) {
    schema.forEach(function (partSchema) {
      return parse(stream, partSchema, result, parent);
    });
  } else if (typeof schema === 'function') {
    schema(stream, result, parent, parse);
  } else {
    var key = Object.keys(schema)[0];
    if (Array.isArray(schema[key])) {
      parent[key] = {};
      parse(stream, schema[key], result, parent[key]);
    } else {
      parent[key] = schema[key](stream, result, parent, parse);
    }
  }
  return result;
};
lib.parse = parse;
var conditional = function conditional(schema, conditionFunc) {
  return function (stream, result, parent, parse) {
    if (conditionFunc(stream, result, parent)) {
      parse(stream, schema, result, parent);
    }
  };
};
lib.conditional = conditional;
var loop = function loop(schema, continueFunc) {
  return function (stream, result, parent, parse) {
    var arr = [];
    var lastStreamPos = stream.pos;
    while (continueFunc(stream, result, parent)) {
      var newParent = {};
      parse(stream, schema, result, newParent); // cases when whole file is parsed but no termination is there and stream position is not getting updated as well
      // it falls into infinite recursion, null check to avoid the same

      if (stream.pos === lastStreamPos) {
        break;
      }
      lastStreamPos = stream.pos;
      arr.push(newParent);
    }
    return arr;
  };
};
lib.loop = loop;

var uint8 = {};

Object.defineProperty(uint8, "__esModule", {
  value: true
});
uint8.readBits = uint8.readArray = uint8.readUnsigned = uint8.readString = uint8.peekBytes = uint8.readBytes = uint8.peekByte = uint8.readByte = uint8.buildStream = void 0;

// Default stream and parsers for Uint8TypedArray data type
var buildStream = function buildStream(uint8Data) {
  return {
    data: uint8Data,
    pos: 0
  };
};
uint8.buildStream = buildStream;
var readByte = function readByte() {
  return function (stream) {
    return stream.data[stream.pos++];
  };
};
uint8.readByte = readByte;
var peekByte = function peekByte() {
  var offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return function (stream) {
    return stream.data[stream.pos + offset];
  };
};
uint8.peekByte = peekByte;
var readBytes = function readBytes(length) {
  return function (stream) {
    return stream.data.subarray(stream.pos, stream.pos += length);
  };
};
uint8.readBytes = readBytes;
var peekBytes = function peekBytes(length) {
  return function (stream) {
    return stream.data.subarray(stream.pos, stream.pos + length);
  };
};
uint8.peekBytes = peekBytes;
var readString = function readString(length) {
  return function (stream) {
    return Array.from(readBytes(length)(stream)).map(function (value) {
      return String.fromCharCode(value);
    }).join('');
  };
};
uint8.readString = readString;
var readUnsigned = function readUnsigned(littleEndian) {
  return function (stream) {
    var bytes = readBytes(2)(stream);
    return littleEndian ? (bytes[1] << 8) + bytes[0] : (bytes[0] << 8) + bytes[1];
  };
};
uint8.readUnsigned = readUnsigned;
var readArray = function readArray(byteSize, totalOrFunc) {
  return function (stream, result, parent) {
    var total = typeof totalOrFunc === 'function' ? totalOrFunc(stream, result, parent) : totalOrFunc;
    var parser = readBytes(byteSize);
    var arr = new Array(total);
    for (var i = 0; i < total; i++) {
      arr[i] = parser(stream);
    }
    return arr;
  };
};
uint8.readArray = readArray;
var subBitsTotal = function subBitsTotal(bits, startIndex, length) {
  var result = 0;
  for (var i = 0; i < length; i++) {
    result += bits[startIndex + i] && Math.pow(2, length - i - 1);
  }
  return result;
};
var readBits = function readBits(schema) {
  return function (stream) {
    var _byte = readByte()(stream); // convert the byte to bit array

    var bits = new Array(8);
    for (var i = 0; i < 8; i++) {
      bits[7 - i] = !!(_byte & 1 << i);
    } // convert the bit array to values based on the schema

    return Object.keys(schema).reduce(function (res, key) {
      var def = schema[key];
      if (def.length) {
        res[key] = subBitsTotal(bits, def.index, def.length);
      } else {
        res[key] = bits[def.index];
      }
      return res;
    }, {});
  };
};
uint8.readBits = readBits;

(function (exports) {

  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _ = lib;
  var _uint = uint8;

  // a set of 0x00 terminated subblocks
  var subBlocksSchema = {
    blocks: function blocks(stream) {
      var terminator = 0x00;
      var chunks = [];
      var streamSize = stream.data.length;
      var total = 0;
      for (var size = (0, _uint.readByte)()(stream); size !== terminator; size = (0, _uint.readByte)()(stream)) {
        // size becomes undefined for some case when file is corrupted and  terminator is not proper 
        // null check to avoid recursion
        if (!size) break; // catch corrupted files with no terminator

        if (stream.pos + size >= streamSize) {
          var availableSize = streamSize - stream.pos;
          chunks.push((0, _uint.readBytes)(availableSize)(stream));
          total += availableSize;
          break;
        }
        chunks.push((0, _uint.readBytes)(size)(stream));
        total += size;
      }
      var result = new Uint8Array(total);
      var offset = 0;
      for (var i = 0; i < chunks.length; i++) {
        result.set(chunks[i], offset);
        offset += chunks[i].length;
      }
      return result;
    }
  }; // global control extension

  var gceSchema = (0, _.conditional)({
    gce: [{
      codes: (0, _uint.readBytes)(2)
    }, {
      byteSize: (0, _uint.readByte)()
    }, {
      extras: (0, _uint.readBits)({
        future: {
          index: 0,
          length: 3
        },
        disposal: {
          index: 3,
          length: 3
        },
        userInput: {
          index: 6
        },
        transparentColorGiven: {
          index: 7
        }
      })
    }, {
      delay: (0, _uint.readUnsigned)(true)
    }, {
      transparentColorIndex: (0, _uint.readByte)()
    }, {
      terminator: (0, _uint.readByte)()
    }]
  }, function (stream) {
    var codes = (0, _uint.peekBytes)(2)(stream);
    return codes[0] === 0x21 && codes[1] === 0xf9;
  }); // image pipeline block

  var imageSchema = (0, _.conditional)({
    image: [{
      code: (0, _uint.readByte)()
    }, {
      descriptor: [{
        left: (0, _uint.readUnsigned)(true)
      }, {
        top: (0, _uint.readUnsigned)(true)
      }, {
        width: (0, _uint.readUnsigned)(true)
      }, {
        height: (0, _uint.readUnsigned)(true)
      }, {
        lct: (0, _uint.readBits)({
          exists: {
            index: 0
          },
          interlaced: {
            index: 1
          },
          sort: {
            index: 2
          },
          future: {
            index: 3,
            length: 2
          },
          size: {
            index: 5,
            length: 3
          }
        })
      }]
    }, (0, _.conditional)({
      lct: (0, _uint.readArray)(3, function (stream, result, parent) {
        return Math.pow(2, parent.descriptor.lct.size + 1);
      })
    }, function (stream, result, parent) {
      return parent.descriptor.lct.exists;
    }), {
      data: [{
        minCodeSize: (0, _uint.readByte)()
      }, subBlocksSchema]
    }]
  }, function (stream) {
    return (0, _uint.peekByte)()(stream) === 0x2c;
  }); // plain text block

  var textSchema = (0, _.conditional)({
    text: [{
      codes: (0, _uint.readBytes)(2)
    }, {
      blockSize: (0, _uint.readByte)()
    }, {
      preData: function preData(stream, result, parent) {
        return (0, _uint.readBytes)(parent.text.blockSize)(stream);
      }
    }, subBlocksSchema]
  }, function (stream) {
    var codes = (0, _uint.peekBytes)(2)(stream);
    return codes[0] === 0x21 && codes[1] === 0x01;
  }); // application block

  var applicationSchema = (0, _.conditional)({
    application: [{
      codes: (0, _uint.readBytes)(2)
    }, {
      blockSize: (0, _uint.readByte)()
    }, {
      id: function id(stream, result, parent) {
        return (0, _uint.readString)(parent.blockSize)(stream);
      }
    }, subBlocksSchema]
  }, function (stream) {
    var codes = (0, _uint.peekBytes)(2)(stream);
    return codes[0] === 0x21 && codes[1] === 0xff;
  }); // comment block

  var commentSchema = (0, _.conditional)({
    comment: [{
      codes: (0, _uint.readBytes)(2)
    }, subBlocksSchema]
  }, function (stream) {
    var codes = (0, _uint.peekBytes)(2)(stream);
    return codes[0] === 0x21 && codes[1] === 0xfe;
  });
  var schema = [{
    header: [{
      signature: (0, _uint.readString)(3)
    }, {
      version: (0, _uint.readString)(3)
    }]
  }, {
    lsd: [{
      width: (0, _uint.readUnsigned)(true)
    }, {
      height: (0, _uint.readUnsigned)(true)
    }, {
      gct: (0, _uint.readBits)({
        exists: {
          index: 0
        },
        resolution: {
          index: 1,
          length: 3
        },
        sort: {
          index: 4
        },
        size: {
          index: 5,
          length: 3
        }
      })
    }, {
      backgroundColorIndex: (0, _uint.readByte)()
    }, {
      pixelAspectRatio: (0, _uint.readByte)()
    }]
  }, (0, _.conditional)({
    gct: (0, _uint.readArray)(3, function (stream, result) {
      return Math.pow(2, result.lsd.gct.size + 1);
    })
  }, function (stream, result) {
    return result.lsd.gct.exists;
  }),
  // content frames
  {
    frames: (0, _.loop)([gceSchema, applicationSchema, commentSchema, imageSchema, textSchema], function (stream) {
      var nextCode = (0, _uint.peekByte)()(stream); // rather than check for a terminator, we should check for the existence
      // of an ext or image block to avoid infinite loops
      //var terminator = 0x3B;
      //return nextCode !== terminator;

      return nextCode === 0x21 || nextCode === 0x2c;
    })
  }];
  var _default = schema;
  exports["default"] = _default;
})(gif);

var deinterlace$1 = {};

Object.defineProperty(deinterlace$1, "__esModule", {
  value: true
});
deinterlace$1.deinterlace = void 0;

/**
 * Deinterlace function from https://github.com/shachaf/jsgif
 */
var deinterlace = function deinterlace(pixels, width) {
  var newPixels = new Array(pixels.length);
  var rows = pixels.length / width;
  var cpRow = function cpRow(toRow, fromRow) {
    var fromPixels = pixels.slice(fromRow * width, (fromRow + 1) * width);
    newPixels.splice.apply(newPixels, [toRow * width, width].concat(fromPixels));
  }; // See appendix E.

  var offsets = [0, 4, 2, 1];
  var steps = [8, 8, 4, 2];
  var fromRow = 0;
  for (var pass = 0; pass < 4; pass++) {
    for (var toRow = offsets[pass]; toRow < rows; toRow += steps[pass]) {
      cpRow(toRow, fromRow);
      fromRow++;
    }
  }
  return newPixels;
};
deinterlace$1.deinterlace = deinterlace;

var lzw$1 = {};

Object.defineProperty(lzw$1, "__esModule", {
  value: true
});
lzw$1.lzw = void 0;

/**
 * javascript port of java LZW decompression
 * Original java author url: https://gist.github.com/devunwired/4479231
 */
var lzw = function lzw(minCodeSize, data, pixelCount) {
  var MAX_STACK_SIZE = 4096;
  var nullCode = -1;
  var npix = pixelCount;
  var available, clear, code_mask, code_size, end_of_information, in_code, old_code, bits, code, i, datum, data_size, first, top, bi, pi;
  var dstPixels = new Array(pixelCount);
  var prefix = new Array(MAX_STACK_SIZE);
  var suffix = new Array(MAX_STACK_SIZE);
  var pixelStack = new Array(MAX_STACK_SIZE + 1); // Initialize GIF data stream decoder.

  data_size = minCodeSize;
  clear = 1 << data_size;
  end_of_information = clear + 1;
  available = clear + 2;
  old_code = nullCode;
  code_size = data_size + 1;
  code_mask = (1 << code_size) - 1;
  for (code = 0; code < clear; code++) {
    prefix[code] = 0;
    suffix[code] = code;
  } // Decode GIF pixel stream.

  var datum, bits, first, top, pi, bi;
  datum = bits = first = top = pi = bi = 0;
  for (i = 0; i < npix;) {
    if (top === 0) {
      if (bits < code_size) {
        // get the next byte
        datum += data[bi] << bits;
        bits += 8;
        bi++;
        continue;
      } // Get the next code.

      code = datum & code_mask;
      datum >>= code_size;
      bits -= code_size; // Interpret the code

      if (code > available || code == end_of_information) {
        break;
      }
      if (code == clear) {
        // Reset decoder.
        code_size = data_size + 1;
        code_mask = (1 << code_size) - 1;
        available = clear + 2;
        old_code = nullCode;
        continue;
      }
      if (old_code == nullCode) {
        pixelStack[top++] = suffix[code];
        old_code = code;
        first = code;
        continue;
      }
      in_code = code;
      if (code == available) {
        pixelStack[top++] = first;
        code = old_code;
      }
      while (code > clear) {
        pixelStack[top++] = suffix[code];
        code = prefix[code];
      }
      first = suffix[code] & 0xff;
      pixelStack[top++] = first; // add a new string to the table, but only if space is available
      // if not, just continue with current table until a clear code is found
      // (deferred clear code implementation as per GIF spec)

      if (available < MAX_STACK_SIZE) {
        prefix[available] = old_code;
        suffix[available] = first;
        available++;
        if ((available & code_mask) === 0 && available < MAX_STACK_SIZE) {
          code_size++;
          code_mask += available;
        }
      }
      old_code = in_code;
    } // Pop a pixel off the pixel stack.

    top--;
    dstPixels[pi++] = pixelStack[top];
    i++;
  }
  for (i = pi; i < npix; i++) {
    dstPixels[i] = 0; // clear missing pixels
  }

  return dstPixels;
};
lzw$1.lzw = lzw;

Object.defineProperty(lib$1, "__esModule", {
  value: true
});
var decompressFrames_1 = lib$1.decompressFrames = lib$1.decompressFrame = parseGIF_1 = lib$1.parseGIF = void 0;
var _gif = _interopRequireDefault(gif);
var _jsBinarySchemaParser = lib;
var _uint = uint8;
var _deinterlace = deinterlace$1;
var _lzw = lzw$1;
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}
var parseGIF = function parseGIF(arrayBuffer) {
  var byteData = new Uint8Array(arrayBuffer);
  return (0, _jsBinarySchemaParser.parse)((0, _uint.buildStream)(byteData), _gif["default"]);
};
var parseGIF_1 = lib$1.parseGIF = parseGIF;
var generatePatch = function generatePatch(image) {
  var totalPixels = image.pixels.length;
  var patchData = new Uint8ClampedArray(totalPixels * 4);
  for (var i = 0; i < totalPixels; i++) {
    var pos = i * 4;
    var colorIndex = image.pixels[i];
    var color = image.colorTable[colorIndex] || [0, 0, 0];
    patchData[pos] = color[0];
    patchData[pos + 1] = color[1];
    patchData[pos + 2] = color[2];
    patchData[pos + 3] = colorIndex !== image.transparentIndex ? 255 : 0;
  }
  return patchData;
};
var decompressFrame = function decompressFrame(frame, gct, buildImagePatch) {
  if (!frame.image) {
    console.warn('gif frame does not have associated image.');
    return;
  }
  var image = frame.image; // get the number of pixels

  var totalPixels = image.descriptor.width * image.descriptor.height; // do lzw decompression

  var pixels = (0, _lzw.lzw)(image.data.minCodeSize, image.data.blocks, totalPixels); // deal with interlacing if necessary

  if (image.descriptor.lct.interlaced) {
    pixels = (0, _deinterlace.deinterlace)(pixels, image.descriptor.width);
  }
  var resultImage = {
    pixels: pixels,
    dims: {
      top: frame.image.descriptor.top,
      left: frame.image.descriptor.left,
      width: frame.image.descriptor.width,
      height: frame.image.descriptor.height
    }
  }; // color table

  if (image.descriptor.lct && image.descriptor.lct.exists) {
    resultImage.colorTable = image.lct;
  } else {
    resultImage.colorTable = gct;
  } // add per frame relevant gce information

  if (frame.gce) {
    resultImage.delay = (frame.gce.delay || 10) * 10; // convert to ms

    resultImage.disposalType = frame.gce.extras.disposal; // transparency

    if (frame.gce.extras.transparentColorGiven) {
      resultImage.transparentIndex = frame.gce.transparentColorIndex;
    }
  } // create canvas usable imagedata if desired

  if (buildImagePatch) {
    resultImage.patch = generatePatch(resultImage);
  }
  return resultImage;
};
lib$1.decompressFrame = decompressFrame;
var decompressFrames = function decompressFrames(parsedGif, buildImagePatches) {
  return parsedGif.frames.filter(function (f) {
    return f.image;
  }).map(function (f) {
    return decompressFrame(f, parsedGif.gct, buildImagePatches);
  });
};
decompressFrames_1 = lib$1.decompressFrames = decompressFrames;

const GIFIMAGE_NUMBER_TYPE = Generator.GenAutoIncrementId();
const LOTTIE_NUMBER_TYPE = Generator.GenAutoIncrementId();

class GifImage extends Image$1 {
  constructor(params) {
    super(params), this.type = "gif-image", this.numberType = GIFIMAGE_NUMBER_TYPE, this.loadGif();
  }
  loadGif() {
    if (isString$1(this.attribute.gifImage)) ResourceLoader.GetFile(this.attribute.gifImage, "arrayBuffer").then(res => {
      const gif = parseGIF_1(res),
        frames = decompressFrames_1(gif, !0);
      this.renderGIF(frames);
    }).catch(e => {
      console.error("Gif load error: ", e);
    });else if (this.attribute.gifImage instanceof ArrayBuffer) {
      const gif = parseGIF_1(this.attribute.gifImage),
        frames = decompressFrames_1(gif, !0);
      this.renderGIF(frames);
    }
  }
  renderGIF(frames) {
    this.loadedFrames = frames, this.frameIndex = 0, this.tempCanvas || (this.tempCanvas = application.global.createCanvas({}), this.tempCtx = this.tempCanvas.getContext("2d")), this.gifCanvas || (this.gifCanvas = application.global.createCanvas({}), this.gifCtx = this.gifCanvas.getContext("2d")), this.gifCanvas.width = frames[0].dims.width, this.gifCanvas.height = frames[0].dims.height, this.playing = !0, this.lastTime = new Date().getTime();
    const animation = this.animate();
    this.attribute.timeline && animation.setTimeline(this.attribute.timeline), animation.to({}, 1e3, "linear").loop(1 / 0);
  }
  renderFrame(context, x, y) {
    const frame = this.loadedFrames[this.frameIndex || 0];
    2 === frame.disposalType && this.gifCtx.clearRect(0, 0, this.gifCanvas.width, this.gifCanvas.height), this.drawPatch(frame), this.manipulate(context, x, y);
    const diff = new Date().getTime() - this.lastTime;
    frame.delay < diff && (this.frameIndex++, this.lastTime = new Date().getTime()), this.frameIndex >= this.loadedFrames.length && (this.frameIndex = 0);
  }
  drawPatch(frame) {
    const dims = frame.dims;
    this.frameImageData && dims.width === this.frameImageData.width && dims.height === this.frameImageData.height || (this.tempCanvas.width = dims.width, this.tempCanvas.height = dims.height, this.frameImageData = this.tempCtx.createImageData(dims.width, dims.height)), this.frameImageData.data.set(frame.patch), this.tempCtx.putImageData(this.frameImageData, 0, 0), this.gifCtx.drawImage(this.tempCanvas, dims.left, dims.top);
  }
  manipulate(context, x, y) {
    context.drawImage(this.gifCanvas, 0, 0, this.gifCanvas.width, this.gifCanvas.height, x, y, this.attribute.width, this.attribute.height);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    super.setAttribute(key, value, forceUpdateTag, context), "gifImage" === key && this.loadGif();
  }
  setAttributes(params, forceUpdateTag, context) {
    super.setAttributes(params, forceUpdateTag, context), params.gifImage && this.loadGif();
  }
}
function createGifImage(attributes) {
  return new GifImage(attributes);
}

var __decorate$3 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultCanvasGifImagePicker = class {
  constructor() {
    this.type = "gif-image", this.numberType = GIFIMAGE_NUMBER_TYPE;
  }
  contains(gifImage, point, params) {
    const {
      pickContext: pickContext
    } = null != params ? params : {};
    return !!pickContext && !!gifImage.AABBBounds.containsPoint(point);
  }
};
DefaultCanvasGifImagePicker = __decorate$3([injectable()], DefaultCanvasGifImagePicker);

let loadGifImagePick = !1;
const gifImageCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadGifImagePick || (loadGifImagePick = !0, bind(CanvasGifImagePicker).to(DefaultCanvasGifImagePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasGifImagePicker));
});

var __decorate$2 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata$1 = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param$1 = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasGifImageRender = class extends DefaultCanvasImageRender {
  constructor(imageRenderContribitions) {
    super(imageRenderContribitions), this.imageRenderContribitions = imageRenderContribitions, this.numberType = GIFIMAGE_NUMBER_TYPE, this._renderContribitions = void 0, this.builtinContributions = [defaultGifImageRenderContribution], this.init(imageRenderContribitions);
  }
  drawShape(image, context, x, y, drawContext, params, fillCb, strokeCb) {
    const imageAttribute = getTheme(image).image,
      {
        x: originX = imageAttribute.x,
        y: originY = imageAttribute.y,
        fillStrokeOrder = imageAttribute.fillStrokeOrder
      } = image.attribute,
      data = this.valid(image, imageAttribute, fillCb);
    if (!data) return;
    const {
        fVisible: fVisible,
        sVisible: sVisible,
        doFill: doFill,
        doStroke: doStroke
      } = data,
      _runFill = () => {
        doFill && fillCb && fillCb(context, image.attribute, imageAttribute);
      },
      _runStroke = () => {
        doStroke && (strokeCb ? strokeCb(context, image.attribute, imageAttribute) : sVisible && (context.setStrokeStyle(image, image.attribute, originX - x, originY - y, imageAttribute), context.stroke()));
      };
    fillStrokeOrder ? (_runStroke(), context.save(), context.clip(), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), context.restore()) : (context.save(), context.clip(), this.beforeRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb), _runFill(), context.restore(), _runStroke()), this.afterRenderStep(image, context, x, y, doFill, !1, fVisible, !1, imageAttribute, drawContext, fillCb);
  }
  draw(image, renderService, drawContext) {
    const {
      context: context
    } = renderService.drawParams;
    if (!context) return;
    const imageAttribute = getTheme(image).image;
    this._draw(image, imageAttribute, !1, drawContext);
  }
};
DefaultCanvasGifImageRender = __decorate$2([injectable(), __param$1(0, inject(ContributionProvider)), __param$1(0, named(ImageRenderContribution)), __metadata$1("design:paramtypes", [Object])], DefaultCanvasGifImageRender);
class DefaultGifImageRenderContribution extends DefaultRectRenderContribution {
  constructor() {
    super(...arguments), this.time = BaseRenderContributionTime.afterFillStroke, this.useStyle = !0, this.order = 0;
  }
  drawShape(image, context, x, y, doFill, doStroke, fVisible, sVisible, rectAttribute, drawContext, fillCb, strokeCb) {
    image.renderFrame && image.playing && image.renderFrame(context, x, y);
  }
}
const defaultGifImageRenderContribution = new DefaultGifImageRenderContribution();

let loadGifImageModule = !1;
const gifImageModule = new ContainerModule(bind => {
  loadGifImageModule || (loadGifImageModule = !0, bind(DefaultCanvasGifImageRender).toSelf().inSingletonScope(), bind(GraphicRender).toService(DefaultCanvasGifImageRender));
});

var lottie = {exports: {}};

(function(module,exports){typeof navigator!=="undefined"&&function(global,factory){module.exports=factory();}(commonjsGlobal,function(){var svgNS='http://www.w3.org/2000/svg';var locationHref='';var _useWebWorker=false;var initialDefaultFrame=-999999;var setWebWorker=function setWebWorker(flag){_useWebWorker=!!flag;};var getWebWorker=function getWebWorker(){return _useWebWorker;};var setLocationHref=function setLocationHref(value){locationHref=value;};var getLocationHref=function getLocationHref(){return locationHref;};function createTag(type){// return {appendChild:function(){},setAttribute:function(){},style:{}}
return document.createElement(type);}function extendPrototype(sources,destination){var i;var len=sources.length;var sourcePrototype;for(i=0;i<len;i+=1){sourcePrototype=sources[i].prototype;for(var attr in sourcePrototype){if(Object.prototype.hasOwnProperty.call(sourcePrototype,attr))destination.prototype[attr]=sourcePrototype[attr];}}}function getDescriptor(object,prop){return Object.getOwnPropertyDescriptor(object,prop);}function createProxyFunction(prototype){function ProxyFunction(){}ProxyFunction.prototype=prototype;return ProxyFunction;}// import Howl from '../../3rd_party/howler';
var audioControllerFactory=function(){function AudioController(audioFactory){this.audios=[];this.audioFactory=audioFactory;this._volume=1;this._isMuted=false;}AudioController.prototype={addAudio:function addAudio(audio){this.audios.push(audio);},pause:function pause(){var i;var len=this.audios.length;for(i=0;i<len;i+=1){this.audios[i].pause();}},resume:function resume(){var i;var len=this.audios.length;for(i=0;i<len;i+=1){this.audios[i].resume();}},setRate:function setRate(rateValue){var i;var len=this.audios.length;for(i=0;i<len;i+=1){this.audios[i].setRate(rateValue);}},createAudio:function createAudio(assetPath){if(this.audioFactory){return this.audioFactory(assetPath);}if(window.Howl){return new window.Howl({src:[assetPath]});}return {isPlaying:false,play:function play(){this.isPlaying=true;},seek:function seek(){this.isPlaying=false;},playing:function playing(){},rate:function rate(){},setVolume:function setVolume(){}};},setAudioFactory:function setAudioFactory(audioFactory){this.audioFactory=audioFactory;},setVolume:function setVolume(value){this._volume=value;this._updateVolume();},mute:function mute(){this._isMuted=true;this._updateVolume();},unmute:function unmute(){this._isMuted=false;this._updateVolume();},getVolume:function getVolume(){return this._volume;},_updateVolume:function _updateVolume(){var i;var len=this.audios.length;for(i=0;i<len;i+=1){this.audios[i].volume(this._volume*(this._isMuted?0:1));}}};return function(){return new AudioController();};}();var createTypedArray=function(){function createRegularArray(type,len){var i=0;var arr=[];var value;switch(type){case'int16':case'uint8c':value=1;break;default:value=1.1;break;}for(i=0;i<len;i+=1){arr.push(value);}return arr;}function createTypedArrayFactory(type,len){if(type==='float32'){return new Float32Array(len);}if(type==='int16'){return new Int16Array(len);}if(type==='uint8c'){return new Uint8ClampedArray(len);}return createRegularArray(type,len);}if(typeof Uint8ClampedArray==='function'&&typeof Float32Array==='function'){return createTypedArrayFactory;}return createRegularArray;}();function createSizedArray(len){return Array.apply(null,{length:len});}function _typeof$6(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof$6=function _typeof(obj){return typeof obj;};}else {_typeof$6=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof$6(obj);}var subframeEnabled=true;var expressionsPlugin=null;var expressionsInterfaces=null;var idPrefix$1='';var isSafari=/^((?!chrome|android).)*safari/i.test(navigator.userAgent);var bmPow=Math.pow;var bmSqrt=Math.sqrt;var bmFloor=Math.floor;var bmMax=Math.max;var bmMin=Math.min;var BMMath={};(function(){var propertyNames=['abs','acos','acosh','asin','asinh','atan','atanh','atan2','ceil','cbrt','expm1','clz32','cos','cosh','exp','floor','fround','hypot','imul','log','log1p','log2','log10','max','min','pow','random','round','sign','sin','sinh','sqrt','tan','tanh','trunc','E','LN10','LN2','LOG10E','LOG2E','PI','SQRT1_2','SQRT2'];var i;var len=propertyNames.length;for(i=0;i<len;i+=1){BMMath[propertyNames[i]]=Math[propertyNames[i]];}})();BMMath.random=Math.random;BMMath.abs=function(val){var tOfVal=_typeof$6(val);if(tOfVal==='object'&&val.length){var absArr=createSizedArray(val.length);var i;var len=val.length;for(i=0;i<len;i+=1){absArr[i]=Math.abs(val[i]);}return absArr;}return Math.abs(val);};var defaultCurveSegments=150;var degToRads=Math.PI/180;var roundCorner=0.5519;function styleDiv(element){element.style.position='absolute';element.style.top=0;element.style.left=0;element.style.display='block';element.style.transformOrigin='0 0';element.style.webkitTransformOrigin='0 0';element.style.backfaceVisibility='visible';element.style.webkitBackfaceVisibility='visible';element.style.transformStyle='preserve-3d';element.style.webkitTransformStyle='preserve-3d';element.style.mozTransformStyle='preserve-3d';}function BMEnterFrameEvent(type,currentTime,totalTime,frameMultiplier){this.type=type;this.currentTime=currentTime;this.totalTime=totalTime;this.direction=frameMultiplier<0?-1:1;}function BMCompleteEvent(type,frameMultiplier){this.type=type;this.direction=frameMultiplier<0?-1:1;}function BMCompleteLoopEvent(type,totalLoops,currentLoop,frameMultiplier){this.type=type;this.currentLoop=currentLoop;this.totalLoops=totalLoops;this.direction=frameMultiplier<0?-1:1;}function BMSegmentStartEvent(type,firstFrame,totalFrames){this.type=type;this.firstFrame=firstFrame;this.totalFrames=totalFrames;}function BMDestroyEvent(type,target){this.type=type;this.target=target;}function BMRenderFrameErrorEvent(nativeError,currentTime){this.type='renderFrameError';this.nativeError=nativeError;this.currentTime=currentTime;}function BMConfigErrorEvent(nativeError){this.type='configError';this.nativeError=nativeError;}var createElementID=function(){var _count=0;return function createID(){_count+=1;return idPrefix$1+'__lottie_element_'+_count;};}();function HSVtoRGB(h,s,v){var r;var g;var b;var i;var f;var p;var q;var t;i=Math.floor(h*6);f=h*6-i;p=v*(1-s);q=v*(1-f*s);t=v*(1-(1-f)*s);switch(i%6){case 0:r=v;g=t;b=p;break;case 1:r=q;g=v;b=p;break;case 2:r=p;g=v;b=t;break;case 3:r=p;g=q;b=v;break;case 4:r=t;g=p;b=v;break;case 5:r=v;g=p;b=q;break;}return [r,g,b];}function RGBtoHSV(r,g,b){var max=Math.max(r,g,b);var min=Math.min(r,g,b);var d=max-min;var h;var s=max===0?0:d/max;var v=max/255;switch(max){case min:h=0;break;case r:h=g-b+d*(g<b?6:0);h/=6*d;break;case g:h=b-r+d*2;h/=6*d;break;case b:h=r-g+d*4;h/=6*d;break;}return [h,s,v];}function addSaturationToRGB(color,offset){var hsv=RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);hsv[1]+=offset;if(hsv[1]>1){hsv[1]=1;}else if(hsv[1]<=0){hsv[1]=0;}return HSVtoRGB(hsv[0],hsv[1],hsv[2]);}function addBrightnessToRGB(color,offset){var hsv=RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);hsv[2]+=offset;if(hsv[2]>1){hsv[2]=1;}else if(hsv[2]<0){hsv[2]=0;}return HSVtoRGB(hsv[0],hsv[1],hsv[2]);}function addHueToRGB(color,offset){var hsv=RGBtoHSV(color[0]*255,color[1]*255,color[2]*255);hsv[0]+=offset/360;if(hsv[0]>1){hsv[0]-=1;}else if(hsv[0]<0){hsv[0]+=1;}return HSVtoRGB(hsv[0],hsv[1],hsv[2]);}var rgbToHex=function(){var colorMap=[];var i;var hex;for(i=0;i<256;i+=1){hex=i.toString(16);colorMap[i]=hex.length===1?'0'+hex:hex;}return function(r,g,b){if(r<0){r=0;}if(g<0){g=0;}if(b<0){b=0;}return '#'+colorMap[r]+colorMap[g]+colorMap[b];};}();var setSubframeEnabled=function setSubframeEnabled(flag){subframeEnabled=!!flag;};var getSubframeEnabled=function getSubframeEnabled(){return subframeEnabled;};var setExpressionsPlugin=function setExpressionsPlugin(value){expressionsPlugin=value;};var getExpressionsPlugin=function getExpressionsPlugin(){return expressionsPlugin;};var setExpressionInterfaces=function setExpressionInterfaces(value){expressionsInterfaces=value;};var getExpressionInterfaces=function getExpressionInterfaces(){return expressionsInterfaces;};var setDefaultCurveSegments=function setDefaultCurveSegments(value){defaultCurveSegments=value;};var getDefaultCurveSegments=function getDefaultCurveSegments(){return defaultCurveSegments;};var setIdPrefix=function setIdPrefix(value){idPrefix$1=value;};function createNS(type){// return {appendChild:function(){},setAttribute:function(){},style:{}}
return document.createElementNS(svgNS,type);}function _typeof$5(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof$5=function _typeof(obj){return typeof obj;};}else {_typeof$5=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof$5(obj);}var dataManager=function(){var _counterId=1;var processes=[];var workerFn;var workerInstance;var workerProxy={onmessage:function onmessage(){},postMessage:function postMessage(path){workerFn({data:path});}};var _workerSelf={postMessage:function postMessage(data){workerProxy.onmessage({data:data});}};function createWorker(fn){if(window.Worker&&window.Blob&&getWebWorker()){var blob=new Blob(['var _workerSelf = self; self.onmessage = ',fn.toString()],{type:'text/javascript'});// var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });
var url=URL.createObjectURL(blob);return new Worker(url);}workerFn=fn;return workerProxy;}function setupWorker(){if(!workerInstance){workerInstance=createWorker(function workerStart(e){function dataFunctionManager(){function completeLayers(layers,comps){var layerData;var i;var len=layers.length;var j;var jLen;var k;var kLen;for(i=0;i<len;i+=1){layerData=layers[i];if('ks'in layerData&&!layerData.completed){layerData.completed=true;if(layerData.hasMask){var maskProps=layerData.masksProperties;jLen=maskProps.length;for(j=0;j<jLen;j+=1){if(maskProps[j].pt.k.i){convertPathsToAbsoluteValues(maskProps[j].pt.k);}else {kLen=maskProps[j].pt.k.length;for(k=0;k<kLen;k+=1){if(maskProps[j].pt.k[k].s){convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);}if(maskProps[j].pt.k[k].e){convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);}}}}}if(layerData.ty===0){layerData.layers=findCompLayers(layerData.refId,comps);completeLayers(layerData.layers,comps);}else if(layerData.ty===4){completeShapes(layerData.shapes);}else if(layerData.ty===5){completeText(layerData);}}}}function completeChars(chars,assets){if(chars){var i=0;var len=chars.length;for(i=0;i<len;i+=1){if(chars[i].t===1){// var compData = findComp(chars[i].data.refId, assets);
chars[i].data.layers=findCompLayers(chars[i].data.refId,assets);// chars[i].data.ip = 0;
// chars[i].data.op = 99999;
// chars[i].data.st = 0;
// chars[i].data.sr = 1;
// chars[i].w = compData.w;
// chars[i].data.ks = {
//   a: { k: [0, 0, 0], a: 0 },
//   p: { k: [0, -compData.h, 0], a: 0 },
//   r: { k: 0, a: 0 },
//   s: { k: [100, 100], a: 0 },
//   o: { k: 100, a: 0 },
// };
completeLayers(chars[i].data.layers,assets);}}}}function findComp(id,comps){var i=0;var len=comps.length;while(i<len){if(comps[i].id===id){return comps[i];}i+=1;}return null;}function findCompLayers(id,comps){var comp=findComp(id,comps);if(comp){if(!comp.layers.__used){comp.layers.__used=true;return comp.layers;}return JSON.parse(JSON.stringify(comp.layers));}return null;}function completeShapes(arr){var i;var len=arr.length;var j;var jLen;for(i=len-1;i>=0;i-=1){if(arr[i].ty==='sh'){if(arr[i].ks.k.i){convertPathsToAbsoluteValues(arr[i].ks.k);}else {jLen=arr[i].ks.k.length;for(j=0;j<jLen;j+=1){if(arr[i].ks.k[j].s){convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);}if(arr[i].ks.k[j].e){convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);}}}}else if(arr[i].ty==='gr'){completeShapes(arr[i].it);}}}function convertPathsToAbsoluteValues(path){var i;var len=path.i.length;for(i=0;i<len;i+=1){path.i[i][0]+=path.v[i][0];path.i[i][1]+=path.v[i][1];path.o[i][0]+=path.v[i][0];path.o[i][1]+=path.v[i][1];}}function checkVersion(minimum,animVersionString){var animVersion=animVersionString?animVersionString.split('.'):[100,100,100];if(minimum[0]>animVersion[0]){return true;}if(animVersion[0]>minimum[0]){return false;}if(minimum[1]>animVersion[1]){return true;}if(animVersion[1]>minimum[1]){return false;}if(minimum[2]>animVersion[2]){return true;}if(animVersion[2]>minimum[2]){return false;}return null;}var checkText=function(){var minimumVersion=[4,4,14];function updateTextLayer(textLayer){var documentData=textLayer.t.d;textLayer.t.d={k:[{s:documentData,t:0}]};}function iterateLayers(layers){var i;var len=layers.length;for(i=0;i<len;i+=1){if(layers[i].ty===5){updateTextLayer(layers[i]);}}}return function(animationData){if(checkVersion(minimumVersion,animationData.v)){iterateLayers(animationData.layers);if(animationData.assets){var i;var len=animationData.assets.length;for(i=0;i<len;i+=1){if(animationData.assets[i].layers){iterateLayers(animationData.assets[i].layers);}}}}};}();var checkChars=function(){var minimumVersion=[4,7,99];return function(animationData){if(animationData.chars&&!checkVersion(minimumVersion,animationData.v)){var i;var len=animationData.chars.length;for(i=0;i<len;i+=1){var charData=animationData.chars[i];if(charData.data&&charData.data.shapes){completeShapes(charData.data.shapes);charData.data.ip=0;charData.data.op=99999;charData.data.st=0;charData.data.sr=1;charData.data.ks={p:{k:[0,0],a:0},s:{k:[100,100],a:0},a:{k:[0,0],a:0},r:{k:0,a:0},o:{k:100,a:0}};if(!animationData.chars[i].t){charData.data.shapes.push({ty:'no'});charData.data.shapes[0].it.push({p:{k:[0,0],a:0},s:{k:[100,100],a:0},a:{k:[0,0],a:0},r:{k:0,a:0},o:{k:100,a:0},sk:{k:0,a:0},sa:{k:0,a:0},ty:'tr'});}}}}};}();var checkPathProperties=function(){var minimumVersion=[5,7,15];function updateTextLayer(textLayer){var pathData=textLayer.t.p;if(typeof pathData.a==='number'){pathData.a={a:0,k:pathData.a};}if(typeof pathData.p==='number'){pathData.p={a:0,k:pathData.p};}if(typeof pathData.r==='number'){pathData.r={a:0,k:pathData.r};}}function iterateLayers(layers){var i;var len=layers.length;for(i=0;i<len;i+=1){if(layers[i].ty===5){updateTextLayer(layers[i]);}}}return function(animationData){if(checkVersion(minimumVersion,animationData.v)){iterateLayers(animationData.layers);if(animationData.assets){var i;var len=animationData.assets.length;for(i=0;i<len;i+=1){if(animationData.assets[i].layers){iterateLayers(animationData.assets[i].layers);}}}}};}();var checkColors=function(){var minimumVersion=[4,1,9];function iterateShapes(shapes){var i;var len=shapes.length;var j;var jLen;for(i=0;i<len;i+=1){if(shapes[i].ty==='gr'){iterateShapes(shapes[i].it);}else if(shapes[i].ty==='fl'||shapes[i].ty==='st'){if(shapes[i].c.k&&shapes[i].c.k[0].i){jLen=shapes[i].c.k.length;for(j=0;j<jLen;j+=1){if(shapes[i].c.k[j].s){shapes[i].c.k[j].s[0]/=255;shapes[i].c.k[j].s[1]/=255;shapes[i].c.k[j].s[2]/=255;shapes[i].c.k[j].s[3]/=255;}if(shapes[i].c.k[j].e){shapes[i].c.k[j].e[0]/=255;shapes[i].c.k[j].e[1]/=255;shapes[i].c.k[j].e[2]/=255;shapes[i].c.k[j].e[3]/=255;}}}else {shapes[i].c.k[0]/=255;shapes[i].c.k[1]/=255;shapes[i].c.k[2]/=255;shapes[i].c.k[3]/=255;}}}}function iterateLayers(layers){var i;var len=layers.length;for(i=0;i<len;i+=1){if(layers[i].ty===4){iterateShapes(layers[i].shapes);}}}return function(animationData){if(checkVersion(minimumVersion,animationData.v)){iterateLayers(animationData.layers);if(animationData.assets){var i;var len=animationData.assets.length;for(i=0;i<len;i+=1){if(animationData.assets[i].layers){iterateLayers(animationData.assets[i].layers);}}}}};}();var checkShapes=function(){var minimumVersion=[4,4,18];function completeClosingShapes(arr){var i;var len=arr.length;var j;var jLen;for(i=len-1;i>=0;i-=1){if(arr[i].ty==='sh'){if(arr[i].ks.k.i){arr[i].ks.k.c=arr[i].closed;}else {jLen=arr[i].ks.k.length;for(j=0;j<jLen;j+=1){if(arr[i].ks.k[j].s){arr[i].ks.k[j].s[0].c=arr[i].closed;}if(arr[i].ks.k[j].e){arr[i].ks.k[j].e[0].c=arr[i].closed;}}}}else if(arr[i].ty==='gr'){completeClosingShapes(arr[i].it);}}}function iterateLayers(layers){var layerData;var i;var len=layers.length;var j;var jLen;var k;var kLen;for(i=0;i<len;i+=1){layerData=layers[i];if(layerData.hasMask){var maskProps=layerData.masksProperties;jLen=maskProps.length;for(j=0;j<jLen;j+=1){if(maskProps[j].pt.k.i){maskProps[j].pt.k.c=maskProps[j].cl;}else {kLen=maskProps[j].pt.k.length;for(k=0;k<kLen;k+=1){if(maskProps[j].pt.k[k].s){maskProps[j].pt.k[k].s[0].c=maskProps[j].cl;}if(maskProps[j].pt.k[k].e){maskProps[j].pt.k[k].e[0].c=maskProps[j].cl;}}}}}if(layerData.ty===4){completeClosingShapes(layerData.shapes);}}}return function(animationData){if(checkVersion(minimumVersion,animationData.v)){iterateLayers(animationData.layers);if(animationData.assets){var i;var len=animationData.assets.length;for(i=0;i<len;i+=1){if(animationData.assets[i].layers){iterateLayers(animationData.assets[i].layers);}}}}};}();function completeData(animationData){if(animationData.__complete){return;}checkColors(animationData);checkText(animationData);checkChars(animationData);checkPathProperties(animationData);checkShapes(animationData);completeLayers(animationData.layers,animationData.assets);completeChars(animationData.chars,animationData.assets);animationData.__complete=true;}function completeText(data){if(data.t.a.length===0&&!('m'in data.t.p));}var moduleOb={};moduleOb.completeData=completeData;moduleOb.checkColors=checkColors;moduleOb.checkChars=checkChars;moduleOb.checkPathProperties=checkPathProperties;moduleOb.checkShapes=checkShapes;moduleOb.completeLayers=completeLayers;return moduleOb;}if(!_workerSelf.dataManager){_workerSelf.dataManager=dataFunctionManager();}if(!_workerSelf.assetLoader){_workerSelf.assetLoader=function(){function formatResponse(xhr){// using typeof doubles the time of execution of this method,
// so if available, it's better to use the header to validate the type
var contentTypeHeader=xhr.getResponseHeader('content-type');if(contentTypeHeader&&xhr.responseType==='json'&&contentTypeHeader.indexOf('json')!==-1){return xhr.response;}if(xhr.response&&_typeof$5(xhr.response)==='object'){return xhr.response;}if(xhr.response&&typeof xhr.response==='string'){return JSON.parse(xhr.response);}if(xhr.responseText){return JSON.parse(xhr.responseText);}return null;}function loadAsset(path,fullPath,callback,errorCallback){var response;var xhr=new XMLHttpRequest();// set responseType after calling open or IE will break.
try{// This crashes on Android WebView prior to KitKat
xhr.responseType='json';}catch(err){}// eslint-disable-line no-empty
xhr.onreadystatechange=function(){if(xhr.readyState===4){if(xhr.status===200){response=formatResponse(xhr);callback(response);}else {try{response=formatResponse(xhr);callback(response);}catch(err){if(errorCallback){errorCallback(err);}}}}};try{// Hack to workaround banner validation
xhr.open(['G','E','T'].join(''),path,true);}catch(error){// Hack to workaround banner validation
xhr.open(['G','E','T'].join(''),fullPath+'/'+path,true);}xhr.send();}return {load:loadAsset};}();}if(e.data.type==='loadAnimation'){_workerSelf.assetLoader.load(e.data.path,e.data.fullPath,function(data){_workerSelf.dataManager.completeData(data);_workerSelf.postMessage({id:e.data.id,payload:data,status:'success'});},function(){_workerSelf.postMessage({id:e.data.id,status:'error'});});}else if(e.data.type==='complete'){var animation=e.data.animation;_workerSelf.dataManager.completeData(animation);_workerSelf.postMessage({id:e.data.id,payload:animation,status:'success'});}else if(e.data.type==='loadData'){_workerSelf.assetLoader.load(e.data.path,e.data.fullPath,function(data){_workerSelf.postMessage({id:e.data.id,payload:data,status:'success'});},function(){_workerSelf.postMessage({id:e.data.id,status:'error'});});}});workerInstance.onmessage=function(event){var data=event.data;var id=data.id;var process=processes[id];processes[id]=null;if(data.status==='success'){process.onComplete(data.payload);}else if(process.onError){process.onError();}};}}function createProcess(onComplete,onError){_counterId+=1;var id='processId_'+_counterId;processes[id]={onComplete:onComplete,onError:onError};return id;}function loadAnimation(path,onComplete,onError){setupWorker();var processId=createProcess(onComplete,onError);workerInstance.postMessage({type:'loadAnimation',path:path,fullPath:window.location.origin+window.location.pathname,id:processId});}function loadData(path,onComplete,onError){setupWorker();var processId=createProcess(onComplete,onError);workerInstance.postMessage({type:'loadData',path:path,fullPath:window.location.origin+window.location.pathname,id:processId});}function completeAnimation(anim,onComplete,onError){setupWorker();var processId=createProcess(onComplete,onError);workerInstance.postMessage({type:'complete',animation:anim,id:processId});}return {loadAnimation:loadAnimation,loadData:loadData,completeAnimation:completeAnimation};}();var ImagePreloader=function(){var proxyImage=function(){var canvas=createTag('canvas');canvas.width=1;canvas.height=1;var ctx=canvas.getContext('2d');ctx.fillStyle='rgba(0,0,0,0)';ctx.fillRect(0,0,1,1);return canvas;}();function imageLoaded(){this.loadedAssets+=1;if(this.loadedAssets===this.totalImages&&this.loadedFootagesCount===this.totalFootages){if(this.imagesLoadedCb){this.imagesLoadedCb(null);}}}function footageLoaded(){this.loadedFootagesCount+=1;if(this.loadedAssets===this.totalImages&&this.loadedFootagesCount===this.totalFootages){if(this.imagesLoadedCb){this.imagesLoadedCb(null);}}}function getAssetsPath(assetData,assetsPath,originalPath){var path='';if(assetData.e){path=assetData.p;}else if(assetsPath){var imagePath=assetData.p;if(imagePath.indexOf('images/')!==-1){imagePath=imagePath.split('/')[1];}path=assetsPath+imagePath;}else {path=originalPath;path+=assetData.u?assetData.u:'';path+=assetData.p;}return path;}function testImageLoaded(img){var _count=0;var intervalId=setInterval(function(){var box=img.getBBox();if(box.width||_count>500){this._imageLoaded();clearInterval(intervalId);}_count+=1;}.bind(this),50);}function createImageData(assetData){var path=getAssetsPath(assetData,this.assetsPath,this.path);var img=createNS('image');if(isSafari){this.testImageLoaded(img);}else {img.addEventListener('load',this._imageLoaded,false);}img.addEventListener('error',function(){ob.img=proxyImage;this._imageLoaded();}.bind(this),false);img.setAttributeNS('http://www.w3.org/1999/xlink','href',path);if(this._elementHelper.append){this._elementHelper.append(img);}else {this._elementHelper.appendChild(img);}var ob={img:img,assetData:assetData};return ob;}function createImgData(assetData){var path=getAssetsPath(assetData,this.assetsPath,this.path);var img=createTag('img');img.crossOrigin='anonymous';img.addEventListener('load',this._imageLoaded,false);img.addEventListener('error',function(){ob.img=proxyImage;this._imageLoaded();}.bind(this),false);img.src=path;var ob={img:img,assetData:assetData};return ob;}function createFootageData(data){var ob={assetData:data};var path=getAssetsPath(data,this.assetsPath,this.path);dataManager.loadData(path,function(footageData){ob.img=footageData;this._footageLoaded();}.bind(this),function(){ob.img={};this._footageLoaded();}.bind(this));return ob;}function loadAssets(assets,cb){this.imagesLoadedCb=cb;var i;var len=assets.length;for(i=0;i<len;i+=1){if(!assets[i].layers){if(!assets[i].t||assets[i].t==='seq'){this.totalImages+=1;this.images.push(this._createImageData(assets[i]));}else if(assets[i].t===3){this.totalFootages+=1;this.images.push(this.createFootageData(assets[i]));}}}}function setPath(path){this.path=path||'';}function setAssetsPath(path){this.assetsPath=path||'';}function getAsset(assetData){var i=0;var len=this.images.length;while(i<len){if(this.images[i].assetData===assetData){return this.images[i].img;}i+=1;}return null;}function destroy(){this.imagesLoadedCb=null;this.images.length=0;}function loadedImages(){return this.totalImages===this.loadedAssets;}function loadedFootages(){return this.totalFootages===this.loadedFootagesCount;}function setCacheType(type,elementHelper){if(type==='svg'){this._elementHelper=elementHelper;this._createImageData=this.createImageData.bind(this);}else {this._createImageData=this.createImgData.bind(this);}}function ImagePreloaderFactory(){this._imageLoaded=imageLoaded.bind(this);this._footageLoaded=footageLoaded.bind(this);this.testImageLoaded=testImageLoaded.bind(this);this.createFootageData=createFootageData.bind(this);this.assetsPath='';this.path='';this.totalImages=0;this.totalFootages=0;this.loadedAssets=0;this.loadedFootagesCount=0;this.imagesLoadedCb=null;this.images=[];}ImagePreloaderFactory.prototype={loadAssets:loadAssets,setAssetsPath:setAssetsPath,setPath:setPath,loadedImages:loadedImages,loadedFootages:loadedFootages,destroy:destroy,getAsset:getAsset,createImgData:createImgData,createImageData:createImageData,imageLoaded:imageLoaded,footageLoaded:footageLoaded,setCacheType:setCacheType};return ImagePreloaderFactory;}();function BaseEvent(){}BaseEvent.prototype={triggerEvent:function triggerEvent(eventName,args){if(this._cbs[eventName]){var callbacks=this._cbs[eventName];for(var i=0;i<callbacks.length;i+=1){callbacks[i](args);}}},addEventListener:function addEventListener(eventName,callback){if(!this._cbs[eventName]){this._cbs[eventName]=[];}this._cbs[eventName].push(callback);return function(){this.removeEventListener(eventName,callback);}.bind(this);},removeEventListener:function removeEventListener(eventName,callback){if(!callback){this._cbs[eventName]=null;}else if(this._cbs[eventName]){var i=0;var len=this._cbs[eventName].length;while(i<len){if(this._cbs[eventName][i]===callback){this._cbs[eventName].splice(i,1);i-=1;len-=1;}i+=1;}if(!this._cbs[eventName].length){this._cbs[eventName]=null;}}}};var markerParser=function(){function parsePayloadLines(payload){var lines=payload.split('\r\n');var keys={};var line;var keysCount=0;for(var i=0;i<lines.length;i+=1){line=lines[i].split(':');if(line.length===2){keys[line[0]]=line[1].trim();keysCount+=1;}}if(keysCount===0){throw new Error();}return keys;}return function(_markers){var markers=[];for(var i=0;i<_markers.length;i+=1){var _marker=_markers[i];var markerData={time:_marker.tm,duration:_marker.dr};try{markerData.payload=JSON.parse(_markers[i].cm);}catch(_){try{markerData.payload=parsePayloadLines(_markers[i].cm);}catch(__){markerData.payload={name:_markers[i].cm};}}markers.push(markerData);}return markers;};}();var ProjectInterface=function(){function registerComposition(comp){this.compositions.push(comp);}return function(){function _thisProjectFunction(name){var i=0;var len=this.compositions.length;while(i<len){if(this.compositions[i].data&&this.compositions[i].data.nm===name){if(this.compositions[i].prepareFrame&&this.compositions[i].data.xt){this.compositions[i].prepareFrame(this.currentFrame);}return this.compositions[i].compInterface;}i+=1;}return null;}_thisProjectFunction.compositions=[];_thisProjectFunction.currentFrame=0;_thisProjectFunction.registerComposition=registerComposition;return _thisProjectFunction;};}();var renderers={};var registerRenderer=function registerRenderer(key,value){renderers[key]=value;};function getRenderer(key){return renderers[key];}function getRegisteredRenderer(){// Returns canvas by default for compatibility
if(renderers.canvas){return 'canvas';}// Returns any renderer that is registered
for(var key in renderers){if(renderers[key]){return key;}}return '';}function _typeof$4(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof$4=function _typeof(obj){return typeof obj;};}else {_typeof$4=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof$4(obj);}var AnimationItem=function AnimationItem(){this._cbs=[];this.name='';this.path='';this.isLoaded=false;this.currentFrame=0;this.currentRawFrame=0;this.firstFrame=0;this.totalFrames=0;this.frameRate=0;this.frameMult=0;this.playSpeed=1;this.playDirection=1;this.playCount=0;this.animationData={};this.assets=[];this.isPaused=true;this.autoplay=false;this.loop=true;this.renderer=null;this.animationID=createElementID();this.assetsPath='';this.timeCompleted=0;this.segmentPos=0;this.isSubframeEnabled=getSubframeEnabled();this.segments=[];this._idle=true;this._completedLoop=false;this.projectInterface=ProjectInterface();this.imagePreloader=new ImagePreloader();this.audioController=audioControllerFactory();this.markers=[];this.configAnimation=this.configAnimation.bind(this);this.onSetupError=this.onSetupError.bind(this);this.onSegmentComplete=this.onSegmentComplete.bind(this);this.drawnFrameEvent=new BMEnterFrameEvent('drawnFrame',0,0,0);this.expressionsPlugin=getExpressionsPlugin();};extendPrototype([BaseEvent],AnimationItem);AnimationItem.prototype.setParams=function(params){if(params.wrapper||params.container){this.wrapper=params.wrapper||params.container;}var animType='svg';if(params.animType){animType=params.animType;}else if(params.renderer){animType=params.renderer;}var RendererClass=getRenderer(animType);this.renderer=new RendererClass(this,params.rendererSettings);this.imagePreloader.setCacheType(animType,this.renderer.globalData.defs);this.renderer.setProjectInterface(this.projectInterface);this.animType=animType;if(params.loop===''||params.loop===null||params.loop===undefined||params.loop===true){this.loop=true;}else if(params.loop===false){this.loop=false;}else {this.loop=parseInt(params.loop,10);}this.autoplay='autoplay'in params?params.autoplay:true;this.name=params.name?params.name:'';this.autoloadSegments=Object.prototype.hasOwnProperty.call(params,'autoloadSegments')?params.autoloadSegments:true;this.assetsPath=params.assetsPath;this.initialSegment=params.initialSegment;if(params.audioFactory){this.audioController.setAudioFactory(params.audioFactory);}if(params.animationData){this.setupAnimation(params.animationData);}else if(params.path){if(params.path.lastIndexOf('\\')!==-1){this.path=params.path.substr(0,params.path.lastIndexOf('\\')+1);}else {this.path=params.path.substr(0,params.path.lastIndexOf('/')+1);}this.fileName=params.path.substr(params.path.lastIndexOf('/')+1);this.fileName=this.fileName.substr(0,this.fileName.lastIndexOf('.json'));dataManager.loadAnimation(params.path,this.configAnimation,this.onSetupError);}};AnimationItem.prototype.onSetupError=function(){this.trigger('data_failed');};AnimationItem.prototype.setupAnimation=function(data){dataManager.completeAnimation(data,this.configAnimation);};AnimationItem.prototype.setData=function(wrapper,animationData){if(animationData){if(_typeof$4(animationData)!=='object'){animationData=JSON.parse(animationData);}}var params={wrapper:wrapper,animationData:animationData};var wrapperAttributes=wrapper.attributes;params.path=wrapperAttributes.getNamedItem('data-animation-path')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-animation-path').value:wrapperAttributes.getNamedItem('data-bm-path')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-bm-path').value:wrapperAttributes.getNamedItem('bm-path')?wrapperAttributes.getNamedItem('bm-path').value:'';params.animType=wrapperAttributes.getNamedItem('data-anim-type')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-anim-type').value:wrapperAttributes.getNamedItem('data-bm-type')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-bm-type').value:wrapperAttributes.getNamedItem('bm-type')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('bm-type').value:wrapperAttributes.getNamedItem('data-bm-renderer')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-bm-renderer').value:wrapperAttributes.getNamedItem('bm-renderer')?wrapperAttributes.getNamedItem('bm-renderer').value:getRegisteredRenderer()||'canvas';var loop=wrapperAttributes.getNamedItem('data-anim-loop')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-anim-loop').value:wrapperAttributes.getNamedItem('data-bm-loop')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-bm-loop').value:wrapperAttributes.getNamedItem('bm-loop')?wrapperAttributes.getNamedItem('bm-loop').value:'';if(loop==='false'){params.loop=false;}else if(loop==='true'){params.loop=true;}else if(loop!==''){params.loop=parseInt(loop,10);}var autoplay=wrapperAttributes.getNamedItem('data-anim-autoplay')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-anim-autoplay').value:wrapperAttributes.getNamedItem('data-bm-autoplay')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-bm-autoplay').value:wrapperAttributes.getNamedItem('bm-autoplay')?wrapperAttributes.getNamedItem('bm-autoplay').value:true;params.autoplay=autoplay!=='false';params.name=wrapperAttributes.getNamedItem('data-name')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-name').value:wrapperAttributes.getNamedItem('data-bm-name')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-bm-name').value:wrapperAttributes.getNamedItem('bm-name')?wrapperAttributes.getNamedItem('bm-name').value:'';var prerender=wrapperAttributes.getNamedItem('data-anim-prerender')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-anim-prerender').value:wrapperAttributes.getNamedItem('data-bm-prerender')// eslint-disable-line no-nested-ternary
?wrapperAttributes.getNamedItem('data-bm-prerender').value:wrapperAttributes.getNamedItem('bm-prerender')?wrapperAttributes.getNamedItem('bm-prerender').value:'';if(prerender==='false'){params.prerender=false;}if(!params.path){this.trigger('destroy');}else {this.setParams(params);}};AnimationItem.prototype.includeLayers=function(data){if(data.op>this.animationData.op){this.animationData.op=data.op;this.totalFrames=Math.floor(data.op-this.animationData.ip);}var layers=this.animationData.layers;var i;var len=layers.length;var newLayers=data.layers;var j;var jLen=newLayers.length;for(j=0;j<jLen;j+=1){i=0;while(i<len){if(layers[i].id===newLayers[j].id){layers[i]=newLayers[j];break;}i+=1;}}if(data.chars||data.fonts){this.renderer.globalData.fontManager.addChars(data.chars);this.renderer.globalData.fontManager.addFonts(data.fonts,this.renderer.globalData.defs);}if(data.assets){len=data.assets.length;for(i=0;i<len;i+=1){this.animationData.assets.push(data.assets[i]);}}this.animationData.__complete=false;dataManager.completeAnimation(this.animationData,this.onSegmentComplete);};AnimationItem.prototype.onSegmentComplete=function(data){this.animationData=data;var expressionsPlugin=getExpressionsPlugin();if(expressionsPlugin){expressionsPlugin.initExpressions(this);}this.loadNextSegment();};AnimationItem.prototype.loadNextSegment=function(){var segments=this.animationData.segments;if(!segments||segments.length===0||!this.autoloadSegments){this.trigger('data_ready');this.timeCompleted=this.totalFrames;return;}var segment=segments.shift();this.timeCompleted=segment.time*this.frameRate;var segmentPath=this.path+this.fileName+'_'+this.segmentPos+'.json';this.segmentPos+=1;dataManager.loadData(segmentPath,this.includeLayers.bind(this),function(){this.trigger('data_failed');}.bind(this));};AnimationItem.prototype.loadSegments=function(){var segments=this.animationData.segments;if(!segments){this.timeCompleted=this.totalFrames;}this.loadNextSegment();};AnimationItem.prototype.imagesLoaded=function(){this.trigger('loaded_images');this.checkLoaded();};AnimationItem.prototype.preloadImages=function(){this.imagePreloader.setAssetsPath(this.assetsPath);this.imagePreloader.setPath(this.path);this.imagePreloader.loadAssets(this.animationData.assets,this.imagesLoaded.bind(this));};AnimationItem.prototype.configAnimation=function(animData){if(!this.renderer){return;}try{this.animationData=animData;if(this.initialSegment){this.totalFrames=Math.floor(this.initialSegment[1]-this.initialSegment[0]);this.firstFrame=Math.round(this.initialSegment[0]);}else {this.totalFrames=Math.floor(this.animationData.op-this.animationData.ip);this.firstFrame=Math.round(this.animationData.ip);}this.renderer.configAnimation(animData);if(!animData.assets){animData.assets=[];}this.assets=this.animationData.assets;this.frameRate=this.animationData.fr;this.frameMult=this.animationData.fr/1000;this.renderer.searchExtraCompositions(animData.assets);this.markers=markerParser(animData.markers||[]);this.trigger('config_ready');this.preloadImages();this.loadSegments();this.updaFrameModifier();this.waitForFontsLoaded();if(this.isPaused){this.audioController.pause();}}catch(error){this.triggerConfigError(error);}};AnimationItem.prototype.waitForFontsLoaded=function(){if(!this.renderer){return;}if(this.renderer.globalData.fontManager.isLoaded){this.checkLoaded();}else {setTimeout(this.waitForFontsLoaded.bind(this),20);}};AnimationItem.prototype.checkLoaded=function(){if(!this.isLoaded&&this.renderer.globalData.fontManager.isLoaded&&(this.imagePreloader.loadedImages()||this.renderer.rendererType!=='canvas')&&this.imagePreloader.loadedFootages()){this.isLoaded=true;var expressionsPlugin=getExpressionsPlugin();if(expressionsPlugin){expressionsPlugin.initExpressions(this);}this.renderer.initItems();setTimeout(function(){this.trigger('DOMLoaded');}.bind(this),0);this.gotoFrame();if(this.autoplay){this.play();}}};AnimationItem.prototype.resize=function(width,height){// Adding this validation for backwards compatibility in case an event object was being passed down
var _width=typeof width==='number'?width:undefined;var _height=typeof height==='number'?height:undefined;this.renderer.updateContainerSize(_width,_height);};AnimationItem.prototype.setSubframe=function(flag){this.isSubframeEnabled=!!flag;};AnimationItem.prototype.gotoFrame=function(){this.currentFrame=this.isSubframeEnabled?this.currentRawFrame:~~this.currentRawFrame;// eslint-disable-line no-bitwise
if(this.timeCompleted!==this.totalFrames&&this.currentFrame>this.timeCompleted){this.currentFrame=this.timeCompleted;}this.trigger('enterFrame');this.renderFrame();this.trigger('drawnFrame');};AnimationItem.prototype.renderFrame=function(){if(this.isLoaded===false||!this.renderer){return;}try{if(this.expressionsPlugin){this.expressionsPlugin.resetFrame();}this.renderer.renderFrame(this.currentFrame+this.firstFrame);}catch(error){this.triggerRenderFrameError(error);}};AnimationItem.prototype.play=function(name){if(name&&this.name!==name){return;}if(this.isPaused===true){this.isPaused=false;this.trigger('_play');this.audioController.resume();if(this._idle){this._idle=false;this.trigger('_active');}}};AnimationItem.prototype.pause=function(name){if(name&&this.name!==name){return;}if(this.isPaused===false){this.isPaused=true;this.trigger('_pause');this._idle=true;this.trigger('_idle');this.audioController.pause();}};AnimationItem.prototype.togglePause=function(name){if(name&&this.name!==name){return;}if(this.isPaused===true){this.play();}else {this.pause();}};AnimationItem.prototype.stop=function(name){if(name&&this.name!==name){return;}this.pause();this.playCount=0;this._completedLoop=false;this.setCurrentRawFrameValue(0);};AnimationItem.prototype.getMarkerData=function(markerName){var marker;for(var i=0;i<this.markers.length;i+=1){marker=this.markers[i];if(marker.payload&&marker.payload.name===markerName){return marker;}}return null;};AnimationItem.prototype.goToAndStop=function(value,isFrame,name){if(name&&this.name!==name){return;}var numValue=Number(value);if(isNaN(numValue)){var marker=this.getMarkerData(value);if(marker){this.goToAndStop(marker.time,true);}}else if(isFrame){this.setCurrentRawFrameValue(value);}else {this.setCurrentRawFrameValue(value*this.frameModifier);}this.pause();};AnimationItem.prototype.goToAndPlay=function(value,isFrame,name){if(name&&this.name!==name){return;}var numValue=Number(value);if(isNaN(numValue)){var marker=this.getMarkerData(value);if(marker){if(!marker.duration){this.goToAndStop(marker.time,true);}else {this.playSegments([marker.time,marker.time+marker.duration],true);}}}else {this.goToAndStop(numValue,isFrame,name);}this.play();};AnimationItem.prototype.advanceTime=function(value){if(this.isPaused===true||this.isLoaded===false){return;}var nextValue=this.currentRawFrame+value*this.frameModifier;var _isComplete=false;// Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.
// If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.
if(nextValue>=this.totalFrames-1&&this.frameModifier>0){if(!this.loop||this.playCount===this.loop){if(!this.checkSegments(nextValue>this.totalFrames?nextValue%this.totalFrames:0)){_isComplete=true;nextValue=this.totalFrames-1;}}else if(nextValue>=this.totalFrames){this.playCount+=1;if(!this.checkSegments(nextValue%this.totalFrames)){this.setCurrentRawFrameValue(nextValue%this.totalFrames);this._completedLoop=true;this.trigger('loopComplete');}}else {this.setCurrentRawFrameValue(nextValue);}}else if(nextValue<0){if(!this.checkSegments(nextValue%this.totalFrames)){if(this.loop&&!(this.playCount--<=0&&this.loop!==true)){// eslint-disable-line no-plusplus
this.setCurrentRawFrameValue(this.totalFrames+nextValue%this.totalFrames);if(!this._completedLoop){this._completedLoop=true;}else {this.trigger('loopComplete');}}else {_isComplete=true;nextValue=0;}}}else {this.setCurrentRawFrameValue(nextValue);}if(_isComplete){this.setCurrentRawFrameValue(nextValue);this.pause();this.trigger('complete');}};AnimationItem.prototype.adjustSegment=function(arr,offset){this.playCount=0;if(arr[1]<arr[0]){if(this.frameModifier>0){if(this.playSpeed<0){this.setSpeed(-this.playSpeed);}else {this.setDirection(-1);}}this.totalFrames=arr[0]-arr[1];this.timeCompleted=this.totalFrames;this.firstFrame=arr[1];this.setCurrentRawFrameValue(this.totalFrames-0.001-offset);}else if(arr[1]>arr[0]){if(this.frameModifier<0){if(this.playSpeed<0){this.setSpeed(-this.playSpeed);}else {this.setDirection(1);}}this.totalFrames=arr[1]-arr[0];this.timeCompleted=this.totalFrames;this.firstFrame=arr[0];this.setCurrentRawFrameValue(0.001+offset);}this.trigger('segmentStart');};AnimationItem.prototype.setSegment=function(init,end){var pendingFrame=-1;if(this.isPaused){if(this.currentRawFrame+this.firstFrame<init){pendingFrame=init;}else if(this.currentRawFrame+this.firstFrame>end){pendingFrame=end-init;}}this.firstFrame=init;this.totalFrames=end-init;this.timeCompleted=this.totalFrames;if(pendingFrame!==-1){this.goToAndStop(pendingFrame,true);}};AnimationItem.prototype.playSegments=function(arr,forceFlag){if(forceFlag){this.segments.length=0;}if(_typeof$4(arr[0])==='object'){var i;var len=arr.length;for(i=0;i<len;i+=1){this.segments.push(arr[i]);}}else {this.segments.push(arr);}if(this.segments.length&&forceFlag){this.adjustSegment(this.segments.shift(),0);}if(this.isPaused){this.play();}};AnimationItem.prototype.resetSegments=function(forceFlag){this.segments.length=0;this.segments.push([this.animationData.ip,this.animationData.op]);if(forceFlag){this.checkSegments(0);}};AnimationItem.prototype.checkSegments=function(offset){if(this.segments.length){this.adjustSegment(this.segments.shift(),offset);return true;}return false;};AnimationItem.prototype.destroy=function(name){if(name&&this.name!==name||!this.renderer){return;}this.renderer.destroy();this.imagePreloader.destroy();this.trigger('destroy');this._cbs=null;this.onEnterFrame=null;this.onLoopComplete=null;this.onComplete=null;this.onSegmentStart=null;this.onDestroy=null;this.renderer=null;this.expressionsPlugin=null;this.imagePreloader=null;this.projectInterface=null;};AnimationItem.prototype.setCurrentRawFrameValue=function(value){this.currentRawFrame=value;this.gotoFrame();};AnimationItem.prototype.setSpeed=function(val){this.playSpeed=val;this.updaFrameModifier();};AnimationItem.prototype.setDirection=function(val){this.playDirection=val<0?-1:1;this.updaFrameModifier();};AnimationItem.prototype.setLoop=function(isLooping){this.loop=isLooping;};AnimationItem.prototype.setVolume=function(val,name){if(name&&this.name!==name){return;}this.audioController.setVolume(val);};AnimationItem.prototype.getVolume=function(){return this.audioController.getVolume();};AnimationItem.prototype.mute=function(name){if(name&&this.name!==name){return;}this.audioController.mute();};AnimationItem.prototype.unmute=function(name){if(name&&this.name!==name){return;}this.audioController.unmute();};AnimationItem.prototype.updaFrameModifier=function(){this.frameModifier=this.frameMult*this.playSpeed*this.playDirection;this.audioController.setRate(this.playSpeed*this.playDirection);};AnimationItem.prototype.getPath=function(){return this.path;};AnimationItem.prototype.getAssetsPath=function(assetData){var path='';if(assetData.e){path=assetData.p;}else if(this.assetsPath){var imagePath=assetData.p;if(imagePath.indexOf('images/')!==-1){imagePath=imagePath.split('/')[1];}path=this.assetsPath+imagePath;}else {path=this.path;path+=assetData.u?assetData.u:'';path+=assetData.p;}return path;};AnimationItem.prototype.getAssetData=function(id){var i=0;var len=this.assets.length;while(i<len){if(id===this.assets[i].id){return this.assets[i];}i+=1;}return null;};AnimationItem.prototype.hide=function(){this.renderer.hide();};AnimationItem.prototype.show=function(){this.renderer.show();};AnimationItem.prototype.getDuration=function(isFrame){return isFrame?this.totalFrames:this.totalFrames/this.frameRate;};AnimationItem.prototype.updateDocumentData=function(path,documentData,index){try{var element=this.renderer.getElementByPath(path);element.updateDocumentData(documentData,index);}catch(error){// TODO: decide how to handle catch case
}};AnimationItem.prototype.trigger=function(name){if(this._cbs&&this._cbs[name]){switch(name){case'enterFrame':this.triggerEvent(name,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameModifier));break;case'drawnFrame':this.drawnFrameEvent.currentTime=this.currentFrame;this.drawnFrameEvent.totalTime=this.totalFrames;this.drawnFrameEvent.direction=this.frameModifier;this.triggerEvent(name,this.drawnFrameEvent);break;case'loopComplete':this.triggerEvent(name,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));break;case'complete':this.triggerEvent(name,new BMCompleteEvent(name,this.frameMult));break;case'segmentStart':this.triggerEvent(name,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));break;case'destroy':this.triggerEvent(name,new BMDestroyEvent(name,this));break;default:this.triggerEvent(name);}}if(name==='enterFrame'&&this.onEnterFrame){this.onEnterFrame.call(this,new BMEnterFrameEvent(name,this.currentFrame,this.totalFrames,this.frameMult));}if(name==='loopComplete'&&this.onLoopComplete){this.onLoopComplete.call(this,new BMCompleteLoopEvent(name,this.loop,this.playCount,this.frameMult));}if(name==='complete'&&this.onComplete){this.onComplete.call(this,new BMCompleteEvent(name,this.frameMult));}if(name==='segmentStart'&&this.onSegmentStart){this.onSegmentStart.call(this,new BMSegmentStartEvent(name,this.firstFrame,this.totalFrames));}if(name==='destroy'&&this.onDestroy){this.onDestroy.call(this,new BMDestroyEvent(name,this));}};AnimationItem.prototype.triggerRenderFrameError=function(nativeError){var error=new BMRenderFrameErrorEvent(nativeError,this.currentFrame);this.triggerEvent('error',error);if(this.onError){this.onError.call(this,error);}};AnimationItem.prototype.triggerConfigError=function(nativeError){var error=new BMConfigErrorEvent(nativeError,this.currentFrame);this.triggerEvent('error',error);if(this.onError){this.onError.call(this,error);}};var animationManager=function(){var moduleOb={};var registeredAnimations=[];var initTime=0;var len=0;var playingAnimationsNum=0;var _stopped=true;var _isFrozen=false;function removeElement(ev){var i=0;var animItem=ev.target;while(i<len){if(registeredAnimations[i].animation===animItem){registeredAnimations.splice(i,1);i-=1;len-=1;if(!animItem.isPaused){subtractPlayingCount();}}i+=1;}}function registerAnimation(element,animationData){if(!element){return null;}var i=0;while(i<len){if(registeredAnimations[i].elem===element&&registeredAnimations[i].elem!==null){return registeredAnimations[i].animation;}i+=1;}var animItem=new AnimationItem();setupAnimation(animItem,element);animItem.setData(element,animationData);return animItem;}function getRegisteredAnimations(){var i;var lenAnims=registeredAnimations.length;var animations=[];for(i=0;i<lenAnims;i+=1){animations.push(registeredAnimations[i].animation);}return animations;}function addPlayingCount(){playingAnimationsNum+=1;activate();}function subtractPlayingCount(){playingAnimationsNum-=1;}function setupAnimation(animItem,element){animItem.addEventListener('destroy',removeElement);animItem.addEventListener('_active',addPlayingCount);animItem.addEventListener('_idle',subtractPlayingCount);registeredAnimations.push({elem:element,animation:animItem});len+=1;}function loadAnimation(params){var animItem=new AnimationItem();setupAnimation(animItem,null);animItem.setParams(params);return animItem;}function setSpeed(val,animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.setSpeed(val,animation);}}function setDirection(val,animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.setDirection(val,animation);}}function play(animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.play(animation);}}function resume(nowTime){var elapsedTime=nowTime-initTime;var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.advanceTime(elapsedTime);}initTime=nowTime;if(playingAnimationsNum&&!_isFrozen){window.requestAnimationFrame(resume);}else {_stopped=true;}}function first(nowTime){initTime=nowTime;window.requestAnimationFrame(resume);}function pause(animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.pause(animation);}}function goToAndStop(value,isFrame,animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.goToAndStop(value,isFrame,animation);}}function stop(animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.stop(animation);}}function togglePause(animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.togglePause(animation);}}function destroy(animation){var i;for(i=len-1;i>=0;i-=1){registeredAnimations[i].animation.destroy(animation);}}function searchAnimations(animationData,standalone,renderer){var animElements=[].concat([].slice.call(document.getElementsByClassName('lottie')),[].slice.call(document.getElementsByClassName('bodymovin')));var i;var lenAnims=animElements.length;for(i=0;i<lenAnims;i+=1){if(renderer){animElements[i].setAttribute('data-bm-type',renderer);}registerAnimation(animElements[i],animationData);}if(standalone&&lenAnims===0){if(!renderer){renderer='svg';}var body=document.getElementsByTagName('body')[0];body.innerText='';var div=createTag('div');div.style.width='100%';div.style.height='100%';div.setAttribute('data-bm-type',renderer);body.appendChild(div);registerAnimation(div,animationData);}}function resize(){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.resize();}}function activate(){if(!_isFrozen&&playingAnimationsNum){if(_stopped){window.requestAnimationFrame(first);_stopped=false;}}}function freeze(){_isFrozen=true;}function unfreeze(){_isFrozen=false;activate();}function setVolume(val,animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.setVolume(val,animation);}}function mute(animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.mute(animation);}}function unmute(animation){var i;for(i=0;i<len;i+=1){registeredAnimations[i].animation.unmute(animation);}}moduleOb.registerAnimation=registerAnimation;moduleOb.loadAnimation=loadAnimation;moduleOb.setSpeed=setSpeed;moduleOb.setDirection=setDirection;moduleOb.play=play;moduleOb.pause=pause;moduleOb.stop=stop;moduleOb.togglePause=togglePause;moduleOb.searchAnimations=searchAnimations;moduleOb.resize=resize;// moduleOb.start = start;
moduleOb.goToAndStop=goToAndStop;moduleOb.destroy=destroy;moduleOb.freeze=freeze;moduleOb.unfreeze=unfreeze;moduleOb.setVolume=setVolume;moduleOb.mute=mute;moduleOb.unmute=unmute;moduleOb.getRegisteredAnimations=getRegisteredAnimations;return moduleOb;}();/* eslint-disable */var BezierFactory=function(){/**
	       * BezierEasing - use bezier curve for transition easing function
	       * by Gaëtan Renaudeau 2014 - 2015 – MIT License
	       *
	       * Credits: is based on Firefox's nsSMILKeySpline.cpp
	       * Usage:
	       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
	       * spline.get(x) => returns the easing value | x must be in [0, 1] range
	       *
	       */var ob={};ob.getBezierEasing=getBezierEasing;var beziers={};function getBezierEasing(a,b,c,d,nm){var str=nm||('bez_'+a+'_'+b+'_'+c+'_'+d).replace(/\./g,'p');if(beziers[str]){return beziers[str];}var bezEasing=new BezierEasing([a,b,c,d]);beziers[str]=bezEasing;return bezEasing;}// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS=4;var NEWTON_MIN_SLOPE=0.001;var SUBDIVISION_PRECISION=0.0000001;var SUBDIVISION_MAX_ITERATIONS=10;var kSplineTableSize=11;var kSampleStepSize=1.0/(kSplineTableSize-1.0);var float32ArraySupported=typeof Float32Array==='function';function A(aA1,aA2){return 1.0-3.0*aA2+3.0*aA1;}function B(aA1,aA2){return 3.0*aA2-6.0*aA1;}function C(aA1){return 3.0*aA1;}// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier(aT,aA1,aA2){return ((A(aA1,aA2)*aT+B(aA1,aA2))*aT+C(aA1))*aT;}// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope(aT,aA1,aA2){return 3.0*A(aA1,aA2)*aT*aT+2.0*B(aA1,aA2)*aT+C(aA1);}function binarySubdivide(aX,aA,aB,mX1,mX2){var currentX,currentT,i=0;do{currentT=aA+(aB-aA)/2.0;currentX=calcBezier(currentT,mX1,mX2)-aX;if(currentX>0.0){aB=currentT;}else {aA=currentT;}}while(Math.abs(currentX)>SUBDIVISION_PRECISION&&++i<SUBDIVISION_MAX_ITERATIONS);return currentT;}function newtonRaphsonIterate(aX,aGuessT,mX1,mX2){for(var i=0;i<NEWTON_ITERATIONS;++i){var currentSlope=getSlope(aGuessT,mX1,mX2);if(currentSlope===0.0)return aGuessT;var currentX=calcBezier(aGuessT,mX1,mX2)-aX;aGuessT-=currentX/currentSlope;}return aGuessT;}/**
	       * points is an array of [ mX1, mY1, mX2, mY2 ]
	       */function BezierEasing(points){this._p=points;this._mSampleValues=float32ArraySupported?new Float32Array(kSplineTableSize):new Array(kSplineTableSize);this._precomputed=false;this.get=this.get.bind(this);}BezierEasing.prototype={get:function get(x){var mX1=this._p[0],mY1=this._p[1],mX2=this._p[2],mY2=this._p[3];if(!this._precomputed)this._precompute();if(mX1===mY1&&mX2===mY2)return x;// linear
// Because JavaScript number are imprecise, we should guarantee the extremes are right.
if(x===0)return 0;if(x===1)return 1;return calcBezier(this._getTForX(x),mY1,mY2);},// Private part
_precompute:function _precompute(){var mX1=this._p[0],mY1=this._p[1],mX2=this._p[2],mY2=this._p[3];this._precomputed=true;if(mX1!==mY1||mX2!==mY2){this._calcSampleValues();}},_calcSampleValues:function _calcSampleValues(){var mX1=this._p[0],mX2=this._p[2];for(var i=0;i<kSplineTableSize;++i){this._mSampleValues[i]=calcBezier(i*kSampleStepSize,mX1,mX2);}},/**
	           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
	           */_getTForX:function _getTForX(aX){var mX1=this._p[0],mX2=this._p[2],mSampleValues=this._mSampleValues;var intervalStart=0.0;var currentSample=1;var lastSample=kSplineTableSize-1;for(;currentSample!==lastSample&&mSampleValues[currentSample]<=aX;++currentSample){intervalStart+=kSampleStepSize;}--currentSample;// Interpolate to provide an initial guess for t
var dist=(aX-mSampleValues[currentSample])/(mSampleValues[currentSample+1]-mSampleValues[currentSample]);var guessForT=intervalStart+dist*kSampleStepSize;var initialSlope=getSlope(guessForT,mX1,mX2);if(initialSlope>=NEWTON_MIN_SLOPE){return newtonRaphsonIterate(aX,guessForT,mX1,mX2);}if(initialSlope===0.0){return guessForT;}return binarySubdivide(aX,intervalStart,intervalStart+kSampleStepSize,mX1,mX2);}};return ob;}();var pooling=function(){function _double(arr){return arr.concat(createSizedArray(arr.length));}return {"double":_double};}();var poolFactory=function(){return function(initialLength,_create,_release){var _length=0;var _maxLength=initialLength;var pool=createSizedArray(_maxLength);var ob={newElement:newElement,release:release};function newElement(){var element;if(_length){_length-=1;element=pool[_length];}else {element=_create();}return element;}function release(element){if(_length===_maxLength){pool=pooling["double"](pool);_maxLength*=2;}if(_release){_release(element);}pool[_length]=element;_length+=1;}return ob;};}();var bezierLengthPool=function(){function create(){return {addedLength:0,percents:createTypedArray('float32',getDefaultCurveSegments()),lengths:createTypedArray('float32',getDefaultCurveSegments())};}return poolFactory(8,create);}();var segmentsLengthPool=function(){function create(){return {lengths:[],totalLength:0};}function release(element){var i;var len=element.lengths.length;for(i=0;i<len;i+=1){bezierLengthPool.release(element.lengths[i]);}element.lengths.length=0;}return poolFactory(8,create,release);}();function bezFunction(){var math=Math;function pointOnLine2D(x1,y1,x2,y2,x3,y3){var det1=x1*y2+y1*x3+x2*y3-x3*y2-y3*x1-x2*y1;return det1>-0.001&&det1<0.001;}function pointOnLine3D(x1,y1,z1,x2,y2,z2,x3,y3,z3){if(z1===0&&z2===0&&z3===0){return pointOnLine2D(x1,y1,x2,y2,x3,y3);}var dist1=math.sqrt(math.pow(x2-x1,2)+math.pow(y2-y1,2)+math.pow(z2-z1,2));var dist2=math.sqrt(math.pow(x3-x1,2)+math.pow(y3-y1,2)+math.pow(z3-z1,2));var dist3=math.sqrt(math.pow(x3-x2,2)+math.pow(y3-y2,2)+math.pow(z3-z2,2));var diffDist;if(dist1>dist2){if(dist1>dist3){diffDist=dist1-dist2-dist3;}else {diffDist=dist3-dist2-dist1;}}else if(dist3>dist2){diffDist=dist3-dist2-dist1;}else {diffDist=dist2-dist1-dist3;}return diffDist>-0.0001&&diffDist<0.0001;}var getBezierLength=function(){return function(pt1,pt2,pt3,pt4){var curveSegments=getDefaultCurveSegments();var k;var i;var len;var ptCoord;var perc;var addedLength=0;var ptDistance;var point=[];var lastPoint=[];var lengthData=bezierLengthPool.newElement();len=pt3.length;for(k=0;k<curveSegments;k+=1){perc=k/(curveSegments-1);ptDistance=0;for(i=0;i<len;i+=1){ptCoord=bmPow(1-perc,3)*pt1[i]+3*bmPow(1-perc,2)*perc*pt3[i]+3*(1-perc)*bmPow(perc,2)*pt4[i]+bmPow(perc,3)*pt2[i];point[i]=ptCoord;if(lastPoint[i]!==null){ptDistance+=bmPow(point[i]-lastPoint[i],2);}lastPoint[i]=point[i];}if(ptDistance){ptDistance=bmSqrt(ptDistance);addedLength+=ptDistance;}lengthData.percents[k]=perc;lengthData.lengths[k]=addedLength;}lengthData.addedLength=addedLength;return lengthData;};}();function getSegmentsLength(shapeData){var segmentsLength=segmentsLengthPool.newElement();var closed=shapeData.c;var pathV=shapeData.v;var pathO=shapeData.o;var pathI=shapeData.i;var i;var len=shapeData._length;var lengths=segmentsLength.lengths;var totalLength=0;for(i=0;i<len-1;i+=1){lengths[i]=getBezierLength(pathV[i],pathV[i+1],pathO[i],pathI[i+1]);totalLength+=lengths[i].addedLength;}if(closed&&len){lengths[i]=getBezierLength(pathV[i],pathV[0],pathO[i],pathI[0]);totalLength+=lengths[i].addedLength;}segmentsLength.totalLength=totalLength;return segmentsLength;}function BezierData(length){this.segmentLength=0;this.points=new Array(length);}function PointData(partial,point){this.partialLength=partial;this.point=point;}var buildBezierData=function(){var storedData={};return function(pt1,pt2,pt3,pt4){var bezierName=(pt1[0]+'_'+pt1[1]+'_'+pt2[0]+'_'+pt2[1]+'_'+pt3[0]+'_'+pt3[1]+'_'+pt4[0]+'_'+pt4[1]).replace(/\./g,'p');if(!storedData[bezierName]){var curveSegments=getDefaultCurveSegments();var k;var i;var len;var ptCoord;var perc;var addedLength=0;var ptDistance;var point;var lastPoint=null;if(pt1.length===2&&(pt1[0]!==pt2[0]||pt1[1]!==pt2[1])&&pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt1[0]+pt3[0],pt1[1]+pt3[1])&&pointOnLine2D(pt1[0],pt1[1],pt2[0],pt2[1],pt2[0]+pt4[0],pt2[1]+pt4[1])){curveSegments=2;}var bezierData=new BezierData(curveSegments);len=pt3.length;for(k=0;k<curveSegments;k+=1){point=createSizedArray(len);perc=k/(curveSegments-1);ptDistance=0;for(i=0;i<len;i+=1){ptCoord=bmPow(1-perc,3)*pt1[i]+3*bmPow(1-perc,2)*perc*(pt1[i]+pt3[i])+3*(1-perc)*bmPow(perc,2)*(pt2[i]+pt4[i])+bmPow(perc,3)*pt2[i];point[i]=ptCoord;if(lastPoint!==null){ptDistance+=bmPow(point[i]-lastPoint[i],2);}}ptDistance=bmSqrt(ptDistance);addedLength+=ptDistance;bezierData.points[k]=new PointData(ptDistance,point);lastPoint=point;}bezierData.segmentLength=addedLength;storedData[bezierName]=bezierData;}return storedData[bezierName];};}();function getDistancePerc(perc,bezierData){var percents=bezierData.percents;var lengths=bezierData.lengths;var len=percents.length;var initPos=bmFloor((len-1)*perc);var lengthPos=perc*bezierData.addedLength;var lPerc=0;if(initPos===len-1||initPos===0||lengthPos===lengths[initPos]){return percents[initPos];}var dir=lengths[initPos]>lengthPos?-1:1;var flag=true;while(flag){if(lengths[initPos]<=lengthPos&&lengths[initPos+1]>lengthPos){lPerc=(lengthPos-lengths[initPos])/(lengths[initPos+1]-lengths[initPos]);flag=false;}else {initPos+=dir;}if(initPos<0||initPos>=len-1){// FIX for TypedArrays that don't store floating point values with enough accuracy
if(initPos===len-1){return percents[initPos];}flag=false;}}return percents[initPos]+(percents[initPos+1]-percents[initPos])*lPerc;}function getPointInSegment(pt1,pt2,pt3,pt4,percent,bezierData){var t1=getDistancePerc(percent,bezierData);var u1=1-t1;var ptX=math.round((u1*u1*u1*pt1[0]+(t1*u1*u1+u1*t1*u1+u1*u1*t1)*pt3[0]+(t1*t1*u1+u1*t1*t1+t1*u1*t1)*pt4[0]+t1*t1*t1*pt2[0])*1000)/1000;var ptY=math.round((u1*u1*u1*pt1[1]+(t1*u1*u1+u1*t1*u1+u1*u1*t1)*pt3[1]+(t1*t1*u1+u1*t1*t1+t1*u1*t1)*pt4[1]+t1*t1*t1*pt2[1])*1000)/1000;return [ptX,ptY];}var bezierSegmentPoints=createTypedArray('float32',8);function getNewSegment(pt1,pt2,pt3,pt4,startPerc,endPerc,bezierData){if(startPerc<0){startPerc=0;}else if(startPerc>1){startPerc=1;}var t0=getDistancePerc(startPerc,bezierData);endPerc=endPerc>1?1:endPerc;var t1=getDistancePerc(endPerc,bezierData);var i;var len=pt1.length;var u0=1-t0;var u1=1-t1;var u0u0u0=u0*u0*u0;var t0u0u0_3=t0*u0*u0*3;// eslint-disable-line camelcase
var t0t0u0_3=t0*t0*u0*3;// eslint-disable-line camelcase
var t0t0t0=t0*t0*t0;//
var u0u0u1=u0*u0*u1;var t0u0u1_3=t0*u0*u1+u0*t0*u1+u0*u0*t1;// eslint-disable-line camelcase
var t0t0u1_3=t0*t0*u1+u0*t0*t1+t0*u0*t1;// eslint-disable-line camelcase
var t0t0t1=t0*t0*t1;//
var u0u1u1=u0*u1*u1;var t0u1u1_3=t0*u1*u1+u0*t1*u1+u0*u1*t1;// eslint-disable-line camelcase
var t0t1u1_3=t0*t1*u1+u0*t1*t1+t0*u1*t1;// eslint-disable-line camelcase
var t0t1t1=t0*t1*t1;//
var u1u1u1=u1*u1*u1;var t1u1u1_3=t1*u1*u1+u1*t1*u1+u1*u1*t1;// eslint-disable-line camelcase
var t1t1u1_3=t1*t1*u1+u1*t1*t1+t1*u1*t1;// eslint-disable-line camelcase
var t1t1t1=t1*t1*t1;for(i=0;i<len;i+=1){bezierSegmentPoints[i*4]=math.round((u0u0u0*pt1[i]+t0u0u0_3*pt3[i]+t0t0u0_3*pt4[i]+t0t0t0*pt2[i])*1000)/1000;// eslint-disable-line camelcase
bezierSegmentPoints[i*4+1]=math.round((u0u0u1*pt1[i]+t0u0u1_3*pt3[i]+t0t0u1_3*pt4[i]+t0t0t1*pt2[i])*1000)/1000;// eslint-disable-line camelcase
bezierSegmentPoints[i*4+2]=math.round((u0u1u1*pt1[i]+t0u1u1_3*pt3[i]+t0t1u1_3*pt4[i]+t0t1t1*pt2[i])*1000)/1000;// eslint-disable-line camelcase
bezierSegmentPoints[i*4+3]=math.round((u1u1u1*pt1[i]+t1u1u1_3*pt3[i]+t1t1u1_3*pt4[i]+t1t1t1*pt2[i])*1000)/1000;// eslint-disable-line camelcase
}return bezierSegmentPoints;}return {getSegmentsLength:getSegmentsLength,getNewSegment:getNewSegment,getPointInSegment:getPointInSegment,buildBezierData:buildBezierData,pointOnLine2D:pointOnLine2D,pointOnLine3D:pointOnLine3D};}var bez=bezFunction();var initFrame=initialDefaultFrame;var mathAbs=Math.abs;function interpolateValue(frameNum,caching){var offsetTime=this.offsetTime;var newValue;if(this.propType==='multidimensional'){newValue=createTypedArray('float32',this.pv.length);}var iterationIndex=caching.lastIndex;var i=iterationIndex;var len=this.keyframes.length-1;var flag=true;var keyData;var nextKeyData;var keyframeMetadata;while(flag){keyData=this.keyframes[i];nextKeyData=this.keyframes[i+1];if(i===len-1&&frameNum>=nextKeyData.t-offsetTime){if(keyData.h){keyData=nextKeyData;}iterationIndex=0;break;}if(nextKeyData.t-offsetTime>frameNum){iterationIndex=i;break;}if(i<len-1){i+=1;}else {iterationIndex=0;flag=false;}}keyframeMetadata=this.keyframesMetadata[i]||{};var k;var kLen;var perc;var jLen;var j;var fnc;var nextKeyTime=nextKeyData.t-offsetTime;var keyTime=keyData.t-offsetTime;var endValue;if(keyData.to){if(!keyframeMetadata.bezierData){keyframeMetadata.bezierData=bez.buildBezierData(keyData.s,nextKeyData.s||keyData.e,keyData.to,keyData.ti);}var bezierData=keyframeMetadata.bezierData;if(frameNum>=nextKeyTime||frameNum<keyTime){var ind=frameNum>=nextKeyTime?bezierData.points.length-1:0;kLen=bezierData.points[ind].point.length;for(k=0;k<kLen;k+=1){newValue[k]=bezierData.points[ind].point[k];}// caching._lastKeyframeIndex = -1;
}else {if(keyframeMetadata.__fnct){fnc=keyframeMetadata.__fnct;}else {fnc=BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y,keyData.n).get;keyframeMetadata.__fnct=fnc;}perc=fnc((frameNum-keyTime)/(nextKeyTime-keyTime));var distanceInLine=bezierData.segmentLength*perc;var segmentPerc;var addedLength=caching.lastFrame<frameNum&&caching._lastKeyframeIndex===i?caching._lastAddedLength:0;j=caching.lastFrame<frameNum&&caching._lastKeyframeIndex===i?caching._lastPoint:0;flag=true;jLen=bezierData.points.length;while(flag){addedLength+=bezierData.points[j].partialLength;if(distanceInLine===0||perc===0||j===bezierData.points.length-1){kLen=bezierData.points[j].point.length;for(k=0;k<kLen;k+=1){newValue[k]=bezierData.points[j].point[k];}break;}else if(distanceInLine>=addedLength&&distanceInLine<addedLength+bezierData.points[j+1].partialLength){segmentPerc=(distanceInLine-addedLength)/bezierData.points[j+1].partialLength;kLen=bezierData.points[j].point.length;for(k=0;k<kLen;k+=1){newValue[k]=bezierData.points[j].point[k]+(bezierData.points[j+1].point[k]-bezierData.points[j].point[k])*segmentPerc;}break;}if(j<jLen-1){j+=1;}else {flag=false;}}caching._lastPoint=j;caching._lastAddedLength=addedLength-bezierData.points[j].partialLength;caching._lastKeyframeIndex=i;}}else {var outX;var outY;var inX;var inY;var keyValue;len=keyData.s.length;endValue=nextKeyData.s||keyData.e;if(this.sh&&keyData.h!==1){if(frameNum>=nextKeyTime){newValue[0]=endValue[0];newValue[1]=endValue[1];newValue[2]=endValue[2];}else if(frameNum<=keyTime){newValue[0]=keyData.s[0];newValue[1]=keyData.s[1];newValue[2]=keyData.s[2];}else {var quatStart=createQuaternion(keyData.s);var quatEnd=createQuaternion(endValue);var time=(frameNum-keyTime)/(nextKeyTime-keyTime);quaternionToEuler(newValue,slerp(quatStart,quatEnd,time));}}else {for(i=0;i<len;i+=1){if(keyData.h!==1){if(frameNum>=nextKeyTime){perc=1;}else if(frameNum<keyTime){perc=0;}else {if(keyData.o.x.constructor===Array){if(!keyframeMetadata.__fnct){keyframeMetadata.__fnct=[];}if(!keyframeMetadata.__fnct[i]){outX=keyData.o.x[i]===undefined?keyData.o.x[0]:keyData.o.x[i];outY=keyData.o.y[i]===undefined?keyData.o.y[0]:keyData.o.y[i];inX=keyData.i.x[i]===undefined?keyData.i.x[0]:keyData.i.x[i];inY=keyData.i.y[i]===undefined?keyData.i.y[0]:keyData.i.y[i];fnc=BezierFactory.getBezierEasing(outX,outY,inX,inY).get;keyframeMetadata.__fnct[i]=fnc;}else {fnc=keyframeMetadata.__fnct[i];}}else if(!keyframeMetadata.__fnct){outX=keyData.o.x;outY=keyData.o.y;inX=keyData.i.x;inY=keyData.i.y;fnc=BezierFactory.getBezierEasing(outX,outY,inX,inY).get;keyData.keyframeMetadata=fnc;}else {fnc=keyframeMetadata.__fnct;}perc=fnc((frameNum-keyTime)/(nextKeyTime-keyTime));}}endValue=nextKeyData.s||keyData.e;keyValue=keyData.h===1?keyData.s[i]:keyData.s[i]+(endValue[i]-keyData.s[i])*perc;if(this.propType==='multidimensional'){newValue[i]=keyValue;}else {newValue=keyValue;}}}}caching.lastIndex=iterationIndex;return newValue;}// based on @Toji's https://github.com/toji/gl-matrix/
function slerp(a,b,t){var out=[];var ax=a[0];var ay=a[1];var az=a[2];var aw=a[3];var bx=b[0];var by=b[1];var bz=b[2];var bw=b[3];var omega;var cosom;var sinom;var scale0;var scale1;cosom=ax*bx+ay*by+az*bz+aw*bw;if(cosom<0.0){cosom=-cosom;bx=-bx;by=-by;bz=-bz;bw=-bw;}if(1.0-cosom>0.000001){omega=Math.acos(cosom);sinom=Math.sin(omega);scale0=Math.sin((1.0-t)*omega)/sinom;scale1=Math.sin(t*omega)/sinom;}else {scale0=1.0-t;scale1=t;}out[0]=scale0*ax+scale1*bx;out[1]=scale0*ay+scale1*by;out[2]=scale0*az+scale1*bz;out[3]=scale0*aw+scale1*bw;return out;}function quaternionToEuler(out,quat){var qx=quat[0];var qy=quat[1];var qz=quat[2];var qw=quat[3];var heading=Math.atan2(2*qy*qw-2*qx*qz,1-2*qy*qy-2*qz*qz);var attitude=Math.asin(2*qx*qy+2*qz*qw);var bank=Math.atan2(2*qx*qw-2*qy*qz,1-2*qx*qx-2*qz*qz);out[0]=heading/degToRads;out[1]=attitude/degToRads;out[2]=bank/degToRads;}function createQuaternion(values){var heading=values[0]*degToRads;var attitude=values[1]*degToRads;var bank=values[2]*degToRads;var c1=Math.cos(heading/2);var c2=Math.cos(attitude/2);var c3=Math.cos(bank/2);var s1=Math.sin(heading/2);var s2=Math.sin(attitude/2);var s3=Math.sin(bank/2);var w=c1*c2*c3-s1*s2*s3;var x=s1*s2*c3+c1*c2*s3;var y=s1*c2*c3+c1*s2*s3;var z=c1*s2*c3-s1*c2*s3;return [x,y,z,w];}function getValueAtCurrentTime(){var frameNum=this.comp.renderedFrame-this.offsetTime;var initTime=this.keyframes[0].t-this.offsetTime;var endTime=this.keyframes[this.keyframes.length-1].t-this.offsetTime;if(!(frameNum===this._caching.lastFrame||this._caching.lastFrame!==initFrame&&(this._caching.lastFrame>=endTime&&frameNum>=endTime||this._caching.lastFrame<initTime&&frameNum<initTime))){if(this._caching.lastFrame>=frameNum){this._caching._lastKeyframeIndex=-1;this._caching.lastIndex=0;}var renderResult=this.interpolateValue(frameNum,this._caching);this.pv=renderResult;}this._caching.lastFrame=frameNum;return this.pv;}function setVValue(val){var multipliedValue;if(this.propType==='unidimensional'){multipliedValue=val*this.mult;if(mathAbs(this.v-multipliedValue)>0.00001){this.v=multipliedValue;this._mdf=true;}}else {var i=0;var len=this.v.length;while(i<len){multipliedValue=val[i]*this.mult;if(mathAbs(this.v[i]-multipliedValue)>0.00001){this.v[i]=multipliedValue;this._mdf=true;}i+=1;}}}function processEffectsSequence(){if(this.elem.globalData.frameId===this.frameId||!this.effectsSequence.length){return;}if(this.lock){this.setVValue(this.pv);return;}this.lock=true;this._mdf=this._isFirstFrame;var i;var len=this.effectsSequence.length;var finalValue=this.kf?this.pv:this.data.k;for(i=0;i<len;i+=1){finalValue=this.effectsSequence[i](finalValue);}this.setVValue(finalValue);this._isFirstFrame=false;this.lock=false;this.frameId=this.elem.globalData.frameId;}function addEffect(effectFunction){this.effectsSequence.push(effectFunction);this.container.addDynamicProperty(this);}function ValueProperty(elem,data,mult,container){this.propType='unidimensional';this.mult=mult||1;this.data=data;this.v=mult?data.k*mult:data.k;this.pv=data.k;this._mdf=false;this.elem=elem;this.container=container;this.comp=elem.comp;this.k=false;this.kf=false;this.vel=0;this.effectsSequence=[];this._isFirstFrame=true;this.getValue=processEffectsSequence;this.setVValue=setVValue;this.addEffect=addEffect;}function MultiDimensionalProperty(elem,data,mult,container){this.propType='multidimensional';this.mult=mult||1;this.data=data;this._mdf=false;this.elem=elem;this.container=container;this.comp=elem.comp;this.k=false;this.kf=false;this.frameId=-1;var i;var len=data.k.length;this.v=createTypedArray('float32',len);this.pv=createTypedArray('float32',len);this.vel=createTypedArray('float32',len);for(i=0;i<len;i+=1){this.v[i]=data.k[i]*this.mult;this.pv[i]=data.k[i];}this._isFirstFrame=true;this.effectsSequence=[];this.getValue=processEffectsSequence;this.setVValue=setVValue;this.addEffect=addEffect;}function KeyframedValueProperty(elem,data,mult,container){this.propType='unidimensional';this.keyframes=data.k;this.keyframesMetadata=[];this.offsetTime=elem.data.st;this.frameId=-1;this._caching={lastFrame:initFrame,lastIndex:0,value:0,_lastKeyframeIndex:-1};this.k=true;this.kf=true;this.data=data;this.mult=mult||1;this.elem=elem;this.container=container;this.comp=elem.comp;this.v=initFrame;this.pv=initFrame;this._isFirstFrame=true;this.getValue=processEffectsSequence;this.setVValue=setVValue;this.interpolateValue=interpolateValue;this.effectsSequence=[getValueAtCurrentTime.bind(this)];this.addEffect=addEffect;}function KeyframedMultidimensionalProperty(elem,data,mult,container){this.propType='multidimensional';var i;var len=data.k.length;var s;var e;var to;var ti;for(i=0;i<len-1;i+=1){if(data.k[i].to&&data.k[i].s&&data.k[i+1]&&data.k[i+1].s){s=data.k[i].s;e=data.k[i+1].s;to=data.k[i].to;ti=data.k[i].ti;if(s.length===2&&!(s[0]===e[0]&&s[1]===e[1])&&bez.pointOnLine2D(s[0],s[1],e[0],e[1],s[0]+to[0],s[1]+to[1])&&bez.pointOnLine2D(s[0],s[1],e[0],e[1],e[0]+ti[0],e[1]+ti[1])||s.length===3&&!(s[0]===e[0]&&s[1]===e[1]&&s[2]===e[2])&&bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],s[0]+to[0],s[1]+to[1],s[2]+to[2])&&bez.pointOnLine3D(s[0],s[1],s[2],e[0],e[1],e[2],e[0]+ti[0],e[1]+ti[1],e[2]+ti[2])){data.k[i].to=null;data.k[i].ti=null;}if(s[0]===e[0]&&s[1]===e[1]&&to[0]===0&&to[1]===0&&ti[0]===0&&ti[1]===0){if(s.length===2||s[2]===e[2]&&to[2]===0&&ti[2]===0){data.k[i].to=null;data.k[i].ti=null;}}}}this.effectsSequence=[getValueAtCurrentTime.bind(this)];this.data=data;this.keyframes=data.k;this.keyframesMetadata=[];this.offsetTime=elem.data.st;this.k=true;this.kf=true;this._isFirstFrame=true;this.mult=mult||1;this.elem=elem;this.container=container;this.comp=elem.comp;this.getValue=processEffectsSequence;this.setVValue=setVValue;this.interpolateValue=interpolateValue;this.frameId=-1;var arrLen=data.k[0].s.length;this.v=createTypedArray('float32',arrLen);this.pv=createTypedArray('float32',arrLen);for(i=0;i<arrLen;i+=1){this.v[i]=initFrame;this.pv[i]=initFrame;}this._caching={lastFrame:initFrame,lastIndex:0,value:createTypedArray('float32',arrLen)};this.addEffect=addEffect;}var PropertyFactory=function(){function getProp(elem,data,type,mult,container){if(data.sid){data=elem.globalData.slotManager.getProp(data);}var p;if(!data.k.length){p=new ValueProperty(elem,data,mult,container);}else if(typeof data.k[0]==='number'){p=new MultiDimensionalProperty(elem,data,mult,container);}else {switch(type){case 0:p=new KeyframedValueProperty(elem,data,mult,container);break;case 1:p=new KeyframedMultidimensionalProperty(elem,data,mult,container);break;}}if(p.effectsSequence.length){container.addDynamicProperty(p);}return p;}var ob={getProp:getProp};return ob;}();function DynamicPropertyContainer(){}DynamicPropertyContainer.prototype={addDynamicProperty:function addDynamicProperty(prop){if(this.dynamicProperties.indexOf(prop)===-1){this.dynamicProperties.push(prop);this.container.addDynamicProperty(this);this._isAnimated=true;}},iterateDynamicProperties:function iterateDynamicProperties(){this._mdf=false;var i;var len=this.dynamicProperties.length;for(i=0;i<len;i+=1){this.dynamicProperties[i].getValue();if(this.dynamicProperties[i]._mdf){this._mdf=true;}}},initDynamicPropertyContainer:function initDynamicPropertyContainer(container){this.container=container;this.dynamicProperties=[];this._mdf=false;this._isAnimated=false;}};var pointPool=function(){function create(){return createTypedArray('float32',2);}return poolFactory(8,create);}();function ShapePath(){this.c=false;this._length=0;this._maxLength=8;this.v=createSizedArray(this._maxLength);this.o=createSizedArray(this._maxLength);this.i=createSizedArray(this._maxLength);}ShapePath.prototype.setPathData=function(closed,len){this.c=closed;this.setLength(len);var i=0;while(i<len){this.v[i]=pointPool.newElement();this.o[i]=pointPool.newElement();this.i[i]=pointPool.newElement();i+=1;}};ShapePath.prototype.setLength=function(len){while(this._maxLength<len){this.doubleArrayLength();}this._length=len;};ShapePath.prototype.doubleArrayLength=function(){this.v=this.v.concat(createSizedArray(this._maxLength));this.i=this.i.concat(createSizedArray(this._maxLength));this.o=this.o.concat(createSizedArray(this._maxLength));this._maxLength*=2;};ShapePath.prototype.setXYAt=function(x,y,type,pos,replace){var arr;this._length=Math.max(this._length,pos+1);if(this._length>=this._maxLength){this.doubleArrayLength();}switch(type){case'v':arr=this.v;break;case'i':arr=this.i;break;case'o':arr=this.o;break;default:arr=[];break;}if(!arr[pos]||arr[pos]&&!replace){arr[pos]=pointPool.newElement();}arr[pos][0]=x;arr[pos][1]=y;};ShapePath.prototype.setTripleAt=function(vX,vY,oX,oY,iX,iY,pos,replace){this.setXYAt(vX,vY,'v',pos,replace);this.setXYAt(oX,oY,'o',pos,replace);this.setXYAt(iX,iY,'i',pos,replace);};ShapePath.prototype.reverse=function(){var newPath=new ShapePath();newPath.setPathData(this.c,this._length);var vertices=this.v;var outPoints=this.o;var inPoints=this.i;var init=0;if(this.c){newPath.setTripleAt(vertices[0][0],vertices[0][1],inPoints[0][0],inPoints[0][1],outPoints[0][0],outPoints[0][1],0,false);init=1;}var cnt=this._length-1;var len=this._length;var i;for(i=init;i<len;i+=1){newPath.setTripleAt(vertices[cnt][0],vertices[cnt][1],inPoints[cnt][0],inPoints[cnt][1],outPoints[cnt][0],outPoints[cnt][1],i,false);cnt-=1;}return newPath;};ShapePath.prototype.length=function(){return this._length;};var shapePool=function(){function create(){return new ShapePath();}function release(shapePath){var len=shapePath._length;var i;for(i=0;i<len;i+=1){pointPool.release(shapePath.v[i]);pointPool.release(shapePath.i[i]);pointPool.release(shapePath.o[i]);shapePath.v[i]=null;shapePath.i[i]=null;shapePath.o[i]=null;}shapePath._length=0;shapePath.c=false;}function clone(shape){var cloned=factory.newElement();var i;var len=shape._length===undefined?shape.v.length:shape._length;cloned.setLength(len);cloned.c=shape.c;for(i=0;i<len;i+=1){cloned.setTripleAt(shape.v[i][0],shape.v[i][1],shape.o[i][0],shape.o[i][1],shape.i[i][0],shape.i[i][1],i);}return cloned;}var factory=poolFactory(4,create,release);factory.clone=clone;return factory;}();function ShapeCollection(){this._length=0;this._maxLength=4;this.shapes=createSizedArray(this._maxLength);}ShapeCollection.prototype.addShape=function(shapeData){if(this._length===this._maxLength){this.shapes=this.shapes.concat(createSizedArray(this._maxLength));this._maxLength*=2;}this.shapes[this._length]=shapeData;this._length+=1;};ShapeCollection.prototype.releaseShapes=function(){var i;for(i=0;i<this._length;i+=1){shapePool.release(this.shapes[i]);}this._length=0;};var shapeCollectionPool=function(){var ob={newShapeCollection:newShapeCollection,release:release};var _length=0;var _maxLength=4;var pool=createSizedArray(_maxLength);function newShapeCollection(){var shapeCollection;if(_length){_length-=1;shapeCollection=pool[_length];}else {shapeCollection=new ShapeCollection();}return shapeCollection;}function release(shapeCollection){var i;var len=shapeCollection._length;for(i=0;i<len;i+=1){shapePool.release(shapeCollection.shapes[i]);}shapeCollection._length=0;if(_length===_maxLength){pool=pooling["double"](pool);_maxLength*=2;}pool[_length]=shapeCollection;_length+=1;}return ob;}();var ShapePropertyFactory=function(){var initFrame=-999999;function interpolateShape(frameNum,previousValue,caching){var iterationIndex=caching.lastIndex;var keyPropS;var keyPropE;var isHold;var j;var k;var jLen;var kLen;var perc;var vertexValue;var kf=this.keyframes;if(frameNum<kf[0].t-this.offsetTime){keyPropS=kf[0].s[0];isHold=true;iterationIndex=0;}else if(frameNum>=kf[kf.length-1].t-this.offsetTime){keyPropS=kf[kf.length-1].s?kf[kf.length-1].s[0]:kf[kf.length-2].e[0];/* if(kf[kf.length - 1].s){
	                  keyPropS = kf[kf.length - 1].s[0];
	              }else{
	                  keyPropS = kf[kf.length - 2].e[0];
	              } */isHold=true;}else {var i=iterationIndex;var len=kf.length-1;var flag=true;var keyData;var nextKeyData;var keyframeMetadata;while(flag){keyData=kf[i];nextKeyData=kf[i+1];if(nextKeyData.t-this.offsetTime>frameNum){break;}if(i<len-1){i+=1;}else {flag=false;}}keyframeMetadata=this.keyframesMetadata[i]||{};isHold=keyData.h===1;iterationIndex=i;if(!isHold){if(frameNum>=nextKeyData.t-this.offsetTime){perc=1;}else if(frameNum<keyData.t-this.offsetTime){perc=0;}else {var fnc;if(keyframeMetadata.__fnct){fnc=keyframeMetadata.__fnct;}else {fnc=BezierFactory.getBezierEasing(keyData.o.x,keyData.o.y,keyData.i.x,keyData.i.y).get;keyframeMetadata.__fnct=fnc;}perc=fnc((frameNum-(keyData.t-this.offsetTime))/(nextKeyData.t-this.offsetTime-(keyData.t-this.offsetTime)));}keyPropE=nextKeyData.s?nextKeyData.s[0]:keyData.e[0];}keyPropS=keyData.s[0];}jLen=previousValue._length;kLen=keyPropS.i[0].length;caching.lastIndex=iterationIndex;for(j=0;j<jLen;j+=1){for(k=0;k<kLen;k+=1){vertexValue=isHold?keyPropS.i[j][k]:keyPropS.i[j][k]+(keyPropE.i[j][k]-keyPropS.i[j][k])*perc;previousValue.i[j][k]=vertexValue;vertexValue=isHold?keyPropS.o[j][k]:keyPropS.o[j][k]+(keyPropE.o[j][k]-keyPropS.o[j][k])*perc;previousValue.o[j][k]=vertexValue;vertexValue=isHold?keyPropS.v[j][k]:keyPropS.v[j][k]+(keyPropE.v[j][k]-keyPropS.v[j][k])*perc;previousValue.v[j][k]=vertexValue;}}}function interpolateShapeCurrentTime(){var frameNum=this.comp.renderedFrame-this.offsetTime;var initTime=this.keyframes[0].t-this.offsetTime;var endTime=this.keyframes[this.keyframes.length-1].t-this.offsetTime;var lastFrame=this._caching.lastFrame;if(!(lastFrame!==initFrame&&(lastFrame<initTime&&frameNum<initTime||lastFrame>endTime&&frameNum>endTime))){/// /
this._caching.lastIndex=lastFrame<frameNum?this._caching.lastIndex:0;this.interpolateShape(frameNum,this.pv,this._caching);/// /
}this._caching.lastFrame=frameNum;return this.pv;}function resetShape(){this.paths=this.localShapeCollection;}function shapesEqual(shape1,shape2){if(shape1._length!==shape2._length||shape1.c!==shape2.c){return false;}var i;var len=shape1._length;for(i=0;i<len;i+=1){if(shape1.v[i][0]!==shape2.v[i][0]||shape1.v[i][1]!==shape2.v[i][1]||shape1.o[i][0]!==shape2.o[i][0]||shape1.o[i][1]!==shape2.o[i][1]||shape1.i[i][0]!==shape2.i[i][0]||shape1.i[i][1]!==shape2.i[i][1]){return false;}}return true;}function setVValue(newPath){if(!shapesEqual(this.v,newPath)){this.v=shapePool.clone(newPath);this.localShapeCollection.releaseShapes();this.localShapeCollection.addShape(this.v);this._mdf=true;this.paths=this.localShapeCollection;}}function processEffectsSequence(){if(this.elem.globalData.frameId===this.frameId){return;}if(!this.effectsSequence.length){this._mdf=false;return;}if(this.lock){this.setVValue(this.pv);return;}this.lock=true;this._mdf=false;var finalValue;if(this.kf){finalValue=this.pv;}else if(this.data.ks){finalValue=this.data.ks.k;}else {finalValue=this.data.pt.k;}var i;var len=this.effectsSequence.length;for(i=0;i<len;i+=1){finalValue=this.effectsSequence[i](finalValue);}this.setVValue(finalValue);this.lock=false;this.frameId=this.elem.globalData.frameId;}function ShapeProperty(elem,data,type){this.propType='shape';this.comp=elem.comp;this.container=elem;this.elem=elem;this.data=data;this.k=false;this.kf=false;this._mdf=false;var pathData=type===3?data.pt.k:data.ks.k;this.v=shapePool.clone(pathData);this.pv=shapePool.clone(this.v);this.localShapeCollection=shapeCollectionPool.newShapeCollection();this.paths=this.localShapeCollection;this.paths.addShape(this.v);this.reset=resetShape;this.effectsSequence=[];}function addEffect(effectFunction){this.effectsSequence.push(effectFunction);this.container.addDynamicProperty(this);}ShapeProperty.prototype.interpolateShape=interpolateShape;ShapeProperty.prototype.getValue=processEffectsSequence;ShapeProperty.prototype.setVValue=setVValue;ShapeProperty.prototype.addEffect=addEffect;function KeyframedShapeProperty(elem,data,type){this.propType='shape';this.comp=elem.comp;this.elem=elem;this.container=elem;this.offsetTime=elem.data.st;this.keyframes=type===3?data.pt.k:data.ks.k;this.keyframesMetadata=[];this.k=true;this.kf=true;var len=this.keyframes[0].s[0].i.length;this.v=shapePool.newElement();this.v.setPathData(this.keyframes[0].s[0].c,len);this.pv=shapePool.clone(this.v);this.localShapeCollection=shapeCollectionPool.newShapeCollection();this.paths=this.localShapeCollection;this.paths.addShape(this.v);this.lastFrame=initFrame;this.reset=resetShape;this._caching={lastFrame:initFrame,lastIndex:0};this.effectsSequence=[interpolateShapeCurrentTime.bind(this)];}KeyframedShapeProperty.prototype.getValue=processEffectsSequence;KeyframedShapeProperty.prototype.interpolateShape=interpolateShape;KeyframedShapeProperty.prototype.setVValue=setVValue;KeyframedShapeProperty.prototype.addEffect=addEffect;var EllShapeProperty=function(){var cPoint=roundCorner;function EllShapePropertyFactory(elem,data){this.v=shapePool.newElement();this.v.setPathData(true,4);this.localShapeCollection=shapeCollectionPool.newShapeCollection();this.paths=this.localShapeCollection;this.localShapeCollection.addShape(this.v);this.d=data.d;this.elem=elem;this.comp=elem.comp;this.frameId=-1;this.initDynamicPropertyContainer(elem);this.p=PropertyFactory.getProp(elem,data.p,1,0,this);this.s=PropertyFactory.getProp(elem,data.s,1,0,this);if(this.dynamicProperties.length){this.k=true;}else {this.k=false;this.convertEllToPath();}}EllShapePropertyFactory.prototype={reset:resetShape,getValue:function getValue(){if(this.elem.globalData.frameId===this.frameId){return;}this.frameId=this.elem.globalData.frameId;this.iterateDynamicProperties();if(this._mdf){this.convertEllToPath();}},convertEllToPath:function convertEllToPath(){var p0=this.p.v[0];var p1=this.p.v[1];var s0=this.s.v[0]/2;var s1=this.s.v[1]/2;var _cw=this.d!==3;var _v=this.v;_v.v[0][0]=p0;_v.v[0][1]=p1-s1;_v.v[1][0]=_cw?p0+s0:p0-s0;_v.v[1][1]=p1;_v.v[2][0]=p0;_v.v[2][1]=p1+s1;_v.v[3][0]=_cw?p0-s0:p0+s0;_v.v[3][1]=p1;_v.i[0][0]=_cw?p0-s0*cPoint:p0+s0*cPoint;_v.i[0][1]=p1-s1;_v.i[1][0]=_cw?p0+s0:p0-s0;_v.i[1][1]=p1-s1*cPoint;_v.i[2][0]=_cw?p0+s0*cPoint:p0-s0*cPoint;_v.i[2][1]=p1+s1;_v.i[3][0]=_cw?p0-s0:p0+s0;_v.i[3][1]=p1+s1*cPoint;_v.o[0][0]=_cw?p0+s0*cPoint:p0-s0*cPoint;_v.o[0][1]=p1-s1;_v.o[1][0]=_cw?p0+s0:p0-s0;_v.o[1][1]=p1+s1*cPoint;_v.o[2][0]=_cw?p0-s0*cPoint:p0+s0*cPoint;_v.o[2][1]=p1+s1;_v.o[3][0]=_cw?p0-s0:p0+s0;_v.o[3][1]=p1-s1*cPoint;}};extendPrototype([DynamicPropertyContainer],EllShapePropertyFactory);return EllShapePropertyFactory;}();var StarShapeProperty=function(){function StarShapePropertyFactory(elem,data){this.v=shapePool.newElement();this.v.setPathData(true,0);this.elem=elem;this.comp=elem.comp;this.data=data;this.frameId=-1;this.d=data.d;this.initDynamicPropertyContainer(elem);if(data.sy===1){this.ir=PropertyFactory.getProp(elem,data.ir,0,0,this);this.is=PropertyFactory.getProp(elem,data.is,0,0.01,this);this.convertToPath=this.convertStarToPath;}else {this.convertToPath=this.convertPolygonToPath;}this.pt=PropertyFactory.getProp(elem,data.pt,0,0,this);this.p=PropertyFactory.getProp(elem,data.p,1,0,this);this.r=PropertyFactory.getProp(elem,data.r,0,degToRads,this);this.or=PropertyFactory.getProp(elem,data.or,0,0,this);this.os=PropertyFactory.getProp(elem,data.os,0,0.01,this);this.localShapeCollection=shapeCollectionPool.newShapeCollection();this.localShapeCollection.addShape(this.v);this.paths=this.localShapeCollection;if(this.dynamicProperties.length){this.k=true;}else {this.k=false;this.convertToPath();}}StarShapePropertyFactory.prototype={reset:resetShape,getValue:function getValue(){if(this.elem.globalData.frameId===this.frameId){return;}this.frameId=this.elem.globalData.frameId;this.iterateDynamicProperties();if(this._mdf){this.convertToPath();}},convertStarToPath:function convertStarToPath(){var numPts=Math.floor(this.pt.v)*2;var angle=Math.PI*2/numPts;/* this.v.v.length = numPts;
	                  this.v.i.length = numPts;
	                  this.v.o.length = numPts; */var longFlag=true;var longRad=this.or.v;var shortRad=this.ir.v;var longRound=this.os.v;var shortRound=this.is.v;var longPerimSegment=2*Math.PI*longRad/(numPts*2);var shortPerimSegment=2*Math.PI*shortRad/(numPts*2);var i;var rad;var roundness;var perimSegment;var currentAng=-Math.PI/2;currentAng+=this.r.v;var dir=this.data.d===3?-1:1;this.v._length=0;for(i=0;i<numPts;i+=1){rad=longFlag?longRad:shortRad;roundness=longFlag?longRound:shortRound;perimSegment=longFlag?longPerimSegment:shortPerimSegment;var x=rad*Math.cos(currentAng);var y=rad*Math.sin(currentAng);var ox=x===0&&y===0?0:y/Math.sqrt(x*x+y*y);var oy=x===0&&y===0?0:-x/Math.sqrt(x*x+y*y);x+=+this.p.v[0];y+=+this.p.v[1];this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir,i,true);/* this.v.v[i] = [x,y];
	                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];
	                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];
	                      this.v._length = numPts; */longFlag=!longFlag;currentAng+=angle*dir;}},convertPolygonToPath:function convertPolygonToPath(){var numPts=Math.floor(this.pt.v);var angle=Math.PI*2/numPts;var rad=this.or.v;var roundness=this.os.v;var perimSegment=2*Math.PI*rad/(numPts*4);var i;var currentAng=-Math.PI*0.5;var dir=this.data.d===3?-1:1;currentAng+=this.r.v;this.v._length=0;for(i=0;i<numPts;i+=1){var x=rad*Math.cos(currentAng);var y=rad*Math.sin(currentAng);var ox=x===0&&y===0?0:y/Math.sqrt(x*x+y*y);var oy=x===0&&y===0?0:-x/Math.sqrt(x*x+y*y);x+=+this.p.v[0];y+=+this.p.v[1];this.v.setTripleAt(x,y,x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir,x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir,i,true);currentAng+=angle*dir;}this.paths.length=0;this.paths[0]=this.v;}};extendPrototype([DynamicPropertyContainer],StarShapePropertyFactory);return StarShapePropertyFactory;}();var RectShapeProperty=function(){function RectShapePropertyFactory(elem,data){this.v=shapePool.newElement();this.v.c=true;this.localShapeCollection=shapeCollectionPool.newShapeCollection();this.localShapeCollection.addShape(this.v);this.paths=this.localShapeCollection;this.elem=elem;this.comp=elem.comp;this.frameId=-1;this.d=data.d;this.initDynamicPropertyContainer(elem);this.p=PropertyFactory.getProp(elem,data.p,1,0,this);this.s=PropertyFactory.getProp(elem,data.s,1,0,this);this.r=PropertyFactory.getProp(elem,data.r,0,0,this);if(this.dynamicProperties.length){this.k=true;}else {this.k=false;this.convertRectToPath();}}RectShapePropertyFactory.prototype={convertRectToPath:function convertRectToPath(){var p0=this.p.v[0];var p1=this.p.v[1];var v0=this.s.v[0]/2;var v1=this.s.v[1]/2;var round=bmMin(v0,v1,this.r.v);var cPoint=round*(1-roundCorner);this.v._length=0;if(this.d===2||this.d===1){this.v.setTripleAt(p0+v0,p1-v1+round,p0+v0,p1-v1+round,p0+v0,p1-v1+cPoint,0,true);this.v.setTripleAt(p0+v0,p1+v1-round,p0+v0,p1+v1-cPoint,p0+v0,p1+v1-round,1,true);if(round!==0){this.v.setTripleAt(p0+v0-round,p1+v1,p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,2,true);this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,p0-v0+round,p1+v1,3,true);this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,4,true);this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,p0-v0,p1-v1+round,5,true);this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,6,true);this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,p0+v0-round,p1-v1,7,true);}else {this.v.setTripleAt(p0-v0,p1+v1,p0-v0+cPoint,p1+v1,p0-v0,p1+v1,2);this.v.setTripleAt(p0-v0,p1-v1,p0-v0,p1-v1+cPoint,p0-v0,p1-v1,3);}}else {this.v.setTripleAt(p0+v0,p1-v1+round,p0+v0,p1-v1+cPoint,p0+v0,p1-v1+round,0,true);if(round!==0){this.v.setTripleAt(p0+v0-round,p1-v1,p0+v0-round,p1-v1,p0+v0-cPoint,p1-v1,1,true);this.v.setTripleAt(p0-v0+round,p1-v1,p0-v0+cPoint,p1-v1,p0-v0+round,p1-v1,2,true);this.v.setTripleAt(p0-v0,p1-v1+round,p0-v0,p1-v1+round,p0-v0,p1-v1+cPoint,3,true);this.v.setTripleAt(p0-v0,p1+v1-round,p0-v0,p1+v1-cPoint,p0-v0,p1+v1-round,4,true);this.v.setTripleAt(p0-v0+round,p1+v1,p0-v0+round,p1+v1,p0-v0+cPoint,p1+v1,5,true);this.v.setTripleAt(p0+v0-round,p1+v1,p0+v0-cPoint,p1+v1,p0+v0-round,p1+v1,6,true);this.v.setTripleAt(p0+v0,p1+v1-round,p0+v0,p1+v1-round,p0+v0,p1+v1-cPoint,7,true);}else {this.v.setTripleAt(p0-v0,p1-v1,p0-v0+cPoint,p1-v1,p0-v0,p1-v1,1,true);this.v.setTripleAt(p0-v0,p1+v1,p0-v0,p1+v1-cPoint,p0-v0,p1+v1,2,true);this.v.setTripleAt(p0+v0,p1+v1,p0+v0-cPoint,p1+v1,p0+v0,p1+v1,3,true);}}},getValue:function getValue(){if(this.elem.globalData.frameId===this.frameId){return;}this.frameId=this.elem.globalData.frameId;this.iterateDynamicProperties();if(this._mdf){this.convertRectToPath();}},reset:resetShape};extendPrototype([DynamicPropertyContainer],RectShapePropertyFactory);return RectShapePropertyFactory;}();function getShapeProp(elem,data,type){var prop;if(type===3||type===4){var dataProp=type===3?data.pt:data.ks;var keys=dataProp.k;if(keys.length){prop=new KeyframedShapeProperty(elem,data,type);}else {prop=new ShapeProperty(elem,data,type);}}else if(type===5){prop=new RectShapeProperty(elem,data);}else if(type===6){prop=new EllShapeProperty(elem,data);}else if(type===7){prop=new StarShapeProperty(elem,data);}if(prop.k){elem.addDynamicProperty(prop);}return prop;}function getConstructorFunction(){return ShapeProperty;}function getKeyframedConstructorFunction(){return KeyframedShapeProperty;}var ob={};ob.getShapeProp=getShapeProp;ob.getConstructorFunction=getConstructorFunction;ob.getKeyframedConstructorFunction=getKeyframedConstructorFunction;return ob;}();/*!
	   Transformation Matrix v2.0
	   (c) Epistemex 2014-2015
	   www.epistemex.com
	   By Ken Fyrstenberg
	   Contributions by leeoniya.
	   License: MIT, header required.
	   */ /**
	   * 2D transformation matrix object initialized with identity matrix.
	   *
	   * The matrix can synchronize a canvas context by supplying the context
	   * as an argument, or later apply current absolute transform to an
	   * existing context.
	   *
	   * All values are handled as floating point values.
	   *
	   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix
	   * @prop {number} a - scale x
	   * @prop {number} b - shear y
	   * @prop {number} c - shear x
	   * @prop {number} d - scale y
	   * @prop {number} e - translate x
	   * @prop {number} f - translate y
	   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context
	   * @constructor
	   */var Matrix=function(){var _cos=Math.cos;var _sin=Math.sin;var _tan=Math.tan;var _rnd=Math.round;function reset(){this.props[0]=1;this.props[1]=0;this.props[2]=0;this.props[3]=0;this.props[4]=0;this.props[5]=1;this.props[6]=0;this.props[7]=0;this.props[8]=0;this.props[9]=0;this.props[10]=1;this.props[11]=0;this.props[12]=0;this.props[13]=0;this.props[14]=0;this.props[15]=1;return this;}function rotate(angle){if(angle===0){return this;}var mCos=_cos(angle);var mSin=_sin(angle);return this._t(mCos,-mSin,0,0,mSin,mCos,0,0,0,0,1,0,0,0,0,1);}function rotateX(angle){if(angle===0){return this;}var mCos=_cos(angle);var mSin=_sin(angle);return this._t(1,0,0,0,0,mCos,-mSin,0,0,mSin,mCos,0,0,0,0,1);}function rotateY(angle){if(angle===0){return this;}var mCos=_cos(angle);var mSin=_sin(angle);return this._t(mCos,0,mSin,0,0,1,0,0,-mSin,0,mCos,0,0,0,0,1);}function rotateZ(angle){if(angle===0){return this;}var mCos=_cos(angle);var mSin=_sin(angle);return this._t(mCos,-mSin,0,0,mSin,mCos,0,0,0,0,1,0,0,0,0,1);}function shear(sx,sy){return this._t(1,sy,sx,1,0,0);}function skew(ax,ay){return this.shear(_tan(ax),_tan(ay));}function skewFromAxis(ax,angle){var mCos=_cos(angle);var mSin=_sin(angle);return this._t(mCos,mSin,0,0,-mSin,mCos,0,0,0,0,1,0,0,0,0,1)._t(1,0,0,0,_tan(ax),1,0,0,0,0,1,0,0,0,0,1)._t(mCos,-mSin,0,0,mSin,mCos,0,0,0,0,1,0,0,0,0,1);// return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);
}function scale(sx,sy,sz){if(!sz&&sz!==0){sz=1;}if(sx===1&&sy===1&&sz===1){return this;}return this._t(sx,0,0,0,0,sy,0,0,0,0,sz,0,0,0,0,1);}function setTransform(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p){this.props[0]=a;this.props[1]=b;this.props[2]=c;this.props[3]=d;this.props[4]=e;this.props[5]=f;this.props[6]=g;this.props[7]=h;this.props[8]=i;this.props[9]=j;this.props[10]=k;this.props[11]=l;this.props[12]=m;this.props[13]=n;this.props[14]=o;this.props[15]=p;return this;}function translate(tx,ty,tz){tz=tz||0;if(tx!==0||ty!==0||tz!==0){return this._t(1,0,0,0,0,1,0,0,0,0,1,0,tx,ty,tz,1);}return this;}function transform(a2,b2,c2,d2,e2,f2,g2,h2,i2,j2,k2,l2,m2,n2,o2,p2){var _p=this.props;if(a2===1&&b2===0&&c2===0&&d2===0&&e2===0&&f2===1&&g2===0&&h2===0&&i2===0&&j2===0&&k2===1&&l2===0){// NOTE: commenting this condition because TurboFan deoptimizes code when present
// if(m2 !== 0 || n2 !== 0 || o2 !== 0){
_p[12]=_p[12]*a2+_p[15]*m2;_p[13]=_p[13]*f2+_p[15]*n2;_p[14]=_p[14]*k2+_p[15]*o2;_p[15]*=p2;// }
this._identityCalculated=false;return this;}var a1=_p[0];var b1=_p[1];var c1=_p[2];var d1=_p[3];var e1=_p[4];var f1=_p[5];var g1=_p[6];var h1=_p[7];var i1=_p[8];var j1=_p[9];var k1=_p[10];var l1=_p[11];var m1=_p[12];var n1=_p[13];var o1=_p[14];var p1=_p[15];/* matrix order (canvas compatible):
	           * ace
	           * bdf
	           * 001
	           */_p[0]=a1*a2+b1*e2+c1*i2+d1*m2;_p[1]=a1*b2+b1*f2+c1*j2+d1*n2;_p[2]=a1*c2+b1*g2+c1*k2+d1*o2;_p[3]=a1*d2+b1*h2+c1*l2+d1*p2;_p[4]=e1*a2+f1*e2+g1*i2+h1*m2;_p[5]=e1*b2+f1*f2+g1*j2+h1*n2;_p[6]=e1*c2+f1*g2+g1*k2+h1*o2;_p[7]=e1*d2+f1*h2+g1*l2+h1*p2;_p[8]=i1*a2+j1*e2+k1*i2+l1*m2;_p[9]=i1*b2+j1*f2+k1*j2+l1*n2;_p[10]=i1*c2+j1*g2+k1*k2+l1*o2;_p[11]=i1*d2+j1*h2+k1*l2+l1*p2;_p[12]=m1*a2+n1*e2+o1*i2+p1*m2;_p[13]=m1*b2+n1*f2+o1*j2+p1*n2;_p[14]=m1*c2+n1*g2+o1*k2+p1*o2;_p[15]=m1*d2+n1*h2+o1*l2+p1*p2;this._identityCalculated=false;return this;}function multiply(matrix){var matrixProps=matrix.props;return this.transform(matrixProps[0],matrixProps[1],matrixProps[2],matrixProps[3],matrixProps[4],matrixProps[5],matrixProps[6],matrixProps[7],matrixProps[8],matrixProps[9],matrixProps[10],matrixProps[11],matrixProps[12],matrixProps[13],matrixProps[14],matrixProps[15]);}function isIdentity(){if(!this._identityCalculated){this._identity=!(this.props[0]!==1||this.props[1]!==0||this.props[2]!==0||this.props[3]!==0||this.props[4]!==0||this.props[5]!==1||this.props[6]!==0||this.props[7]!==0||this.props[8]!==0||this.props[9]!==0||this.props[10]!==1||this.props[11]!==0||this.props[12]!==0||this.props[13]!==0||this.props[14]!==0||this.props[15]!==1);this._identityCalculated=true;}return this._identity;}function equals(matr){var i=0;while(i<16){if(matr.props[i]!==this.props[i]){return false;}i+=1;}return true;}function clone(matr){var i;for(i=0;i<16;i+=1){matr.props[i]=this.props[i];}return matr;}function cloneFromProps(props){var i;for(i=0;i<16;i+=1){this.props[i]=props[i];}}function applyToPoint(x,y,z){return {x:x*this.props[0]+y*this.props[4]+z*this.props[8]+this.props[12],y:x*this.props[1]+y*this.props[5]+z*this.props[9]+this.props[13],z:x*this.props[2]+y*this.props[6]+z*this.props[10]+this.props[14]};/* return {
	           x: x * me.a + y * me.c + me.e,
	           y: x * me.b + y * me.d + me.f
	           }; */}function applyToX(x,y,z){return x*this.props[0]+y*this.props[4]+z*this.props[8]+this.props[12];}function applyToY(x,y,z){return x*this.props[1]+y*this.props[5]+z*this.props[9]+this.props[13];}function applyToZ(x,y,z){return x*this.props[2]+y*this.props[6]+z*this.props[10]+this.props[14];}function getInverseMatrix(){var determinant=this.props[0]*this.props[5]-this.props[1]*this.props[4];var a=this.props[5]/determinant;var b=-this.props[1]/determinant;var c=-this.props[4]/determinant;var d=this.props[0]/determinant;var e=(this.props[4]*this.props[13]-this.props[5]*this.props[12])/determinant;var f=-(this.props[0]*this.props[13]-this.props[1]*this.props[12])/determinant;var inverseMatrix=new Matrix();inverseMatrix.props[0]=a;inverseMatrix.props[1]=b;inverseMatrix.props[4]=c;inverseMatrix.props[5]=d;inverseMatrix.props[12]=e;inverseMatrix.props[13]=f;return inverseMatrix;}function inversePoint(pt){var inverseMatrix=this.getInverseMatrix();return inverseMatrix.applyToPointArray(pt[0],pt[1],pt[2]||0);}function inversePoints(pts){var i;var len=pts.length;var retPts=[];for(i=0;i<len;i+=1){retPts[i]=inversePoint(pts[i]);}return retPts;}function applyToTriplePoints(pt1,pt2,pt3){var arr=createTypedArray('float32',6);if(this.isIdentity()){arr[0]=pt1[0];arr[1]=pt1[1];arr[2]=pt2[0];arr[3]=pt2[1];arr[4]=pt3[0];arr[5]=pt3[1];}else {var p0=this.props[0];var p1=this.props[1];var p4=this.props[4];var p5=this.props[5];var p12=this.props[12];var p13=this.props[13];arr[0]=pt1[0]*p0+pt1[1]*p4+p12;arr[1]=pt1[0]*p1+pt1[1]*p5+p13;arr[2]=pt2[0]*p0+pt2[1]*p4+p12;arr[3]=pt2[0]*p1+pt2[1]*p5+p13;arr[4]=pt3[0]*p0+pt3[1]*p4+p12;arr[5]=pt3[0]*p1+pt3[1]*p5+p13;}return arr;}function applyToPointArray(x,y,z){var arr;if(this.isIdentity()){arr=[x,y,z];}else {arr=[x*this.props[0]+y*this.props[4]+z*this.props[8]+this.props[12],x*this.props[1]+y*this.props[5]+z*this.props[9]+this.props[13],x*this.props[2]+y*this.props[6]+z*this.props[10]+this.props[14]];}return arr;}function applyToPointStringified(x,y){if(this.isIdentity()){return x+','+y;}var _p=this.props;return Math.round((x*_p[0]+y*_p[4]+_p[12])*100)/100+','+Math.round((x*_p[1]+y*_p[5]+_p[13])*100)/100;}function toCSS(){// Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
/* if(this.isIdentity()) {
	              return '';
	          } */var i=0;var props=this.props;var cssValue='matrix3d(';var v=10000;while(i<16){cssValue+=_rnd(props[i]*v)/v;cssValue+=i===15?')':',';i+=1;}return cssValue;}function roundMatrixProperty(val){var v=10000;if(val<0.000001&&val>0||val>-0.000001&&val<0){return _rnd(val*v)/v;}return val;}function to2dCSS(){// Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.
/* if(this.isIdentity()) {
	              return '';
	          } */var props=this.props;var _a=roundMatrixProperty(props[0]);var _b=roundMatrixProperty(props[1]);var _c=roundMatrixProperty(props[4]);var _d=roundMatrixProperty(props[5]);var _e=roundMatrixProperty(props[12]);var _f=roundMatrixProperty(props[13]);return 'matrix('+_a+','+_b+','+_c+','+_d+','+_e+','+_f+')';}return function(){this.reset=reset;this.rotate=rotate;this.rotateX=rotateX;this.rotateY=rotateY;this.rotateZ=rotateZ;this.skew=skew;this.skewFromAxis=skewFromAxis;this.shear=shear;this.scale=scale;this.setTransform=setTransform;this.translate=translate;this.transform=transform;this.multiply=multiply;this.applyToPoint=applyToPoint;this.applyToX=applyToX;this.applyToY=applyToY;this.applyToZ=applyToZ;this.applyToPointArray=applyToPointArray;this.applyToTriplePoints=applyToTriplePoints;this.applyToPointStringified=applyToPointStringified;this.toCSS=toCSS;this.to2dCSS=to2dCSS;this.clone=clone;this.cloneFromProps=cloneFromProps;this.equals=equals;this.inversePoints=inversePoints;this.inversePoint=inversePoint;this.getInverseMatrix=getInverseMatrix;this._t=this.transform;this.isIdentity=isIdentity;this._identity=true;this._identityCalculated=false;this.props=createTypedArray('float32',16);this.reset();};}();function _typeof$3(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof$3=function _typeof(obj){return typeof obj;};}else {_typeof$3=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof$3(obj);}var lottie={};function setLocation(href){setLocationHref(href);}function searchAnimations(){{animationManager.searchAnimations();}}function setSubframeRendering(flag){setSubframeEnabled(flag);}function setPrefix(prefix){setIdPrefix(prefix);}function loadAnimation(params){return animationManager.loadAnimation(params);}function setQuality(value){if(typeof value==='string'){switch(value){case'high':setDefaultCurveSegments(200);break;default:case'medium':setDefaultCurveSegments(50);break;case'low':setDefaultCurveSegments(10);break;}}else if(!isNaN(value)&&value>1){setDefaultCurveSegments(value);}}function inBrowser(){return typeof navigator!=='undefined';}function installPlugin(type,plugin){if(type==='expressions'){setExpressionsPlugin(plugin);}}function getFactory(name){switch(name){case'propertyFactory':return PropertyFactory;case'shapePropertyFactory':return ShapePropertyFactory;case'matrix':return Matrix;default:return null;}}lottie.play=animationManager.play;lottie.pause=animationManager.pause;lottie.setLocationHref=setLocation;lottie.togglePause=animationManager.togglePause;lottie.setSpeed=animationManager.setSpeed;lottie.setDirection=animationManager.setDirection;lottie.stop=animationManager.stop;lottie.searchAnimations=searchAnimations;lottie.registerAnimation=animationManager.registerAnimation;lottie.loadAnimation=loadAnimation;lottie.setSubframeRendering=setSubframeRendering;lottie.resize=animationManager.resize;// lottie.start = start;
lottie.goToAndStop=animationManager.goToAndStop;lottie.destroy=animationManager.destroy;lottie.setQuality=setQuality;lottie.inBrowser=inBrowser;lottie.installPlugin=installPlugin;lottie.freeze=animationManager.freeze;lottie.unfreeze=animationManager.unfreeze;lottie.setVolume=animationManager.setVolume;lottie.mute=animationManager.mute;lottie.unmute=animationManager.unmute;lottie.getRegisteredAnimations=animationManager.getRegisteredAnimations;lottie.useWebWorker=setWebWorker;lottie.setIDPrefix=setPrefix;lottie.__getFactory=getFactory;lottie.version='5.12.2';function checkReady(){if(document.readyState==='complete'){clearInterval(readyStateCheckInterval);searchAnimations();}}function getQueryVariable(variable){var vars=queryString.split('&');for(var i=0;i<vars.length;i+=1){var pair=vars[i].split('=');if(decodeURIComponent(pair[0])==variable){// eslint-disable-line eqeqeq
return decodeURIComponent(pair[1]);}}return null;}var queryString='';{var scripts=document.getElementsByTagName('script');var index=scripts.length-1;var myScript=scripts[index]||{src:''};queryString=myScript.src?myScript.src.replace(/^[^\?]+\??/,''):'';// eslint-disable-line no-useless-escape
getQueryVariable('renderer');}var readyStateCheckInterval=setInterval(checkReady,100);// this adds bodymovin to the window object for backwards compatibility
try{if(!(('object'==="undefined"?"undefined":_typeof$3(exports))==='object'&&'object'!=='undefined')&&!(typeof undefined==='function'&&undefined.amd)// eslint-disable-line no-undef
){window.bodymovin=lottie;}}catch(err){//
}var ShapeModifiers=function(){var ob={};var modifiers={};ob.registerModifier=registerModifier;ob.getModifier=getModifier;function registerModifier(nm,factory){if(!modifiers[nm]){modifiers[nm]=factory;}}function getModifier(nm,elem,data){return new modifiers[nm](elem,data);}return ob;}();function ShapeModifier(){}ShapeModifier.prototype.initModifierProperties=function(){};ShapeModifier.prototype.addShapeToModifier=function(){};ShapeModifier.prototype.addShape=function(data){if(!this.closed){// Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.
data.sh.container.addDynamicProperty(data.sh);var shapeData={shape:data.sh,data:data,localShapeCollection:shapeCollectionPool.newShapeCollection()};this.shapes.push(shapeData);this.addShapeToModifier(shapeData);if(this._isAnimated){data.setAsAnimated();}}};ShapeModifier.prototype.init=function(elem,data){this.shapes=[];this.elem=elem;this.initDynamicPropertyContainer(elem);this.initModifierProperties(elem,data);this.frameId=initialDefaultFrame;this.closed=false;this.k=false;if(this.dynamicProperties.length){this.k=true;}else {this.getValue(true);}};ShapeModifier.prototype.processKeys=function(){if(this.elem.globalData.frameId===this.frameId){return;}this.frameId=this.elem.globalData.frameId;this.iterateDynamicProperties();};extendPrototype([DynamicPropertyContainer],ShapeModifier);function TrimModifier(){}extendPrototype([ShapeModifier],TrimModifier);TrimModifier.prototype.initModifierProperties=function(elem,data){this.s=PropertyFactory.getProp(elem,data.s,0,0.01,this);this.e=PropertyFactory.getProp(elem,data.e,0,0.01,this);this.o=PropertyFactory.getProp(elem,data.o,0,0,this);this.sValue=0;this.eValue=0;this.getValue=this.processKeys;this.m=data.m;this._isAnimated=!!this.s.effectsSequence.length||!!this.e.effectsSequence.length||!!this.o.effectsSequence.length;};TrimModifier.prototype.addShapeToModifier=function(shapeData){shapeData.pathsData=[];};TrimModifier.prototype.calculateShapeEdges=function(s,e,shapeLength,addedLength,totalModifierLength){var segments=[];if(e<=1){segments.push({s:s,e:e});}else if(s>=1){segments.push({s:s-1,e:e-1});}else {segments.push({s:s,e:1});segments.push({s:0,e:e-1});}var shapeSegments=[];var i;var len=segments.length;var segmentOb;for(i=0;i<len;i+=1){segmentOb=segments[i];if(!(segmentOb.e*totalModifierLength<addedLength||segmentOb.s*totalModifierLength>addedLength+shapeLength)){var shapeS;var shapeE;if(segmentOb.s*totalModifierLength<=addedLength){shapeS=0;}else {shapeS=(segmentOb.s*totalModifierLength-addedLength)/shapeLength;}if(segmentOb.e*totalModifierLength>=addedLength+shapeLength){shapeE=1;}else {shapeE=(segmentOb.e*totalModifierLength-addedLength)/shapeLength;}shapeSegments.push([shapeS,shapeE]);}}if(!shapeSegments.length){shapeSegments.push([0,0]);}return shapeSegments;};TrimModifier.prototype.releasePathsData=function(pathsData){var i;var len=pathsData.length;for(i=0;i<len;i+=1){segmentsLengthPool.release(pathsData[i]);}pathsData.length=0;return pathsData;};TrimModifier.prototype.processShapes=function(_isFirstFrame){var s;var e;if(this._mdf||_isFirstFrame){var o=this.o.v%360/360;if(o<0){o+=1;}if(this.s.v>1){s=1+o;}else if(this.s.v<0){s=0+o;}else {s=this.s.v+o;}if(this.e.v>1){e=1+o;}else if(this.e.v<0){e=0+o;}else {e=this.e.v+o;}if(s>e){var _s=s;s=e;e=_s;}s=Math.round(s*10000)*0.0001;e=Math.round(e*10000)*0.0001;this.sValue=s;this.eValue=e;}else {s=this.sValue;e=this.eValue;}var shapePaths;var i;var len=this.shapes.length;var j;var jLen;var pathsData;var pathData;var totalShapeLength;var totalModifierLength=0;if(e===s){for(i=0;i<len;i+=1){this.shapes[i].localShapeCollection.releaseShapes();this.shapes[i].shape._mdf=true;this.shapes[i].shape.paths=this.shapes[i].localShapeCollection;if(this._mdf){this.shapes[i].pathsData.length=0;}}}else if(!(e===1&&s===0||e===0&&s===1)){var segments=[];var shapeData;var localShapeCollection;for(i=0;i<len;i+=1){shapeData=this.shapes[i];// if shape hasn't changed and trim properties haven't changed, cached previous path can be used
if(!shapeData.shape._mdf&&!this._mdf&&!_isFirstFrame&&this.m!==2){shapeData.shape.paths=shapeData.localShapeCollection;}else {shapePaths=shapeData.shape.paths;jLen=shapePaths._length;totalShapeLength=0;if(!shapeData.shape._mdf&&shapeData.pathsData.length){totalShapeLength=shapeData.totalShapeLength;}else {pathsData=this.releasePathsData(shapeData.pathsData);for(j=0;j<jLen;j+=1){pathData=bez.getSegmentsLength(shapePaths.shapes[j]);pathsData.push(pathData);totalShapeLength+=pathData.totalLength;}shapeData.totalShapeLength=totalShapeLength;shapeData.pathsData=pathsData;}totalModifierLength+=totalShapeLength;shapeData.shape._mdf=true;}}var shapeS=s;var shapeE=e;var addedLength=0;var edges;for(i=len-1;i>=0;i-=1){shapeData=this.shapes[i];if(shapeData.shape._mdf){localShapeCollection=shapeData.localShapeCollection;localShapeCollection.releaseShapes();// if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group
if(this.m===2&&len>1){edges=this.calculateShapeEdges(s,e,shapeData.totalShapeLength,addedLength,totalModifierLength);addedLength+=shapeData.totalShapeLength;}else {edges=[[shapeS,shapeE]];}jLen=edges.length;for(j=0;j<jLen;j+=1){shapeS=edges[j][0];shapeE=edges[j][1];segments.length=0;if(shapeE<=1){segments.push({s:shapeData.totalShapeLength*shapeS,e:shapeData.totalShapeLength*shapeE});}else if(shapeS>=1){segments.push({s:shapeData.totalShapeLength*(shapeS-1),e:shapeData.totalShapeLength*(shapeE-1)});}else {segments.push({s:shapeData.totalShapeLength*shapeS,e:shapeData.totalShapeLength});segments.push({s:0,e:shapeData.totalShapeLength*(shapeE-1)});}var newShapesData=this.addShapes(shapeData,segments[0]);if(segments[0].s!==segments[0].e){if(segments.length>1){var lastShapeInCollection=shapeData.shape.paths.shapes[shapeData.shape.paths._length-1];if(lastShapeInCollection.c){var lastShape=newShapesData.pop();this.addPaths(newShapesData,localShapeCollection);newShapesData=this.addShapes(shapeData,segments[1],lastShape);}else {this.addPaths(newShapesData,localShapeCollection);newShapesData=this.addShapes(shapeData,segments[1]);}}this.addPaths(newShapesData,localShapeCollection);}}shapeData.shape.paths=localShapeCollection;}}}else if(this._mdf){for(i=0;i<len;i+=1){// Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.
// Don't remove this even if it's losing cached info.
this.shapes[i].pathsData.length=0;this.shapes[i].shape._mdf=true;}}};TrimModifier.prototype.addPaths=function(newPaths,localShapeCollection){var i;var len=newPaths.length;for(i=0;i<len;i+=1){localShapeCollection.addShape(newPaths[i]);}};TrimModifier.prototype.addSegment=function(pt1,pt2,pt3,pt4,shapePath,pos,newShape){shapePath.setXYAt(pt2[0],pt2[1],'o',pos);shapePath.setXYAt(pt3[0],pt3[1],'i',pos+1);if(newShape){shapePath.setXYAt(pt1[0],pt1[1],'v',pos);}shapePath.setXYAt(pt4[0],pt4[1],'v',pos+1);};TrimModifier.prototype.addSegmentFromArray=function(points,shapePath,pos,newShape){shapePath.setXYAt(points[1],points[5],'o',pos);shapePath.setXYAt(points[2],points[6],'i',pos+1);if(newShape){shapePath.setXYAt(points[0],points[4],'v',pos);}shapePath.setXYAt(points[3],points[7],'v',pos+1);};TrimModifier.prototype.addShapes=function(shapeData,shapeSegment,shapePath){var pathsData=shapeData.pathsData;var shapePaths=shapeData.shape.paths.shapes;var i;var len=shapeData.shape.paths._length;var j;var jLen;var addedLength=0;var currentLengthData;var segmentCount;var lengths;var segment;var shapes=[];var initPos;var newShape=true;if(!shapePath){shapePath=shapePool.newElement();segmentCount=0;initPos=0;}else {segmentCount=shapePath._length;initPos=shapePath._length;}shapes.push(shapePath);for(i=0;i<len;i+=1){lengths=pathsData[i].lengths;shapePath.c=shapePaths[i].c;jLen=shapePaths[i].c?lengths.length:lengths.length+1;for(j=1;j<jLen;j+=1){currentLengthData=lengths[j-1];if(addedLength+currentLengthData.addedLength<shapeSegment.s){addedLength+=currentLengthData.addedLength;shapePath.c=false;}else if(addedLength>shapeSegment.e){shapePath.c=false;break;}else {if(shapeSegment.s<=addedLength&&shapeSegment.e>=addedLength+currentLengthData.addedLength){this.addSegment(shapePaths[i].v[j-1],shapePaths[i].o[j-1],shapePaths[i].i[j],shapePaths[i].v[j],shapePath,segmentCount,newShape);newShape=false;}else {segment=bez.getNewSegment(shapePaths[i].v[j-1],shapePaths[i].v[j],shapePaths[i].o[j-1],shapePaths[i].i[j],(shapeSegment.s-addedLength)/currentLengthData.addedLength,(shapeSegment.e-addedLength)/currentLengthData.addedLength,lengths[j-1]);this.addSegmentFromArray(segment,shapePath,segmentCount,newShape);// this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
newShape=false;shapePath.c=false;}addedLength+=currentLengthData.addedLength;segmentCount+=1;}}if(shapePaths[i].c&&lengths.length){currentLengthData=lengths[j-1];if(addedLength<=shapeSegment.e){var segmentLength=lengths[j-1].addedLength;if(shapeSegment.s<=addedLength&&shapeSegment.e>=addedLength+segmentLength){this.addSegment(shapePaths[i].v[j-1],shapePaths[i].o[j-1],shapePaths[i].i[0],shapePaths[i].v[0],shapePath,segmentCount,newShape);newShape=false;}else {segment=bez.getNewSegment(shapePaths[i].v[j-1],shapePaths[i].v[0],shapePaths[i].o[j-1],shapePaths[i].i[0],(shapeSegment.s-addedLength)/segmentLength,(shapeSegment.e-addedLength)/segmentLength,lengths[j-1]);this.addSegmentFromArray(segment,shapePath,segmentCount,newShape);// this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);
newShape=false;shapePath.c=false;}}else {shapePath.c=false;}addedLength+=currentLengthData.addedLength;segmentCount+=1;}if(shapePath._length){shapePath.setXYAt(shapePath.v[initPos][0],shapePath.v[initPos][1],'i',initPos);shapePath.setXYAt(shapePath.v[shapePath._length-1][0],shapePath.v[shapePath._length-1][1],'o',shapePath._length-1);}if(addedLength>shapeSegment.e){break;}if(i<len-1){shapePath=shapePool.newElement();newShape=true;shapes.push(shapePath);segmentCount=0;}}return shapes;};function PuckerAndBloatModifier(){}extendPrototype([ShapeModifier],PuckerAndBloatModifier);PuckerAndBloatModifier.prototype.initModifierProperties=function(elem,data){this.getValue=this.processKeys;this.amount=PropertyFactory.getProp(elem,data.a,0,null,this);this._isAnimated=!!this.amount.effectsSequence.length;};PuckerAndBloatModifier.prototype.processPath=function(path,amount){var percent=amount/100;var centerPoint=[0,0];var pathLength=path._length;var i=0;for(i=0;i<pathLength;i+=1){centerPoint[0]+=path.v[i][0];centerPoint[1]+=path.v[i][1];}centerPoint[0]/=pathLength;centerPoint[1]/=pathLength;var clonedPath=shapePool.newElement();clonedPath.c=path.c;var vX;var vY;var oX;var oY;var iX;var iY;for(i=0;i<pathLength;i+=1){vX=path.v[i][0]+(centerPoint[0]-path.v[i][0])*percent;vY=path.v[i][1]+(centerPoint[1]-path.v[i][1])*percent;oX=path.o[i][0]+(centerPoint[0]-path.o[i][0])*-percent;oY=path.o[i][1]+(centerPoint[1]-path.o[i][1])*-percent;iX=path.i[i][0]+(centerPoint[0]-path.i[i][0])*-percent;iY=path.i[i][1]+(centerPoint[1]-path.i[i][1])*-percent;clonedPath.setTripleAt(vX,vY,oX,oY,iX,iY,i);}return clonedPath;};PuckerAndBloatModifier.prototype.processShapes=function(_isFirstFrame){var shapePaths;var i;var len=this.shapes.length;var j;var jLen;var amount=this.amount.v;if(amount!==0){var shapeData;var localShapeCollection;for(i=0;i<len;i+=1){shapeData=this.shapes[i];localShapeCollection=shapeData.localShapeCollection;if(!(!shapeData.shape._mdf&&!this._mdf&&!_isFirstFrame)){localShapeCollection.releaseShapes();shapeData.shape._mdf=true;shapePaths=shapeData.shape.paths.shapes;jLen=shapeData.shape.paths._length;for(j=0;j<jLen;j+=1){localShapeCollection.addShape(this.processPath(shapePaths[j],amount));}}shapeData.shape.paths=shapeData.localShapeCollection;}}if(!this.dynamicProperties.length){this._mdf=false;}};var TransformPropertyFactory=function(){var defaultVector=[0,0];function applyToMatrix(mat){var _mdf=this._mdf;this.iterateDynamicProperties();this._mdf=this._mdf||_mdf;if(this.a){mat.translate(-this.a.v[0],-this.a.v[1],this.a.v[2]);}if(this.s){mat.scale(this.s.v[0],this.s.v[1],this.s.v[2]);}if(this.sk){mat.skewFromAxis(-this.sk.v,this.sa.v);}if(this.r){mat.rotate(-this.r.v);}else {mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);}if(this.data.p.s){if(this.data.p.z){mat.translate(this.px.v,this.py.v,-this.pz.v);}else {mat.translate(this.px.v,this.py.v,0);}}else {mat.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);}}function processKeys(forceRender){if(this.elem.globalData.frameId===this.frameId){return;}if(this._isDirty){this.precalculateMatrix();this._isDirty=false;}this.iterateDynamicProperties();if(this._mdf||forceRender){var frameRate;this.v.cloneFromProps(this.pre.props);if(this.appliedTransformations<1){this.v.translate(-this.a.v[0],-this.a.v[1],this.a.v[2]);}if(this.appliedTransformations<2){this.v.scale(this.s.v[0],this.s.v[1],this.s.v[2]);}if(this.sk&&this.appliedTransformations<3){this.v.skewFromAxis(-this.sk.v,this.sa.v);}if(this.r&&this.appliedTransformations<4){this.v.rotate(-this.r.v);}else if(!this.r&&this.appliedTransformations<4){this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);}if(this.autoOriented){var v1;var v2;frameRate=this.elem.globalData.frameRate;if(this.p&&this.p.keyframes&&this.p.getValueAtTime){if(this.p._caching.lastFrame+this.p.offsetTime<=this.p.keyframes[0].t){v1=this.p.getValueAtTime((this.p.keyframes[0].t+0.01)/frameRate,0);v2=this.p.getValueAtTime(this.p.keyframes[0].t/frameRate,0);}else if(this.p._caching.lastFrame+this.p.offsetTime>=this.p.keyframes[this.p.keyframes.length-1].t){v1=this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length-1].t/frameRate,0);v2=this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length-1].t-0.05)/frameRate,0);}else {v1=this.p.pv;v2=this.p.getValueAtTime((this.p._caching.lastFrame+this.p.offsetTime-0.01)/frameRate,this.p.offsetTime);}}else if(this.px&&this.px.keyframes&&this.py.keyframes&&this.px.getValueAtTime&&this.py.getValueAtTime){v1=[];v2=[];var px=this.px;var py=this.py;if(px._caching.lastFrame+px.offsetTime<=px.keyframes[0].t){v1[0]=px.getValueAtTime((px.keyframes[0].t+0.01)/frameRate,0);v1[1]=py.getValueAtTime((py.keyframes[0].t+0.01)/frameRate,0);v2[0]=px.getValueAtTime(px.keyframes[0].t/frameRate,0);v2[1]=py.getValueAtTime(py.keyframes[0].t/frameRate,0);}else if(px._caching.lastFrame+px.offsetTime>=px.keyframes[px.keyframes.length-1].t){v1[0]=px.getValueAtTime(px.keyframes[px.keyframes.length-1].t/frameRate,0);v1[1]=py.getValueAtTime(py.keyframes[py.keyframes.length-1].t/frameRate,0);v2[0]=px.getValueAtTime((px.keyframes[px.keyframes.length-1].t-0.01)/frameRate,0);v2[1]=py.getValueAtTime((py.keyframes[py.keyframes.length-1].t-0.01)/frameRate,0);}else {v1=[px.pv,py.pv];v2[0]=px.getValueAtTime((px._caching.lastFrame+px.offsetTime-0.01)/frameRate,px.offsetTime);v2[1]=py.getValueAtTime((py._caching.lastFrame+py.offsetTime-0.01)/frameRate,py.offsetTime);}}else {v2=defaultVector;v1=v2;}this.v.rotate(-Math.atan2(v1[1]-v2[1],v1[0]-v2[0]));}if(this.data.p&&this.data.p.s){if(this.data.p.z){this.v.translate(this.px.v,this.py.v,-this.pz.v);}else {this.v.translate(this.px.v,this.py.v,0);}}else {this.v.translate(this.p.v[0],this.p.v[1],-this.p.v[2]);}}this.frameId=this.elem.globalData.frameId;}function precalculateMatrix(){this.appliedTransformations=0;this.pre.reset();if(!this.a.effectsSequence.length){this.pre.translate(-this.a.v[0],-this.a.v[1],this.a.v[2]);this.appliedTransformations=1;}else {return;}if(!this.s.effectsSequence.length){this.pre.scale(this.s.v[0],this.s.v[1],this.s.v[2]);this.appliedTransformations=2;}else {return;}if(this.sk){if(!this.sk.effectsSequence.length&&!this.sa.effectsSequence.length){this.pre.skewFromAxis(-this.sk.v,this.sa.v);this.appliedTransformations=3;}else {return;}}if(this.r){if(!this.r.effectsSequence.length){this.pre.rotate(-this.r.v);this.appliedTransformations=4;}}else if(!this.rz.effectsSequence.length&&!this.ry.effectsSequence.length&&!this.rx.effectsSequence.length&&!this.or.effectsSequence.length){this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);this.appliedTransformations=4;}}function autoOrient(){//
// var prevP = this.getValueAtTime();
}function addDynamicProperty(prop){this._addDynamicProperty(prop);this.elem.addDynamicProperty(prop);this._isDirty=true;}function TransformProperty(elem,data,container){this.elem=elem;this.frameId=-1;this.propType='transform';this.data=data;this.v=new Matrix();// Precalculated matrix with non animated properties
this.pre=new Matrix();this.appliedTransformations=0;this.initDynamicPropertyContainer(container||elem);if(data.p&&data.p.s){this.px=PropertyFactory.getProp(elem,data.p.x,0,0,this);this.py=PropertyFactory.getProp(elem,data.p.y,0,0,this);if(data.p.z){this.pz=PropertyFactory.getProp(elem,data.p.z,0,0,this);}}else {this.p=PropertyFactory.getProp(elem,data.p||{k:[0,0,0]},1,0,this);}if(data.rx){this.rx=PropertyFactory.getProp(elem,data.rx,0,degToRads,this);this.ry=PropertyFactory.getProp(elem,data.ry,0,degToRads,this);this.rz=PropertyFactory.getProp(elem,data.rz,0,degToRads,this);if(data.or.k[0].ti){var i;var len=data.or.k.length;for(i=0;i<len;i+=1){data.or.k[i].to=null;data.or.k[i].ti=null;}}this.or=PropertyFactory.getProp(elem,data.or,1,degToRads,this);// sh Indicates it needs to be capped between -180 and 180
this.or.sh=true;}else {this.r=PropertyFactory.getProp(elem,data.r||{k:0},0,degToRads,this);}if(data.sk){this.sk=PropertyFactory.getProp(elem,data.sk,0,degToRads,this);this.sa=PropertyFactory.getProp(elem,data.sa,0,degToRads,this);}this.a=PropertyFactory.getProp(elem,data.a||{k:[0,0,0]},1,0,this);this.s=PropertyFactory.getProp(elem,data.s||{k:[100,100,100]},1,0.01,this);// Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.
if(data.o){this.o=PropertyFactory.getProp(elem,data.o,0,0.01,elem);}else {this.o={_mdf:false,v:1};}this._isDirty=true;if(!this.dynamicProperties.length){this.getValue(true);}}TransformProperty.prototype={applyToMatrix:applyToMatrix,getValue:processKeys,precalculateMatrix:precalculateMatrix,autoOrient:autoOrient};extendPrototype([DynamicPropertyContainer],TransformProperty);TransformProperty.prototype.addDynamicProperty=addDynamicProperty;TransformProperty.prototype._addDynamicProperty=DynamicPropertyContainer.prototype.addDynamicProperty;function getTransformProperty(elem,data,container){return new TransformProperty(elem,data,container);}return {getTransformProperty:getTransformProperty};}();function RepeaterModifier(){}extendPrototype([ShapeModifier],RepeaterModifier);RepeaterModifier.prototype.initModifierProperties=function(elem,data){this.getValue=this.processKeys;this.c=PropertyFactory.getProp(elem,data.c,0,null,this);this.o=PropertyFactory.getProp(elem,data.o,0,null,this);this.tr=TransformPropertyFactory.getTransformProperty(elem,data.tr,this);this.so=PropertyFactory.getProp(elem,data.tr.so,0,0.01,this);this.eo=PropertyFactory.getProp(elem,data.tr.eo,0,0.01,this);this.data=data;if(!this.dynamicProperties.length){this.getValue(true);}this._isAnimated=!!this.dynamicProperties.length;this.pMatrix=new Matrix();this.rMatrix=new Matrix();this.sMatrix=new Matrix();this.tMatrix=new Matrix();this.matrix=new Matrix();};RepeaterModifier.prototype.applyTransforms=function(pMatrix,rMatrix,sMatrix,transform,perc,inv){var dir=inv?-1:1;var scaleX=transform.s.v[0]+(1-transform.s.v[0])*(1-perc);var scaleY=transform.s.v[1]+(1-transform.s.v[1])*(1-perc);pMatrix.translate(transform.p.v[0]*dir*perc,transform.p.v[1]*dir*perc,transform.p.v[2]);rMatrix.translate(-transform.a.v[0],-transform.a.v[1],transform.a.v[2]);rMatrix.rotate(-transform.r.v*dir*perc);rMatrix.translate(transform.a.v[0],transform.a.v[1],transform.a.v[2]);sMatrix.translate(-transform.a.v[0],-transform.a.v[1],transform.a.v[2]);sMatrix.scale(inv?1/scaleX:scaleX,inv?1/scaleY:scaleY);sMatrix.translate(transform.a.v[0],transform.a.v[1],transform.a.v[2]);};RepeaterModifier.prototype.init=function(elem,arr,pos,elemsData){this.elem=elem;this.arr=arr;this.pos=pos;this.elemsData=elemsData;this._currentCopies=0;this._elements=[];this._groups=[];this.frameId=-1;this.initDynamicPropertyContainer(elem);this.initModifierProperties(elem,arr[pos]);while(pos>0){pos-=1;// this._elements.unshift(arr.splice(pos,1)[0]);
this._elements.unshift(arr[pos]);}if(this.dynamicProperties.length){this.k=true;}else {this.getValue(true);}};RepeaterModifier.prototype.resetElements=function(elements){var i;var len=elements.length;for(i=0;i<len;i+=1){elements[i]._processed=false;if(elements[i].ty==='gr'){this.resetElements(elements[i].it);}}};RepeaterModifier.prototype.cloneElements=function(elements){var newElements=JSON.parse(JSON.stringify(elements));this.resetElements(newElements);return newElements;};RepeaterModifier.prototype.changeGroupRender=function(elements,renderFlag){var i;var len=elements.length;for(i=0;i<len;i+=1){elements[i]._render=renderFlag;if(elements[i].ty==='gr'){this.changeGroupRender(elements[i].it,renderFlag);}}};RepeaterModifier.prototype.processShapes=function(_isFirstFrame){var items;var itemsTransform;var i;var dir;var cont;var hasReloaded=false;if(this._mdf||_isFirstFrame){var copies=Math.ceil(this.c.v);if(this._groups.length<copies){while(this._groups.length<copies){var group={it:this.cloneElements(this._elements),ty:'gr'};group.it.push({a:{a:0,ix:1,k:[0,0]},nm:'Transform',o:{a:0,ix:7,k:100},p:{a:0,ix:2,k:[0,0]},r:{a:1,ix:6,k:[{s:0,e:0,t:0},{s:0,e:0,t:1}]},s:{a:0,ix:3,k:[100,100]},sa:{a:0,ix:5,k:0},sk:{a:0,ix:4,k:0},ty:'tr'});this.arr.splice(0,0,group);this._groups.splice(0,0,group);this._currentCopies+=1;}this.elem.reloadShapes();hasReloaded=true;}cont=0;var renderFlag;for(i=0;i<=this._groups.length-1;i+=1){renderFlag=cont<copies;this._groups[i]._render=renderFlag;this.changeGroupRender(this._groups[i].it,renderFlag);if(!renderFlag){var elems=this.elemsData[i].it;var transformData=elems[elems.length-1];if(transformData.transform.op.v!==0){transformData.transform.op._mdf=true;transformData.transform.op.v=0;}else {transformData.transform.op._mdf=false;}}cont+=1;}this._currentCopies=copies;/// /
var offset=this.o.v;var offsetModulo=offset%1;var roundOffset=offset>0?Math.floor(offset):Math.ceil(offset);var pProps=this.pMatrix.props;var rProps=this.rMatrix.props;var sProps=this.sMatrix.props;this.pMatrix.reset();this.rMatrix.reset();this.sMatrix.reset();this.tMatrix.reset();this.matrix.reset();var iteration=0;if(offset>0){while(iteration<roundOffset){this.applyTransforms(this.pMatrix,this.rMatrix,this.sMatrix,this.tr,1,false);iteration+=1;}if(offsetModulo){this.applyTransforms(this.pMatrix,this.rMatrix,this.sMatrix,this.tr,offsetModulo,false);iteration+=offsetModulo;}}else if(offset<0){while(iteration>roundOffset){this.applyTransforms(this.pMatrix,this.rMatrix,this.sMatrix,this.tr,1,true);iteration-=1;}if(offsetModulo){this.applyTransforms(this.pMatrix,this.rMatrix,this.sMatrix,this.tr,-offsetModulo,true);iteration-=offsetModulo;}}i=this.data.m===1?0:this._currentCopies-1;dir=this.data.m===1?1:-1;cont=this._currentCopies;var j;var jLen;while(cont){items=this.elemsData[i].it;itemsTransform=items[items.length-1].transform.mProps.v.props;jLen=itemsTransform.length;items[items.length-1].transform.mProps._mdf=true;items[items.length-1].transform.op._mdf=true;items[items.length-1].transform.op.v=this._currentCopies===1?this.so.v:this.so.v+(this.eo.v-this.so.v)*(i/(this._currentCopies-1));if(iteration!==0){if(i!==0&&dir===1||i!==this._currentCopies-1&&dir===-1){this.applyTransforms(this.pMatrix,this.rMatrix,this.sMatrix,this.tr,1,false);}this.matrix.transform(rProps[0],rProps[1],rProps[2],rProps[3],rProps[4],rProps[5],rProps[6],rProps[7],rProps[8],rProps[9],rProps[10],rProps[11],rProps[12],rProps[13],rProps[14],rProps[15]);this.matrix.transform(sProps[0],sProps[1],sProps[2],sProps[3],sProps[4],sProps[5],sProps[6],sProps[7],sProps[8],sProps[9],sProps[10],sProps[11],sProps[12],sProps[13],sProps[14],sProps[15]);this.matrix.transform(pProps[0],pProps[1],pProps[2],pProps[3],pProps[4],pProps[5],pProps[6],pProps[7],pProps[8],pProps[9],pProps[10],pProps[11],pProps[12],pProps[13],pProps[14],pProps[15]);for(j=0;j<jLen;j+=1){itemsTransform[j]=this.matrix.props[j];}this.matrix.reset();}else {this.matrix.reset();for(j=0;j<jLen;j+=1){itemsTransform[j]=this.matrix.props[j];}}iteration+=1;cont-=1;i+=dir;}}else {cont=this._currentCopies;i=0;dir=1;while(cont){items=this.elemsData[i].it;itemsTransform=items[items.length-1].transform.mProps.v.props;items[items.length-1].transform.mProps._mdf=false;items[items.length-1].transform.op._mdf=false;cont-=1;i+=dir;}}return hasReloaded;};RepeaterModifier.prototype.addShape=function(){};function RoundCornersModifier(){}extendPrototype([ShapeModifier],RoundCornersModifier);RoundCornersModifier.prototype.initModifierProperties=function(elem,data){this.getValue=this.processKeys;this.rd=PropertyFactory.getProp(elem,data.r,0,null,this);this._isAnimated=!!this.rd.effectsSequence.length;};RoundCornersModifier.prototype.processPath=function(path,round){var clonedPath=shapePool.newElement();clonedPath.c=path.c;var i;var len=path._length;var currentV;var currentI;var currentO;var closerV;var distance;var newPosPerc;var index=0;var vX;var vY;var oX;var oY;var iX;var iY;for(i=0;i<len;i+=1){currentV=path.v[i];currentO=path.o[i];currentI=path.i[i];if(currentV[0]===currentO[0]&&currentV[1]===currentO[1]&&currentV[0]===currentI[0]&&currentV[1]===currentI[1]){if((i===0||i===len-1)&&!path.c){clonedPath.setTripleAt(currentV[0],currentV[1],currentO[0],currentO[1],currentI[0],currentI[1],index);/* clonedPath.v[index] = currentV;
	                  clonedPath.o[index] = currentO;
	                  clonedPath.i[index] = currentI; */index+=1;}else {if(i===0){closerV=path.v[len-1];}else {closerV=path.v[i-1];}distance=Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));newPosPerc=distance?Math.min(distance/2,round)/distance:0;iX=currentV[0]+(closerV[0]-currentV[0])*newPosPerc;vX=iX;iY=currentV[1]-(currentV[1]-closerV[1])*newPosPerc;vY=iY;oX=vX-(vX-currentV[0])*roundCorner;oY=vY-(vY-currentV[1])*roundCorner;clonedPath.setTripleAt(vX,vY,oX,oY,iX,iY,index);index+=1;if(i===len-1){closerV=path.v[0];}else {closerV=path.v[i+1];}distance=Math.sqrt(Math.pow(currentV[0]-closerV[0],2)+Math.pow(currentV[1]-closerV[1],2));newPosPerc=distance?Math.min(distance/2,round)/distance:0;oX=currentV[0]+(closerV[0]-currentV[0])*newPosPerc;vX=oX;oY=currentV[1]+(closerV[1]-currentV[1])*newPosPerc;vY=oY;iX=vX-(vX-currentV[0])*roundCorner;iY=vY-(vY-currentV[1])*roundCorner;clonedPath.setTripleAt(vX,vY,oX,oY,iX,iY,index);index+=1;}}else {clonedPath.setTripleAt(path.v[i][0],path.v[i][1],path.o[i][0],path.o[i][1],path.i[i][0],path.i[i][1],index);index+=1;}}return clonedPath;};RoundCornersModifier.prototype.processShapes=function(_isFirstFrame){var shapePaths;var i;var len=this.shapes.length;var j;var jLen;var rd=this.rd.v;if(rd!==0){var shapeData;var localShapeCollection;for(i=0;i<len;i+=1){shapeData=this.shapes[i];localShapeCollection=shapeData.localShapeCollection;if(!(!shapeData.shape._mdf&&!this._mdf&&!_isFirstFrame)){localShapeCollection.releaseShapes();shapeData.shape._mdf=true;shapePaths=shapeData.shape.paths.shapes;jLen=shapeData.shape.paths._length;for(j=0;j<jLen;j+=1){localShapeCollection.addShape(this.processPath(shapePaths[j],rd));}}shapeData.shape.paths=shapeData.localShapeCollection;}}if(!this.dynamicProperties.length){this._mdf=false;}};function floatEqual(a,b){return Math.abs(a-b)*100000<=Math.min(Math.abs(a),Math.abs(b));}function floatZero(f){return Math.abs(f)<=0.00001;}function lerp(p0,p1,amount){return p0*(1-amount)+p1*amount;}function lerpPoint(p0,p1,amount){return [lerp(p0[0],p1[0],amount),lerp(p0[1],p1[1],amount)];}function quadRoots(a,b,c){// no root
if(a===0)return [];var s=b*b-4*a*c;// Complex roots
if(s<0)return [];var singleRoot=-b/(2*a);// 1 root
if(s===0)return [singleRoot];var delta=Math.sqrt(s)/(2*a);// 2 roots
return [singleRoot-delta,singleRoot+delta];}function polynomialCoefficients(p0,p1,p2,p3){return [-p0+3*p1-3*p2+p3,3*p0-6*p1+3*p2,-3*p0+3*p1,p0];}function singlePoint(p){return new PolynomialBezier(p,p,p,p,false);}function PolynomialBezier(p0,p1,p2,p3,linearize){if(linearize&&pointEqual(p0,p1)){p1=lerpPoint(p0,p3,1/3);}if(linearize&&pointEqual(p2,p3)){p2=lerpPoint(p0,p3,2/3);}var coeffx=polynomialCoefficients(p0[0],p1[0],p2[0],p3[0]);var coeffy=polynomialCoefficients(p0[1],p1[1],p2[1],p3[1]);this.a=[coeffx[0],coeffy[0]];this.b=[coeffx[1],coeffy[1]];this.c=[coeffx[2],coeffy[2]];this.d=[coeffx[3],coeffy[3]];this.points=[p0,p1,p2,p3];}PolynomialBezier.prototype.point=function(t){return [((this.a[0]*t+this.b[0])*t+this.c[0])*t+this.d[0],((this.a[1]*t+this.b[1])*t+this.c[1])*t+this.d[1]];};PolynomialBezier.prototype.derivative=function(t){return [(3*t*this.a[0]+2*this.b[0])*t+this.c[0],(3*t*this.a[1]+2*this.b[1])*t+this.c[1]];};PolynomialBezier.prototype.tangentAngle=function(t){var p=this.derivative(t);return Math.atan2(p[1],p[0]);};PolynomialBezier.prototype.normalAngle=function(t){var p=this.derivative(t);return Math.atan2(p[0],p[1]);};PolynomialBezier.prototype.inflectionPoints=function(){var denom=this.a[1]*this.b[0]-this.a[0]*this.b[1];if(floatZero(denom))return [];var tcusp=-0.5*(this.a[1]*this.c[0]-this.a[0]*this.c[1])/denom;var square=tcusp*tcusp-1/3*(this.b[1]*this.c[0]-this.b[0]*this.c[1])/denom;if(square<0)return [];var root=Math.sqrt(square);if(floatZero(root)){if(root>0&&root<1)return [tcusp];return [];}return [tcusp-root,tcusp+root].filter(function(r){return r>0&&r<1;});};PolynomialBezier.prototype.split=function(t){if(t<=0)return [singlePoint(this.points[0]),this];if(t>=1)return [this,singlePoint(this.points[this.points.length-1])];var p10=lerpPoint(this.points[0],this.points[1],t);var p11=lerpPoint(this.points[1],this.points[2],t);var p12=lerpPoint(this.points[2],this.points[3],t);var p20=lerpPoint(p10,p11,t);var p21=lerpPoint(p11,p12,t);var p3=lerpPoint(p20,p21,t);return [new PolynomialBezier(this.points[0],p10,p20,p3,true),new PolynomialBezier(p3,p21,p12,this.points[3],true)];};function extrema(bez,comp){var min=bez.points[0][comp];var max=bez.points[bez.points.length-1][comp];if(min>max){var e=max;max=min;min=e;}// Derivative roots to find min/max
var f=quadRoots(3*bez.a[comp],2*bez.b[comp],bez.c[comp]);for(var i=0;i<f.length;i+=1){if(f[i]>0&&f[i]<1){var val=bez.point(f[i])[comp];if(val<min)min=val;else if(val>max)max=val;}}return {min:min,max:max};}PolynomialBezier.prototype.bounds=function(){return {x:extrema(this,0),y:extrema(this,1)};};PolynomialBezier.prototype.boundingBox=function(){var bounds=this.bounds();return {left:bounds.x.min,right:bounds.x.max,top:bounds.y.min,bottom:bounds.y.max,width:bounds.x.max-bounds.x.min,height:bounds.y.max-bounds.y.min,cx:(bounds.x.max+bounds.x.min)/2,cy:(bounds.y.max+bounds.y.min)/2};};function intersectData(bez,t1,t2){var box=bez.boundingBox();return {cx:box.cx,cy:box.cy,width:box.width,height:box.height,bez:bez,t:(t1+t2)/2,t1:t1,t2:t2};}function splitData(data){var split=data.bez.split(0.5);return [intersectData(split[0],data.t1,data.t),intersectData(split[1],data.t,data.t2)];}function boxIntersect(b1,b2){return Math.abs(b1.cx-b2.cx)*2<b1.width+b2.width&&Math.abs(b1.cy-b2.cy)*2<b1.height+b2.height;}function intersectsImpl(d1,d2,depth,tolerance,intersections,maxRecursion){if(!boxIntersect(d1,d2))return;if(depth>=maxRecursion||d1.width<=tolerance&&d1.height<=tolerance&&d2.width<=tolerance&&d2.height<=tolerance){intersections.push([d1.t,d2.t]);return;}var d1s=splitData(d1);var d2s=splitData(d2);intersectsImpl(d1s[0],d2s[0],depth+1,tolerance,intersections,maxRecursion);intersectsImpl(d1s[0],d2s[1],depth+1,tolerance,intersections,maxRecursion);intersectsImpl(d1s[1],d2s[0],depth+1,tolerance,intersections,maxRecursion);intersectsImpl(d1s[1],d2s[1],depth+1,tolerance,intersections,maxRecursion);}PolynomialBezier.prototype.intersections=function(other,tolerance,maxRecursion){if(tolerance===undefined)tolerance=2;if(maxRecursion===undefined)maxRecursion=7;var intersections=[];intersectsImpl(intersectData(this,0,1),intersectData(other,0,1),0,tolerance,intersections,maxRecursion);return intersections;};PolynomialBezier.shapeSegment=function(shapePath,index){var nextIndex=(index+1)%shapePath.length();return new PolynomialBezier(shapePath.v[index],shapePath.o[index],shapePath.i[nextIndex],shapePath.v[nextIndex],true);};PolynomialBezier.shapeSegmentInverted=function(shapePath,index){var nextIndex=(index+1)%shapePath.length();return new PolynomialBezier(shapePath.v[nextIndex],shapePath.i[nextIndex],shapePath.o[index],shapePath.v[index],true);};function crossProduct(a,b){return [a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];}function lineIntersection(start1,end1,start2,end2){var v1=[start1[0],start1[1],1];var v2=[end1[0],end1[1],1];var v3=[start2[0],start2[1],1];var v4=[end2[0],end2[1],1];var r=crossProduct(crossProduct(v1,v2),crossProduct(v3,v4));if(floatZero(r[2]))return null;return [r[0]/r[2],r[1]/r[2]];}function polarOffset(p,angle,length){return [p[0]+Math.cos(angle)*length,p[1]-Math.sin(angle)*length];}function pointDistance(p1,p2){return Math.hypot(p1[0]-p2[0],p1[1]-p2[1]);}function pointEqual(p1,p2){return floatEqual(p1[0],p2[0])&&floatEqual(p1[1],p2[1]);}function ZigZagModifier(){}extendPrototype([ShapeModifier],ZigZagModifier);ZigZagModifier.prototype.initModifierProperties=function(elem,data){this.getValue=this.processKeys;this.amplitude=PropertyFactory.getProp(elem,data.s,0,null,this);this.frequency=PropertyFactory.getProp(elem,data.r,0,null,this);this.pointsType=PropertyFactory.getProp(elem,data.pt,0,null,this);this._isAnimated=this.amplitude.effectsSequence.length!==0||this.frequency.effectsSequence.length!==0||this.pointsType.effectsSequence.length!==0;};function setPoint(outputBezier,point,angle,direction,amplitude,outAmplitude,inAmplitude){var angO=angle-Math.PI/2;var angI=angle+Math.PI/2;var px=point[0]+Math.cos(angle)*direction*amplitude;var py=point[1]-Math.sin(angle)*direction*amplitude;outputBezier.setTripleAt(px,py,px+Math.cos(angO)*outAmplitude,py-Math.sin(angO)*outAmplitude,px+Math.cos(angI)*inAmplitude,py-Math.sin(angI)*inAmplitude,outputBezier.length());}function getPerpendicularVector(pt1,pt2){var vector=[pt2[0]-pt1[0],pt2[1]-pt1[1]];var rot=-Math.PI*0.5;var rotatedVector=[Math.cos(rot)*vector[0]-Math.sin(rot)*vector[1],Math.sin(rot)*vector[0]+Math.cos(rot)*vector[1]];return rotatedVector;}function getProjectingAngle(path,cur){var prevIndex=cur===0?path.length()-1:cur-1;var nextIndex=(cur+1)%path.length();var prevPoint=path.v[prevIndex];var nextPoint=path.v[nextIndex];var pVector=getPerpendicularVector(prevPoint,nextPoint);return Math.atan2(0,1)-Math.atan2(pVector[1],pVector[0]);}function zigZagCorner(outputBezier,path,cur,amplitude,frequency,pointType,direction){var angle=getProjectingAngle(path,cur);var point=path.v[cur%path._length];var prevPoint=path.v[cur===0?path._length-1:cur-1];var nextPoint=path.v[(cur+1)%path._length];var prevDist=pointType===2?Math.sqrt(Math.pow(point[0]-prevPoint[0],2)+Math.pow(point[1]-prevPoint[1],2)):0;var nextDist=pointType===2?Math.sqrt(Math.pow(point[0]-nextPoint[0],2)+Math.pow(point[1]-nextPoint[1],2)):0;setPoint(outputBezier,path.v[cur%path._length],angle,direction,amplitude,nextDist/((frequency+1)*2),prevDist/((frequency+1)*2));}function zigZagSegment(outputBezier,segment,amplitude,frequency,pointType,direction){for(var i=0;i<frequency;i+=1){var t=(i+1)/(frequency+1);var dist=pointType===2?Math.sqrt(Math.pow(segment.points[3][0]-segment.points[0][0],2)+Math.pow(segment.points[3][1]-segment.points[0][1],2)):0;var angle=segment.normalAngle(t);var point=segment.point(t);setPoint(outputBezier,point,angle,direction,amplitude,dist/((frequency+1)*2),dist/((frequency+1)*2));direction=-direction;}return direction;}ZigZagModifier.prototype.processPath=function(path,amplitude,frequency,pointType){var count=path._length;var clonedPath=shapePool.newElement();clonedPath.c=path.c;if(!path.c){count-=1;}if(count===0)return clonedPath;var direction=-1;var segment=PolynomialBezier.shapeSegment(path,0);zigZagCorner(clonedPath,path,0,amplitude,frequency,pointType,direction);for(var i=0;i<count;i+=1){direction=zigZagSegment(clonedPath,segment,amplitude,frequency,pointType,-direction);if(i===count-1&&!path.c){segment=null;}else {segment=PolynomialBezier.shapeSegment(path,(i+1)%count);}zigZagCorner(clonedPath,path,i+1,amplitude,frequency,pointType,direction);}return clonedPath;};ZigZagModifier.prototype.processShapes=function(_isFirstFrame){var shapePaths;var i;var len=this.shapes.length;var j;var jLen;var amplitude=this.amplitude.v;var frequency=Math.max(0,Math.round(this.frequency.v));var pointType=this.pointsType.v;if(amplitude!==0){var shapeData;var localShapeCollection;for(i=0;i<len;i+=1){shapeData=this.shapes[i];localShapeCollection=shapeData.localShapeCollection;if(!(!shapeData.shape._mdf&&!this._mdf&&!_isFirstFrame)){localShapeCollection.releaseShapes();shapeData.shape._mdf=true;shapePaths=shapeData.shape.paths.shapes;jLen=shapeData.shape.paths._length;for(j=0;j<jLen;j+=1){localShapeCollection.addShape(this.processPath(shapePaths[j],amplitude,frequency,pointType));}}shapeData.shape.paths=shapeData.localShapeCollection;}}if(!this.dynamicProperties.length){this._mdf=false;}};function linearOffset(p1,p2,amount){var angle=Math.atan2(p2[0]-p1[0],p2[1]-p1[1]);return [polarOffset(p1,angle,amount),polarOffset(p2,angle,amount)];}function offsetSegment(segment,amount){var p0;var p1a;var p1b;var p2b;var p2a;var p3;var e;e=linearOffset(segment.points[0],segment.points[1],amount);p0=e[0];p1a=e[1];e=linearOffset(segment.points[1],segment.points[2],amount);p1b=e[0];p2b=e[1];e=linearOffset(segment.points[2],segment.points[3],amount);p2a=e[0];p3=e[1];var p1=lineIntersection(p0,p1a,p1b,p2b);if(p1===null)p1=p1a;var p2=lineIntersection(p2a,p3,p1b,p2b);if(p2===null)p2=p2a;return new PolynomialBezier(p0,p1,p2,p3);}function joinLines(outputBezier,seg1,seg2,lineJoin,miterLimit){var p0=seg1.points[3];var p1=seg2.points[0];// Bevel
if(lineJoin===3)return p0;// Connected, they don't need a joint
if(pointEqual(p0,p1))return p0;// Round
if(lineJoin===2){var angleOut=-seg1.tangentAngle(1);var angleIn=-seg2.tangentAngle(0)+Math.PI;var center=lineIntersection(p0,polarOffset(p0,angleOut+Math.PI/2,100),p1,polarOffset(p1,angleOut+Math.PI/2,100));var radius=center?pointDistance(center,p0):pointDistance(p0,p1)/2;var tan=polarOffset(p0,angleOut,2*radius*roundCorner);outputBezier.setXYAt(tan[0],tan[1],'o',outputBezier.length()-1);tan=polarOffset(p1,angleIn,2*radius*roundCorner);outputBezier.setTripleAt(p1[0],p1[1],p1[0],p1[1],tan[0],tan[1],outputBezier.length());return p1;}// Miter
var t0=pointEqual(p0,seg1.points[2])?seg1.points[0]:seg1.points[2];var t1=pointEqual(p1,seg2.points[1])?seg2.points[3]:seg2.points[1];var intersection=lineIntersection(t0,p0,p1,t1);if(intersection&&pointDistance(intersection,p0)<miterLimit){outputBezier.setTripleAt(intersection[0],intersection[1],intersection[0],intersection[1],intersection[0],intersection[1],outputBezier.length());return intersection;}return p0;}function getIntersection(a,b){var intersect=a.intersections(b);if(intersect.length&&floatEqual(intersect[0][0],1))intersect.shift();if(intersect.length)return intersect[0];return null;}function pruneSegmentIntersection(a,b){var outa=a.slice();var outb=b.slice();var intersect=getIntersection(a[a.length-1],b[0]);if(intersect){outa[a.length-1]=a[a.length-1].split(intersect[0])[0];outb[0]=b[0].split(intersect[1])[1];}if(a.length>1&&b.length>1){intersect=getIntersection(a[0],b[b.length-1]);if(intersect){return [[a[0].split(intersect[0])[0]],[b[b.length-1].split(intersect[1])[1]]];}}return [outa,outb];}function pruneIntersections(segments){var e;for(var i=1;i<segments.length;i+=1){e=pruneSegmentIntersection(segments[i-1],segments[i]);segments[i-1]=e[0];segments[i]=e[1];}if(segments.length>1){e=pruneSegmentIntersection(segments[segments.length-1],segments[0]);segments[segments.length-1]=e[0];segments[0]=e[1];}return segments;}function offsetSegmentSplit(segment,amount){/*
	      We split each bezier segment into smaller pieces based
	      on inflection points, this ensures the control point
	      polygon is convex.
	        (A cubic bezier can have none, one, or two inflection points)
	    */var flex=segment.inflectionPoints();var left;var right;var split;var mid;if(flex.length===0){return [offsetSegment(segment,amount)];}if(flex.length===1||floatEqual(flex[1],1)){split=segment.split(flex[0]);left=split[0];right=split[1];return [offsetSegment(left,amount),offsetSegment(right,amount)];}split=segment.split(flex[0]);left=split[0];var t=(flex[1]-flex[0])/(1-flex[0]);split=split[1].split(t);mid=split[0];right=split[1];return [offsetSegment(left,amount),offsetSegment(mid,amount),offsetSegment(right,amount)];}function OffsetPathModifier(){}extendPrototype([ShapeModifier],OffsetPathModifier);OffsetPathModifier.prototype.initModifierProperties=function(elem,data){this.getValue=this.processKeys;this.amount=PropertyFactory.getProp(elem,data.a,0,null,this);this.miterLimit=PropertyFactory.getProp(elem,data.ml,0,null,this);this.lineJoin=data.lj;this._isAnimated=this.amount.effectsSequence.length!==0;};OffsetPathModifier.prototype.processPath=function(inputBezier,amount,lineJoin,miterLimit){var outputBezier=shapePool.newElement();outputBezier.c=inputBezier.c;var count=inputBezier.length();if(!inputBezier.c){count-=1;}var i;var j;var segment;var multiSegments=[];for(i=0;i<count;i+=1){segment=PolynomialBezier.shapeSegment(inputBezier,i);multiSegments.push(offsetSegmentSplit(segment,amount));}if(!inputBezier.c){for(i=count-1;i>=0;i-=1){segment=PolynomialBezier.shapeSegmentInverted(inputBezier,i);multiSegments.push(offsetSegmentSplit(segment,amount));}}multiSegments=pruneIntersections(multiSegments);// Add bezier segments to the output and apply line joints
var lastPoint=null;var lastSeg=null;for(i=0;i<multiSegments.length;i+=1){var multiSegment=multiSegments[i];if(lastSeg)lastPoint=joinLines(outputBezier,lastSeg,multiSegment[0],lineJoin,miterLimit);lastSeg=multiSegment[multiSegment.length-1];for(j=0;j<multiSegment.length;j+=1){segment=multiSegment[j];if(lastPoint&&pointEqual(segment.points[0],lastPoint)){outputBezier.setXYAt(segment.points[1][0],segment.points[1][1],'o',outputBezier.length()-1);}else {outputBezier.setTripleAt(segment.points[0][0],segment.points[0][1],segment.points[1][0],segment.points[1][1],segment.points[0][0],segment.points[0][1],outputBezier.length());}outputBezier.setTripleAt(segment.points[3][0],segment.points[3][1],segment.points[3][0],segment.points[3][1],segment.points[2][0],segment.points[2][1],outputBezier.length());lastPoint=segment.points[3];}}if(multiSegments.length)joinLines(outputBezier,lastSeg,multiSegments[0][0],lineJoin,miterLimit);return outputBezier;};OffsetPathModifier.prototype.processShapes=function(_isFirstFrame){var shapePaths;var i;var len=this.shapes.length;var j;var jLen;var amount=this.amount.v;var miterLimit=this.miterLimit.v;var lineJoin=this.lineJoin;if(amount!==0){var shapeData;var localShapeCollection;for(i=0;i<len;i+=1){shapeData=this.shapes[i];localShapeCollection=shapeData.localShapeCollection;if(!(!shapeData.shape._mdf&&!this._mdf&&!_isFirstFrame)){localShapeCollection.releaseShapes();shapeData.shape._mdf=true;shapePaths=shapeData.shape.paths.shapes;jLen=shapeData.shape.paths._length;for(j=0;j<jLen;j+=1){localShapeCollection.addShape(this.processPath(shapePaths[j],amount,lineJoin,miterLimit));}}shapeData.shape.paths=shapeData.localShapeCollection;}}if(!this.dynamicProperties.length){this._mdf=false;}};function getFontProperties(fontData){var styles=fontData.fStyle?fontData.fStyle.split(' '):[];var fWeight='normal';var fStyle='normal';var len=styles.length;var styleName;for(var i=0;i<len;i+=1){styleName=styles[i].toLowerCase();switch(styleName){case'italic':fStyle='italic';break;case'bold':fWeight='700';break;case'black':fWeight='900';break;case'medium':fWeight='500';break;case'regular':case'normal':fWeight='400';break;case'light':case'thin':fWeight='200';break;}}return {style:fStyle,weight:fontData.fWeight||fWeight};}var FontManager=function(){var maxWaitingTime=5000;var emptyChar={w:0,size:0,shapes:[],data:{shapes:[]}};var combinedCharacters=[];// Hindi characters
combinedCharacters=combinedCharacters.concat([2304,2305,2306,2307,2362,2363,2364,2364,2366,2367,2368,2369,2370,2371,2372,2373,2374,2375,2376,2377,2378,2379,2380,2381,2382,2383,2387,2388,2389,2390,2391,2402,2403]);var BLACK_FLAG_CODE_POINT=127988;var CANCEL_TAG_CODE_POINT=917631;var A_TAG_CODE_POINT=917601;var Z_TAG_CODE_POINT=917626;var VARIATION_SELECTOR_16_CODE_POINT=65039;var ZERO_WIDTH_JOINER_CODE_POINT=8205;var REGIONAL_CHARACTER_A_CODE_POINT=127462;var REGIONAL_CHARACTER_Z_CODE_POINT=127487;var surrogateModifiers=['d83cdffb','d83cdffc','d83cdffd','d83cdffe','d83cdfff'];function trimFontOptions(font){var familyArray=font.split(',');var i;var len=familyArray.length;var enabledFamilies=[];for(i=0;i<len;i+=1){if(familyArray[i]!=='sans-serif'&&familyArray[i]!=='monospace'){enabledFamilies.push(familyArray[i]);}}return enabledFamilies.join(',');}function setUpNode(font,family){var parentNode=createTag('span');// Node is invisible to screen readers.
parentNode.setAttribute('aria-hidden',true);parentNode.style.fontFamily=family;var node=createTag('span');// Characters that vary significantly among different fonts
node.innerText='giItT1WQy@!-/#';// Visible - so we can measure it - but not on the screen
parentNode.style.position='absolute';parentNode.style.left='-10000px';parentNode.style.top='-10000px';// Large font size makes even subtle changes obvious
parentNode.style.fontSize='300px';// Reset any font properties
parentNode.style.fontVariant='normal';parentNode.style.fontStyle='normal';parentNode.style.fontWeight='normal';parentNode.style.letterSpacing='0';parentNode.appendChild(node);document.body.appendChild(parentNode);// Remember width with no applied web font
var width=node.offsetWidth;node.style.fontFamily=trimFontOptions(font)+', '+family;return {node:node,w:width,parent:parentNode};}function checkLoadedFonts(){var i;var len=this.fonts.length;var node;var w;var loadedCount=len;for(i=0;i<len;i+=1){if(this.fonts[i].loaded){loadedCount-=1;}else if(this.fonts[i].fOrigin==='n'||this.fonts[i].origin===0){this.fonts[i].loaded=true;}else {node=this.fonts[i].monoCase.node;w=this.fonts[i].monoCase.w;if(node.offsetWidth!==w){loadedCount-=1;this.fonts[i].loaded=true;}else {node=this.fonts[i].sansCase.node;w=this.fonts[i].sansCase.w;if(node.offsetWidth!==w){loadedCount-=1;this.fonts[i].loaded=true;}}if(this.fonts[i].loaded){this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);}}}if(loadedCount!==0&&Date.now()-this.initTime<maxWaitingTime){setTimeout(this.checkLoadedFontsBinded,20);}else {setTimeout(this.setIsLoadedBinded,10);}}function createHelper(fontData,def){var engine=document.body&&def?'svg':'canvas';var helper;var fontProps=getFontProperties(fontData);if(engine==='svg'){var tHelper=createNS('text');tHelper.style.fontSize='100px';// tHelper.style.fontFamily = fontData.fFamily;
tHelper.setAttribute('font-family',fontData.fFamily);tHelper.setAttribute('font-style',fontProps.style);tHelper.setAttribute('font-weight',fontProps.weight);tHelper.textContent='1';if(fontData.fClass){tHelper.style.fontFamily='inherit';tHelper.setAttribute('class',fontData.fClass);}else {tHelper.style.fontFamily=fontData.fFamily;}def.appendChild(tHelper);helper=tHelper;}else {var tCanvasHelper=new OffscreenCanvas(500,500).getContext('2d');tCanvasHelper.font=fontProps.style+' '+fontProps.weight+' 100px '+fontData.fFamily;helper=tCanvasHelper;}function measure(text){if(engine==='svg'){helper.textContent=text;return helper.getComputedTextLength();}return helper.measureText(text).width;}return {measureText:measure};}function addFonts(fontData,defs){if(!fontData){this.isLoaded=true;return;}if(this.chars){this.isLoaded=true;this.fonts=fontData.list;return;}if(!document.body){this.isLoaded=true;fontData.list.forEach(function(data){data.helper=createHelper(data);data.cache={};});this.fonts=fontData.list;return;}var fontArr=fontData.list;var i;var len=fontArr.length;var _pendingFonts=len;for(i=0;i<len;i+=1){var shouldLoadFont=true;var loadedSelector;var j;fontArr[i].loaded=false;fontArr[i].monoCase=setUpNode(fontArr[i].fFamily,'monospace');fontArr[i].sansCase=setUpNode(fontArr[i].fFamily,'sans-serif');if(!fontArr[i].fPath){fontArr[i].loaded=true;_pendingFonts-=1;}else if(fontArr[i].fOrigin==='p'||fontArr[i].origin===3){loadedSelector=document.querySelectorAll('style[f-forigin="p"][f-family="'+fontArr[i].fFamily+'"], style[f-origin="3"][f-family="'+fontArr[i].fFamily+'"]');if(loadedSelector.length>0){shouldLoadFont=false;}if(shouldLoadFont){var s=createTag('style');s.setAttribute('f-forigin',fontArr[i].fOrigin);s.setAttribute('f-origin',fontArr[i].origin);s.setAttribute('f-family',fontArr[i].fFamily);s.type='text/css';s.innerText='@font-face {font-family: '+fontArr[i].fFamily+"; font-style: normal; src: url('"+fontArr[i].fPath+"');}";defs.appendChild(s);}}else if(fontArr[i].fOrigin==='g'||fontArr[i].origin===1){loadedSelector=document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]');for(j=0;j<loadedSelector.length;j+=1){if(loadedSelector[j].href.indexOf(fontArr[i].fPath)!==-1){// Font is already loaded
shouldLoadFont=false;}}if(shouldLoadFont){var l=createTag('link');l.setAttribute('f-forigin',fontArr[i].fOrigin);l.setAttribute('f-origin',fontArr[i].origin);l.type='text/css';l.rel='stylesheet';l.href=fontArr[i].fPath;document.body.appendChild(l);}}else if(fontArr[i].fOrigin==='t'||fontArr[i].origin===2){loadedSelector=document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]');for(j=0;j<loadedSelector.length;j+=1){if(fontArr[i].fPath===loadedSelector[j].src){// Font is already loaded
shouldLoadFont=false;}}if(shouldLoadFont){var sc=createTag('link');sc.setAttribute('f-forigin',fontArr[i].fOrigin);sc.setAttribute('f-origin',fontArr[i].origin);sc.setAttribute('rel','stylesheet');sc.setAttribute('href',fontArr[i].fPath);defs.appendChild(sc);}}fontArr[i].helper=createHelper(fontArr[i],defs);fontArr[i].cache={};this.fonts.push(fontArr[i]);}if(_pendingFonts===0){this.isLoaded=true;}else {// On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.
// Adding this timeout seems to fix it
setTimeout(this.checkLoadedFonts.bind(this),100);}}function addChars(chars){if(!chars){return;}if(!this.chars){this.chars=[];}var i;var len=chars.length;var j;var jLen=this.chars.length;var found;for(i=0;i<len;i+=1){j=0;found=false;while(j<jLen){if(this.chars[j].style===chars[i].style&&this.chars[j].fFamily===chars[i].fFamily&&this.chars[j].ch===chars[i].ch){found=true;}j+=1;}if(!found){this.chars.push(chars[i]);jLen+=1;}}}function getCharData(_char,style,font){var i=0;var len=this.chars.length;while(i<len){if(this.chars[i].ch===_char&&this.chars[i].style===style&&this.chars[i].fFamily===font){return this.chars[i];}i+=1;}if((typeof _char==='string'&&_char.charCodeAt(0)!==13||!_char)&&console&&console.warn// eslint-disable-line no-console
&&!this._warned){this._warned=true;console.warn('Missing character from exported characters list: ',_char,style,font);// eslint-disable-line no-console
}return emptyChar;}function measureText(_char2,fontName,size){var fontData=this.getFontByName(fontName);// Using the char instead of char.charCodeAt(0)
// to avoid collisions between equal chars
var index=_char2;if(!fontData.cache[index]){var tHelper=fontData.helper;if(_char2===' '){var doubleSize=tHelper.measureText('|'+_char2+'|');var singleSize=tHelper.measureText('||');fontData.cache[index]=(doubleSize-singleSize)/100;}else {fontData.cache[index]=tHelper.measureText(_char2)/100;}}return fontData.cache[index]*size;}function getFontByName(name){var i=0;var len=this.fonts.length;while(i<len){if(this.fonts[i].fName===name){return this.fonts[i];}i+=1;}return this.fonts[0];}function getCodePoint(string){var codePoint=0;var first=string.charCodeAt(0);if(first>=0xD800&&first<=0xDBFF){var second=string.charCodeAt(1);if(second>=0xDC00&&second<=0xDFFF){codePoint=(first-0xD800)*0x400+second-0xDC00+0x10000;}}return codePoint;}// Skin tone modifiers
function isModifier(firstCharCode,secondCharCode){var sum=firstCharCode.toString(16)+secondCharCode.toString(16);return surrogateModifiers.indexOf(sum)!==-1;}function isZeroWidthJoiner(charCode){return charCode===ZERO_WIDTH_JOINER_CODE_POINT;}// This codepoint may change the appearance of the preceding character.
// If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered
// as a colorful image as compared to a monochrome text variant.
function isVariationSelector(charCode){return charCode===VARIATION_SELECTOR_16_CODE_POINT;}// The regional indicator symbols are a set of 26 alphabetic Unicode
/// characters (A–Z) intended to be used to encode ISO 3166-1 alpha-2
// two-letter country codes in a way that allows optional special treatment.
function isRegionalCode(string){var codePoint=getCodePoint(string);if(codePoint>=REGIONAL_CHARACTER_A_CODE_POINT&&codePoint<=REGIONAL_CHARACTER_Z_CODE_POINT){return true;}return false;}// Some Emoji implementations represent combinations of
// two “regional indicator” letters as a single flag symbol.
function isFlagEmoji(string){return isRegionalCode(string.substr(0,2))&&isRegionalCode(string.substr(2,2));}function isCombinedCharacter(_char3){return combinedCharacters.indexOf(_char3)!==-1;}// Regional flags start with a BLACK_FLAG_CODE_POINT
// folowed by 5 chars in the TAG range
// and end with a CANCEL_TAG_CODE_POINT
function isRegionalFlag(text,index){var codePoint=getCodePoint(text.substr(index,2));if(codePoint!==BLACK_FLAG_CODE_POINT){return false;}var count=0;index+=2;while(count<5){codePoint=getCodePoint(text.substr(index,2));if(codePoint<A_TAG_CODE_POINT||codePoint>Z_TAG_CODE_POINT){return false;}count+=1;index+=2;}return getCodePoint(text.substr(index,2))===CANCEL_TAG_CODE_POINT;}function setIsLoaded(){this.isLoaded=true;}var Font=function Font(){this.fonts=[];this.chars=null;this.typekitLoaded=0;this.isLoaded=false;this._warned=false;this.initTime=Date.now();this.setIsLoadedBinded=this.setIsLoaded.bind(this);this.checkLoadedFontsBinded=this.checkLoadedFonts.bind(this);};Font.isModifier=isModifier;Font.isZeroWidthJoiner=isZeroWidthJoiner;Font.isFlagEmoji=isFlagEmoji;Font.isRegionalCode=isRegionalCode;Font.isCombinedCharacter=isCombinedCharacter;Font.isRegionalFlag=isRegionalFlag;Font.isVariationSelector=isVariationSelector;Font.BLACK_FLAG_CODE_POINT=BLACK_FLAG_CODE_POINT;var fontPrototype={addChars:addChars,addFonts:addFonts,getCharData:getCharData,getFontByName:getFontByName,measureText:measureText,checkLoadedFonts:checkLoadedFonts,setIsLoaded:setIsLoaded};Font.prototype=fontPrototype;return Font;}();function SlotManager(animationData){this.animationData=animationData;}SlotManager.prototype.getProp=function(data){if(this.animationData.slots&&this.animationData.slots[data.sid]){return Object.assign(data,this.animationData.slots[data.sid].p);}return data;};function slotFactory(animationData){return new SlotManager(animationData);}function RenderableElement(){}RenderableElement.prototype={initRenderable:function initRenderable(){// layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange
this.isInRange=false;// layer's display state
this.hidden=false;// If layer's transparency equals 0, it can be hidden
this.isTransparent=false;// list of animated components
this.renderableComponents=[];},addRenderableComponent:function addRenderableComponent(component){if(this.renderableComponents.indexOf(component)===-1){this.renderableComponents.push(component);}},removeRenderableComponent:function removeRenderableComponent(component){if(this.renderableComponents.indexOf(component)!==-1){this.renderableComponents.splice(this.renderableComponents.indexOf(component),1);}},prepareRenderableFrame:function prepareRenderableFrame(num){this.checkLayerLimits(num);},checkTransparency:function checkTransparency(){if(this.finalTransform.mProp.o.v<=0){if(!this.isTransparent&&this.globalData.renderConfig.hideOnTransparent){this.isTransparent=true;this.hide();}}else if(this.isTransparent){this.isTransparent=false;this.show();}},/**
	       * @function
	       * Initializes frame related properties.
	       *
	       * @param {number} num
	       * current frame number in Layer's time
	       *
	       */checkLayerLimits:function checkLayerLimits(num){if(this.data.ip-this.data.st<=num&&this.data.op-this.data.st>num){if(this.isInRange!==true){this.globalData._mdf=true;this._mdf=true;this.isInRange=true;this.show();}}else if(this.isInRange!==false){this.globalData._mdf=true;this.isInRange=false;this.hide();}},renderRenderable:function renderRenderable(){var i;var len=this.renderableComponents.length;for(i=0;i<len;i+=1){this.renderableComponents[i].renderFrame(this._isFirstFrame);}/* this.maskManager.renderFrame(this.finalTransform.mat);
	          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */},sourceRectAtTime:function sourceRectAtTime(){return {top:0,left:0,width:100,height:100};},getLayerSize:function getLayerSize(){if(this.data.ty===5){return {w:this.data.textData.width,h:this.data.textData.height};}return {w:this.data.width,h:this.data.height};}};var getBlendMode=function(){var blendModeEnums={0:'source-over',1:'multiply',2:'screen',3:'overlay',4:'darken',5:'lighten',6:'color-dodge',7:'color-burn',8:'hard-light',9:'soft-light',10:'difference',11:'exclusion',12:'hue',13:'saturation',14:'color',15:'luminosity'};return function(mode){return blendModeEnums[mode]||'';};}();function SliderEffect(data,elem,container){this.p=PropertyFactory.getProp(elem,data.v,0,0,container);}function AngleEffect(data,elem,container){this.p=PropertyFactory.getProp(elem,data.v,0,0,container);}function ColorEffect(data,elem,container){this.p=PropertyFactory.getProp(elem,data.v,1,0,container);}function PointEffect(data,elem,container){this.p=PropertyFactory.getProp(elem,data.v,1,0,container);}function LayerIndexEffect(data,elem,container){this.p=PropertyFactory.getProp(elem,data.v,0,0,container);}function MaskIndexEffect(data,elem,container){this.p=PropertyFactory.getProp(elem,data.v,0,0,container);}function CheckboxEffect(data,elem,container){this.p=PropertyFactory.getProp(elem,data.v,0,0,container);}function NoValueEffect(){this.p={};}function EffectsManager(data,element){var effects=data.ef||[];this.effectElements=[];var i;var len=effects.length;var effectItem;for(i=0;i<len;i+=1){effectItem=new GroupEffect(effects[i],element);this.effectElements.push(effectItem);}}function GroupEffect(data,element){this.init(data,element);}extendPrototype([DynamicPropertyContainer],GroupEffect);GroupEffect.prototype.getValue=GroupEffect.prototype.iterateDynamicProperties;GroupEffect.prototype.init=function(data,element){this.data=data;this.effectElements=[];this.initDynamicPropertyContainer(element);var i;var len=this.data.ef.length;var eff;var effects=this.data.ef;for(i=0;i<len;i+=1){eff=null;switch(effects[i].ty){case 0:eff=new SliderEffect(effects[i],element,this);break;case 1:eff=new AngleEffect(effects[i],element,this);break;case 2:eff=new ColorEffect(effects[i],element,this);break;case 3:eff=new PointEffect(effects[i],element,this);break;case 4:case 7:eff=new CheckboxEffect(effects[i],element,this);break;case 10:eff=new LayerIndexEffect(effects[i],element,this);break;case 11:eff=new MaskIndexEffect(effects[i],element,this);break;case 5:eff=new EffectsManager(effects[i],element);break;// case 6:
default:eff=new NoValueEffect(effects[i]);break;}if(eff){this.effectElements.push(eff);}}};function BaseElement(){}BaseElement.prototype={checkMasks:function checkMasks(){if(!this.data.hasMask){return false;}var i=0;var len=this.data.masksProperties.length;while(i<len){if(this.data.masksProperties[i].mode!=='n'&&this.data.masksProperties[i].cl!==false){return true;}i+=1;}return false;},initExpressions:function initExpressions(){var expressionsInterfaces=getExpressionInterfaces();if(!expressionsInterfaces){return;}var LayerExpressionInterface=expressionsInterfaces('layer');var EffectsExpressionInterface=expressionsInterfaces('effects');var ShapeExpressionInterface=expressionsInterfaces('shape');var TextExpressionInterface=expressionsInterfaces('text');var CompExpressionInterface=expressionsInterfaces('comp');this.layerInterface=LayerExpressionInterface(this);if(this.data.hasMask&&this.maskManager){this.layerInterface.registerMaskInterface(this.maskManager);}var effectsInterface=EffectsExpressionInterface.createEffectsInterface(this,this.layerInterface);this.layerInterface.registerEffectsInterface(effectsInterface);if(this.data.ty===0||this.data.xt){this.compInterface=CompExpressionInterface(this);}else if(this.data.ty===4){this.layerInterface.shapeInterface=ShapeExpressionInterface(this.shapesData,this.itemsData,this.layerInterface);this.layerInterface.content=this.layerInterface.shapeInterface;}else if(this.data.ty===5){this.layerInterface.textInterface=TextExpressionInterface(this);this.layerInterface.text=this.layerInterface.textInterface;}},setBlendMode:function setBlendMode(){var blendModeValue=getBlendMode(this.data.bm);var elem=this.baseElement||this.layerElement;elem.style['mix-blend-mode']=blendModeValue;},initBaseData:function initBaseData(data,globalData,comp){this.globalData=globalData;this.comp=comp;this.data=data;this.layerId=createElementID();// Stretch factor for old animations missing this property.
if(!this.data.sr){this.data.sr=1;}// effects manager
this.effectsManager=new EffectsManager(this.data,this,this.dynamicProperties);},getType:function getType(){return this.type;},sourceRectAtTime:function sourceRectAtTime(){}};/**
	   * @file
	   * Handles element's layer frame update.
	   * Checks layer in point and out point
	   *
	   */function FrameElement(){}FrameElement.prototype={/**
	       * @function
	       * Initializes frame related properties.
	       *
	       */initFrame:function initFrame(){// set to true when inpoint is rendered
this._isFirstFrame=false;// list of animated properties
this.dynamicProperties=[];// If layer has been modified in current tick this will be true
this._mdf=false;},/**
	       * @function
	       * Calculates all dynamic values
	       *
	       * @param {number} num
	       * current frame number in Layer's time
	       * @param {boolean} isVisible
	       * if layers is currently in range
	       *
	       */prepareProperties:function prepareProperties(num,isVisible){var i;var len=this.dynamicProperties.length;for(i=0;i<len;i+=1){if(isVisible||this._isParent&&this.dynamicProperties[i].propType==='transform'){this.dynamicProperties[i].getValue();if(this.dynamicProperties[i]._mdf){this.globalData._mdf=true;this._mdf=true;}}}},addDynamicProperty:function addDynamicProperty(prop){if(this.dynamicProperties.indexOf(prop)===-1){this.dynamicProperties.push(prop);}}};function FootageElement(data,globalData,comp){this.initFrame();this.initRenderable();this.assetData=globalData.getAssetData(data.refId);this.footageData=globalData.imageLoader.getAsset(this.assetData);this.initBaseData(data,globalData,comp);}FootageElement.prototype.prepareFrame=function(){};extendPrototype([RenderableElement,BaseElement,FrameElement],FootageElement);FootageElement.prototype.getBaseElement=function(){return null;};FootageElement.prototype.renderFrame=function(){};FootageElement.prototype.destroy=function(){};FootageElement.prototype.initExpressions=function(){var expressionsInterfaces=getExpressionInterfaces();if(!expressionsInterfaces){return;}var FootageInterface=expressionsInterfaces('footage');this.layerInterface=FootageInterface(this);};FootageElement.prototype.getFootageData=function(){return this.footageData;};function AudioElement(data,globalData,comp){this.initFrame();this.initRenderable();this.assetData=globalData.getAssetData(data.refId);this.initBaseData(data,globalData,comp);this._isPlaying=false;this._canPlay=false;var assetPath=this.globalData.getAssetsPath(this.assetData);this.audio=this.globalData.audioController.createAudio(assetPath);this._currentTime=0;this.globalData.audioController.addAudio(this);this._volumeMultiplier=1;this._volume=1;this._previousVolume=null;this.tm=data.tm?PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this):{_placeholder:true};this.lv=PropertyFactory.getProp(this,data.au&&data.au.lv?data.au.lv:{k:[100]},1,0.01,this);}AudioElement.prototype.prepareFrame=function(num){this.prepareRenderableFrame(num,true);this.prepareProperties(num,true);if(!this.tm._placeholder){var timeRemapped=this.tm.v;this._currentTime=timeRemapped;}else {this._currentTime=num/this.data.sr;}this._volume=this.lv.v[0];var totalVolume=this._volume*this._volumeMultiplier;if(this._previousVolume!==totalVolume){this._previousVolume=totalVolume;this.audio.volume(totalVolume);}};extendPrototype([RenderableElement,BaseElement,FrameElement],AudioElement);AudioElement.prototype.renderFrame=function(){if(this.isInRange&&this._canPlay){if(!this._isPlaying){this.audio.play();this.audio.seek(this._currentTime/this.globalData.frameRate);this._isPlaying=true;}else if(!this.audio.playing()||Math.abs(this._currentTime/this.globalData.frameRate-this.audio.seek())>0.1){this.audio.seek(this._currentTime/this.globalData.frameRate);}}};AudioElement.prototype.show=function(){// this.audio.play()
};AudioElement.prototype.hide=function(){this.audio.pause();this._isPlaying=false;};AudioElement.prototype.pause=function(){this.audio.pause();this._isPlaying=false;this._canPlay=false;};AudioElement.prototype.resume=function(){this._canPlay=true;};AudioElement.prototype.setRate=function(rateValue){this.audio.rate(rateValue);};AudioElement.prototype.volume=function(volumeValue){this._volumeMultiplier=volumeValue;this._previousVolume=volumeValue*this._volume;this.audio.volume(this._previousVolume);};AudioElement.prototype.getBaseElement=function(){return null;};AudioElement.prototype.destroy=function(){};AudioElement.prototype.sourceRectAtTime=function(){};AudioElement.prototype.initExpressions=function(){};function BaseRenderer(){}BaseRenderer.prototype.checkLayers=function(num){var i;var len=this.layers.length;var data;this.completeLayers=true;for(i=len-1;i>=0;i-=1){if(!this.elements[i]){data=this.layers[i];if(data.ip-data.st<=num-this.layers[i].st&&data.op-data.st>num-this.layers[i].st){this.buildItem(i);}}this.completeLayers=this.elements[i]?this.completeLayers:false;}this.checkPendingElements();};BaseRenderer.prototype.createItem=function(layer){switch(layer.ty){case 2:return this.createImage(layer);case 0:return this.createComp(layer);case 1:return this.createSolid(layer);case 3:return this.createNull(layer);case 4:return this.createShape(layer);case 5:return this.createText(layer);case 6:return this.createAudio(layer);case 13:return this.createCamera(layer);case 15:return this.createFootage(layer);default:return this.createNull(layer);}};BaseRenderer.prototype.createCamera=function(){throw new Error('You\'re using a 3d camera. Try the html renderer.');};BaseRenderer.prototype.createAudio=function(data){return new AudioElement(data,this.globalData,this);};BaseRenderer.prototype.createFootage=function(data){return new FootageElement(data,this.globalData,this);};BaseRenderer.prototype.buildAllItems=function(){var i;var len=this.layers.length;for(i=0;i<len;i+=1){this.buildItem(i);}this.checkPendingElements();};BaseRenderer.prototype.includeLayers=function(newLayers){this.completeLayers=false;var i;var len=newLayers.length;var j;var jLen=this.layers.length;for(i=0;i<len;i+=1){j=0;while(j<jLen){if(this.layers[j].id===newLayers[i].id){this.layers[j]=newLayers[i];break;}j+=1;}}};BaseRenderer.prototype.setProjectInterface=function(pInterface){this.globalData.projectInterface=pInterface;};BaseRenderer.prototype.initItems=function(){if(!this.globalData.progressiveLoad){this.buildAllItems();}};BaseRenderer.prototype.buildElementParenting=function(element,parentName,hierarchy){var elements=this.elements;var layers=this.layers;var i=0;var len=layers.length;while(i<len){if(layers[i].ind==parentName){// eslint-disable-line eqeqeq
if(!elements[i]||elements[i]===true){this.buildItem(i);this.addPendingElement(element);}else {hierarchy.push(elements[i]);elements[i].setAsParent();if(layers[i].parent!==undefined){this.buildElementParenting(element,layers[i].parent,hierarchy);}else {element.setHierarchy(hierarchy);}}}i+=1;}};BaseRenderer.prototype.addPendingElement=function(element){this.pendingElements.push(element);};BaseRenderer.prototype.searchExtraCompositions=function(assets){var i;var len=assets.length;for(i=0;i<len;i+=1){if(assets[i].xt){var comp=this.createComp(assets[i]);comp.initExpressions();this.globalData.projectInterface.registerComposition(comp);}}};BaseRenderer.prototype.getElementById=function(ind){var i;var len=this.elements.length;for(i=0;i<len;i+=1){if(this.elements[i].data.ind===ind){return this.elements[i];}}return null;};BaseRenderer.prototype.getElementByPath=function(path){var pathValue=path.shift();var element;if(typeof pathValue==='number'){element=this.elements[pathValue];}else {var i;var len=this.elements.length;for(i=0;i<len;i+=1){if(this.elements[i].data.nm===pathValue){element=this.elements[i];break;}}}if(path.length===0){return element;}return element.getElementByPath(path);};BaseRenderer.prototype.setupGlobalData=function(animData,fontsContainer){this.globalData.fontManager=new FontManager();this.globalData.slotManager=slotFactory(animData);this.globalData.fontManager.addChars(animData.chars);this.globalData.fontManager.addFonts(animData.fonts,fontsContainer);this.globalData.getAssetData=this.animationItem.getAssetData.bind(this.animationItem);this.globalData.getAssetsPath=this.animationItem.getAssetsPath.bind(this.animationItem);this.globalData.imageLoader=this.animationItem.imagePreloader;this.globalData.audioController=this.animationItem.audioController;this.globalData.frameId=0;this.globalData.frameRate=animData.fr;this.globalData.nm=animData.nm;this.globalData.compSize={w:animData.w,h:animData.h};};var effectTypes={TRANSFORM_EFFECT:'transformEFfect'};function TransformElement(){}TransformElement.prototype={initTransform:function initTransform(){var mat=new Matrix();this.finalTransform={mProp:this.data.ks?TransformPropertyFactory.getTransformProperty(this,this.data.ks,this):{o:0},_matMdf:false,_localMatMdf:false,_opMdf:false,mat:mat,localMat:mat,localOpacity:1};if(this.data.ao){this.finalTransform.mProp.autoOriented=true;}// TODO: check TYPE 11: Guided elements
if(this.data.ty!==11);},renderTransform:function renderTransform(){this.finalTransform._opMdf=this.finalTransform.mProp.o._mdf||this._isFirstFrame;this.finalTransform._matMdf=this.finalTransform.mProp._mdf||this._isFirstFrame;if(this.hierarchy){var mat;var finalMat=this.finalTransform.mat;var i=0;var len=this.hierarchy.length;// Checking if any of the transformation matrices in the hierarchy chain has changed.
if(!this.finalTransform._matMdf){while(i<len){if(this.hierarchy[i].finalTransform.mProp._mdf){this.finalTransform._matMdf=true;break;}i+=1;}}if(this.finalTransform._matMdf){mat=this.finalTransform.mProp.v.props;finalMat.cloneFromProps(mat);for(i=0;i<len;i+=1){finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);}}}if(this.finalTransform._matMdf){this.finalTransform._localMatMdf=this.finalTransform._matMdf;}if(this.finalTransform._opMdf){this.finalTransform.localOpacity=this.finalTransform.mProp.o.v;}},renderLocalTransform:function renderLocalTransform(){if(this.localTransforms){var i=0;var len=this.localTransforms.length;this.finalTransform._localMatMdf=this.finalTransform._matMdf;if(!this.finalTransform._localMatMdf||!this.finalTransform._opMdf){while(i<len){if(this.localTransforms[i]._mdf){this.finalTransform._localMatMdf=true;}if(this.localTransforms[i]._opMdf&&!this.finalTransform._opMdf){this.finalTransform.localOpacity=this.finalTransform.mProp.o.v;this.finalTransform._opMdf=true;}i+=1;}}if(this.finalTransform._localMatMdf){var localMat=this.finalTransform.localMat;this.localTransforms[0].matrix.clone(localMat);for(i=1;i<len;i+=1){var lmat=this.localTransforms[i].matrix;localMat.multiply(lmat);}localMat.multiply(this.finalTransform.mat);}if(this.finalTransform._opMdf){var localOp=this.finalTransform.localOpacity;for(i=0;i<len;i+=1){localOp*=this.localTransforms[i].opacity*0.01;}this.finalTransform.localOpacity=localOp;}}},searchEffectTransforms:function searchEffectTransforms(){if(this.renderableEffectsManager){var transformEffects=this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);if(transformEffects.length){this.localTransforms=[];this.finalTransform.localMat=new Matrix();var i=0;var len=transformEffects.length;for(i=0;i<len;i+=1){this.localTransforms.push(transformEffects[i]);}}}},globalToLocal:function globalToLocal(pt){var transforms=[];transforms.push(this.finalTransform);var flag=true;var comp=this.comp;while(flag){if(comp.finalTransform){if(comp.data.hasMask){transforms.splice(0,0,comp.finalTransform);}comp=comp.comp;}else {flag=false;}}var i;var len=transforms.length;var ptNew;for(i=0;i<len;i+=1){ptNew=transforms[i].mat.applyToPointArray(0,0,0);// ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);
pt=[pt[0]-ptNew[0],pt[1]-ptNew[1],0];}return pt;},mHelper:new Matrix()};function MaskElement(data,element,globalData){this.data=data;this.element=element;this.globalData=globalData;this.storedData=[];this.masksProperties=this.data.masksProperties||[];this.maskElement=null;var defs=this.globalData.defs;var i;var len=this.masksProperties?this.masksProperties.length:0;this.viewData=createSizedArray(len);this.solidPath='';var path;var properties=this.masksProperties;var count=0;var currentMasks=[];var j;var jLen;var layerId=createElementID();var rect;var expansor;var feMorph;var x;var maskType='clipPath';var maskRef='clip-path';for(i=0;i<len;i+=1){if(properties[i].mode!=='a'&&properties[i].mode!=='n'||properties[i].inv||properties[i].o.k!==100||properties[i].o.x){maskType='mask';maskRef='mask';}if((properties[i].mode==='s'||properties[i].mode==='i')&&count===0){rect=createNS('rect');rect.setAttribute('fill','#ffffff');rect.setAttribute('width',this.element.comp.data.w||0);rect.setAttribute('height',this.element.comp.data.h||0);currentMasks.push(rect);}else {rect=null;}path=createNS('path');if(properties[i].mode==='n'){// TODO move this to a factory or to a constructor
this.viewData[i]={op:PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.element),prop:ShapePropertyFactory.getShapeProp(this.element,properties[i],3),elem:path,lastPath:''};defs.appendChild(path);}else {count+=1;path.setAttribute('fill',properties[i].mode==='s'?'#000000':'#ffffff');path.setAttribute('clip-rule','nonzero');var filterID;if(properties[i].x.k!==0){maskType='mask';maskRef='mask';x=PropertyFactory.getProp(this.element,properties[i].x,0,null,this.element);filterID=createElementID();expansor=createNS('filter');expansor.setAttribute('id',filterID);feMorph=createNS('feMorphology');feMorph.setAttribute('operator','erode');feMorph.setAttribute('in','SourceGraphic');feMorph.setAttribute('radius','0');expansor.appendChild(feMorph);defs.appendChild(expansor);path.setAttribute('stroke',properties[i].mode==='s'?'#000000':'#ffffff');}else {feMorph=null;x=null;}// TODO move this to a factory or to a constructor
this.storedData[i]={elem:path,x:x,expan:feMorph,lastPath:'',lastOperator:'',filterId:filterID,lastRadius:0};if(properties[i].mode==='i'){jLen=currentMasks.length;var g=createNS('g');for(j=0;j<jLen;j+=1){g.appendChild(currentMasks[j]);}var mask=createNS('mask');mask.setAttribute('mask-type','alpha');mask.setAttribute('id',layerId+'_'+count);mask.appendChild(path);defs.appendChild(mask);g.setAttribute('mask','url('+getLocationHref()+'#'+layerId+'_'+count+')');currentMasks.length=0;currentMasks.push(g);}else {currentMasks.push(path);}if(properties[i].inv&&!this.solidPath){this.solidPath=this.createLayerSolidPath();}// TODO move this to a factory or to a constructor
this.viewData[i]={elem:path,lastPath:'',op:PropertyFactory.getProp(this.element,properties[i].o,0,0.01,this.element),prop:ShapePropertyFactory.getShapeProp(this.element,properties[i],3),invRect:rect};if(!this.viewData[i].prop.k){this.drawPath(properties[i],this.viewData[i].prop.v,this.viewData[i]);}}}this.maskElement=createNS(maskType);len=currentMasks.length;for(i=0;i<len;i+=1){this.maskElement.appendChild(currentMasks[i]);}if(count>0){this.maskElement.setAttribute('id',layerId);this.element.maskedElement.setAttribute(maskRef,'url('+getLocationHref()+'#'+layerId+')');defs.appendChild(this.maskElement);}if(this.viewData.length){this.element.addRenderableComponent(this);}}MaskElement.prototype.getMaskProperty=function(pos){return this.viewData[pos].prop;};MaskElement.prototype.renderFrame=function(isFirstFrame){var finalMat=this.element.finalTransform.mat;var i;var len=this.masksProperties.length;for(i=0;i<len;i+=1){if(this.viewData[i].prop._mdf||isFirstFrame){this.drawPath(this.masksProperties[i],this.viewData[i].prop.v,this.viewData[i]);}if(this.viewData[i].op._mdf||isFirstFrame){this.viewData[i].elem.setAttribute('fill-opacity',this.viewData[i].op.v);}if(this.masksProperties[i].mode!=='n'){if(this.viewData[i].invRect&&(this.element.finalTransform.mProp._mdf||isFirstFrame)){this.viewData[i].invRect.setAttribute('transform',finalMat.getInverseMatrix().to2dCSS());}if(this.storedData[i].x&&(this.storedData[i].x._mdf||isFirstFrame)){var feMorph=this.storedData[i].expan;if(this.storedData[i].x.v<0){if(this.storedData[i].lastOperator!=='erode'){this.storedData[i].lastOperator='erode';this.storedData[i].elem.setAttribute('filter','url('+getLocationHref()+'#'+this.storedData[i].filterId+')');}feMorph.setAttribute('radius',-this.storedData[i].x.v);}else {if(this.storedData[i].lastOperator!=='dilate'){this.storedData[i].lastOperator='dilate';this.storedData[i].elem.setAttribute('filter',null);}this.storedData[i].elem.setAttribute('stroke-width',this.storedData[i].x.v*2);}}}}};MaskElement.prototype.getMaskelement=function(){return this.maskElement;};MaskElement.prototype.createLayerSolidPath=function(){var path='M0,0 ';path+=' h'+this.globalData.compSize.w;path+=' v'+this.globalData.compSize.h;path+=' h-'+this.globalData.compSize.w;path+=' v-'+this.globalData.compSize.h+' ';return path;};MaskElement.prototype.drawPath=function(pathData,pathNodes,viewData){var pathString=' M'+pathNodes.v[0][0]+','+pathNodes.v[0][1];var i;var len;len=pathNodes._length;for(i=1;i<len;i+=1){// pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[i][0]+','+pathNodes.i[i][1] + " "+pathNodes.v[i][0]+','+pathNodes.v[i][1];
pathString+=' C'+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1]+' '+pathNodes.i[i][0]+','+pathNodes.i[i][1]+' '+pathNodes.v[i][0]+','+pathNodes.v[i][1];}// pathString += " C"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + " "+pathNodes.i[0][0]+','+pathNodes.i[0][1] + " "+pathNodes.v[0][0]+','+pathNodes.v[0][1];
if(pathNodes.c&&len>1){pathString+=' C'+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1]+' '+pathNodes.i[0][0]+','+pathNodes.i[0][1]+' '+pathNodes.v[0][0]+','+pathNodes.v[0][1];}// pathNodes.__renderedString = pathString;
if(viewData.lastPath!==pathString){var pathShapeValue='';if(viewData.elem){if(pathNodes.c){pathShapeValue=pathData.inv?this.solidPath+pathString:pathString;}viewData.elem.setAttribute('d',pathShapeValue);}viewData.lastPath=pathString;}};MaskElement.prototype.destroy=function(){this.element=null;this.globalData=null;this.maskElement=null;this.data=null;this.masksProperties=null;};var filtersFactory=function(){var ob={};ob.createFilter=createFilter;ob.createAlphaToLuminanceFilter=createAlphaToLuminanceFilter;function createFilter(filId,skipCoordinates){var fil=createNS('filter');fil.setAttribute('id',filId);if(skipCoordinates!==true){fil.setAttribute('filterUnits','objectBoundingBox');fil.setAttribute('x','0%');fil.setAttribute('y','0%');fil.setAttribute('width','100%');fil.setAttribute('height','100%');}return fil;}function createAlphaToLuminanceFilter(){var feColorMatrix=createNS('feColorMatrix');feColorMatrix.setAttribute('type','matrix');feColorMatrix.setAttribute('color-interpolation-filters','sRGB');feColorMatrix.setAttribute('values','0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');return feColorMatrix;}return ob;}();var featureSupport=function(){var ob={maskType:true,svgLumaHidden:true,offscreenCanvas:typeof OffscreenCanvas!=='undefined'};if(/MSIE 10/i.test(navigator.userAgent)||/MSIE 9/i.test(navigator.userAgent)||/rv:11.0/i.test(navigator.userAgent)||/Edge\/\d./i.test(navigator.userAgent)){ob.maskType=false;}if(/firefox/i.test(navigator.userAgent)){ob.svgLumaHidden=false;}return ob;}();var registeredEffects$1={};var idPrefix='filter_result_';function SVGEffects(elem){var i;var source='SourceGraphic';var len=elem.data.ef?elem.data.ef.length:0;var filId=createElementID();var fil=filtersFactory.createFilter(filId,true);var count=0;this.filters=[];var filterManager;for(i=0;i<len;i+=1){filterManager=null;var type=elem.data.ef[i].ty;if(registeredEffects$1[type]){var Effect=registeredEffects$1[type].effect;filterManager=new Effect(fil,elem.effectsManager.effectElements[i],elem,idPrefix+count,source);source=idPrefix+count;if(registeredEffects$1[type].countsAsEffect){count+=1;}}if(filterManager){this.filters.push(filterManager);}}if(count){elem.globalData.defs.appendChild(fil);elem.layerElement.setAttribute('filter','url('+getLocationHref()+'#'+filId+')');}if(this.filters.length){elem.addRenderableComponent(this);}}SVGEffects.prototype.renderFrame=function(_isFirstFrame){var i;var len=this.filters.length;for(i=0;i<len;i+=1){this.filters[i].renderFrame(_isFirstFrame);}};SVGEffects.prototype.getEffects=function(type){var i;var len=this.filters.length;var effects=[];for(i=0;i<len;i+=1){if(this.filters[i].type===type){effects.push(this.filters[i]);}}return effects;};function registerEffect$1(id,effect,countsAsEffect){registeredEffects$1[id]={effect:effect,countsAsEffect:countsAsEffect};}function SVGBaseElement(){}SVGBaseElement.prototype={initRendererElement:function initRendererElement(){this.layerElement=createNS('g');},createContainerElements:function createContainerElements(){this.matteElement=createNS('g');this.transformedElement=this.layerElement;this.maskedElement=this.layerElement;this._sizeChanged=false;var layerElementParent=null;// If this layer acts as a mask for the following layer
if(this.data.td){this.matteMasks={};var gg=createNS('g');gg.setAttribute('id',this.layerId);gg.appendChild(this.layerElement);layerElementParent=gg;this.globalData.defs.appendChild(gg);}else if(this.data.tt){this.matteElement.appendChild(this.layerElement);layerElementParent=this.matteElement;this.baseElement=this.matteElement;}else {this.baseElement=this.layerElement;}if(this.data.ln){this.layerElement.setAttribute('id',this.data.ln);}if(this.data.cl){this.layerElement.setAttribute('class',this.data.cl);}// Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped
if(this.data.ty===0&&!this.data.hd){var cp=createNS('clipPath');var pt=createNS('path');pt.setAttribute('d','M0,0 L'+this.data.w+',0 L'+this.data.w+','+this.data.h+' L0,'+this.data.h+'z');var clipId=createElementID();cp.setAttribute('id',clipId);cp.appendChild(pt);this.globalData.defs.appendChild(cp);if(this.checkMasks()){var cpGroup=createNS('g');cpGroup.setAttribute('clip-path','url('+getLocationHref()+'#'+clipId+')');cpGroup.appendChild(this.layerElement);this.transformedElement=cpGroup;if(layerElementParent){layerElementParent.appendChild(this.transformedElement);}else {this.baseElement=this.transformedElement;}}else {this.layerElement.setAttribute('clip-path','url('+getLocationHref()+'#'+clipId+')');}}if(this.data.bm!==0){this.setBlendMode();}},renderElement:function renderElement(){if(this.finalTransform._localMatMdf){this.transformedElement.setAttribute('transform',this.finalTransform.localMat.to2dCSS());}if(this.finalTransform._opMdf){this.transformedElement.setAttribute('opacity',this.finalTransform.localOpacity);}},destroyBaseElement:function destroyBaseElement(){this.layerElement=null;this.matteElement=null;this.maskManager.destroy();},getBaseElement:function getBaseElement(){if(this.data.hd){return null;}return this.baseElement;},createRenderableComponents:function createRenderableComponents(){this.maskManager=new MaskElement(this.data,this,this.globalData);this.renderableEffectsManager=new SVGEffects(this);this.searchEffectTransforms();},getMatte:function getMatte(matteType){// This should not be a common case. But for backward compatibility, we'll create the matte object.
// It solves animations that have two consecutive layers marked as matte masks.
// Which is an undefined behavior in AE.
if(!this.matteMasks){this.matteMasks={};}if(!this.matteMasks[matteType]){var id=this.layerId+'_'+matteType;var filId;var fil;var useElement;var gg;if(matteType===1||matteType===3){var masker=createNS('mask');masker.setAttribute('id',id);masker.setAttribute('mask-type',matteType===3?'luminance':'alpha');useElement=createNS('use');useElement.setAttributeNS('http://www.w3.org/1999/xlink','href','#'+this.layerId);masker.appendChild(useElement);this.globalData.defs.appendChild(masker);if(!featureSupport.maskType&&matteType===1){masker.setAttribute('mask-type','luminance');filId=createElementID();fil=filtersFactory.createFilter(filId);this.globalData.defs.appendChild(fil);fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());gg=createNS('g');gg.appendChild(useElement);masker.appendChild(gg);gg.setAttribute('filter','url('+getLocationHref()+'#'+filId+')');}}else if(matteType===2){var maskGroup=createNS('mask');maskGroup.setAttribute('id',id);maskGroup.setAttribute('mask-type','alpha');var maskGrouper=createNS('g');maskGroup.appendChild(maskGrouper);filId=createElementID();fil=filtersFactory.createFilter(filId);/// /
var feCTr=createNS('feComponentTransfer');feCTr.setAttribute('in','SourceGraphic');fil.appendChild(feCTr);var feFunc=createNS('feFuncA');feFunc.setAttribute('type','table');feFunc.setAttribute('tableValues','1.0 0.0');feCTr.appendChild(feFunc);/// /
this.globalData.defs.appendChild(fil);var alphaRect=createNS('rect');alphaRect.setAttribute('width',this.comp.data.w);alphaRect.setAttribute('height',this.comp.data.h);alphaRect.setAttribute('x','0');alphaRect.setAttribute('y','0');alphaRect.setAttribute('fill','#ffffff');alphaRect.setAttribute('opacity','0');maskGrouper.setAttribute('filter','url('+getLocationHref()+'#'+filId+')');maskGrouper.appendChild(alphaRect);useElement=createNS('use');useElement.setAttributeNS('http://www.w3.org/1999/xlink','href','#'+this.layerId);maskGrouper.appendChild(useElement);if(!featureSupport.maskType){maskGroup.setAttribute('mask-type','luminance');fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());gg=createNS('g');maskGrouper.appendChild(alphaRect);gg.appendChild(this.layerElement);maskGrouper.appendChild(gg);}this.globalData.defs.appendChild(maskGroup);}this.matteMasks[matteType]=id;}return this.matteMasks[matteType];},setMatte:function setMatte(id){if(!this.matteElement){return;}this.matteElement.setAttribute('mask','url('+getLocationHref()+'#'+id+')');}};/**
	   * @file
	   * Handles AE's layer parenting property.
	   *
	   */function HierarchyElement(){}HierarchyElement.prototype={/**
	       * @function
	       * Initializes hierarchy properties
	       *
	       */initHierarchy:function initHierarchy(){// element's parent list
this.hierarchy=[];// if element is parent of another layer _isParent will be true
this._isParent=false;this.checkParenting();},/**
	       * @function
	       * Sets layer's hierarchy.
	       * @param {array} hierarch
	       * layer's parent list
	       *
	       */setHierarchy:function setHierarchy(hierarchy){this.hierarchy=hierarchy;},/**
	       * @function
	       * Sets layer as parent.
	       *
	       */setAsParent:function setAsParent(){this._isParent=true;},/**
	       * @function
	       * Searches layer's parenting chain
	       *
	       */checkParenting:function checkParenting(){if(this.data.parent!==undefined){this.comp.buildElementParenting(this,this.data.parent,[]);}}};function RenderableDOMElement(){}(function(){var _prototype={initElement:function initElement(data,globalData,comp){this.initFrame();this.initBaseData(data,globalData,comp);this.initTransform(data,globalData,comp);this.initHierarchy();this.initRenderable();this.initRendererElement();this.createContainerElements();this.createRenderableComponents();this.createContent();this.hide();},hide:function hide(){// console.log('HIDE', this);
if(!this.hidden&&(!this.isInRange||this.isTransparent)){var elem=this.baseElement||this.layerElement;elem.style.display='none';this.hidden=true;}},show:function show(){// console.log('SHOW', this);
if(this.isInRange&&!this.isTransparent){if(!this.data.hd){var elem=this.baseElement||this.layerElement;elem.style.display='block';}this.hidden=false;this._isFirstFrame=true;}},renderFrame:function renderFrame(){// If it is exported as hidden (data.hd === true) no need to render
// If it is not visible no need to render
if(this.data.hd||this.hidden){return;}this.renderTransform();this.renderRenderable();this.renderLocalTransform();this.renderElement();this.renderInnerContent();if(this._isFirstFrame){this._isFirstFrame=false;}},renderInnerContent:function renderInnerContent(){},prepareFrame:function prepareFrame(num){this._mdf=false;this.prepareRenderableFrame(num);this.prepareProperties(num,this.isInRange);this.checkTransparency();},destroy:function destroy(){this.innerElem=null;this.destroyBaseElement();}};extendPrototype([RenderableElement,createProxyFunction(_prototype)],RenderableDOMElement);})();function IImageElement(data,globalData,comp){this.assetData=globalData.getAssetData(data.refId);if(this.assetData&&this.assetData.sid){this.assetData=globalData.slotManager.getProp(this.assetData);}this.initElement(data,globalData,comp);this.sourceRect={top:0,left:0,width:this.assetData.w,height:this.assetData.h};}extendPrototype([BaseElement,TransformElement,SVGBaseElement,HierarchyElement,FrameElement,RenderableDOMElement],IImageElement);IImageElement.prototype.createContent=function(){var assetPath=this.globalData.getAssetsPath(this.assetData);this.innerElem=createNS('image');this.innerElem.setAttribute('width',this.assetData.w+'px');this.innerElem.setAttribute('height',this.assetData.h+'px');this.innerElem.setAttribute('preserveAspectRatio',this.assetData.pr||this.globalData.renderConfig.imagePreserveAspectRatio);this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);this.layerElement.appendChild(this.innerElem);};IImageElement.prototype.sourceRectAtTime=function(){return this.sourceRect;};function ProcessedElement(element,position){this.elem=element;this.pos=position;}function IShapeElement(){}IShapeElement.prototype={addShapeToModifiers:function addShapeToModifiers(data){var i;var len=this.shapeModifiers.length;for(i=0;i<len;i+=1){this.shapeModifiers[i].addShape(data);}},isShapeInAnimatedModifiers:function isShapeInAnimatedModifiers(data){var i=0;var len=this.shapeModifiers.length;while(i<len){if(this.shapeModifiers[i].isAnimatedWithShape(data)){return true;}}return false;},renderModifiers:function renderModifiers(){if(!this.shapeModifiers.length){return;}var i;var len=this.shapes.length;for(i=0;i<len;i+=1){this.shapes[i].sh.reset();}len=this.shapeModifiers.length;var shouldBreakProcess;for(i=len-1;i>=0;i-=1){shouldBreakProcess=this.shapeModifiers[i].processShapes(this._isFirstFrame);// workaround to fix cases where a repeater resets the shape so the following processes get called twice
// TODO: find a better solution for this
if(shouldBreakProcess){break;}}},searchProcessedElement:function searchProcessedElement(elem){var elements=this.processedElements;var i=0;var len=elements.length;while(i<len){if(elements[i].elem===elem){return elements[i].pos;}i+=1;}return 0;},addProcessedElement:function addProcessedElement(elem,pos){var elements=this.processedElements;var i=elements.length;while(i){i-=1;if(elements[i].elem===elem){elements[i].pos=pos;return;}}elements.push(new ProcessedElement(elem,pos));},prepareFrame:function prepareFrame(num){this.prepareRenderableFrame(num);this.prepareProperties(num,this.isInRange);}};var lineCapEnum={1:'butt',2:'round',3:'square'};var lineJoinEnum={1:'miter',2:'round',3:'bevel'};function SVGShapeData(transformers,level,shape){this.caches=[];this.styles=[];this.transformers=transformers;this.lStr='';this.sh=shape;this.lvl=level;// TODO find if there are some cases where _isAnimated can be false.
// For now, since shapes add up with other shapes. They have to be calculated every time.
// One way of finding out is checking if all styles associated to this shape depend only of this shape
this._isAnimated=!!shape.k;// TODO: commenting this for now since all shapes are animated
var i=0;var len=transformers.length;while(i<len){if(transformers[i].mProps.dynamicProperties.length){this._isAnimated=true;break;}i+=1;}}SVGShapeData.prototype.setAsAnimated=function(){this._isAnimated=true;};function SVGStyleData(data,level){this.data=data;this.type=data.ty;this.d='';this.lvl=level;this._mdf=false;this.closed=data.hd===true;this.pElem=createNS('path');this.msElem=null;}SVGStyleData.prototype.reset=function(){this.d='';this._mdf=false;};function DashProperty(elem,data,renderer,container){this.elem=elem;this.frameId=-1;this.dataProps=createSizedArray(data.length);this.renderer=renderer;this.k=false;this.dashStr='';this.dashArray=createTypedArray('float32',data.length?data.length-1:0);this.dashoffset=createTypedArray('float32',1);this.initDynamicPropertyContainer(container);var i;var len=data.length||0;var prop;for(i=0;i<len;i+=1){prop=PropertyFactory.getProp(elem,data[i].v,0,0,this);this.k=prop.k||this.k;this.dataProps[i]={n:data[i].n,p:prop};}if(!this.k){this.getValue(true);}this._isAnimated=this.k;}DashProperty.prototype.getValue=function(forceRender){if(this.elem.globalData.frameId===this.frameId&&!forceRender){return;}this.frameId=this.elem.globalData.frameId;this.iterateDynamicProperties();this._mdf=this._mdf||forceRender;if(this._mdf){var i=0;var len=this.dataProps.length;if(this.renderer==='svg'){this.dashStr='';}for(i=0;i<len;i+=1){if(this.dataProps[i].n!=='o'){if(this.renderer==='svg'){this.dashStr+=' '+this.dataProps[i].p.v;}else {this.dashArray[i]=this.dataProps[i].p.v;}}else {this.dashoffset[0]=this.dataProps[i].p.v;}}}};extendPrototype([DynamicPropertyContainer],DashProperty);function SVGStrokeStyleData(elem,data,styleOb){this.initDynamicPropertyContainer(elem);this.getValue=this.iterateDynamicProperties;this.o=PropertyFactory.getProp(elem,data.o,0,0.01,this);this.w=PropertyFactory.getProp(elem,data.w,0,null,this);this.d=new DashProperty(elem,data.d||{},'svg',this);this.c=PropertyFactory.getProp(elem,data.c,1,255,this);this.style=styleOb;this._isAnimated=!!this._isAnimated;}extendPrototype([DynamicPropertyContainer],SVGStrokeStyleData);function SVGFillStyleData(elem,data,styleOb){this.initDynamicPropertyContainer(elem);this.getValue=this.iterateDynamicProperties;this.o=PropertyFactory.getProp(elem,data.o,0,0.01,this);this.c=PropertyFactory.getProp(elem,data.c,1,255,this);this.style=styleOb;}extendPrototype([DynamicPropertyContainer],SVGFillStyleData);function SVGNoStyleData(elem,data,styleOb){this.initDynamicPropertyContainer(elem);this.getValue=this.iterateDynamicProperties;this.style=styleOb;}extendPrototype([DynamicPropertyContainer],SVGNoStyleData);function GradientProperty(elem,data,container){this.data=data;this.c=createTypedArray('uint8c',data.p*4);var cLength=data.k.k[0].s?data.k.k[0].s.length-data.p*4:data.k.k.length-data.p*4;this.o=createTypedArray('float32',cLength);this._cmdf=false;this._omdf=false;this._collapsable=this.checkCollapsable();this._hasOpacity=cLength;this.initDynamicPropertyContainer(container);this.prop=PropertyFactory.getProp(elem,data.k,1,null,this);this.k=this.prop.k;this.getValue(true);}GradientProperty.prototype.comparePoints=function(values,points){var i=0;var len=this.o.length/2;var diff;while(i<len){diff=Math.abs(values[i*4]-values[points*4+i*2]);if(diff>0.01){return false;}i+=1;}return true;};GradientProperty.prototype.checkCollapsable=function(){if(this.o.length/2!==this.c.length/4){return false;}if(this.data.k.k[0].s){var i=0;var len=this.data.k.k.length;while(i<len){if(!this.comparePoints(this.data.k.k[i].s,this.data.p)){return false;}i+=1;}}else if(!this.comparePoints(this.data.k.k,this.data.p)){return false;}return true;};GradientProperty.prototype.getValue=function(forceRender){this.prop.getValue();this._mdf=false;this._cmdf=false;this._omdf=false;if(this.prop._mdf||forceRender){var i;var len=this.data.p*4;var mult;var val;for(i=0;i<len;i+=1){mult=i%4===0?100:255;val=Math.round(this.prop.v[i]*mult);if(this.c[i]!==val){this.c[i]=val;this._cmdf=!forceRender;}}if(this.o.length){len=this.prop.v.length;for(i=this.data.p*4;i<len;i+=1){mult=i%2===0?100:1;val=i%2===0?Math.round(this.prop.v[i]*100):this.prop.v[i];if(this.o[i-this.data.p*4]!==val){this.o[i-this.data.p*4]=val;this._omdf=!forceRender;}}}this._mdf=!forceRender;}};extendPrototype([DynamicPropertyContainer],GradientProperty);function SVGGradientFillStyleData(elem,data,styleOb){this.initDynamicPropertyContainer(elem);this.getValue=this.iterateDynamicProperties;this.initGradientData(elem,data,styleOb);}SVGGradientFillStyleData.prototype.initGradientData=function(elem,data,styleOb){this.o=PropertyFactory.getProp(elem,data.o,0,0.01,this);this.s=PropertyFactory.getProp(elem,data.s,1,null,this);this.e=PropertyFactory.getProp(elem,data.e,1,null,this);this.h=PropertyFactory.getProp(elem,data.h||{k:0},0,0.01,this);this.a=PropertyFactory.getProp(elem,data.a||{k:0},0,degToRads,this);this.g=new GradientProperty(elem,data.g,this);this.style=styleOb;this.stops=[];this.setGradientData(styleOb.pElem,data);this.setGradientOpacity(data,styleOb);this._isAnimated=!!this._isAnimated;};SVGGradientFillStyleData.prototype.setGradientData=function(pathElement,data){var gradientId=createElementID();var gfill=createNS(data.t===1?'linearGradient':'radialGradient');gfill.setAttribute('id',gradientId);gfill.setAttribute('spreadMethod','pad');gfill.setAttribute('gradientUnits','userSpaceOnUse');var stops=[];var stop;var j;var jLen;jLen=data.g.p*4;for(j=0;j<jLen;j+=4){stop=createNS('stop');gfill.appendChild(stop);stops.push(stop);}pathElement.setAttribute(data.ty==='gf'?'fill':'stroke','url('+getLocationHref()+'#'+gradientId+')');this.gf=gfill;this.cst=stops;};SVGGradientFillStyleData.prototype.setGradientOpacity=function(data,styleOb){if(this.g._hasOpacity&&!this.g._collapsable){var stop;var j;var jLen;var mask=createNS('mask');var maskElement=createNS('path');mask.appendChild(maskElement);var opacityId=createElementID();var maskId=createElementID();mask.setAttribute('id',maskId);var opFill=createNS(data.t===1?'linearGradient':'radialGradient');opFill.setAttribute('id',opacityId);opFill.setAttribute('spreadMethod','pad');opFill.setAttribute('gradientUnits','userSpaceOnUse');jLen=data.g.k.k[0].s?data.g.k.k[0].s.length:data.g.k.k.length;var stops=this.stops;for(j=data.g.p*4;j<jLen;j+=2){stop=createNS('stop');stop.setAttribute('stop-color','rgb(255,255,255)');opFill.appendChild(stop);stops.push(stop);}maskElement.setAttribute(data.ty==='gf'?'fill':'stroke','url('+getLocationHref()+'#'+opacityId+')');if(data.ty==='gs'){maskElement.setAttribute('stroke-linecap',lineCapEnum[data.lc||2]);maskElement.setAttribute('stroke-linejoin',lineJoinEnum[data.lj||2]);if(data.lj===1){maskElement.setAttribute('stroke-miterlimit',data.ml);}}this.of=opFill;this.ms=mask;this.ost=stops;this.maskId=maskId;styleOb.msElem=maskElement;}};extendPrototype([DynamicPropertyContainer],SVGGradientFillStyleData);function SVGGradientStrokeStyleData(elem,data,styleOb){this.initDynamicPropertyContainer(elem);this.getValue=this.iterateDynamicProperties;this.w=PropertyFactory.getProp(elem,data.w,0,null,this);this.d=new DashProperty(elem,data.d||{},'svg',this);this.initGradientData(elem,data,styleOb);this._isAnimated=!!this._isAnimated;}extendPrototype([SVGGradientFillStyleData,DynamicPropertyContainer],SVGGradientStrokeStyleData);function ShapeGroupData(){this.it=[];this.prevViewData=[];this.gr=createNS('g');}function SVGTransformData(mProps,op,container){this.transform={mProps:mProps,op:op,container:container};this.elements=[];this._isAnimated=this.transform.mProps.dynamicProperties.length||this.transform.op.effectsSequence.length;}var buildShapeString=function buildShapeString(pathNodes,length,closed,mat){if(length===0){return '';}var _o=pathNodes.o;var _i=pathNodes.i;var _v=pathNodes.v;var i;var shapeString=' M'+mat.applyToPointStringified(_v[0][0],_v[0][1]);for(i=1;i<length;i+=1){shapeString+=' C'+mat.applyToPointStringified(_o[i-1][0],_o[i-1][1])+' '+mat.applyToPointStringified(_i[i][0],_i[i][1])+' '+mat.applyToPointStringified(_v[i][0],_v[i][1]);}if(closed&&length){shapeString+=' C'+mat.applyToPointStringified(_o[i-1][0],_o[i-1][1])+' '+mat.applyToPointStringified(_i[0][0],_i[0][1])+' '+mat.applyToPointStringified(_v[0][0],_v[0][1]);shapeString+='z';}return shapeString;};var SVGElementsRenderer=function(){var _identityMatrix=new Matrix();var _matrixHelper=new Matrix();var ob={createRenderFunction:createRenderFunction};function createRenderFunction(data){switch(data.ty){case'fl':return renderFill;case'gf':return renderGradient;case'gs':return renderGradientStroke;case'st':return renderStroke;case'sh':case'el':case'rc':case'sr':return renderPath;case'tr':return renderContentTransform;case'no':return renderNoop;default:return null;}}function renderContentTransform(styleData,itemData,isFirstFrame){if(isFirstFrame||itemData.transform.op._mdf){itemData.transform.container.setAttribute('opacity',itemData.transform.op.v);}if(isFirstFrame||itemData.transform.mProps._mdf){itemData.transform.container.setAttribute('transform',itemData.transform.mProps.v.to2dCSS());}}function renderNoop(){}function renderPath(styleData,itemData,isFirstFrame){var j;var jLen;var pathStringTransformed;var redraw;var pathNodes;var l;var lLen=itemData.styles.length;var lvl=itemData.lvl;var paths;var mat;var iterations;var k;for(l=0;l<lLen;l+=1){redraw=itemData.sh._mdf||isFirstFrame;if(itemData.styles[l].lvl<lvl){mat=_matrixHelper.reset();iterations=lvl-itemData.styles[l].lvl;k=itemData.transformers.length-1;while(!redraw&&iterations>0){redraw=itemData.transformers[k].mProps._mdf||redraw;iterations-=1;k-=1;}if(redraw){iterations=lvl-itemData.styles[l].lvl;k=itemData.transformers.length-1;while(iterations>0){mat.multiply(itemData.transformers[k].mProps.v);iterations-=1;k-=1;}}}else {mat=_identityMatrix;}paths=itemData.sh.paths;jLen=paths._length;if(redraw){pathStringTransformed='';for(j=0;j<jLen;j+=1){pathNodes=paths.shapes[j];if(pathNodes&&pathNodes._length){pathStringTransformed+=buildShapeString(pathNodes,pathNodes._length,pathNodes.c,mat);}}itemData.caches[l]=pathStringTransformed;}else {pathStringTransformed=itemData.caches[l];}itemData.styles[l].d+=styleData.hd===true?'':pathStringTransformed;itemData.styles[l]._mdf=redraw||itemData.styles[l]._mdf;}}function renderFill(styleData,itemData,isFirstFrame){var styleElem=itemData.style;if(itemData.c._mdf||isFirstFrame){styleElem.pElem.setAttribute('fill','rgb('+bmFloor(itemData.c.v[0])+','+bmFloor(itemData.c.v[1])+','+bmFloor(itemData.c.v[2])+')');}if(itemData.o._mdf||isFirstFrame){styleElem.pElem.setAttribute('fill-opacity',itemData.o.v);}}function renderGradientStroke(styleData,itemData,isFirstFrame){renderGradient(styleData,itemData,isFirstFrame);renderStroke(styleData,itemData,isFirstFrame);}function renderGradient(styleData,itemData,isFirstFrame){var gfill=itemData.gf;var hasOpacity=itemData.g._hasOpacity;var pt1=itemData.s.v;var pt2=itemData.e.v;if(itemData.o._mdf||isFirstFrame){var attr=styleData.ty==='gf'?'fill-opacity':'stroke-opacity';itemData.style.pElem.setAttribute(attr,itemData.o.v);}if(itemData.s._mdf||isFirstFrame){var attr1=styleData.t===1?'x1':'cx';var attr2=attr1==='x1'?'y1':'cy';gfill.setAttribute(attr1,pt1[0]);gfill.setAttribute(attr2,pt1[1]);if(hasOpacity&&!itemData.g._collapsable){itemData.of.setAttribute(attr1,pt1[0]);itemData.of.setAttribute(attr2,pt1[1]);}}var stops;var i;var len;var stop;if(itemData.g._cmdf||isFirstFrame){stops=itemData.cst;var cValues=itemData.g.c;len=stops.length;for(i=0;i<len;i+=1){stop=stops[i];stop.setAttribute('offset',cValues[i*4]+'%');stop.setAttribute('stop-color','rgb('+cValues[i*4+1]+','+cValues[i*4+2]+','+cValues[i*4+3]+')');}}if(hasOpacity&&(itemData.g._omdf||isFirstFrame)){var oValues=itemData.g.o;if(itemData.g._collapsable){stops=itemData.cst;}else {stops=itemData.ost;}len=stops.length;for(i=0;i<len;i+=1){stop=stops[i];if(!itemData.g._collapsable){stop.setAttribute('offset',oValues[i*2]+'%');}stop.setAttribute('stop-opacity',oValues[i*2+1]);}}if(styleData.t===1){if(itemData.e._mdf||isFirstFrame){gfill.setAttribute('x2',pt2[0]);gfill.setAttribute('y2',pt2[1]);if(hasOpacity&&!itemData.g._collapsable){itemData.of.setAttribute('x2',pt2[0]);itemData.of.setAttribute('y2',pt2[1]);}}}else {var rad;if(itemData.s._mdf||itemData.e._mdf||isFirstFrame){rad=Math.sqrt(Math.pow(pt1[0]-pt2[0],2)+Math.pow(pt1[1]-pt2[1],2));gfill.setAttribute('r',rad);if(hasOpacity&&!itemData.g._collapsable){itemData.of.setAttribute('r',rad);}}if(itemData.e._mdf||itemData.h._mdf||itemData.a._mdf||isFirstFrame){if(!rad){rad=Math.sqrt(Math.pow(pt1[0]-pt2[0],2)+Math.pow(pt1[1]-pt2[1],2));}var ang=Math.atan2(pt2[1]-pt1[1],pt2[0]-pt1[0]);var percent=itemData.h.v;if(percent>=1){percent=0.99;}else if(percent<=-1){percent=-0.99;}var dist=rad*percent;var x=Math.cos(ang+itemData.a.v)*dist+pt1[0];var y=Math.sin(ang+itemData.a.v)*dist+pt1[1];gfill.setAttribute('fx',x);gfill.setAttribute('fy',y);if(hasOpacity&&!itemData.g._collapsable){itemData.of.setAttribute('fx',x);itemData.of.setAttribute('fy',y);}}// gfill.setAttribute('fy','200');
}}function renderStroke(styleData,itemData,isFirstFrame){var styleElem=itemData.style;var d=itemData.d;if(d&&(d._mdf||isFirstFrame)&&d.dashStr){styleElem.pElem.setAttribute('stroke-dasharray',d.dashStr);styleElem.pElem.setAttribute('stroke-dashoffset',d.dashoffset[0]);}if(itemData.c&&(itemData.c._mdf||isFirstFrame)){styleElem.pElem.setAttribute('stroke','rgb('+bmFloor(itemData.c.v[0])+','+bmFloor(itemData.c.v[1])+','+bmFloor(itemData.c.v[2])+')');}if(itemData.o._mdf||isFirstFrame){styleElem.pElem.setAttribute('stroke-opacity',itemData.o.v);}if(itemData.w._mdf||isFirstFrame){styleElem.pElem.setAttribute('stroke-width',itemData.w.v);if(styleElem.msElem){styleElem.msElem.setAttribute('stroke-width',itemData.w.v);}}}return ob;}();function SVGShapeElement(data,globalData,comp){// List of drawable elements
this.shapes=[];// Full shape data
this.shapesData=data.shapes;// List of styles that will be applied to shapes
this.stylesList=[];// List of modifiers that will be applied to shapes
this.shapeModifiers=[];// List of items in shape tree
this.itemsData=[];// List of items in previous shape tree
this.processedElements=[];// List of animated components
this.animatedContents=[];this.initElement(data,globalData,comp);// Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
// List of elements that have been created
this.prevViewData=[];// Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
}extendPrototype([BaseElement,TransformElement,SVGBaseElement,IShapeElement,HierarchyElement,FrameElement,RenderableDOMElement],SVGShapeElement);SVGShapeElement.prototype.initSecondaryElement=function(){};SVGShapeElement.prototype.identityMatrix=new Matrix();SVGShapeElement.prototype.buildExpressionInterface=function(){};SVGShapeElement.prototype.createContent=function(){this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement,0,[],true);this.filterUniqueShapes();};/*
	  This method searches for multiple shapes that affect a single element and one of them is animated
	  */SVGShapeElement.prototype.filterUniqueShapes=function(){var i;var len=this.shapes.length;var shape;var j;var jLen=this.stylesList.length;var style;var tempShapes=[];var areAnimated=false;for(j=0;j<jLen;j+=1){style=this.stylesList[j];areAnimated=false;tempShapes.length=0;for(i=0;i<len;i+=1){shape=this.shapes[i];if(shape.styles.indexOf(style)!==-1){tempShapes.push(shape);areAnimated=shape._isAnimated||areAnimated;}}if(tempShapes.length>1&&areAnimated){this.setShapesAsAnimated(tempShapes);}}};SVGShapeElement.prototype.setShapesAsAnimated=function(shapes){var i;var len=shapes.length;for(i=0;i<len;i+=1){shapes[i].setAsAnimated();}};SVGShapeElement.prototype.createStyleElement=function(data,level){// TODO: prevent drawing of hidden styles
var elementData;var styleOb=new SVGStyleData(data,level);var pathElement=styleOb.pElem;if(data.ty==='st'){elementData=new SVGStrokeStyleData(this,data,styleOb);}else if(data.ty==='fl'){elementData=new SVGFillStyleData(this,data,styleOb);}else if(data.ty==='gf'||data.ty==='gs'){var GradientConstructor=data.ty==='gf'?SVGGradientFillStyleData:SVGGradientStrokeStyleData;elementData=new GradientConstructor(this,data,styleOb);this.globalData.defs.appendChild(elementData.gf);if(elementData.maskId){this.globalData.defs.appendChild(elementData.ms);this.globalData.defs.appendChild(elementData.of);pathElement.setAttribute('mask','url('+getLocationHref()+'#'+elementData.maskId+')');}}else if(data.ty==='no'){elementData=new SVGNoStyleData(this,data,styleOb);}if(data.ty==='st'||data.ty==='gs'){pathElement.setAttribute('stroke-linecap',lineCapEnum[data.lc||2]);pathElement.setAttribute('stroke-linejoin',lineJoinEnum[data.lj||2]);pathElement.setAttribute('fill-opacity','0');if(data.lj===1){pathElement.setAttribute('stroke-miterlimit',data.ml);}}if(data.r===2){pathElement.setAttribute('fill-rule','evenodd');}if(data.ln){pathElement.setAttribute('id',data.ln);}if(data.cl){pathElement.setAttribute('class',data.cl);}if(data.bm){pathElement.style['mix-blend-mode']=getBlendMode(data.bm);}this.stylesList.push(styleOb);this.addToAnimatedContents(data,elementData);return elementData;};SVGShapeElement.prototype.createGroupElement=function(data){var elementData=new ShapeGroupData();if(data.ln){elementData.gr.setAttribute('id',data.ln);}if(data.cl){elementData.gr.setAttribute('class',data.cl);}if(data.bm){elementData.gr.style['mix-blend-mode']=getBlendMode(data.bm);}return elementData;};SVGShapeElement.prototype.createTransformElement=function(data,container){var transformProperty=TransformPropertyFactory.getTransformProperty(this,data,this);var elementData=new SVGTransformData(transformProperty,transformProperty.o,container);this.addToAnimatedContents(data,elementData);return elementData;};SVGShapeElement.prototype.createShapeElement=function(data,ownTransformers,level){var ty=4;if(data.ty==='rc'){ty=5;}else if(data.ty==='el'){ty=6;}else if(data.ty==='sr'){ty=7;}var shapeProperty=ShapePropertyFactory.getShapeProp(this,data,ty,this);var elementData=new SVGShapeData(ownTransformers,level,shapeProperty);this.shapes.push(elementData);this.addShapeToModifiers(elementData);this.addToAnimatedContents(data,elementData);return elementData;};SVGShapeElement.prototype.addToAnimatedContents=function(data,element){var i=0;var len=this.animatedContents.length;while(i<len){if(this.animatedContents[i].element===element){return;}i+=1;}this.animatedContents.push({fn:SVGElementsRenderer.createRenderFunction(data),element:element,data:data});};SVGShapeElement.prototype.setElementStyles=function(elementData){var arr=elementData.styles;var j;var jLen=this.stylesList.length;for(j=0;j<jLen;j+=1){if(!this.stylesList[j].closed){arr.push(this.stylesList[j]);}}};SVGShapeElement.prototype.reloadShapes=function(){this._isFirstFrame=true;var i;var len=this.itemsData.length;for(i=0;i<len;i+=1){this.prevViewData[i]=this.itemsData[i];}this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.layerElement,0,[],true);this.filterUniqueShapes();len=this.dynamicProperties.length;for(i=0;i<len;i+=1){this.dynamicProperties[i].getValue();}this.renderModifiers();};SVGShapeElement.prototype.searchShapes=function(arr,itemsData,prevViewData,container,level,transformers,render){var ownTransformers=[].concat(transformers);var i;var len=arr.length-1;var j;var jLen;var ownStyles=[];var ownModifiers=[];var currentTransform;var modifier;var processedPos;for(i=len;i>=0;i-=1){processedPos=this.searchProcessedElement(arr[i]);if(!processedPos){arr[i]._render=render;}else {itemsData[i]=prevViewData[processedPos-1];}if(arr[i].ty==='fl'||arr[i].ty==='st'||arr[i].ty==='gf'||arr[i].ty==='gs'||arr[i].ty==='no'){if(!processedPos){itemsData[i]=this.createStyleElement(arr[i],level);}else {itemsData[i].style.closed=false;}if(arr[i]._render){if(itemsData[i].style.pElem.parentNode!==container){container.appendChild(itemsData[i].style.pElem);}}ownStyles.push(itemsData[i].style);}else if(arr[i].ty==='gr'){if(!processedPos){itemsData[i]=this.createGroupElement(arr[i]);}else {jLen=itemsData[i].it.length;for(j=0;j<jLen;j+=1){itemsData[i].prevViewData[j]=itemsData[i].it[j];}}this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData,itemsData[i].gr,level+1,ownTransformers,render);if(arr[i]._render){if(itemsData[i].gr.parentNode!==container){container.appendChild(itemsData[i].gr);}}}else if(arr[i].ty==='tr'){if(!processedPos){itemsData[i]=this.createTransformElement(arr[i],container);}currentTransform=itemsData[i].transform;ownTransformers.push(currentTransform);}else if(arr[i].ty==='sh'||arr[i].ty==='rc'||arr[i].ty==='el'||arr[i].ty==='sr'){if(!processedPos){itemsData[i]=this.createShapeElement(arr[i],ownTransformers,level);}this.setElementStyles(itemsData[i]);}else if(arr[i].ty==='tm'||arr[i].ty==='rd'||arr[i].ty==='ms'||arr[i].ty==='pb'||arr[i].ty==='zz'||arr[i].ty==='op'){if(!processedPos){modifier=ShapeModifiers.getModifier(arr[i].ty);modifier.init(this,arr[i]);itemsData[i]=modifier;this.shapeModifiers.push(modifier);}else {modifier=itemsData[i];modifier.closed=false;}ownModifiers.push(modifier);}else if(arr[i].ty==='rp'){if(!processedPos){modifier=ShapeModifiers.getModifier(arr[i].ty);itemsData[i]=modifier;modifier.init(this,arr,i,itemsData);this.shapeModifiers.push(modifier);render=false;}else {modifier=itemsData[i];modifier.closed=true;}ownModifiers.push(modifier);}this.addProcessedElement(arr[i],i+1);}len=ownStyles.length;for(i=0;i<len;i+=1){ownStyles[i].closed=true;}len=ownModifiers.length;for(i=0;i<len;i+=1){ownModifiers[i].closed=true;}};SVGShapeElement.prototype.renderInnerContent=function(){this.renderModifiers();var i;var len=this.stylesList.length;for(i=0;i<len;i+=1){this.stylesList[i].reset();}this.renderShape();for(i=0;i<len;i+=1){if(this.stylesList[i]._mdf||this._isFirstFrame){if(this.stylesList[i].msElem){this.stylesList[i].msElem.setAttribute('d',this.stylesList[i].d);// Adding M0 0 fixes same mask bug on all browsers
this.stylesList[i].d='M0 0'+this.stylesList[i].d;}this.stylesList[i].pElem.setAttribute('d',this.stylesList[i].d||'M0 0');}}};SVGShapeElement.prototype.renderShape=function(){var i;var len=this.animatedContents.length;var animatedContent;for(i=0;i<len;i+=1){animatedContent=this.animatedContents[i];if((this._isFirstFrame||animatedContent.element._isAnimated)&&animatedContent.data!==true){animatedContent.fn(animatedContent.data,animatedContent.element,this._isFirstFrame);}}};SVGShapeElement.prototype.destroy=function(){this.destroyBaseElement();this.shapesData=null;this.itemsData=null;};function LetterProps(o,sw,sc,fc,m,p){this.o=o;this.sw=sw;this.sc=sc;this.fc=fc;this.m=m;this.p=p;this._mdf={o:true,sw:!!sw,sc:!!sc,fc:!!fc,m:true,p:true};}LetterProps.prototype.update=function(o,sw,sc,fc,m,p){this._mdf.o=false;this._mdf.sw=false;this._mdf.sc=false;this._mdf.fc=false;this._mdf.m=false;this._mdf.p=false;var updated=false;if(this.o!==o){this.o=o;this._mdf.o=true;updated=true;}if(this.sw!==sw){this.sw=sw;this._mdf.sw=true;updated=true;}if(this.sc!==sc){this.sc=sc;this._mdf.sc=true;updated=true;}if(this.fc!==fc){this.fc=fc;this._mdf.fc=true;updated=true;}if(this.m!==m){this.m=m;this._mdf.m=true;updated=true;}if(p.length&&(this.p[0]!==p[0]||this.p[1]!==p[1]||this.p[4]!==p[4]||this.p[5]!==p[5]||this.p[12]!==p[12]||this.p[13]!==p[13])){this.p=p;this._mdf.p=true;updated=true;}return updated;};function TextProperty(elem,data){this._frameId=initialDefaultFrame;this.pv='';this.v='';this.kf=false;this._isFirstFrame=true;this._mdf=false;if(data.d&&data.d.sid){data.d=elem.globalData.slotManager.getProp(data.d);}this.data=data;this.elem=elem;this.comp=this.elem.comp;this.keysIndex=0;this.canResize=false;this.minimumFontSize=1;this.effectsSequence=[];this.currentData={ascent:0,boxWidth:this.defaultBoxWidth,f:'',fStyle:'',fWeight:'',fc:'',j:'',justifyOffset:'',l:[],lh:0,lineWidths:[],ls:'',of:'',s:'',sc:'',sw:0,t:0,tr:0,sz:0,ps:null,fillColorAnim:false,strokeColorAnim:false,strokeWidthAnim:false,yOffset:0,finalSize:0,finalText:[],finalLineHeight:0,__complete:false};this.copyData(this.currentData,this.data.d.k[0].s);if(!this.searchProperty()){this.completeTextData(this.currentData);}}TextProperty.prototype.defaultBoxWidth=[0,0];TextProperty.prototype.copyData=function(obj,data){for(var s in data){if(Object.prototype.hasOwnProperty.call(data,s)){obj[s]=data[s];}}return obj;};TextProperty.prototype.setCurrentData=function(data){if(!data.__complete){this.completeTextData(data);}this.currentData=data;this.currentData.boxWidth=this.currentData.boxWidth||this.defaultBoxWidth;this._mdf=true;};TextProperty.prototype.searchProperty=function(){return this.searchKeyframes();};TextProperty.prototype.searchKeyframes=function(){this.kf=this.data.d.k.length>1;if(this.kf){this.addEffect(this.getKeyframeValue.bind(this));}return this.kf;};TextProperty.prototype.addEffect=function(effectFunction){this.effectsSequence.push(effectFunction);this.elem.addDynamicProperty(this);};TextProperty.prototype.getValue=function(_finalValue){if((this.elem.globalData.frameId===this.frameId||!this.effectsSequence.length)&&!_finalValue){return;}this.currentData.t=this.data.d.k[this.keysIndex].s.t;var currentValue=this.currentData;var currentIndex=this.keysIndex;if(this.lock){this.setCurrentData(this.currentData);return;}this.lock=true;this._mdf=false;var i;var len=this.effectsSequence.length;var finalValue=_finalValue||this.data.d.k[this.keysIndex].s;for(i=0;i<len;i+=1){// Checking if index changed to prevent creating a new object every time the expression updates.
if(currentIndex!==this.keysIndex){finalValue=this.effectsSequence[i](finalValue,finalValue.t);}else {finalValue=this.effectsSequence[i](this.currentData,finalValue.t);}}if(currentValue!==finalValue){this.setCurrentData(finalValue);}this.v=this.currentData;this.pv=this.v;this.lock=false;this.frameId=this.elem.globalData.frameId;};TextProperty.prototype.getKeyframeValue=function(){var textKeys=this.data.d.k;var frameNum=this.elem.comp.renderedFrame;var i=0;var len=textKeys.length;while(i<=len-1){if(i===len-1||textKeys[i+1].t>frameNum){break;}i+=1;}if(this.keysIndex!==i){this.keysIndex=i;}return this.data.d.k[this.keysIndex].s;};TextProperty.prototype.buildFinalText=function(text){var charactersArray=[];var i=0;var len=text.length;var charCode;var secondCharCode;var shouldCombine=false;var shouldCombineNext=false;var currentChars='';while(i<len){shouldCombine=shouldCombineNext;shouldCombineNext=false;charCode=text.charCodeAt(i);currentChars=text.charAt(i);if(FontManager.isCombinedCharacter(charCode)){shouldCombine=true;// It's a potential surrogate pair (this is the High surrogate)
}else if(charCode>=0xD800&&charCode<=0xDBFF){if(FontManager.isRegionalFlag(text,i)){currentChars=text.substr(i,14);}else {secondCharCode=text.charCodeAt(i+1);// It's a surrogate pair (this is the Low surrogate)
if(secondCharCode>=0xDC00&&secondCharCode<=0xDFFF){if(FontManager.isModifier(charCode,secondCharCode)){currentChars=text.substr(i,2);shouldCombine=true;}else if(FontManager.isFlagEmoji(text.substr(i,4))){currentChars=text.substr(i,4);}else {currentChars=text.substr(i,2);}}}}else if(charCode>0xDBFF){secondCharCode=text.charCodeAt(i+1);if(FontManager.isVariationSelector(charCode)){shouldCombine=true;}}else if(FontManager.isZeroWidthJoiner(charCode)){shouldCombine=true;shouldCombineNext=true;}if(shouldCombine){charactersArray[charactersArray.length-1]+=currentChars;shouldCombine=false;}else {charactersArray.push(currentChars);}i+=currentChars.length;}return charactersArray;};TextProperty.prototype.completeTextData=function(documentData){documentData.__complete=true;var fontManager=this.elem.globalData.fontManager;var data=this.data;var letters=[];var i;var len;var newLineFlag;var index=0;var val;var anchorGrouping=data.m.g;var currentSize=0;var currentPos=0;var currentLine=0;var lineWidths=[];var lineWidth=0;var maxLineWidth=0;var j;var jLen;var fontData=fontManager.getFontByName(documentData.f);var charData;var cLength=0;var fontProps=getFontProperties(fontData);documentData.fWeight=fontProps.weight;documentData.fStyle=fontProps.style;documentData.finalSize=documentData.s;documentData.finalText=this.buildFinalText(documentData.t);len=documentData.finalText.length;documentData.finalLineHeight=documentData.lh;var trackingOffset=documentData.tr/1000*documentData.finalSize;var charCode;if(documentData.sz){var flag=true;var boxWidth=documentData.sz[0];var boxHeight=documentData.sz[1];var currentHeight;var finalText;while(flag){finalText=this.buildFinalText(documentData.t);currentHeight=0;lineWidth=0;len=finalText.length;trackingOffset=documentData.tr/1000*documentData.finalSize;var lastSpaceIndex=-1;for(i=0;i<len;i+=1){charCode=finalText[i].charCodeAt(0);newLineFlag=false;if(finalText[i]===' '){lastSpaceIndex=i;}else if(charCode===13||charCode===3){lineWidth=0;newLineFlag=true;currentHeight+=documentData.finalLineHeight||documentData.finalSize*1.2;}if(fontManager.chars){charData=fontManager.getCharData(finalText[i],fontData.fStyle,fontData.fFamily);cLength=newLineFlag?0:charData.w*documentData.finalSize/100;}else {// tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;
cLength=fontManager.measureText(finalText[i],documentData.f,documentData.finalSize);}if(lineWidth+cLength>boxWidth&&finalText[i]!==' '){if(lastSpaceIndex===-1){len+=1;}else {i=lastSpaceIndex;}currentHeight+=documentData.finalLineHeight||documentData.finalSize*1.2;finalText.splice(i,lastSpaceIndex===i?1:0,'\r');// finalText = finalText.substr(0,i) + "\r" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);
lastSpaceIndex=-1;lineWidth=0;}else {lineWidth+=cLength;lineWidth+=trackingOffset;}}currentHeight+=fontData.ascent*documentData.finalSize/100;if(this.canResize&&documentData.finalSize>this.minimumFontSize&&boxHeight<currentHeight){documentData.finalSize-=1;documentData.finalLineHeight=documentData.finalSize*documentData.lh/documentData.s;}else {documentData.finalText=finalText;len=documentData.finalText.length;flag=false;}}}lineWidth=-trackingOffset;cLength=0;var uncollapsedSpaces=0;var currentChar;for(i=0;i<len;i+=1){newLineFlag=false;currentChar=documentData.finalText[i];charCode=currentChar.charCodeAt(0);if(charCode===13||charCode===3){uncollapsedSpaces=0;lineWidths.push(lineWidth);maxLineWidth=lineWidth>maxLineWidth?lineWidth:maxLineWidth;lineWidth=-2*trackingOffset;val='';newLineFlag=true;currentLine+=1;}else {val=currentChar;}if(fontManager.chars){charData=fontManager.getCharData(currentChar,fontData.fStyle,fontManager.getFontByName(documentData.f).fFamily);cLength=newLineFlag?0:charData.w*documentData.finalSize/100;}else {// var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);
// tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;
cLength=fontManager.measureText(val,documentData.f,documentData.finalSize);}//
if(currentChar===' '){uncollapsedSpaces+=cLength+trackingOffset;}else {lineWidth+=cLength+trackingOffset+uncollapsedSpaces;uncollapsedSpaces=0;}letters.push({l:cLength,an:cLength,add:currentSize,n:newLineFlag,anIndexes:[],val:val,line:currentLine,animatorJustifyOffset:0});if(anchorGrouping==2){// eslint-disable-line eqeqeq
currentSize+=cLength;if(val===''||val===' '||i===len-1){if(val===''||val===' '){currentSize-=cLength;}while(currentPos<=i){letters[currentPos].an=currentSize;letters[currentPos].ind=index;letters[currentPos].extra=cLength;currentPos+=1;}index+=1;currentSize=0;}}else if(anchorGrouping==3){// eslint-disable-line eqeqeq
currentSize+=cLength;if(val===''||i===len-1){if(val===''){currentSize-=cLength;}while(currentPos<=i){letters[currentPos].an=currentSize;letters[currentPos].ind=index;letters[currentPos].extra=cLength;currentPos+=1;}currentSize=0;index+=1;}}else {letters[index].ind=index;letters[index].extra=0;index+=1;}}documentData.l=letters;maxLineWidth=lineWidth>maxLineWidth?lineWidth:maxLineWidth;lineWidths.push(lineWidth);if(documentData.sz){documentData.boxWidth=documentData.sz[0];documentData.justifyOffset=0;}else {documentData.boxWidth=maxLineWidth;switch(documentData.j){case 1:documentData.justifyOffset=-documentData.boxWidth;break;case 2:documentData.justifyOffset=-documentData.boxWidth/2;break;default:documentData.justifyOffset=0;}}documentData.lineWidths=lineWidths;var animators=data.a;var animatorData;var letterData;jLen=animators.length;var based;var ind;var indexes=[];for(j=0;j<jLen;j+=1){animatorData=animators[j];if(animatorData.a.sc){documentData.strokeColorAnim=true;}if(animatorData.a.sw){documentData.strokeWidthAnim=true;}if(animatorData.a.fc||animatorData.a.fh||animatorData.a.fs||animatorData.a.fb){documentData.fillColorAnim=true;}ind=0;based=animatorData.s.b;for(i=0;i<len;i+=1){letterData=letters[i];letterData.anIndexes[j]=ind;if(based==1&&letterData.val!==''||based==2&&letterData.val!==''&&letterData.val!==' '||based==3&&(letterData.n||letterData.val==' '||i==len-1)||based==4&&(letterData.n||i==len-1)){// eslint-disable-line eqeqeq
if(animatorData.s.rn===1){indexes.push(ind);}ind+=1;}}data.a[j].s.totalChars=ind;var currentInd=-1;var newInd;if(animatorData.s.rn===1){for(i=0;i<len;i+=1){letterData=letters[i];if(currentInd!=letterData.anIndexes[j]){// eslint-disable-line eqeqeq
currentInd=letterData.anIndexes[j];newInd=indexes.splice(Math.floor(Math.random()*indexes.length),1)[0];}letterData.anIndexes[j]=newInd;}}}documentData.yOffset=documentData.finalLineHeight||documentData.finalSize*1.2;documentData.ls=documentData.ls||0;documentData.ascent=fontData.ascent*documentData.finalSize/100;};TextProperty.prototype.updateDocumentData=function(newData,index){index=index===undefined?this.keysIndex:index;var dData=this.copyData({},this.data.d.k[index].s);dData=this.copyData(dData,newData);this.data.d.k[index].s=dData;this.recalculate(index);this.setCurrentData(dData);this.elem.addDynamicProperty(this);};TextProperty.prototype.recalculate=function(index){var dData=this.data.d.k[index].s;dData.__complete=false;this.keysIndex=0;this._isFirstFrame=true;this.getValue(dData);};TextProperty.prototype.canResizeFont=function(_canResize){this.canResize=_canResize;this.recalculate(this.keysIndex);this.elem.addDynamicProperty(this);};TextProperty.prototype.setMinimumFontSize=function(_fontValue){this.minimumFontSize=Math.floor(_fontValue)||1;this.recalculate(this.keysIndex);this.elem.addDynamicProperty(this);};var TextSelectorProp=function(){var max=Math.max;var min=Math.min;var floor=Math.floor;function TextSelectorPropFactory(elem,data){this._currentTextLength=-1;this.k=false;this.data=data;this.elem=elem;this.comp=elem.comp;this.finalS=0;this.finalE=0;this.initDynamicPropertyContainer(elem);this.s=PropertyFactory.getProp(elem,data.s||{k:0},0,0,this);if('e'in data){this.e=PropertyFactory.getProp(elem,data.e,0,0,this);}else {this.e={v:100};}this.o=PropertyFactory.getProp(elem,data.o||{k:0},0,0,this);this.xe=PropertyFactory.getProp(elem,data.xe||{k:0},0,0,this);this.ne=PropertyFactory.getProp(elem,data.ne||{k:0},0,0,this);this.sm=PropertyFactory.getProp(elem,data.sm||{k:100},0,0,this);this.a=PropertyFactory.getProp(elem,data.a,0,0.01,this);if(!this.dynamicProperties.length){this.getValue();}}TextSelectorPropFactory.prototype={getMult:function getMult(ind){if(this._currentTextLength!==this.elem.textProperty.currentData.l.length){this.getValue();}var x1=0;var y1=0;var x2=1;var y2=1;if(this.ne.v>0){x1=this.ne.v/100.0;}else {y1=-this.ne.v/100.0;}if(this.xe.v>0){x2=1.0-this.xe.v/100.0;}else {y2=1.0+this.xe.v/100.0;}var easer=BezierFactory.getBezierEasing(x1,y1,x2,y2).get;var mult=0;var s=this.finalS;var e=this.finalE;var type=this.data.sh;if(type===2){if(e===s){mult=ind>=e?1:0;}else {mult=max(0,min(0.5/(e-s)+(ind-s)/(e-s),1));}mult=easer(mult);}else if(type===3){if(e===s){mult=ind>=e?0:1;}else {mult=1-max(0,min(0.5/(e-s)+(ind-s)/(e-s),1));}mult=easer(mult);}else if(type===4){if(e===s){mult=0;}else {mult=max(0,min(0.5/(e-s)+(ind-s)/(e-s),1));if(mult<0.5){mult*=2;}else {mult=1-2*(mult-0.5);}}mult=easer(mult);}else if(type===5){if(e===s){mult=0;}else {var tot=e-s;/* ind += 0.5;
	                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */ind=min(max(0,ind+0.5-s),e-s);var x=-tot/2+ind;var a=tot/2;mult=Math.sqrt(1-x*x/(a*a));}mult=easer(mult);}else if(type===6){if(e===s){mult=0;}else {ind=min(max(0,ind+0.5-s),e-s);mult=(1+Math.cos(Math.PI+Math.PI*2*ind/(e-s)))/2;// eslint-disable-line
}mult=easer(mult);}else {if(ind>=floor(s)){if(ind-s<0){mult=max(0,min(min(e,1)-(s-ind),1));}else {mult=max(0,min(e-ind,1));}}mult=easer(mult);}// Smoothness implementation.
// The smoothness represents a reduced range of the original [0; 1] range.
// if smoothness is 25%, the new range will be [0.375; 0.625]
// Steps are:
// - find the lower value of the new range (threshold)
// - if multiplier is smaller than that value, floor it to 0
// - if it is larger,
//     - subtract the threshold
//     - divide it by the smoothness (this will return the range to [0; 1])
// Note: If it doesn't work on some scenarios, consider applying it before the easer.
if(this.sm.v!==100){var smoothness=this.sm.v*0.01;if(smoothness===0){smoothness=0.00000001;}var threshold=0.5-smoothness*0.5;if(mult<threshold){mult=0;}else {mult=(mult-threshold)/smoothness;if(mult>1){mult=1;}}}return mult*this.a.v;},getValue:function getValue(newCharsFlag){this.iterateDynamicProperties();this._mdf=newCharsFlag||this._mdf;this._currentTextLength=this.elem.textProperty.currentData.l.length||0;if(newCharsFlag&&this.data.r===2){this.e.v=this._currentTextLength;}var divisor=this.data.r===2?1:100/this.data.totalChars;var o=this.o.v/divisor;var s=this.s.v/divisor+o;var e=this.e.v/divisor+o;if(s>e){var _s=s;s=e;e=_s;}this.finalS=s;this.finalE=e;}};extendPrototype([DynamicPropertyContainer],TextSelectorPropFactory);function getTextSelectorProp(elem,data,arr){return new TextSelectorPropFactory(elem,data);}return {getTextSelectorProp:getTextSelectorProp};}();function TextAnimatorDataProperty(elem,animatorProps,container){var defaultData={propType:false};var getProp=PropertyFactory.getProp;var textAnimatorAnimatables=animatorProps.a;this.a={r:textAnimatorAnimatables.r?getProp(elem,textAnimatorAnimatables.r,0,degToRads,container):defaultData,rx:textAnimatorAnimatables.rx?getProp(elem,textAnimatorAnimatables.rx,0,degToRads,container):defaultData,ry:textAnimatorAnimatables.ry?getProp(elem,textAnimatorAnimatables.ry,0,degToRads,container):defaultData,sk:textAnimatorAnimatables.sk?getProp(elem,textAnimatorAnimatables.sk,0,degToRads,container):defaultData,sa:textAnimatorAnimatables.sa?getProp(elem,textAnimatorAnimatables.sa,0,degToRads,container):defaultData,s:textAnimatorAnimatables.s?getProp(elem,textAnimatorAnimatables.s,1,0.01,container):defaultData,a:textAnimatorAnimatables.a?getProp(elem,textAnimatorAnimatables.a,1,0,container):defaultData,o:textAnimatorAnimatables.o?getProp(elem,textAnimatorAnimatables.o,0,0.01,container):defaultData,p:textAnimatorAnimatables.p?getProp(elem,textAnimatorAnimatables.p,1,0,container):defaultData,sw:textAnimatorAnimatables.sw?getProp(elem,textAnimatorAnimatables.sw,0,0,container):defaultData,sc:textAnimatorAnimatables.sc?getProp(elem,textAnimatorAnimatables.sc,1,0,container):defaultData,fc:textAnimatorAnimatables.fc?getProp(elem,textAnimatorAnimatables.fc,1,0,container):defaultData,fh:textAnimatorAnimatables.fh?getProp(elem,textAnimatorAnimatables.fh,0,0,container):defaultData,fs:textAnimatorAnimatables.fs?getProp(elem,textAnimatorAnimatables.fs,0,0.01,container):defaultData,fb:textAnimatorAnimatables.fb?getProp(elem,textAnimatorAnimatables.fb,0,0.01,container):defaultData,t:textAnimatorAnimatables.t?getProp(elem,textAnimatorAnimatables.t,0,0,container):defaultData};this.s=TextSelectorProp.getTextSelectorProp(elem,animatorProps.s,container);this.s.t=animatorProps.s.t;}function TextAnimatorProperty(textData,renderType,elem){this._isFirstFrame=true;this._hasMaskedPath=false;this._frameId=-1;this._textData=textData;this._renderType=renderType;this._elem=elem;this._animatorsData=createSizedArray(this._textData.a.length);this._pathData={};this._moreOptions={alignment:{}};this.renderedLetters=[];this.lettersChangedFlag=false;this.initDynamicPropertyContainer(elem);}TextAnimatorProperty.prototype.searchProperties=function(){var i;var len=this._textData.a.length;var animatorProps;var getProp=PropertyFactory.getProp;for(i=0;i<len;i+=1){animatorProps=this._textData.a[i];this._animatorsData[i]=new TextAnimatorDataProperty(this._elem,animatorProps,this);}if(this._textData.p&&'m'in this._textData.p){this._pathData={a:getProp(this._elem,this._textData.p.a,0,0,this),f:getProp(this._elem,this._textData.p.f,0,0,this),l:getProp(this._elem,this._textData.p.l,0,0,this),r:getProp(this._elem,this._textData.p.r,0,0,this),p:getProp(this._elem,this._textData.p.p,0,0,this),m:this._elem.maskManager.getMaskProperty(this._textData.p.m)};this._hasMaskedPath=true;}else {this._hasMaskedPath=false;}this._moreOptions.alignment=getProp(this._elem,this._textData.m.a,1,0,this);};TextAnimatorProperty.prototype.getMeasures=function(documentData,lettersChangedFlag){this.lettersChangedFlag=lettersChangedFlag;if(!this._mdf&&!this._isFirstFrame&&!lettersChangedFlag&&(!this._hasMaskedPath||!this._pathData.m._mdf)){return;}this._isFirstFrame=false;var alignment=this._moreOptions.alignment.v;var animators=this._animatorsData;var textData=this._textData;var matrixHelper=this.mHelper;var renderType=this._renderType;var renderedLettersCount=this.renderedLetters.length;var xPos;var yPos;var i;var len;var letters=documentData.l;var pathInfo;var currentLength;var currentPoint;var segmentLength;var flag;var pointInd;var segmentInd;var prevPoint;var points;var segments;var partialLength;var totalLength;var perc;var tanAngle;var mask;if(this._hasMaskedPath){mask=this._pathData.m;if(!this._pathData.n||this._pathData._mdf){var paths=mask.v;if(this._pathData.r.v){paths=paths.reverse();}// TODO: release bezier data cached from previous pathInfo: this._pathData.pi
pathInfo={tLength:0,segments:[]};len=paths._length-1;var bezierData;totalLength=0;for(i=0;i<len;i+=1){bezierData=bez.buildBezierData(paths.v[i],paths.v[i+1],[paths.o[i][0]-paths.v[i][0],paths.o[i][1]-paths.v[i][1]],[paths.i[i+1][0]-paths.v[i+1][0],paths.i[i+1][1]-paths.v[i+1][1]]);pathInfo.tLength+=bezierData.segmentLength;pathInfo.segments.push(bezierData);totalLength+=bezierData.segmentLength;}i=len;if(mask.v.c){bezierData=bez.buildBezierData(paths.v[i],paths.v[0],[paths.o[i][0]-paths.v[i][0],paths.o[i][1]-paths.v[i][1]],[paths.i[0][0]-paths.v[0][0],paths.i[0][1]-paths.v[0][1]]);pathInfo.tLength+=bezierData.segmentLength;pathInfo.segments.push(bezierData);totalLength+=bezierData.segmentLength;}this._pathData.pi=pathInfo;}pathInfo=this._pathData.pi;currentLength=this._pathData.f.v;segmentInd=0;pointInd=1;segmentLength=0;flag=true;segments=pathInfo.segments;if(currentLength<0&&mask.v.c){if(pathInfo.tLength<Math.abs(currentLength)){currentLength=-Math.abs(currentLength)%pathInfo.tLength;}segmentInd=segments.length-1;points=segments[segmentInd].points;pointInd=points.length-1;while(currentLength<0){currentLength+=points[pointInd].partialLength;pointInd-=1;if(pointInd<0){segmentInd-=1;points=segments[segmentInd].points;pointInd=points.length-1;}}}points=segments[segmentInd].points;prevPoint=points[pointInd-1];currentPoint=points[pointInd];partialLength=currentPoint.partialLength;}len=letters.length;xPos=0;yPos=0;var yOff=documentData.finalSize*1.2*0.714;var firstLine=true;var animatorProps;var animatorSelector;var j;var jLen;var letterValue;jLen=animators.length;var mult;var ind=-1;var offf;var xPathPos;var yPathPos;var initPathPos=currentLength;var initSegmentInd=segmentInd;var initPointInd=pointInd;var currentLine=-1;var elemOpacity;var sc;var sw;var fc;var k;var letterSw;var letterSc;var letterFc;var letterM='';var letterP=this.defaultPropsArray;var letterO;//
if(documentData.j===2||documentData.j===1){var animatorJustifyOffset=0;var animatorFirstCharOffset=0;var justifyOffsetMult=documentData.j===2?-0.5:-1;var lastIndex=0;var isNewLine=true;for(i=0;i<len;i+=1){if(letters[i].n){if(animatorJustifyOffset){animatorJustifyOffset+=animatorFirstCharOffset;}while(lastIndex<i){letters[lastIndex].animatorJustifyOffset=animatorJustifyOffset;lastIndex+=1;}animatorJustifyOffset=0;isNewLine=true;}else {for(j=0;j<jLen;j+=1){animatorProps=animators[j].a;if(animatorProps.t.propType){if(isNewLine&&documentData.j===2){animatorFirstCharOffset+=animatorProps.t.v*justifyOffsetMult;}animatorSelector=animators[j].s;mult=animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);if(mult.length){animatorJustifyOffset+=animatorProps.t.v*mult[0]*justifyOffsetMult;}else {animatorJustifyOffset+=animatorProps.t.v*mult*justifyOffsetMult;}}}isNewLine=false;}}if(animatorJustifyOffset){animatorJustifyOffset+=animatorFirstCharOffset;}while(lastIndex<i){letters[lastIndex].animatorJustifyOffset=animatorJustifyOffset;lastIndex+=1;}}//
for(i=0;i<len;i+=1){matrixHelper.reset();elemOpacity=1;if(letters[i].n){xPos=0;yPos+=documentData.yOffset;yPos+=firstLine?1:0;currentLength=initPathPos;firstLine=false;if(this._hasMaskedPath){segmentInd=initSegmentInd;pointInd=initPointInd;points=segments[segmentInd].points;prevPoint=points[pointInd-1];currentPoint=points[pointInd];partialLength=currentPoint.partialLength;segmentLength=0;}letterM='';letterFc='';letterSw='';letterO='';letterP=this.defaultPropsArray;}else {if(this._hasMaskedPath){if(currentLine!==letters[i].line){switch(documentData.j){case 1:currentLength+=totalLength-documentData.lineWidths[letters[i].line];break;case 2:currentLength+=(totalLength-documentData.lineWidths[letters[i].line])/2;break;}currentLine=letters[i].line;}if(ind!==letters[i].ind){if(letters[ind]){currentLength+=letters[ind].extra;}currentLength+=letters[i].an/2;ind=letters[i].ind;}currentLength+=alignment[0]*letters[i].an*0.005;var animatorOffset=0;for(j=0;j<jLen;j+=1){animatorProps=animators[j].a;if(animatorProps.p.propType){animatorSelector=animators[j].s;mult=animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);if(mult.length){animatorOffset+=animatorProps.p.v[0]*mult[0];}else {animatorOffset+=animatorProps.p.v[0]*mult;}}if(animatorProps.a.propType){animatorSelector=animators[j].s;mult=animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);if(mult.length){animatorOffset+=animatorProps.a.v[0]*mult[0];}else {animatorOffset+=animatorProps.a.v[0]*mult;}}}flag=true;// Force alignment only works with a single line for now
if(this._pathData.a.v){currentLength=letters[0].an*0.5+(totalLength-this._pathData.f.v-letters[0].an*0.5-letters[letters.length-1].an*0.5)*ind/(len-1);currentLength+=this._pathData.f.v;}while(flag){if(segmentLength+partialLength>=currentLength+animatorOffset||!points){perc=(currentLength+animatorOffset-segmentLength)/currentPoint.partialLength;xPathPos=prevPoint.point[0]+(currentPoint.point[0]-prevPoint.point[0])*perc;yPathPos=prevPoint.point[1]+(currentPoint.point[1]-prevPoint.point[1])*perc;matrixHelper.translate(-alignment[0]*letters[i].an*0.005,-(alignment[1]*yOff)*0.01);flag=false;}else if(points){segmentLength+=currentPoint.partialLength;pointInd+=1;if(pointInd>=points.length){pointInd=0;segmentInd+=1;if(!segments[segmentInd]){if(mask.v.c){pointInd=0;segmentInd=0;points=segments[segmentInd].points;}else {segmentLength-=currentPoint.partialLength;points=null;}}else {points=segments[segmentInd].points;}}if(points){prevPoint=currentPoint;currentPoint=points[pointInd];partialLength=currentPoint.partialLength;}}}offf=letters[i].an/2-letters[i].add;matrixHelper.translate(-offf,0,0);}else {offf=letters[i].an/2-letters[i].add;matrixHelper.translate(-offf,0,0);// Grouping alignment
matrixHelper.translate(-alignment[0]*letters[i].an*0.005,-alignment[1]*yOff*0.01,0);}for(j=0;j<jLen;j+=1){animatorProps=animators[j].a;if(animatorProps.t.propType){animatorSelector=animators[j].s;mult=animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);// This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean "isNewLine"
if(xPos!==0||documentData.j!==0){if(this._hasMaskedPath){if(mult.length){currentLength+=animatorProps.t.v*mult[0];}else {currentLength+=animatorProps.t.v*mult;}}else if(mult.length){xPos+=animatorProps.t.v*mult[0];}else {xPos+=animatorProps.t.v*mult;}}}}if(documentData.strokeWidthAnim){sw=documentData.sw||0;}if(documentData.strokeColorAnim){if(documentData.sc){sc=[documentData.sc[0],documentData.sc[1],documentData.sc[2]];}else {sc=[0,0,0];}}if(documentData.fillColorAnim&&documentData.fc){fc=[documentData.fc[0],documentData.fc[1],documentData.fc[2]];}for(j=0;j<jLen;j+=1){animatorProps=animators[j].a;if(animatorProps.a.propType){animatorSelector=animators[j].s;mult=animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);if(mult.length){matrixHelper.translate(-animatorProps.a.v[0]*mult[0],-animatorProps.a.v[1]*mult[1],animatorProps.a.v[2]*mult[2]);}else {matrixHelper.translate(-animatorProps.a.v[0]*mult,-animatorProps.a.v[1]*mult,animatorProps.a.v[2]*mult);}}}for(j=0;j<jLen;j+=1){animatorProps=animators[j].a;if(animatorProps.s.propType){animatorSelector=animators[j].s;mult=animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);if(mult.length){matrixHelper.scale(1+(animatorProps.s.v[0]-1)*mult[0],1+(animatorProps.s.v[1]-1)*mult[1],1);}else {matrixHelper.scale(1+(animatorProps.s.v[0]-1)*mult,1+(animatorProps.s.v[1]-1)*mult,1);}}}for(j=0;j<jLen;j+=1){animatorProps=animators[j].a;animatorSelector=animators[j].s;mult=animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);if(animatorProps.sk.propType){if(mult.length){matrixHelper.skewFromAxis(-animatorProps.sk.v*mult[0],animatorProps.sa.v*mult[1]);}else {matrixHelper.skewFromAxis(-animatorProps.sk.v*mult,animatorProps.sa.v*mult);}}if(animatorProps.r.propType){if(mult.length){matrixHelper.rotateZ(-animatorProps.r.v*mult[2]);}else {matrixHelper.rotateZ(-animatorProps.r.v*mult);}}if(animatorProps.ry.propType){if(mult.length){matrixHelper.rotateY(animatorProps.ry.v*mult[1]);}else {matrixHelper.rotateY(animatorProps.ry.v*mult);}}if(animatorProps.rx.propType){if(mult.length){matrixHelper.rotateX(animatorProps.rx.v*mult[0]);}else {matrixHelper.rotateX(animatorProps.rx.v*mult);}}if(animatorProps.o.propType){if(mult.length){elemOpacity+=(animatorProps.o.v*mult[0]-elemOpacity)*mult[0];}else {elemOpacity+=(animatorProps.o.v*mult-elemOpacity)*mult;}}if(documentData.strokeWidthAnim&&animatorProps.sw.propType){if(mult.length){sw+=animatorProps.sw.v*mult[0];}else {sw+=animatorProps.sw.v*mult;}}if(documentData.strokeColorAnim&&animatorProps.sc.propType){for(k=0;k<3;k+=1){if(mult.length){sc[k]+=(animatorProps.sc.v[k]-sc[k])*mult[0];}else {sc[k]+=(animatorProps.sc.v[k]-sc[k])*mult;}}}if(documentData.fillColorAnim&&documentData.fc){if(animatorProps.fc.propType){for(k=0;k<3;k+=1){if(mult.length){fc[k]+=(animatorProps.fc.v[k]-fc[k])*mult[0];}else {fc[k]+=(animatorProps.fc.v[k]-fc[k])*mult;}}}if(animatorProps.fh.propType){if(mult.length){fc=addHueToRGB(fc,animatorProps.fh.v*mult[0]);}else {fc=addHueToRGB(fc,animatorProps.fh.v*mult);}}if(animatorProps.fs.propType){if(mult.length){fc=addSaturationToRGB(fc,animatorProps.fs.v*mult[0]);}else {fc=addSaturationToRGB(fc,animatorProps.fs.v*mult);}}if(animatorProps.fb.propType){if(mult.length){fc=addBrightnessToRGB(fc,animatorProps.fb.v*mult[0]);}else {fc=addBrightnessToRGB(fc,animatorProps.fb.v*mult);}}}}for(j=0;j<jLen;j+=1){animatorProps=animators[j].a;if(animatorProps.p.propType){animatorSelector=animators[j].s;mult=animatorSelector.getMult(letters[i].anIndexes[j],textData.a[j].s.totalChars);if(this._hasMaskedPath){if(mult.length){matrixHelper.translate(0,animatorProps.p.v[1]*mult[0],-animatorProps.p.v[2]*mult[1]);}else {matrixHelper.translate(0,animatorProps.p.v[1]*mult,-animatorProps.p.v[2]*mult);}}else if(mult.length){matrixHelper.translate(animatorProps.p.v[0]*mult[0],animatorProps.p.v[1]*mult[1],-animatorProps.p.v[2]*mult[2]);}else {matrixHelper.translate(animatorProps.p.v[0]*mult,animatorProps.p.v[1]*mult,-animatorProps.p.v[2]*mult);}}}if(documentData.strokeWidthAnim){letterSw=sw<0?0:sw;}if(documentData.strokeColorAnim){letterSc='rgb('+Math.round(sc[0]*255)+','+Math.round(sc[1]*255)+','+Math.round(sc[2]*255)+')';}if(documentData.fillColorAnim&&documentData.fc){letterFc='rgb('+Math.round(fc[0]*255)+','+Math.round(fc[1]*255)+','+Math.round(fc[2]*255)+')';}if(this._hasMaskedPath){matrixHelper.translate(0,-documentData.ls);matrixHelper.translate(0,alignment[1]*yOff*0.01+yPos,0);if(this._pathData.p.v){tanAngle=(currentPoint.point[1]-prevPoint.point[1])/(currentPoint.point[0]-prevPoint.point[0]);var rot=Math.atan(tanAngle)*180/Math.PI;if(currentPoint.point[0]<prevPoint.point[0]){rot+=180;}matrixHelper.rotate(-rot*Math.PI/180);}matrixHelper.translate(xPathPos,yPathPos,0);currentLength-=alignment[0]*letters[i].an*0.005;if(letters[i+1]&&ind!==letters[i+1].ind){currentLength+=letters[i].an/2;currentLength+=documentData.tr*0.001*documentData.finalSize;}}else {matrixHelper.translate(xPos,yPos,0);if(documentData.ps){// matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);
matrixHelper.translate(documentData.ps[0],documentData.ps[1]+documentData.ascent,0);}switch(documentData.j){case 1:matrixHelper.translate(letters[i].animatorJustifyOffset+documentData.justifyOffset+(documentData.boxWidth-documentData.lineWidths[letters[i].line]),0,0);break;case 2:matrixHelper.translate(letters[i].animatorJustifyOffset+documentData.justifyOffset+(documentData.boxWidth-documentData.lineWidths[letters[i].line])/2,0,0);break;}matrixHelper.translate(0,-documentData.ls);matrixHelper.translate(offf,0,0);matrixHelper.translate(alignment[0]*letters[i].an*0.005,alignment[1]*yOff*0.01,0);xPos+=letters[i].l+documentData.tr*0.001*documentData.finalSize;}if(renderType==='html'){letterM=matrixHelper.toCSS();}else if(renderType==='svg'){letterM=matrixHelper.to2dCSS();}else {letterP=[matrixHelper.props[0],matrixHelper.props[1],matrixHelper.props[2],matrixHelper.props[3],matrixHelper.props[4],matrixHelper.props[5],matrixHelper.props[6],matrixHelper.props[7],matrixHelper.props[8],matrixHelper.props[9],matrixHelper.props[10],matrixHelper.props[11],matrixHelper.props[12],matrixHelper.props[13],matrixHelper.props[14],matrixHelper.props[15]];}letterO=elemOpacity;}if(renderedLettersCount<=i){letterValue=new LetterProps(letterO,letterSw,letterSc,letterFc,letterM,letterP);this.renderedLetters.push(letterValue);renderedLettersCount+=1;this.lettersChangedFlag=true;}else {letterValue=this.renderedLetters[i];this.lettersChangedFlag=letterValue.update(letterO,letterSw,letterSc,letterFc,letterM,letterP)||this.lettersChangedFlag;}}};TextAnimatorProperty.prototype.getValue=function(){if(this._elem.globalData.frameId===this._frameId){return;}this._frameId=this._elem.globalData.frameId;this.iterateDynamicProperties();};TextAnimatorProperty.prototype.mHelper=new Matrix();TextAnimatorProperty.prototype.defaultPropsArray=[];extendPrototype([DynamicPropertyContainer],TextAnimatorProperty);function ITextElement(){}ITextElement.prototype.initElement=function(data,globalData,comp){this.lettersChangedFlag=true;this.initFrame();this.initBaseData(data,globalData,comp);this.textProperty=new TextProperty(this,data.t,this.dynamicProperties);this.textAnimator=new TextAnimatorProperty(data.t,this.renderType,this);this.initTransform(data,globalData,comp);this.initHierarchy();this.initRenderable();this.initRendererElement();this.createContainerElements();this.createRenderableComponents();this.createContent();this.hide();this.textAnimator.searchProperties(this.dynamicProperties);};ITextElement.prototype.prepareFrame=function(num){this._mdf=false;this.prepareRenderableFrame(num);this.prepareProperties(num,this.isInRange);};ITextElement.prototype.createPathShape=function(matrixHelper,shapes){var j;var jLen=shapes.length;var pathNodes;var shapeStr='';for(j=0;j<jLen;j+=1){if(shapes[j].ty==='sh'){pathNodes=shapes[j].ks.k;shapeStr+=buildShapeString(pathNodes,pathNodes.i.length,true,matrixHelper);}}return shapeStr;};ITextElement.prototype.updateDocumentData=function(newData,index){this.textProperty.updateDocumentData(newData,index);};ITextElement.prototype.canResizeFont=function(_canResize){this.textProperty.canResizeFont(_canResize);};ITextElement.prototype.setMinimumFontSize=function(_fontSize){this.textProperty.setMinimumFontSize(_fontSize);};ITextElement.prototype.applyTextPropertiesToMatrix=function(documentData,matrixHelper,lineNumber,xPos,yPos){if(documentData.ps){matrixHelper.translate(documentData.ps[0],documentData.ps[1]+documentData.ascent,0);}matrixHelper.translate(0,-documentData.ls,0);switch(documentData.j){case 1:matrixHelper.translate(documentData.justifyOffset+(documentData.boxWidth-documentData.lineWidths[lineNumber]),0,0);break;case 2:matrixHelper.translate(documentData.justifyOffset+(documentData.boxWidth-documentData.lineWidths[lineNumber])/2,0,0);break;}matrixHelper.translate(xPos,yPos,0);};ITextElement.prototype.buildColor=function(colorData){return 'rgb('+Math.round(colorData[0]*255)+','+Math.round(colorData[1]*255)+','+Math.round(colorData[2]*255)+')';};ITextElement.prototype.emptyProp=new LetterProps();ITextElement.prototype.destroy=function(){};ITextElement.prototype.validateText=function(){if(this.textProperty._mdf||this.textProperty._isFirstFrame){this.buildNewText();this.textProperty._isFirstFrame=false;this.textProperty._mdf=false;}};var emptyShapeData={shapes:[]};function SVGTextLottieElement(data,globalData,comp){this.textSpans=[];this.renderType='svg';this.initElement(data,globalData,comp);}extendPrototype([BaseElement,TransformElement,SVGBaseElement,HierarchyElement,FrameElement,RenderableDOMElement,ITextElement],SVGTextLottieElement);SVGTextLottieElement.prototype.createContent=function(){if(this.data.singleShape&&!this.globalData.fontManager.chars){this.textContainer=createNS('text');}};SVGTextLottieElement.prototype.buildTextContents=function(textArray){var i=0;var len=textArray.length;var textContents=[];var currentTextContent='';while(i<len){if(textArray[i]===String.fromCharCode(13)||textArray[i]===String.fromCharCode(3)){textContents.push(currentTextContent);currentTextContent='';}else {currentTextContent+=textArray[i];}i+=1;}textContents.push(currentTextContent);return textContents;};SVGTextLottieElement.prototype.buildShapeData=function(data,scale){// data should probably be cloned to apply scale separately to each instance of a text on different layers
// but since text internal content gets only rendered once and then it's never rerendered,
// it's probably safe not to clone data and reuse always the same instance even if the object is mutated.
// Avoiding cloning is preferred since cloning each character shape data is expensive
if(data.shapes&&data.shapes.length){var shape=data.shapes[0];if(shape.it){var shapeItem=shape.it[shape.it.length-1];if(shapeItem.s){shapeItem.s.k[0]=scale;shapeItem.s.k[1]=scale;}}}return data;};SVGTextLottieElement.prototype.buildNewText=function(){this.addDynamicProperty(this);var i;var len;var documentData=this.textProperty.currentData;this.renderedLetters=createSizedArray(documentData?documentData.l.length:0);if(documentData.fc){this.layerElement.setAttribute('fill',this.buildColor(documentData.fc));}else {this.layerElement.setAttribute('fill','rgba(0,0,0,0)');}if(documentData.sc){this.layerElement.setAttribute('stroke',this.buildColor(documentData.sc));this.layerElement.setAttribute('stroke-width',documentData.sw);}this.layerElement.setAttribute('font-size',documentData.finalSize);var fontData=this.globalData.fontManager.getFontByName(documentData.f);if(fontData.fClass){this.layerElement.setAttribute('class',fontData.fClass);}else {this.layerElement.setAttribute('font-family',fontData.fFamily);var fWeight=documentData.fWeight;var fStyle=documentData.fStyle;this.layerElement.setAttribute('font-style',fStyle);this.layerElement.setAttribute('font-weight',fWeight);}this.layerElement.setAttribute('aria-label',documentData.t);var letters=documentData.l||[];var usesGlyphs=!!this.globalData.fontManager.chars;len=letters.length;var tSpan;var matrixHelper=this.mHelper;var shapeStr='';var singleShape=this.data.singleShape;var xPos=0;var yPos=0;var firstLine=true;var trackingOffset=documentData.tr*0.001*documentData.finalSize;if(singleShape&&!usesGlyphs&&!documentData.sz){var tElement=this.textContainer;var justify='start';switch(documentData.j){case 1:justify='end';break;case 2:justify='middle';break;default:justify='start';break;}tElement.setAttribute('text-anchor',justify);tElement.setAttribute('letter-spacing',trackingOffset);var textContent=this.buildTextContents(documentData.finalText);len=textContent.length;yPos=documentData.ps?documentData.ps[1]+documentData.ascent:0;for(i=0;i<len;i+=1){tSpan=this.textSpans[i].span||createNS('tspan');tSpan.textContent=textContent[i];tSpan.setAttribute('x',0);tSpan.setAttribute('y',yPos);tSpan.style.display='inherit';tElement.appendChild(tSpan);if(!this.textSpans[i]){this.textSpans[i]={span:null,glyph:null};}this.textSpans[i].span=tSpan;yPos+=documentData.finalLineHeight;}this.layerElement.appendChild(tElement);}else {var cachedSpansLength=this.textSpans.length;var charData;for(i=0;i<len;i+=1){if(!this.textSpans[i]){this.textSpans[i]={span:null,childSpan:null,glyph:null};}if(!usesGlyphs||!singleShape||i===0){tSpan=cachedSpansLength>i?this.textSpans[i].span:createNS(usesGlyphs?'g':'text');if(cachedSpansLength<=i){tSpan.setAttribute('stroke-linecap','butt');tSpan.setAttribute('stroke-linejoin','round');tSpan.setAttribute('stroke-miterlimit','4');this.textSpans[i].span=tSpan;if(usesGlyphs){var childSpan=createNS('g');tSpan.appendChild(childSpan);this.textSpans[i].childSpan=childSpan;}this.textSpans[i].span=tSpan;this.layerElement.appendChild(tSpan);}tSpan.style.display='inherit';}matrixHelper.reset();if(singleShape){if(letters[i].n){xPos=-trackingOffset;yPos+=documentData.yOffset;yPos+=firstLine?1:0;firstLine=false;}this.applyTextPropertiesToMatrix(documentData,matrixHelper,letters[i].line,xPos,yPos);xPos+=letters[i].l||0;// xPos += letters[i].val === ' ' ? 0 : trackingOffset;
xPos+=trackingOffset;}if(usesGlyphs){charData=this.globalData.fontManager.getCharData(documentData.finalText[i],fontData.fStyle,this.globalData.fontManager.getFontByName(documentData.f).fFamily);var glyphElement;// t === 1 means the character has been replaced with an animated shaped
if(charData.t===1){glyphElement=new SVGCompElement(charData.data,this.globalData,this);}else {var data=emptyShapeData;if(charData.data&&charData.data.shapes){data=this.buildShapeData(charData.data,documentData.finalSize);}glyphElement=new SVGShapeElement(data,this.globalData,this);}if(this.textSpans[i].glyph){var glyph=this.textSpans[i].glyph;this.textSpans[i].childSpan.removeChild(glyph.layerElement);glyph.destroy();}this.textSpans[i].glyph=glyphElement;glyphElement._debug=true;glyphElement.prepareFrame(0);glyphElement.renderFrame();this.textSpans[i].childSpan.appendChild(glyphElement.layerElement);// when using animated shapes, the layer will be scaled instead of replacing the internal scale
// this might have issues with strokes and might need a different solution
if(charData.t===1){this.textSpans[i].childSpan.setAttribute('transform','scale('+documentData.finalSize/100+','+documentData.finalSize/100+')');}}else {if(singleShape){tSpan.setAttribute('transform','translate('+matrixHelper.props[12]+','+matrixHelper.props[13]+')');}tSpan.textContent=letters[i].val;tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace','xml:space','preserve');}//
}if(singleShape&&tSpan){tSpan.setAttribute('d',shapeStr);}}while(i<this.textSpans.length){this.textSpans[i].span.style.display='none';i+=1;}this._sizeChanged=true;};SVGTextLottieElement.prototype.sourceRectAtTime=function(){this.prepareFrame(this.comp.renderedFrame-this.data.st);this.renderInnerContent();if(this._sizeChanged){this._sizeChanged=false;var textBox=this.layerElement.getBBox();this.bbox={top:textBox.y,left:textBox.x,width:textBox.width,height:textBox.height};}return this.bbox;};SVGTextLottieElement.prototype.getValue=function(){var i;var len=this.textSpans.length;var glyphElement;this.renderedFrame=this.comp.renderedFrame;for(i=0;i<len;i+=1){glyphElement=this.textSpans[i].glyph;if(glyphElement){glyphElement.prepareFrame(this.comp.renderedFrame-this.data.st);if(glyphElement._mdf){this._mdf=true;}}}};SVGTextLottieElement.prototype.renderInnerContent=function(){this.validateText();if(!this.data.singleShape||this._mdf){this.textAnimator.getMeasures(this.textProperty.currentData,this.lettersChangedFlag);if(this.lettersChangedFlag||this.textAnimator.lettersChangedFlag){this._sizeChanged=true;var i;var len;var renderedLetters=this.textAnimator.renderedLetters;var letters=this.textProperty.currentData.l;len=letters.length;var renderedLetter;var textSpan;var glyphElement;for(i=0;i<len;i+=1){if(!letters[i].n){renderedLetter=renderedLetters[i];textSpan=this.textSpans[i].span;glyphElement=this.textSpans[i].glyph;if(glyphElement){glyphElement.renderFrame();}if(renderedLetter._mdf.m){textSpan.setAttribute('transform',renderedLetter.m);}if(renderedLetter._mdf.o){textSpan.setAttribute('opacity',renderedLetter.o);}if(renderedLetter._mdf.sw){textSpan.setAttribute('stroke-width',renderedLetter.sw);}if(renderedLetter._mdf.sc){textSpan.setAttribute('stroke',renderedLetter.sc);}if(renderedLetter._mdf.fc){textSpan.setAttribute('fill',renderedLetter.fc);}}}}}};function ISolidElement(data,globalData,comp){this.initElement(data,globalData,comp);}extendPrototype([IImageElement],ISolidElement);ISolidElement.prototype.createContent=function(){var rect=createNS('rect');/// /rect.style.width = this.data.sw;
/// /rect.style.height = this.data.sh;
/// /rect.style.fill = this.data.sc;
rect.setAttribute('width',this.data.sw);rect.setAttribute('height',this.data.sh);rect.setAttribute('fill',this.data.sc);this.layerElement.appendChild(rect);};function NullElement(data,globalData,comp){this.initFrame();this.initBaseData(data,globalData,comp);this.initFrame();this.initTransform(data,globalData,comp);this.initHierarchy();}NullElement.prototype.prepareFrame=function(num){this.prepareProperties(num,true);};NullElement.prototype.renderFrame=function(){};NullElement.prototype.getBaseElement=function(){return null;};NullElement.prototype.destroy=function(){};NullElement.prototype.sourceRectAtTime=function(){};NullElement.prototype.hide=function(){};extendPrototype([BaseElement,TransformElement,HierarchyElement,FrameElement],NullElement);function SVGRendererBase(){}extendPrototype([BaseRenderer],SVGRendererBase);SVGRendererBase.prototype.createNull=function(data){return new NullElement(data,this.globalData,this);};SVGRendererBase.prototype.createShape=function(data){return new SVGShapeElement(data,this.globalData,this);};SVGRendererBase.prototype.createText=function(data){return new SVGTextLottieElement(data,this.globalData,this);};SVGRendererBase.prototype.createImage=function(data){return new IImageElement(data,this.globalData,this);};SVGRendererBase.prototype.createSolid=function(data){return new ISolidElement(data,this.globalData,this);};SVGRendererBase.prototype.configAnimation=function(animData){this.svgElement.setAttribute('xmlns','http://www.w3.org/2000/svg');this.svgElement.setAttribute('xmlns:xlink','http://www.w3.org/1999/xlink');if(this.renderConfig.viewBoxSize){this.svgElement.setAttribute('viewBox',this.renderConfig.viewBoxSize);}else {this.svgElement.setAttribute('viewBox','0 0 '+animData.w+' '+animData.h);}if(!this.renderConfig.viewBoxOnly){this.svgElement.setAttribute('width',animData.w);this.svgElement.setAttribute('height',animData.h);this.svgElement.style.width='100%';this.svgElement.style.height='100%';this.svgElement.style.transform='translate3d(0,0,0)';this.svgElement.style.contentVisibility=this.renderConfig.contentVisibility;}if(this.renderConfig.width){this.svgElement.setAttribute('width',this.renderConfig.width);}if(this.renderConfig.height){this.svgElement.setAttribute('height',this.renderConfig.height);}if(this.renderConfig.className){this.svgElement.setAttribute('class',this.renderConfig.className);}if(this.renderConfig.id){this.svgElement.setAttribute('id',this.renderConfig.id);}if(this.renderConfig.focusable!==undefined){this.svgElement.setAttribute('focusable',this.renderConfig.focusable);}this.svgElement.setAttribute('preserveAspectRatio',this.renderConfig.preserveAspectRatio);// this.layerElement.style.transform = 'translate3d(0,0,0)';
// this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = "0px 0px 0px";
this.animationItem.wrapper.appendChild(this.svgElement);// Mask animation
var defs=this.globalData.defs;this.setupGlobalData(animData,defs);this.globalData.progressiveLoad=this.renderConfig.progressiveLoad;this.data=animData;var maskElement=createNS('clipPath');var rect=createNS('rect');rect.setAttribute('width',animData.w);rect.setAttribute('height',animData.h);rect.setAttribute('x',0);rect.setAttribute('y',0);var maskId=createElementID();maskElement.setAttribute('id',maskId);maskElement.appendChild(rect);this.layerElement.setAttribute('clip-path','url('+getLocationHref()+'#'+maskId+')');defs.appendChild(maskElement);this.layers=animData.layers;this.elements=createSizedArray(animData.layers.length);};SVGRendererBase.prototype.destroy=function(){if(this.animationItem.wrapper){this.animationItem.wrapper.innerText='';}this.layerElement=null;this.globalData.defs=null;var i;var len=this.layers?this.layers.length:0;for(i=0;i<len;i+=1){if(this.elements[i]&&this.elements[i].destroy){this.elements[i].destroy();}}this.elements.length=0;this.destroyed=true;this.animationItem=null;};SVGRendererBase.prototype.updateContainerSize=function(){};SVGRendererBase.prototype.findIndexByInd=function(ind){var i=0;var len=this.layers.length;for(i=0;i<len;i+=1){if(this.layers[i].ind===ind){return i;}}return -1;};SVGRendererBase.prototype.buildItem=function(pos){var elements=this.elements;if(elements[pos]||this.layers[pos].ty===99){return;}elements[pos]=true;var element=this.createItem(this.layers[pos]);elements[pos]=element;if(getExpressionsPlugin()){if(this.layers[pos].ty===0){this.globalData.projectInterface.registerComposition(element);}element.initExpressions();}this.appendElementInPos(element,pos);if(this.layers[pos].tt){var elementIndex='tp'in this.layers[pos]?this.findIndexByInd(this.layers[pos].tp):pos-1;if(elementIndex===-1){return;}if(!this.elements[elementIndex]||this.elements[elementIndex]===true){this.buildItem(elementIndex);this.addPendingElement(element);}else {var matteElement=elements[elementIndex];var matteMask=matteElement.getMatte(this.layers[pos].tt);element.setMatte(matteMask);}}};SVGRendererBase.prototype.checkPendingElements=function(){while(this.pendingElements.length){var element=this.pendingElements.pop();element.checkParenting();if(element.data.tt){var i=0;var len=this.elements.length;while(i<len){if(this.elements[i]===element){var elementIndex='tp'in element.data?this.findIndexByInd(element.data.tp):i-1;var matteElement=this.elements[elementIndex];var matteMask=matteElement.getMatte(this.layers[i].tt);element.setMatte(matteMask);break;}i+=1;}}}};SVGRendererBase.prototype.renderFrame=function(num){if(this.renderedFrame===num||this.destroyed){return;}if(num===null){num=this.renderedFrame;}else {this.renderedFrame=num;}// console.log('-------');
// console.log('FRAME ',num);
this.globalData.frameNum=num;this.globalData.frameId+=1;this.globalData.projectInterface.currentFrame=num;this.globalData._mdf=false;var i;var len=this.layers.length;if(!this.completeLayers){this.checkLayers(num);}for(i=len-1;i>=0;i-=1){if(this.completeLayers||this.elements[i]){this.elements[i].prepareFrame(num-this.layers[i].st);}}if(this.globalData._mdf){for(i=0;i<len;i+=1){if(this.completeLayers||this.elements[i]){this.elements[i].renderFrame();}}}};SVGRendererBase.prototype.appendElementInPos=function(element,pos){var newElement=element.getBaseElement();if(!newElement){return;}var i=0;var nextElement;while(i<pos){if(this.elements[i]&&this.elements[i]!==true&&this.elements[i].getBaseElement()){nextElement=this.elements[i].getBaseElement();}i+=1;}if(nextElement){this.layerElement.insertBefore(newElement,nextElement);}else {this.layerElement.appendChild(newElement);}};SVGRendererBase.prototype.hide=function(){this.layerElement.style.display='none';};SVGRendererBase.prototype.show=function(){this.layerElement.style.display='block';};function ICompElement(){}extendPrototype([BaseElement,TransformElement,HierarchyElement,FrameElement,RenderableDOMElement],ICompElement);ICompElement.prototype.initElement=function(data,globalData,comp){this.initFrame();this.initBaseData(data,globalData,comp);this.initTransform(data,globalData,comp);this.initRenderable();this.initHierarchy();this.initRendererElement();this.createContainerElements();this.createRenderableComponents();if(this.data.xt||!globalData.progressiveLoad){this.buildAllItems();}this.hide();};/* ICompElement.prototype.hide = function(){
	      if(!this.hidden){
	          this.hideElement();
	          var i,len = this.elements.length;
	          for( i = 0; i < len; i+=1 ){
	              if(this.elements[i]){
	                  this.elements[i].hide();
	              }
	          }
	      }
	  }; */ICompElement.prototype.prepareFrame=function(num){this._mdf=false;this.prepareRenderableFrame(num);this.prepareProperties(num,this.isInRange);if(!this.isInRange&&!this.data.xt){return;}if(!this.tm._placeholder){var timeRemapped=this.tm.v;if(timeRemapped===this.data.op){timeRemapped=this.data.op-1;}this.renderedFrame=timeRemapped;}else {this.renderedFrame=num/this.data.sr;}var i;var len=this.elements.length;if(!this.completeLayers){this.checkLayers(this.renderedFrame);}// This iteration needs to be backwards because of how expressions connect between each other
for(i=len-1;i>=0;i-=1){if(this.completeLayers||this.elements[i]){this.elements[i].prepareFrame(this.renderedFrame-this.layers[i].st);if(this.elements[i]._mdf){this._mdf=true;}}}};ICompElement.prototype.renderInnerContent=function(){var i;var len=this.layers.length;for(i=0;i<len;i+=1){if(this.completeLayers||this.elements[i]){this.elements[i].renderFrame();}}};ICompElement.prototype.setElements=function(elems){this.elements=elems;};ICompElement.prototype.getElements=function(){return this.elements;};ICompElement.prototype.destroyElements=function(){var i;var len=this.layers.length;for(i=0;i<len;i+=1){if(this.elements[i]){this.elements[i].destroy();}}};ICompElement.prototype.destroy=function(){this.destroyElements();this.destroyBaseElement();};function SVGCompElement(data,globalData,comp){this.layers=data.layers;this.supports3d=true;this.completeLayers=false;this.pendingElements=[];this.elements=this.layers?createSizedArray(this.layers.length):[];this.initElement(data,globalData,comp);this.tm=data.tm?PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this):{_placeholder:true};}extendPrototype([SVGRendererBase,ICompElement,SVGBaseElement],SVGCompElement);SVGCompElement.prototype.createComp=function(data){return new SVGCompElement(data,this.globalData,this);};function SVGRenderer(animationItem,config){this.animationItem=animationItem;this.layers=null;this.renderedFrame=-1;this.svgElement=createNS('svg');var ariaLabel='';if(config&&config.title){var titleElement=createNS('title');var titleId=createElementID();titleElement.setAttribute('id',titleId);titleElement.textContent=config.title;this.svgElement.appendChild(titleElement);ariaLabel+=titleId;}if(config&&config.description){var descElement=createNS('desc');var descId=createElementID();descElement.setAttribute('id',descId);descElement.textContent=config.description;this.svgElement.appendChild(descElement);ariaLabel+=' '+descId;}if(ariaLabel){this.svgElement.setAttribute('aria-labelledby',ariaLabel);}var defs=createNS('defs');this.svgElement.appendChild(defs);var maskElement=createNS('g');this.svgElement.appendChild(maskElement);this.layerElement=maskElement;this.renderConfig={preserveAspectRatio:config&&config.preserveAspectRatio||'xMidYMid meet',imagePreserveAspectRatio:config&&config.imagePreserveAspectRatio||'xMidYMid slice',contentVisibility:config&&config.contentVisibility||'visible',progressiveLoad:config&&config.progressiveLoad||false,hideOnTransparent:!(config&&config.hideOnTransparent===false),viewBoxOnly:config&&config.viewBoxOnly||false,viewBoxSize:config&&config.viewBoxSize||false,className:config&&config.className||'',id:config&&config.id||'',focusable:config&&config.focusable,filterSize:{width:config&&config.filterSize&&config.filterSize.width||'100%',height:config&&config.filterSize&&config.filterSize.height||'100%',x:config&&config.filterSize&&config.filterSize.x||'0%',y:config&&config.filterSize&&config.filterSize.y||'0%'},width:config&&config.width,height:config&&config.height,runExpressions:!config||config.runExpressions===undefined||config.runExpressions};this.globalData={_mdf:false,frameNum:-1,defs:defs,renderConfig:this.renderConfig};this.elements=[];this.pendingElements=[];this.destroyed=false;this.rendererType='svg';}extendPrototype([SVGRendererBase],SVGRenderer);SVGRenderer.prototype.createComp=function(data){return new SVGCompElement(data,this.globalData,this);};function ShapeTransformManager(){this.sequences={};this.sequenceList=[];this.transform_key_count=0;}ShapeTransformManager.prototype={addTransformSequence:function addTransformSequence(transforms){var i;var len=transforms.length;var key='_';for(i=0;i<len;i+=1){key+=transforms[i].transform.key+'_';}var sequence=this.sequences[key];if(!sequence){sequence={transforms:[].concat(transforms),finalTransform:new Matrix(),_mdf:false};this.sequences[key]=sequence;this.sequenceList.push(sequence);}return sequence;},processSequence:function processSequence(sequence,isFirstFrame){var i=0;var len=sequence.transforms.length;var _mdf=isFirstFrame;while(i<len&&!isFirstFrame){if(sequence.transforms[i].transform.mProps._mdf){_mdf=true;break;}i+=1;}if(_mdf){sequence.finalTransform.reset();for(i=len-1;i>=0;i-=1){sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);}}sequence._mdf=_mdf;},processSequences:function processSequences(isFirstFrame){var i;var len=this.sequenceList.length;for(i=0;i<len;i+=1){this.processSequence(this.sequenceList[i],isFirstFrame);}},getNewKey:function getNewKey(){this.transform_key_count+=1;return '_'+this.transform_key_count;}};var lumaLoader=function lumaLoader(){var id='__lottie_element_luma_buffer';var lumaBuffer=null;var lumaBufferCtx=null;var svg=null;// This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.
// Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.
// For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.
// Naming it solution 2 to mark the extra comment lines.
/*
	    var svgString = [
	      '<svg xmlns="http://www.w3.org/2000/svg">',
	      '<filter id="' + id + '">',
	      '<feColorMatrix type="matrix" color-interpolation-filters="sRGB" values="',
	      '0.3, 0.3, 0.3, 0, 0, ',
	      '0.3, 0.3, 0.3, 0, 0, ',
	      '0.3, 0.3, 0.3, 0, 0, ',
	      '0.3, 0.3, 0.3, 0, 0',
	      '"/>',
	      '</filter>',
	      '</svg>',
	    ].join('');
	    var blob = new Blob([svgString], { type: 'image/svg+xml' });
	    var url = URL.createObjectURL(blob);
	    */function createLumaSvgFilter(){var _svg=createNS('svg');var fil=createNS('filter');var matrix=createNS('feColorMatrix');fil.setAttribute('id',id);matrix.setAttribute('type','matrix');matrix.setAttribute('color-interpolation-filters','sRGB');matrix.setAttribute('values','0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0');fil.appendChild(matrix);_svg.appendChild(fil);_svg.setAttribute('id',id+'_svg');if(featureSupport.svgLumaHidden){_svg.style.display='none';}return _svg;}function loadLuma(){if(!lumaBuffer){svg=createLumaSvgFilter();document.body.appendChild(svg);lumaBuffer=createTag('canvas');lumaBufferCtx=lumaBuffer.getContext('2d');// lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2
lumaBufferCtx.filter='url(#'+id+')';lumaBufferCtx.fillStyle='rgba(0,0,0,0)';lumaBufferCtx.fillRect(0,0,1,1);}}function getLuma(canvas){if(!lumaBuffer){loadLuma();}lumaBuffer.width=canvas.width;lumaBuffer.height=canvas.height;// lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2
lumaBufferCtx.filter='url(#'+id+')';return lumaBuffer;}return {load:loadLuma,get:getLuma};};function createCanvas(width,height){if(featureSupport.offscreenCanvas){return new OffscreenCanvas(width,height);}var canvas=createTag('canvas');canvas.width=width;canvas.height=height;return canvas;}var assetLoader=function(){return {loadLumaCanvas:lumaLoader.load,getLumaCanvas:lumaLoader.get,createCanvas:createCanvas};}();var registeredEffects={};function CVEffects(elem){var i;var len=elem.data.ef?elem.data.ef.length:0;this.filters=[];var filterManager;for(i=0;i<len;i+=1){filterManager=null;var type=elem.data.ef[i].ty;if(registeredEffects[type]){var Effect=registeredEffects[type].effect;filterManager=new Effect(elem.effectsManager.effectElements[i],elem);}if(filterManager){this.filters.push(filterManager);}}if(this.filters.length){elem.addRenderableComponent(this);}}CVEffects.prototype.renderFrame=function(_isFirstFrame){var i;var len=this.filters.length;for(i=0;i<len;i+=1){this.filters[i].renderFrame(_isFirstFrame);}};CVEffects.prototype.getEffects=function(type){var i;var len=this.filters.length;var effects=[];for(i=0;i<len;i+=1){if(this.filters[i].type===type){effects.push(this.filters[i]);}}return effects;};function registerEffect(id,effect){registeredEffects[id]={effect:effect};}function CVMaskElement(data,element){this.data=data;this.element=element;this.masksProperties=this.data.masksProperties||[];this.viewData=createSizedArray(this.masksProperties.length);var i;var len=this.masksProperties.length;var hasMasks=false;for(i=0;i<len;i+=1){if(this.masksProperties[i].mode!=='n'){hasMasks=true;}this.viewData[i]=ShapePropertyFactory.getShapeProp(this.element,this.masksProperties[i],3);}this.hasMasks=hasMasks;if(hasMasks){this.element.addRenderableComponent(this);}}CVMaskElement.prototype.renderFrame=function(){if(!this.hasMasks){return;}var transform=this.element.finalTransform.mat;var ctx=this.element.canvasContext;var i;var len=this.masksProperties.length;var pt;var pts;var data;ctx.beginPath();for(i=0;i<len;i+=1){if(this.masksProperties[i].mode!=='n'){if(this.masksProperties[i].inv){ctx.moveTo(0,0);ctx.lineTo(this.element.globalData.compSize.w,0);ctx.lineTo(this.element.globalData.compSize.w,this.element.globalData.compSize.h);ctx.lineTo(0,this.element.globalData.compSize.h);ctx.lineTo(0,0);}data=this.viewData[i].v;pt=transform.applyToPointArray(data.v[0][0],data.v[0][1],0);ctx.moveTo(pt[0],pt[1]);var j;var jLen=data._length;for(j=1;j<jLen;j+=1){pts=transform.applyToTriplePoints(data.o[j-1],data.i[j],data.v[j]);ctx.bezierCurveTo(pts[0],pts[1],pts[2],pts[3],pts[4],pts[5]);}pts=transform.applyToTriplePoints(data.o[j-1],data.i[0],data.v[0]);ctx.bezierCurveTo(pts[0],pts[1],pts[2],pts[3],pts[4],pts[5]);}}this.element.globalData.renderer.save(true);ctx.clip();};CVMaskElement.prototype.getMaskProperty=MaskElement.prototype.getMaskProperty;CVMaskElement.prototype.destroy=function(){this.element=null;};function CVBaseElement(){}var operationsMap={1:'source-in',2:'source-out',3:'source-in',4:'source-out'};CVBaseElement.prototype={createElements:function createElements(){},initRendererElement:function initRendererElement(){},createContainerElements:function createContainerElements(){// If the layer is masked we will use two buffers to store each different states of the drawing
// This solution is not ideal for several reason. But unfortunately, because of the recursive
// nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.
// TODO: try to reduce the size of these buffers to the size of the composition contaning the layer
// It might be challenging because the layer most likely is transformed in some way
if(this.data.tt>=1){this.buffers=[];var canvasContext=this.globalData.canvasContext;var bufferCanvas=assetLoader.createCanvas(canvasContext.canvas.width,canvasContext.canvas.height);this.buffers.push(bufferCanvas);var bufferCanvas2=assetLoader.createCanvas(canvasContext.canvas.width,canvasContext.canvas.height);this.buffers.push(bufferCanvas2);if(this.data.tt>=3&&!document._isProxy){assetLoader.loadLumaCanvas();}}this.canvasContext=this.globalData.canvasContext;this.transformCanvas=this.globalData.transformCanvas;this.renderableEffectsManager=new CVEffects(this);this.searchEffectTransforms();},createContent:function createContent(){},setBlendMode:function setBlendMode(){var globalData=this.globalData;if(globalData.blendMode!==this.data.bm){globalData.blendMode=this.data.bm;var blendModeValue=getBlendMode(this.data.bm);globalData.canvasContext.globalCompositeOperation=blendModeValue;}},createRenderableComponents:function createRenderableComponents(){this.maskManager=new CVMaskElement(this.data,this);this.transformEffects=this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);},hideElement:function hideElement(){if(!this.hidden&&(!this.isInRange||this.isTransparent)){this.hidden=true;}},showElement:function showElement(){if(this.isInRange&&!this.isTransparent){this.hidden=false;this._isFirstFrame=true;this.maskManager._isFirstFrame=true;}},clearCanvas:function clearCanvas(canvasContext){canvasContext.clearRect(this.transformCanvas.tx,this.transformCanvas.ty,this.transformCanvas.w*this.transformCanvas.sx,this.transformCanvas.h*this.transformCanvas.sy);},prepareLayer:function prepareLayer(){if(this.data.tt>=1){var buffer=this.buffers[0];var bufferCtx=buffer.getContext('2d');this.clearCanvas(bufferCtx);// on the first buffer we store the current state of the global drawing
bufferCtx.drawImage(this.canvasContext.canvas,0,0);// The next four lines are to clear the canvas
// TODO: Check if there is a way to clear the canvas without resetting the transform
this.currentTransform=this.canvasContext.getTransform();this.canvasContext.setTransform(1,0,0,1,0,0);this.clearCanvas(this.canvasContext);this.canvasContext.setTransform(this.currentTransform);}},exitLayer:function exitLayer(){if(this.data.tt>=1){var buffer=this.buffers[1];// On the second buffer we store the current state of the global drawing
// that only contains the content of this layer
// (if it is a composition, it also includes the nested layers)
var bufferCtx=buffer.getContext('2d');this.clearCanvas(bufferCtx);bufferCtx.drawImage(this.canvasContext.canvas,0,0);// We clear the canvas again
this.canvasContext.setTransform(1,0,0,1,0,0);this.clearCanvas(this.canvasContext);this.canvasContext.setTransform(this.currentTransform);// We draw the mask
var mask=this.comp.getElementById('tp'in this.data?this.data.tp:this.data.ind-1);mask.renderFrame(true);// We draw the second buffer (that contains the content of this layer)
this.canvasContext.setTransform(1,0,0,1,0,0);// If the mask is a Luma matte, we need to do two extra painting operations
// the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error
if(this.data.tt>=3&&!document._isProxy){// We copy the painted mask to a buffer that has a color matrix filter applied to it
// that applies the rgb values to the alpha channel
var lumaBuffer=assetLoader.getLumaCanvas(this.canvasContext.canvas);var lumaBufferCtx=lumaBuffer.getContext('2d');lumaBufferCtx.drawImage(this.canvasContext.canvas,0,0);this.clearCanvas(this.canvasContext);// we repaint the context with the mask applied to it
this.canvasContext.drawImage(lumaBuffer,0,0);}this.canvasContext.globalCompositeOperation=operationsMap[this.data.tt];this.canvasContext.drawImage(buffer,0,0);// We finally draw the first buffer (that contains the content of the global drawing)
// We use destination-over to draw the global drawing below the current layer
this.canvasContext.globalCompositeOperation='destination-over';this.canvasContext.drawImage(this.buffers[0],0,0);this.canvasContext.setTransform(this.currentTransform);// We reset the globalCompositeOperation to source-over, the standard type of operation
this.canvasContext.globalCompositeOperation='source-over';}},renderFrame:function renderFrame(forceRender){if(this.hidden||this.data.hd){return;}if(this.data.td===1&&!forceRender){return;}this.renderTransform();this.renderRenderable();this.renderLocalTransform();this.setBlendMode();var forceRealStack=this.data.ty===0;this.prepareLayer();this.globalData.renderer.save(forceRealStack);this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);this.renderInnerContent();this.globalData.renderer.restore(forceRealStack);this.exitLayer();if(this.maskManager.hasMasks){this.globalData.renderer.restore(true);}if(this._isFirstFrame){this._isFirstFrame=false;}},destroy:function destroy(){this.canvasContext=null;this.data=null;this.globalData=null;this.maskManager.destroy();},mHelper:new Matrix()};CVBaseElement.prototype.hide=CVBaseElement.prototype.hideElement;CVBaseElement.prototype.show=CVBaseElement.prototype.showElement;function CVShapeData(element,data,styles,transformsManager){this.styledShapes=[];this.tr=[0,0,0,0,0,0];var ty=4;if(data.ty==='rc'){ty=5;}else if(data.ty==='el'){ty=6;}else if(data.ty==='sr'){ty=7;}this.sh=ShapePropertyFactory.getShapeProp(element,data,ty,element);var i;var len=styles.length;var styledShape;for(i=0;i<len;i+=1){if(!styles[i].closed){styledShape={transforms:transformsManager.addTransformSequence(styles[i].transforms),trNodes:[]};this.styledShapes.push(styledShape);styles[i].elements.push(styledShape);}}}CVShapeData.prototype.setAsAnimated=SVGShapeData.prototype.setAsAnimated;function CVShapeElement(data,globalData,comp){this.shapes=[];this.shapesData=data.shapes;this.stylesList=[];this.itemsData=[];this.prevViewData=[];this.shapeModifiers=[];this.processedElements=[];this.transformsManager=new ShapeTransformManager();this.initElement(data,globalData,comp);}extendPrototype([BaseElement,TransformElement,CVBaseElement,IShapeElement,HierarchyElement,FrameElement,RenderableElement],CVShapeElement);CVShapeElement.prototype.initElement=RenderableDOMElement.prototype.initElement;CVShapeElement.prototype.transformHelper={opacity:1,_opMdf:false};CVShapeElement.prototype.dashResetter=[];CVShapeElement.prototype.createContent=function(){this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,true,[]);};CVShapeElement.prototype.createStyleElement=function(data,transforms){var styleElem={data:data,type:data.ty,preTransforms:this.transformsManager.addTransformSequence(transforms),transforms:[],elements:[],closed:data.hd===true};var elementData={};if(data.ty==='fl'||data.ty==='st'){elementData.c=PropertyFactory.getProp(this,data.c,1,255,this);if(!elementData.c.k){styleElem.co='rgb('+bmFloor(elementData.c.v[0])+','+bmFloor(elementData.c.v[1])+','+bmFloor(elementData.c.v[2])+')';}}else if(data.ty==='gf'||data.ty==='gs'){elementData.s=PropertyFactory.getProp(this,data.s,1,null,this);elementData.e=PropertyFactory.getProp(this,data.e,1,null,this);elementData.h=PropertyFactory.getProp(this,data.h||{k:0},0,0.01,this);elementData.a=PropertyFactory.getProp(this,data.a||{k:0},0,degToRads,this);elementData.g=new GradientProperty(this,data.g,this);}elementData.o=PropertyFactory.getProp(this,data.o,0,0.01,this);if(data.ty==='st'||data.ty==='gs'){styleElem.lc=lineCapEnum[data.lc||2];styleElem.lj=lineJoinEnum[data.lj||2];if(data.lj==1){// eslint-disable-line eqeqeq
styleElem.ml=data.ml;}elementData.w=PropertyFactory.getProp(this,data.w,0,null,this);if(!elementData.w.k){styleElem.wi=elementData.w.v;}if(data.d){var d=new DashProperty(this,data.d,'canvas',this);elementData.d=d;if(!elementData.d.k){styleElem.da=elementData.d.dashArray;styleElem["do"]=elementData.d.dashoffset[0];}}}else {styleElem.r=data.r===2?'evenodd':'nonzero';}this.stylesList.push(styleElem);elementData.style=styleElem;return elementData;};CVShapeElement.prototype.createGroupElement=function(){var elementData={it:[],prevViewData:[]};return elementData;};CVShapeElement.prototype.createTransformElement=function(data){var elementData={transform:{opacity:1,_opMdf:false,key:this.transformsManager.getNewKey(),op:PropertyFactory.getProp(this,data.o,0,0.01,this),mProps:TransformPropertyFactory.getTransformProperty(this,data,this)}};return elementData;};CVShapeElement.prototype.createShapeElement=function(data){var elementData=new CVShapeData(this,data,this.stylesList,this.transformsManager);this.shapes.push(elementData);this.addShapeToModifiers(elementData);return elementData;};CVShapeElement.prototype.reloadShapes=function(){this._isFirstFrame=true;var i;var len=this.itemsData.length;for(i=0;i<len;i+=1){this.prevViewData[i]=this.itemsData[i];}this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,true,[]);len=this.dynamicProperties.length;for(i=0;i<len;i+=1){this.dynamicProperties[i].getValue();}this.renderModifiers();this.transformsManager.processSequences(this._isFirstFrame);};CVShapeElement.prototype.addTransformToStyleList=function(transform){var i;var len=this.stylesList.length;for(i=0;i<len;i+=1){if(!this.stylesList[i].closed){this.stylesList[i].transforms.push(transform);}}};CVShapeElement.prototype.removeTransformFromStyleList=function(){var i;var len=this.stylesList.length;for(i=0;i<len;i+=1){if(!this.stylesList[i].closed){this.stylesList[i].transforms.pop();}}};CVShapeElement.prototype.closeStyles=function(styles){var i;var len=styles.length;for(i=0;i<len;i+=1){styles[i].closed=true;}};CVShapeElement.prototype.searchShapes=function(arr,itemsData,prevViewData,shouldRender,transforms){var i;var len=arr.length-1;var j;var jLen;var ownStyles=[];var ownModifiers=[];var processedPos;var modifier;var currentTransform;var ownTransforms=[].concat(transforms);for(i=len;i>=0;i-=1){processedPos=this.searchProcessedElement(arr[i]);if(!processedPos){arr[i]._shouldRender=shouldRender;}else {itemsData[i]=prevViewData[processedPos-1];}if(arr[i].ty==='fl'||arr[i].ty==='st'||arr[i].ty==='gf'||arr[i].ty==='gs'){if(!processedPos){itemsData[i]=this.createStyleElement(arr[i],ownTransforms);}else {itemsData[i].style.closed=false;}ownStyles.push(itemsData[i].style);}else if(arr[i].ty==='gr'){if(!processedPos){itemsData[i]=this.createGroupElement(arr[i]);}else {jLen=itemsData[i].it.length;for(j=0;j<jLen;j+=1){itemsData[i].prevViewData[j]=itemsData[i].it[j];}}this.searchShapes(arr[i].it,itemsData[i].it,itemsData[i].prevViewData,shouldRender,ownTransforms);}else if(arr[i].ty==='tr'){if(!processedPos){currentTransform=this.createTransformElement(arr[i]);itemsData[i]=currentTransform;}ownTransforms.push(itemsData[i]);this.addTransformToStyleList(itemsData[i]);}else if(arr[i].ty==='sh'||arr[i].ty==='rc'||arr[i].ty==='el'||arr[i].ty==='sr'){if(!processedPos){itemsData[i]=this.createShapeElement(arr[i]);}}else if(arr[i].ty==='tm'||arr[i].ty==='rd'||arr[i].ty==='pb'||arr[i].ty==='zz'||arr[i].ty==='op'){if(!processedPos){modifier=ShapeModifiers.getModifier(arr[i].ty);modifier.init(this,arr[i]);itemsData[i]=modifier;this.shapeModifiers.push(modifier);}else {modifier=itemsData[i];modifier.closed=false;}ownModifiers.push(modifier);}else if(arr[i].ty==='rp'){if(!processedPos){modifier=ShapeModifiers.getModifier(arr[i].ty);itemsData[i]=modifier;modifier.init(this,arr,i,itemsData);this.shapeModifiers.push(modifier);shouldRender=false;}else {modifier=itemsData[i];modifier.closed=true;}ownModifiers.push(modifier);}this.addProcessedElement(arr[i],i+1);}this.removeTransformFromStyleList();this.closeStyles(ownStyles);len=ownModifiers.length;for(i=0;i<len;i+=1){ownModifiers[i].closed=true;}};CVShapeElement.prototype.renderInnerContent=function(){this.transformHelper.opacity=1;this.transformHelper._opMdf=false;this.renderModifiers();this.transformsManager.processSequences(this._isFirstFrame);this.renderShape(this.transformHelper,this.shapesData,this.itemsData,true);};CVShapeElement.prototype.renderShapeTransform=function(parentTransform,groupTransform){if(parentTransform._opMdf||groupTransform.op._mdf||this._isFirstFrame){groupTransform.opacity=parentTransform.opacity;groupTransform.opacity*=groupTransform.op.v;groupTransform._opMdf=true;}};CVShapeElement.prototype.drawLayer=function(){var i;var len=this.stylesList.length;var j;var jLen;var k;var kLen;var elems;var nodes;var renderer=this.globalData.renderer;var ctx=this.globalData.canvasContext;var type;var currentStyle;for(i=0;i<len;i+=1){currentStyle=this.stylesList[i];type=currentStyle.type;// Skipping style when
// Stroke width equals 0
// style should not be rendered (extra unused repeaters)
// current opacity equals 0
// global opacity equals 0
if(!((type==='st'||type==='gs')&&currentStyle.wi===0||!currentStyle.data._shouldRender||currentStyle.coOp===0||this.globalData.currentGlobalAlpha===0)){renderer.save();elems=currentStyle.elements;if(type==='st'||type==='gs'){renderer.ctxStrokeStyle(type==='st'?currentStyle.co:currentStyle.grd);// ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;
renderer.ctxLineWidth(currentStyle.wi);// ctx.lineWidth = currentStyle.wi;
renderer.ctxLineCap(currentStyle.lc);// ctx.lineCap = currentStyle.lc;
renderer.ctxLineJoin(currentStyle.lj);// ctx.lineJoin = currentStyle.lj;
renderer.ctxMiterLimit(currentStyle.ml||0);// ctx.miterLimit = currentStyle.ml || 0;
}else {renderer.ctxFillStyle(type==='fl'?currentStyle.co:currentStyle.grd);// ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;
}renderer.ctxOpacity(currentStyle.coOp);if(type!=='st'&&type!=='gs'){ctx.beginPath();}renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);jLen=elems.length;for(j=0;j<jLen;j+=1){if(type==='st'||type==='gs'){ctx.beginPath();if(currentStyle.da){ctx.setLineDash(currentStyle.da);ctx.lineDashOffset=currentStyle["do"];}}nodes=elems[j].trNodes;kLen=nodes.length;for(k=0;k<kLen;k+=1){if(nodes[k].t==='m'){ctx.moveTo(nodes[k].p[0],nodes[k].p[1]);}else if(nodes[k].t==='c'){ctx.bezierCurveTo(nodes[k].pts[0],nodes[k].pts[1],nodes[k].pts[2],nodes[k].pts[3],nodes[k].pts[4],nodes[k].pts[5]);}else {ctx.closePath();}}if(type==='st'||type==='gs'){// ctx.stroke();
renderer.ctxStroke();if(currentStyle.da){ctx.setLineDash(this.dashResetter);}}}if(type!=='st'&&type!=='gs'){// ctx.fill(currentStyle.r);
this.globalData.renderer.ctxFill(currentStyle.r);}renderer.restore();}}};CVShapeElement.prototype.renderShape=function(parentTransform,items,data,isMain){var i;var len=items.length-1;var groupTransform;groupTransform=parentTransform;for(i=len;i>=0;i-=1){if(items[i].ty==='tr'){groupTransform=data[i].transform;this.renderShapeTransform(parentTransform,groupTransform);}else if(items[i].ty==='sh'||items[i].ty==='el'||items[i].ty==='rc'||items[i].ty==='sr'){this.renderPath(items[i],data[i]);}else if(items[i].ty==='fl'){this.renderFill(items[i],data[i],groupTransform);}else if(items[i].ty==='st'){this.renderStroke(items[i],data[i],groupTransform);}else if(items[i].ty==='gf'||items[i].ty==='gs'){this.renderGradientFill(items[i],data[i],groupTransform);}else if(items[i].ty==='gr'){this.renderShape(groupTransform,items[i].it,data[i].it);}else if(items[i].ty==='tm');}if(isMain){this.drawLayer();}};CVShapeElement.prototype.renderStyledShape=function(styledShape,shape){if(this._isFirstFrame||shape._mdf||styledShape.transforms._mdf){var shapeNodes=styledShape.trNodes;var paths=shape.paths;var i;var len;var j;var jLen=paths._length;shapeNodes.length=0;var groupTransformMat=styledShape.transforms.finalTransform;for(j=0;j<jLen;j+=1){var pathNodes=paths.shapes[j];if(pathNodes&&pathNodes.v){len=pathNodes._length;for(i=1;i<len;i+=1){if(i===1){shapeNodes.push({t:'m',p:groupTransformMat.applyToPointArray(pathNodes.v[0][0],pathNodes.v[0][1],0)});}shapeNodes.push({t:'c',pts:groupTransformMat.applyToTriplePoints(pathNodes.o[i-1],pathNodes.i[i],pathNodes.v[i])});}if(len===1){shapeNodes.push({t:'m',p:groupTransformMat.applyToPointArray(pathNodes.v[0][0],pathNodes.v[0][1],0)});}if(pathNodes.c&&len){shapeNodes.push({t:'c',pts:groupTransformMat.applyToTriplePoints(pathNodes.o[i-1],pathNodes.i[0],pathNodes.v[0])});shapeNodes.push({t:'z'});}}}styledShape.trNodes=shapeNodes;}};CVShapeElement.prototype.renderPath=function(pathData,itemData){if(pathData.hd!==true&&pathData._shouldRender){var i;var len=itemData.styledShapes.length;for(i=0;i<len;i+=1){this.renderStyledShape(itemData.styledShapes[i],itemData.sh);}}};CVShapeElement.prototype.renderFill=function(styleData,itemData,groupTransform){var styleElem=itemData.style;if(itemData.c._mdf||this._isFirstFrame){styleElem.co='rgb('+bmFloor(itemData.c.v[0])+','+bmFloor(itemData.c.v[1])+','+bmFloor(itemData.c.v[2])+')';}if(itemData.o._mdf||groupTransform._opMdf||this._isFirstFrame){styleElem.coOp=itemData.o.v*groupTransform.opacity;}};CVShapeElement.prototype.renderGradientFill=function(styleData,itemData,groupTransform){var styleElem=itemData.style;var grd;if(!styleElem.grd||itemData.g._mdf||itemData.s._mdf||itemData.e._mdf||styleData.t!==1&&(itemData.h._mdf||itemData.a._mdf)){var ctx=this.globalData.canvasContext;var pt1=itemData.s.v;var pt2=itemData.e.v;if(styleData.t===1){grd=ctx.createLinearGradient(pt1[0],pt1[1],pt2[0],pt2[1]);}else {var rad=Math.sqrt(Math.pow(pt1[0]-pt2[0],2)+Math.pow(pt1[1]-pt2[1],2));var ang=Math.atan2(pt2[1]-pt1[1],pt2[0]-pt1[0]);var percent=itemData.h.v;if(percent>=1){percent=0.99;}else if(percent<=-1){percent=-0.99;}var dist=rad*percent;var x=Math.cos(ang+itemData.a.v)*dist+pt1[0];var y=Math.sin(ang+itemData.a.v)*dist+pt1[1];grd=ctx.createRadialGradient(x,y,0,pt1[0],pt1[1],rad);}var i;var len=styleData.g.p;var cValues=itemData.g.c;var opacity=1;for(i=0;i<len;i+=1){if(itemData.g._hasOpacity&&itemData.g._collapsable){opacity=itemData.g.o[i*2+1];}grd.addColorStop(cValues[i*4]/100,'rgba('+cValues[i*4+1]+','+cValues[i*4+2]+','+cValues[i*4+3]+','+opacity+')');}styleElem.grd=grd;}styleElem.coOp=itemData.o.v*groupTransform.opacity;};CVShapeElement.prototype.renderStroke=function(styleData,itemData,groupTransform){var styleElem=itemData.style;var d=itemData.d;if(d&&(d._mdf||this._isFirstFrame)){styleElem.da=d.dashArray;styleElem["do"]=d.dashoffset[0];}if(itemData.c._mdf||this._isFirstFrame){styleElem.co='rgb('+bmFloor(itemData.c.v[0])+','+bmFloor(itemData.c.v[1])+','+bmFloor(itemData.c.v[2])+')';}if(itemData.o._mdf||groupTransform._opMdf||this._isFirstFrame){styleElem.coOp=itemData.o.v*groupTransform.opacity;}if(itemData.w._mdf||this._isFirstFrame){styleElem.wi=itemData.w.v;}};CVShapeElement.prototype.destroy=function(){this.shapesData=null;this.globalData=null;this.canvasContext=null;this.stylesList.length=0;this.itemsData.length=0;};function CVTextElement(data,globalData,comp){this.textSpans=[];this.yOffset=0;this.fillColorAnim=false;this.strokeColorAnim=false;this.strokeWidthAnim=false;this.stroke=false;this.fill=false;this.justifyOffset=0;this.currentRender=null;this.renderType='canvas';this.values={fill:'rgba(0,0,0,0)',stroke:'rgba(0,0,0,0)',sWidth:0,fValue:''};this.initElement(data,globalData,comp);}extendPrototype([BaseElement,TransformElement,CVBaseElement,HierarchyElement,FrameElement,RenderableElement,ITextElement],CVTextElement);CVTextElement.prototype.tHelper=createTag('canvas').getContext('2d');CVTextElement.prototype.buildNewText=function(){var documentData=this.textProperty.currentData;this.renderedLetters=createSizedArray(documentData.l?documentData.l.length:0);var hasFill=false;if(documentData.fc){hasFill=true;this.values.fill=this.buildColor(documentData.fc);}else {this.values.fill='rgba(0,0,0,0)';}this.fill=hasFill;var hasStroke=false;if(documentData.sc){hasStroke=true;this.values.stroke=this.buildColor(documentData.sc);this.values.sWidth=documentData.sw;}var fontData=this.globalData.fontManager.getFontByName(documentData.f);var i;var len;var letters=documentData.l;var matrixHelper=this.mHelper;this.stroke=hasStroke;this.values.fValue=documentData.finalSize+'px '+this.globalData.fontManager.getFontByName(documentData.f).fFamily;len=documentData.finalText.length;// this.tHelper.font = this.values.fValue;
var charData;var shapeData;var k;var kLen;var shapes;var j;var jLen;var pathNodes;var commands;var pathArr;var singleShape=this.data.singleShape;var trackingOffset=documentData.tr*0.001*documentData.finalSize;var xPos=0;var yPos=0;var firstLine=true;var cnt=0;for(i=0;i<len;i+=1){charData=this.globalData.fontManager.getCharData(documentData.finalText[i],fontData.fStyle,this.globalData.fontManager.getFontByName(documentData.f).fFamily);shapeData=charData&&charData.data||{};matrixHelper.reset();if(singleShape&&letters[i].n){xPos=-trackingOffset;yPos+=documentData.yOffset;yPos+=firstLine?1:0;firstLine=false;}shapes=shapeData.shapes?shapeData.shapes[0].it:[];jLen=shapes.length;matrixHelper.scale(documentData.finalSize/100,documentData.finalSize/100);if(singleShape){this.applyTextPropertiesToMatrix(documentData,matrixHelper,letters[i].line,xPos,yPos);}commands=createSizedArray(jLen-1);var commandsCounter=0;for(j=0;j<jLen;j+=1){if(shapes[j].ty==='sh'){kLen=shapes[j].ks.k.i.length;pathNodes=shapes[j].ks.k;pathArr=[];for(k=1;k<kLen;k+=1){if(k===1){pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));}pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToY(pathNodes.i[k][0],pathNodes.i[k][1],0),matrixHelper.applyToX(pathNodes.v[k][0],pathNodes.v[k][1],0),matrixHelper.applyToY(pathNodes.v[k][0],pathNodes.v[k][1],0));}pathArr.push(matrixHelper.applyToX(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToY(pathNodes.o[k-1][0],pathNodes.o[k-1][1],0),matrixHelper.applyToX(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToY(pathNodes.i[0][0],pathNodes.i[0][1],0),matrixHelper.applyToX(pathNodes.v[0][0],pathNodes.v[0][1],0),matrixHelper.applyToY(pathNodes.v[0][0],pathNodes.v[0][1],0));commands[commandsCounter]=pathArr;commandsCounter+=1;}}if(singleShape){xPos+=letters[i].l;xPos+=trackingOffset;}if(this.textSpans[cnt]){this.textSpans[cnt].elem=commands;}else {this.textSpans[cnt]={elem:commands};}cnt+=1;}};CVTextElement.prototype.renderInnerContent=function(){this.validateText();var ctx=this.canvasContext;ctx.font=this.values.fValue;this.globalData.renderer.ctxLineCap('butt');// ctx.lineCap = 'butt';
this.globalData.renderer.ctxLineJoin('miter');// ctx.lineJoin = 'miter';
this.globalData.renderer.ctxMiterLimit(4);// ctx.miterLimit = 4;
if(!this.data.singleShape){this.textAnimator.getMeasures(this.textProperty.currentData,this.lettersChangedFlag);}var i;var len;var j;var jLen;var k;var kLen;var renderedLetters=this.textAnimator.renderedLetters;var letters=this.textProperty.currentData.l;len=letters.length;var renderedLetter;var lastFill=null;var lastStroke=null;var lastStrokeW=null;var commands;var pathArr;var renderer=this.globalData.renderer;for(i=0;i<len;i+=1){if(!letters[i].n){renderedLetter=renderedLetters[i];if(renderedLetter){renderer.save();renderer.ctxTransform(renderedLetter.p);renderer.ctxOpacity(renderedLetter.o);}if(this.fill){if(renderedLetter&&renderedLetter.fc){if(lastFill!==renderedLetter.fc){renderer.ctxFillStyle(renderedLetter.fc);lastFill=renderedLetter.fc;// ctx.fillStyle = renderedLetter.fc;
}}else if(lastFill!==this.values.fill){lastFill=this.values.fill;renderer.ctxFillStyle(this.values.fill);// ctx.fillStyle = this.values.fill;
}commands=this.textSpans[i].elem;jLen=commands.length;this.globalData.canvasContext.beginPath();for(j=0;j<jLen;j+=1){pathArr=commands[j];kLen=pathArr.length;this.globalData.canvasContext.moveTo(pathArr[0],pathArr[1]);for(k=2;k<kLen;k+=6){this.globalData.canvasContext.bezierCurveTo(pathArr[k],pathArr[k+1],pathArr[k+2],pathArr[k+3],pathArr[k+4],pathArr[k+5]);}}this.globalData.canvasContext.closePath();renderer.ctxFill();// this.globalData.canvasContext.fill();
/// ctx.fillText(this.textSpans[i].val,0,0);
}if(this.stroke){if(renderedLetter&&renderedLetter.sw){if(lastStrokeW!==renderedLetter.sw){lastStrokeW=renderedLetter.sw;renderer.ctxLineWidth(renderedLetter.sw);// ctx.lineWidth = renderedLetter.sw;
}}else if(lastStrokeW!==this.values.sWidth){lastStrokeW=this.values.sWidth;renderer.ctxLineWidth(this.values.sWidth);// ctx.lineWidth = this.values.sWidth;
}if(renderedLetter&&renderedLetter.sc){if(lastStroke!==renderedLetter.sc){lastStroke=renderedLetter.sc;renderer.ctxStrokeStyle(renderedLetter.sc);// ctx.strokeStyle = renderedLetter.sc;
}}else if(lastStroke!==this.values.stroke){lastStroke=this.values.stroke;renderer.ctxStrokeStyle(this.values.stroke);// ctx.strokeStyle = this.values.stroke;
}commands=this.textSpans[i].elem;jLen=commands.length;this.globalData.canvasContext.beginPath();for(j=0;j<jLen;j+=1){pathArr=commands[j];kLen=pathArr.length;this.globalData.canvasContext.moveTo(pathArr[0],pathArr[1]);for(k=2;k<kLen;k+=6){this.globalData.canvasContext.bezierCurveTo(pathArr[k],pathArr[k+1],pathArr[k+2],pathArr[k+3],pathArr[k+4],pathArr[k+5]);}}this.globalData.canvasContext.closePath();renderer.ctxStroke();// this.globalData.canvasContext.stroke();
/// ctx.strokeText(letters[i].val,0,0);
}if(renderedLetter){this.globalData.renderer.restore();}}}};function CVImageElement(data,globalData,comp){this.assetData=globalData.getAssetData(data.refId);this.img=globalData.imageLoader.getAsset(this.assetData);this.initElement(data,globalData,comp);}extendPrototype([BaseElement,TransformElement,CVBaseElement,HierarchyElement,FrameElement,RenderableElement],CVImageElement);CVImageElement.prototype.initElement=SVGShapeElement.prototype.initElement;CVImageElement.prototype.prepareFrame=IImageElement.prototype.prepareFrame;CVImageElement.prototype.createContent=function(){if(this.img.width&&(this.assetData.w!==this.img.width||this.assetData.h!==this.img.height)){var canvas=createTag('canvas');canvas.width=this.assetData.w;canvas.height=this.assetData.h;var ctx=canvas.getContext('2d');var imgW=this.img.width;var imgH=this.img.height;var imgRel=imgW/imgH;var canvasRel=this.assetData.w/this.assetData.h;var widthCrop;var heightCrop;var par=this.assetData.pr||this.globalData.renderConfig.imagePreserveAspectRatio;if(imgRel>canvasRel&&par==='xMidYMid slice'||imgRel<canvasRel&&par!=='xMidYMid slice'){heightCrop=imgH;widthCrop=heightCrop*canvasRel;}else {widthCrop=imgW;heightCrop=widthCrop/canvasRel;}ctx.drawImage(this.img,(imgW-widthCrop)/2,(imgH-heightCrop)/2,widthCrop,heightCrop,0,0,this.assetData.w,this.assetData.h);this.img=canvas;}};CVImageElement.prototype.renderInnerContent=function(){this.canvasContext.drawImage(this.img,0,0);};CVImageElement.prototype.destroy=function(){this.img=null;};function CVSolidElement(data,globalData,comp){this.initElement(data,globalData,comp);}extendPrototype([BaseElement,TransformElement,CVBaseElement,HierarchyElement,FrameElement,RenderableElement],CVSolidElement);CVSolidElement.prototype.initElement=SVGShapeElement.prototype.initElement;CVSolidElement.prototype.prepareFrame=IImageElement.prototype.prepareFrame;CVSolidElement.prototype.renderInnerContent=function(){// var ctx = this.canvasContext;
this.globalData.renderer.ctxFillStyle(this.data.sc);// ctx.fillStyle = this.data.sc;
this.globalData.renderer.ctxFillRect(0,0,this.data.sw,this.data.sh);// ctx.fillRect(0, 0, this.data.sw, this.data.sh);
//
};function CanvasRendererBase(){}extendPrototype([BaseRenderer],CanvasRendererBase);CanvasRendererBase.prototype.createShape=function(data){return new CVShapeElement(data,this.globalData,this);};CanvasRendererBase.prototype.createText=function(data){return new CVTextElement(data,this.globalData,this);};CanvasRendererBase.prototype.createImage=function(data){return new CVImageElement(data,this.globalData,this);};CanvasRendererBase.prototype.createSolid=function(data){return new CVSolidElement(data,this.globalData,this);};CanvasRendererBase.prototype.createNull=SVGRenderer.prototype.createNull;CanvasRendererBase.prototype.ctxTransform=function(props){if(props[0]===1&&props[1]===0&&props[4]===0&&props[5]===1&&props[12]===0&&props[13]===0){return;}this.canvasContext.transform(props[0],props[1],props[4],props[5],props[12],props[13]);};CanvasRendererBase.prototype.ctxOpacity=function(op){this.canvasContext.globalAlpha*=op<0?0:op;};CanvasRendererBase.prototype.ctxFillStyle=function(value){this.canvasContext.fillStyle=value;};CanvasRendererBase.prototype.ctxStrokeStyle=function(value){this.canvasContext.strokeStyle=value;};CanvasRendererBase.prototype.ctxLineWidth=function(value){this.canvasContext.lineWidth=value;};CanvasRendererBase.prototype.ctxLineCap=function(value){this.canvasContext.lineCap=value;};CanvasRendererBase.prototype.ctxLineJoin=function(value){this.canvasContext.lineJoin=value;};CanvasRendererBase.prototype.ctxMiterLimit=function(value){this.canvasContext.miterLimit=value;};CanvasRendererBase.prototype.ctxFill=function(rule){this.canvasContext.fill(rule);};CanvasRendererBase.prototype.ctxFillRect=function(x,y,w,h){this.canvasContext.fillRect(x,y,w,h);};CanvasRendererBase.prototype.ctxStroke=function(){this.canvasContext.stroke();};CanvasRendererBase.prototype.reset=function(){if(!this.renderConfig.clearCanvas){this.canvasContext.restore();return;}this.contextData.reset();};CanvasRendererBase.prototype.save=function(){this.canvasContext.save();};CanvasRendererBase.prototype.restore=function(actionFlag){if(!this.renderConfig.clearCanvas){this.canvasContext.restore();return;}if(actionFlag){this.globalData.blendMode='source-over';}this.contextData.restore(actionFlag);};CanvasRendererBase.prototype.configAnimation=function(animData){if(this.animationItem.wrapper){this.animationItem.container=createTag('canvas');var containerStyle=this.animationItem.container.style;containerStyle.width='100%';containerStyle.height='100%';var origin='0px 0px 0px';containerStyle.transformOrigin=origin;containerStyle.mozTransformOrigin=origin;containerStyle.webkitTransformOrigin=origin;containerStyle['-webkit-transform']=origin;containerStyle.contentVisibility=this.renderConfig.contentVisibility;this.animationItem.wrapper.appendChild(this.animationItem.container);this.canvasContext=this.animationItem.container.getContext('2d');if(this.renderConfig.className){this.animationItem.container.setAttribute('class',this.renderConfig.className);}if(this.renderConfig.id){this.animationItem.container.setAttribute('id',this.renderConfig.id);}}else {this.canvasContext=this.renderConfig.context;}this.contextData.setContext(this.canvasContext);this.data=animData;this.layers=animData.layers;this.transformCanvas={w:animData.w,h:animData.h,sx:0,sy:0,tx:0,ty:0};this.setupGlobalData(animData,document.body);this.globalData.canvasContext=this.canvasContext;this.globalData.renderer=this;this.globalData.isDashed=false;this.globalData.progressiveLoad=this.renderConfig.progressiveLoad;this.globalData.transformCanvas=this.transformCanvas;this.elements=createSizedArray(animData.layers.length);this.updateContainerSize();};CanvasRendererBase.prototype.updateContainerSize=function(width,height){this.reset();var elementWidth;var elementHeight;if(width){elementWidth=width;elementHeight=height;this.canvasContext.canvas.width=elementWidth;this.canvasContext.canvas.height=elementHeight;}else {if(this.animationItem.wrapper&&this.animationItem.container){elementWidth=this.animationItem.wrapper.offsetWidth;elementHeight=this.animationItem.wrapper.offsetHeight;}else {elementWidth=this.canvasContext.canvas.width;elementHeight=this.canvasContext.canvas.height;}this.canvasContext.canvas.width=elementWidth*this.renderConfig.dpr;this.canvasContext.canvas.height=elementHeight*this.renderConfig.dpr;}var elementRel;var animationRel;if(this.renderConfig.preserveAspectRatio.indexOf('meet')!==-1||this.renderConfig.preserveAspectRatio.indexOf('slice')!==-1){var par=this.renderConfig.preserveAspectRatio.split(' ');var fillType=par[1]||'meet';var pos=par[0]||'xMidYMid';var xPos=pos.substr(0,4);var yPos=pos.substr(4);elementRel=elementWidth/elementHeight;animationRel=this.transformCanvas.w/this.transformCanvas.h;if(animationRel>elementRel&&fillType==='meet'||animationRel<elementRel&&fillType==='slice'){this.transformCanvas.sx=elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);this.transformCanvas.sy=elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);}else {this.transformCanvas.sx=elementHeight/(this.transformCanvas.h/this.renderConfig.dpr);this.transformCanvas.sy=elementHeight/(this.transformCanvas.h/this.renderConfig.dpr);}if(xPos==='xMid'&&(animationRel<elementRel&&fillType==='meet'||animationRel>elementRel&&fillType==='slice')){this.transformCanvas.tx=(elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))/2*this.renderConfig.dpr;}else if(xPos==='xMax'&&(animationRel<elementRel&&fillType==='meet'||animationRel>elementRel&&fillType==='slice')){this.transformCanvas.tx=(elementWidth-this.transformCanvas.w*(elementHeight/this.transformCanvas.h))*this.renderConfig.dpr;}else {this.transformCanvas.tx=0;}if(yPos==='YMid'&&(animationRel>elementRel&&fillType==='meet'||animationRel<elementRel&&fillType==='slice')){this.transformCanvas.ty=(elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w))/2*this.renderConfig.dpr;}else if(yPos==='YMax'&&(animationRel>elementRel&&fillType==='meet'||animationRel<elementRel&&fillType==='slice')){this.transformCanvas.ty=(elementHeight-this.transformCanvas.h*(elementWidth/this.transformCanvas.w))*this.renderConfig.dpr;}else {this.transformCanvas.ty=0;}}else if(this.renderConfig.preserveAspectRatio==='none'){this.transformCanvas.sx=elementWidth/(this.transformCanvas.w/this.renderConfig.dpr);this.transformCanvas.sy=elementHeight/(this.transformCanvas.h/this.renderConfig.dpr);this.transformCanvas.tx=0;this.transformCanvas.ty=0;}else {this.transformCanvas.sx=this.renderConfig.dpr;this.transformCanvas.sy=this.renderConfig.dpr;this.transformCanvas.tx=0;this.transformCanvas.ty=0;}this.transformCanvas.props=[this.transformCanvas.sx,0,0,0,0,this.transformCanvas.sy,0,0,0,0,1,0,this.transformCanvas.tx,this.transformCanvas.ty,0,1];/* var i, len = this.elements.length;
	      for(i=0;i<len;i+=1){
	          if(this.elements[i] && this.elements[i].data.ty === 0){
	              this.elements[i].resize(this.globalData.transformCanvas);
	          }
	      } */this.ctxTransform(this.transformCanvas.props);this.canvasContext.beginPath();this.canvasContext.rect(0,0,this.transformCanvas.w,this.transformCanvas.h);this.canvasContext.closePath();this.canvasContext.clip();this.renderFrame(this.renderedFrame,true);};CanvasRendererBase.prototype.destroy=function(){if(this.renderConfig.clearCanvas&&this.animationItem.wrapper){this.animationItem.wrapper.innerText='';}var i;var len=this.layers?this.layers.length:0;for(i=len-1;i>=0;i-=1){if(this.elements[i]&&this.elements[i].destroy){this.elements[i].destroy();}}this.elements.length=0;this.globalData.canvasContext=null;this.animationItem.container=null;this.destroyed=true;};CanvasRendererBase.prototype.renderFrame=function(num,forceRender){if(this.renderedFrame===num&&this.renderConfig.clearCanvas===true&&!forceRender||this.destroyed||num===-1){return;}this.renderedFrame=num;this.globalData.frameNum=num-this.animationItem._isFirstFrame;this.globalData.frameId+=1;this.globalData._mdf=!this.renderConfig.clearCanvas||forceRender;this.globalData.projectInterface.currentFrame=num;// console.log('--------');
// console.log('NEW: ',num);
var i;var len=this.layers.length;if(!this.completeLayers){this.checkLayers(num);}for(i=len-1;i>=0;i-=1){if(this.completeLayers||this.elements[i]){this.elements[i].prepareFrame(num-this.layers[i].st);}}if(this.globalData._mdf){if(this.renderConfig.clearCanvas===true){this.canvasContext.clearRect(0,0,this.transformCanvas.w,this.transformCanvas.h);}else {this.save();}for(i=len-1;i>=0;i-=1){if(this.completeLayers||this.elements[i]){this.elements[i].renderFrame();}}if(this.renderConfig.clearCanvas!==true){this.restore();}}};CanvasRendererBase.prototype.buildItem=function(pos){var elements=this.elements;if(elements[pos]||this.layers[pos].ty===99){return;}var element=this.createItem(this.layers[pos],this,this.globalData);elements[pos]=element;element.initExpressions();/* if(this.layers[pos].ty === 0){
	          element.resize(this.globalData.transformCanvas);
	      } */};CanvasRendererBase.prototype.checkPendingElements=function(){while(this.pendingElements.length){var element=this.pendingElements.pop();element.checkParenting();}};CanvasRendererBase.prototype.hide=function(){this.animationItem.container.style.display='none';};CanvasRendererBase.prototype.show=function(){this.animationItem.container.style.display='block';};function CanvasContext(){this.opacity=-1;this.transform=createTypedArray('float32',16);this.fillStyle='';this.strokeStyle='';this.lineWidth='';this.lineCap='';this.lineJoin='';this.miterLimit='';this.id=Math.random();}function CVContextData(){this.stack=[];this.cArrPos=0;this.cTr=new Matrix();var i;var len=15;for(i=0;i<len;i+=1){var canvasContext=new CanvasContext();this.stack[i]=canvasContext;}this._length=len;this.nativeContext=null;this.transformMat=new Matrix();this.currentOpacity=1;//
this.currentFillStyle='';this.appliedFillStyle='';//
this.currentStrokeStyle='';this.appliedStrokeStyle='';//
this.currentLineWidth='';this.appliedLineWidth='';//
this.currentLineCap='';this.appliedLineCap='';//
this.currentLineJoin='';this.appliedLineJoin='';//
this.appliedMiterLimit='';this.currentMiterLimit='';}CVContextData.prototype.duplicate=function(){var newLength=this._length*2;var i=0;for(i=this._length;i<newLength;i+=1){this.stack[i]=new CanvasContext();}this._length=newLength;};CVContextData.prototype.reset=function(){this.cArrPos=0;this.cTr.reset();this.stack[this.cArrPos].opacity=1;};CVContextData.prototype.restore=function(forceRestore){this.cArrPos-=1;var currentContext=this.stack[this.cArrPos];var transform=currentContext.transform;var i;var arr=this.cTr.props;for(i=0;i<16;i+=1){arr[i]=transform[i];}if(forceRestore){this.nativeContext.restore();var prevStack=this.stack[this.cArrPos+1];this.appliedFillStyle=prevStack.fillStyle;this.appliedStrokeStyle=prevStack.strokeStyle;this.appliedLineWidth=prevStack.lineWidth;this.appliedLineCap=prevStack.lineCap;this.appliedLineJoin=prevStack.lineJoin;this.appliedMiterLimit=prevStack.miterLimit;}this.nativeContext.setTransform(transform[0],transform[1],transform[4],transform[5],transform[12],transform[13]);if(forceRestore||currentContext.opacity!==-1&&this.currentOpacity!==currentContext.opacity){this.nativeContext.globalAlpha=currentContext.opacity;this.currentOpacity=currentContext.opacity;}this.currentFillStyle=currentContext.fillStyle;this.currentStrokeStyle=currentContext.strokeStyle;this.currentLineWidth=currentContext.lineWidth;this.currentLineCap=currentContext.lineCap;this.currentLineJoin=currentContext.lineJoin;this.currentMiterLimit=currentContext.miterLimit;};CVContextData.prototype.save=function(saveOnNativeFlag){if(saveOnNativeFlag){this.nativeContext.save();}var props=this.cTr.props;if(this._length<=this.cArrPos){this.duplicate();}var currentStack=this.stack[this.cArrPos];var i;for(i=0;i<16;i+=1){currentStack.transform[i]=props[i];}this.cArrPos+=1;var newStack=this.stack[this.cArrPos];newStack.opacity=currentStack.opacity;newStack.fillStyle=currentStack.fillStyle;newStack.strokeStyle=currentStack.strokeStyle;newStack.lineWidth=currentStack.lineWidth;newStack.lineCap=currentStack.lineCap;newStack.lineJoin=currentStack.lineJoin;newStack.miterLimit=currentStack.miterLimit;};CVContextData.prototype.setOpacity=function(value){this.stack[this.cArrPos].opacity=value;};CVContextData.prototype.setContext=function(value){this.nativeContext=value;};CVContextData.prototype.fillStyle=function(value){if(this.stack[this.cArrPos].fillStyle!==value){this.currentFillStyle=value;this.stack[this.cArrPos].fillStyle=value;}};CVContextData.prototype.strokeStyle=function(value){if(this.stack[this.cArrPos].strokeStyle!==value){this.currentStrokeStyle=value;this.stack[this.cArrPos].strokeStyle=value;}};CVContextData.prototype.lineWidth=function(value){if(this.stack[this.cArrPos].lineWidth!==value){this.currentLineWidth=value;this.stack[this.cArrPos].lineWidth=value;}};CVContextData.prototype.lineCap=function(value){if(this.stack[this.cArrPos].lineCap!==value){this.currentLineCap=value;this.stack[this.cArrPos].lineCap=value;}};CVContextData.prototype.lineJoin=function(value){if(this.stack[this.cArrPos].lineJoin!==value){this.currentLineJoin=value;this.stack[this.cArrPos].lineJoin=value;}};CVContextData.prototype.miterLimit=function(value){if(this.stack[this.cArrPos].miterLimit!==value){this.currentMiterLimit=value;this.stack[this.cArrPos].miterLimit=value;}};CVContextData.prototype.transform=function(props){this.transformMat.cloneFromProps(props);// Taking the last transform value from the stored stack of transforms
var currentTransform=this.cTr;// Applying the last transform value after the new transform to respect the order of transformations
this.transformMat.multiply(currentTransform);// Storing the new transformed value in the stored transform
currentTransform.cloneFromProps(this.transformMat.props);var trProps=currentTransform.props;// Applying the new transform to the canvas
this.nativeContext.setTransform(trProps[0],trProps[1],trProps[4],trProps[5],trProps[12],trProps[13]);};CVContextData.prototype.opacity=function(op){var currentOpacity=this.stack[this.cArrPos].opacity;currentOpacity*=op<0?0:op;if(this.stack[this.cArrPos].opacity!==currentOpacity){if(this.currentOpacity!==op){this.nativeContext.globalAlpha=op;this.currentOpacity=op;}this.stack[this.cArrPos].opacity=currentOpacity;}};CVContextData.prototype.fill=function(rule){if(this.appliedFillStyle!==this.currentFillStyle){this.appliedFillStyle=this.currentFillStyle;this.nativeContext.fillStyle=this.appliedFillStyle;}this.nativeContext.fill(rule);};CVContextData.prototype.fillRect=function(x,y,w,h){if(this.appliedFillStyle!==this.currentFillStyle){this.appliedFillStyle=this.currentFillStyle;this.nativeContext.fillStyle=this.appliedFillStyle;}this.nativeContext.fillRect(x,y,w,h);};CVContextData.prototype.stroke=function(){if(this.appliedStrokeStyle!==this.currentStrokeStyle){this.appliedStrokeStyle=this.currentStrokeStyle;this.nativeContext.strokeStyle=this.appliedStrokeStyle;}if(this.appliedLineWidth!==this.currentLineWidth){this.appliedLineWidth=this.currentLineWidth;this.nativeContext.lineWidth=this.appliedLineWidth;}if(this.appliedLineCap!==this.currentLineCap){this.appliedLineCap=this.currentLineCap;this.nativeContext.lineCap=this.appliedLineCap;}if(this.appliedLineJoin!==this.currentLineJoin){this.appliedLineJoin=this.currentLineJoin;this.nativeContext.lineJoin=this.appliedLineJoin;}if(this.appliedMiterLimit!==this.currentMiterLimit){this.appliedMiterLimit=this.currentMiterLimit;this.nativeContext.miterLimit=this.appliedMiterLimit;}this.nativeContext.stroke();};function CVCompElement(data,globalData,comp){this.completeLayers=false;this.layers=data.layers;this.pendingElements=[];this.elements=createSizedArray(this.layers.length);this.initElement(data,globalData,comp);this.tm=data.tm?PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this):{_placeholder:true};}extendPrototype([CanvasRendererBase,ICompElement,CVBaseElement],CVCompElement);CVCompElement.prototype.renderInnerContent=function(){var ctx=this.canvasContext;ctx.beginPath();ctx.moveTo(0,0);ctx.lineTo(this.data.w,0);ctx.lineTo(this.data.w,this.data.h);ctx.lineTo(0,this.data.h);ctx.lineTo(0,0);ctx.clip();var i;var len=this.layers.length;for(i=len-1;i>=0;i-=1){if(this.completeLayers||this.elements[i]){this.elements[i].renderFrame();}}};CVCompElement.prototype.destroy=function(){var i;var len=this.layers.length;for(i=len-1;i>=0;i-=1){if(this.elements[i]){this.elements[i].destroy();}}this.layers=null;this.elements=null;};CVCompElement.prototype.createComp=function(data){return new CVCompElement(data,this.globalData,this);};function CanvasRenderer(animationItem,config){this.animationItem=animationItem;this.renderConfig={clearCanvas:config&&config.clearCanvas!==undefined?config.clearCanvas:true,context:config&&config.context||null,progressiveLoad:config&&config.progressiveLoad||false,preserveAspectRatio:config&&config.preserveAspectRatio||'xMidYMid meet',imagePreserveAspectRatio:config&&config.imagePreserveAspectRatio||'xMidYMid slice',contentVisibility:config&&config.contentVisibility||'visible',className:config&&config.className||'',id:config&&config.id||'',runExpressions:!config||config.runExpressions===undefined||config.runExpressions};this.renderConfig.dpr=config&&config.dpr||1;if(this.animationItem.wrapper){this.renderConfig.dpr=config&&config.dpr||window.devicePixelRatio||1;}this.renderedFrame=-1;this.globalData={frameNum:-1,_mdf:false,renderConfig:this.renderConfig,currentGlobalAlpha:-1};this.contextData=new CVContextData();this.elements=[];this.pendingElements=[];this.transformMat=new Matrix();this.completeLayers=false;this.rendererType='canvas';if(this.renderConfig.clearCanvas){this.ctxTransform=this.contextData.transform.bind(this.contextData);this.ctxOpacity=this.contextData.opacity.bind(this.contextData);this.ctxFillStyle=this.contextData.fillStyle.bind(this.contextData);this.ctxStrokeStyle=this.contextData.strokeStyle.bind(this.contextData);this.ctxLineWidth=this.contextData.lineWidth.bind(this.contextData);this.ctxLineCap=this.contextData.lineCap.bind(this.contextData);this.ctxLineJoin=this.contextData.lineJoin.bind(this.contextData);this.ctxMiterLimit=this.contextData.miterLimit.bind(this.contextData);this.ctxFill=this.contextData.fill.bind(this.contextData);this.ctxFillRect=this.contextData.fillRect.bind(this.contextData);this.ctxStroke=this.contextData.stroke.bind(this.contextData);this.save=this.contextData.save.bind(this.contextData);}}extendPrototype([CanvasRendererBase],CanvasRenderer);CanvasRenderer.prototype.createComp=function(data){return new CVCompElement(data,this.globalData,this);};function HBaseElement(){}HBaseElement.prototype={checkBlendMode:function checkBlendMode(){},initRendererElement:function initRendererElement(){this.baseElement=createTag(this.data.tg||'div');if(this.data.hasMask){this.svgElement=createNS('svg');this.layerElement=createNS('g');this.maskedElement=this.layerElement;this.svgElement.appendChild(this.layerElement);this.baseElement.appendChild(this.svgElement);}else {this.layerElement=this.baseElement;}styleDiv(this.baseElement);},createContainerElements:function createContainerElements(){this.renderableEffectsManager=new CVEffects(this);this.transformedElement=this.baseElement;this.maskedElement=this.layerElement;if(this.data.ln){this.layerElement.setAttribute('id',this.data.ln);}if(this.data.cl){this.layerElement.setAttribute('class',this.data.cl);}if(this.data.bm!==0){this.setBlendMode();}},renderElement:function renderElement(){var transformedElementStyle=this.transformedElement?this.transformedElement.style:{};if(this.finalTransform._matMdf){var matrixValue=this.finalTransform.mat.toCSS();transformedElementStyle.transform=matrixValue;transformedElementStyle.webkitTransform=matrixValue;}if(this.finalTransform._opMdf){transformedElementStyle.opacity=this.finalTransform.mProp.o.v;}},renderFrame:function renderFrame(){// If it is exported as hidden (data.hd === true) no need to render
// If it is not visible no need to render
if(this.data.hd||this.hidden){return;}this.renderTransform();this.renderRenderable();this.renderElement();this.renderInnerContent();if(this._isFirstFrame){this._isFirstFrame=false;}},destroy:function destroy(){this.layerElement=null;this.transformedElement=null;if(this.matteElement){this.matteElement=null;}if(this.maskManager){this.maskManager.destroy();this.maskManager=null;}},createRenderableComponents:function createRenderableComponents(){this.maskManager=new MaskElement(this.data,this,this.globalData);},addEffects:function addEffects(){},setMatte:function setMatte(){}};HBaseElement.prototype.getBaseElement=SVGBaseElement.prototype.getBaseElement;HBaseElement.prototype.destroyBaseElement=HBaseElement.prototype.destroy;HBaseElement.prototype.buildElementParenting=BaseRenderer.prototype.buildElementParenting;function HSolidElement(data,globalData,comp){this.initElement(data,globalData,comp);}extendPrototype([BaseElement,TransformElement,HBaseElement,HierarchyElement,FrameElement,RenderableDOMElement],HSolidElement);HSolidElement.prototype.createContent=function(){var rect;if(this.data.hasMask){rect=createNS('rect');rect.setAttribute('width',this.data.sw);rect.setAttribute('height',this.data.sh);rect.setAttribute('fill',this.data.sc);this.svgElement.setAttribute('width',this.data.sw);this.svgElement.setAttribute('height',this.data.sh);}else {rect=createTag('div');rect.style.width=this.data.sw+'px';rect.style.height=this.data.sh+'px';rect.style.backgroundColor=this.data.sc;}this.layerElement.appendChild(rect);};function HShapeElement(data,globalData,comp){// List of drawable elements
this.shapes=[];// Full shape data
this.shapesData=data.shapes;// List of styles that will be applied to shapes
this.stylesList=[];// List of modifiers that will be applied to shapes
this.shapeModifiers=[];// List of items in shape tree
this.itemsData=[];// List of items in previous shape tree
this.processedElements=[];// List of animated components
this.animatedContents=[];this.shapesContainer=createNS('g');this.initElement(data,globalData,comp);// Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.
// List of elements that have been created
this.prevViewData=[];this.currentBBox={x:999999,y:-999999,h:0,w:0};}extendPrototype([BaseElement,TransformElement,HSolidElement,SVGShapeElement,HBaseElement,HierarchyElement,FrameElement,RenderableElement],HShapeElement);HShapeElement.prototype._renderShapeFrame=HShapeElement.prototype.renderInnerContent;HShapeElement.prototype.createContent=function(){var cont;this.baseElement.style.fontSize=0;if(this.data.hasMask){this.layerElement.appendChild(this.shapesContainer);cont=this.svgElement;}else {cont=createNS('svg');var size=this.comp.data?this.comp.data:this.globalData.compSize;cont.setAttribute('width',size.w);cont.setAttribute('height',size.h);cont.appendChild(this.shapesContainer);this.layerElement.appendChild(cont);}this.searchShapes(this.shapesData,this.itemsData,this.prevViewData,this.shapesContainer,0,[],true);this.filterUniqueShapes();this.shapeCont=cont;};HShapeElement.prototype.getTransformedPoint=function(transformers,point){var i;var len=transformers.length;for(i=0;i<len;i+=1){point=transformers[i].mProps.v.applyToPointArray(point[0],point[1],0);}return point;};HShapeElement.prototype.calculateShapeBoundingBox=function(item,boundingBox){var shape=item.sh.v;var transformers=item.transformers;var i;var len=shape._length;var vPoint;var oPoint;var nextIPoint;var nextVPoint;if(len<=1){return;}for(i=0;i<len-1;i+=1){vPoint=this.getTransformedPoint(transformers,shape.v[i]);oPoint=this.getTransformedPoint(transformers,shape.o[i]);nextIPoint=this.getTransformedPoint(transformers,shape.i[i+1]);nextVPoint=this.getTransformedPoint(transformers,shape.v[i+1]);this.checkBounds(vPoint,oPoint,nextIPoint,nextVPoint,boundingBox);}if(shape.c){vPoint=this.getTransformedPoint(transformers,shape.v[i]);oPoint=this.getTransformedPoint(transformers,shape.o[i]);nextIPoint=this.getTransformedPoint(transformers,shape.i[0]);nextVPoint=this.getTransformedPoint(transformers,shape.v[0]);this.checkBounds(vPoint,oPoint,nextIPoint,nextVPoint,boundingBox);}};HShapeElement.prototype.checkBounds=function(vPoint,oPoint,nextIPoint,nextVPoint,boundingBox){this.getBoundsOfCurve(vPoint,oPoint,nextIPoint,nextVPoint);var bounds=this.shapeBoundingBox;boundingBox.x=bmMin(bounds.left,boundingBox.x);boundingBox.xMax=bmMax(bounds.right,boundingBox.xMax);boundingBox.y=bmMin(bounds.top,boundingBox.y);boundingBox.yMax=bmMax(bounds.bottom,boundingBox.yMax);};HShapeElement.prototype.shapeBoundingBox={left:0,right:0,top:0,bottom:0};HShapeElement.prototype.tempBoundingBox={x:0,xMax:0,y:0,yMax:0,width:0,height:0};HShapeElement.prototype.getBoundsOfCurve=function(p0,p1,p2,p3){var bounds=[[p0[0],p3[0]],[p0[1],p3[1]]];for(var a,b,c,t,b2ac,t1,t2,i=0;i<2;++i){// eslint-disable-line no-plusplus
b=6*p0[i]-12*p1[i]+6*p2[i];a=-3*p0[i]+9*p1[i]-9*p2[i]+3*p3[i];c=3*p1[i]-3*p0[i];b|=0;// eslint-disable-line no-bitwise
a|=0;// eslint-disable-line no-bitwise
c|=0;// eslint-disable-line no-bitwise
if(a===0&&b===0);else if(a===0){t=-c/b;if(t>0&&t<1){bounds[i].push(this.calculateF(t,p0,p1,p2,p3,i));}}else {b2ac=b*b-4*c*a;if(b2ac>=0){t1=(-b+bmSqrt(b2ac))/(2*a);if(t1>0&&t1<1)bounds[i].push(this.calculateF(t1,p0,p1,p2,p3,i));t2=(-b-bmSqrt(b2ac))/(2*a);if(t2>0&&t2<1)bounds[i].push(this.calculateF(t2,p0,p1,p2,p3,i));}}}this.shapeBoundingBox.left=bmMin.apply(null,bounds[0]);this.shapeBoundingBox.top=bmMin.apply(null,bounds[1]);this.shapeBoundingBox.right=bmMax.apply(null,bounds[0]);this.shapeBoundingBox.bottom=bmMax.apply(null,bounds[1]);};HShapeElement.prototype.calculateF=function(t,p0,p1,p2,p3,i){return bmPow(1-t,3)*p0[i]+3*bmPow(1-t,2)*t*p1[i]+3*(1-t)*bmPow(t,2)*p2[i]+bmPow(t,3)*p3[i];};HShapeElement.prototype.calculateBoundingBox=function(itemsData,boundingBox){var i;var len=itemsData.length;for(i=0;i<len;i+=1){if(itemsData[i]&&itemsData[i].sh){this.calculateShapeBoundingBox(itemsData[i],boundingBox);}else if(itemsData[i]&&itemsData[i].it){this.calculateBoundingBox(itemsData[i].it,boundingBox);}else if(itemsData[i]&&itemsData[i].style&&itemsData[i].w){this.expandStrokeBoundingBox(itemsData[i].w,boundingBox);}}};HShapeElement.prototype.expandStrokeBoundingBox=function(widthProperty,boundingBox){var width=0;if(widthProperty.keyframes){for(var i=0;i<widthProperty.keyframes.length;i+=1){var kfw=widthProperty.keyframes[i].s;if(kfw>width){width=kfw;}}width*=widthProperty.mult;}else {width=widthProperty.v*widthProperty.mult;}boundingBox.x-=width;boundingBox.xMax+=width;boundingBox.y-=width;boundingBox.yMax+=width;};HShapeElement.prototype.currentBoxContains=function(box){return this.currentBBox.x<=box.x&&this.currentBBox.y<=box.y&&this.currentBBox.width+this.currentBBox.x>=box.x+box.width&&this.currentBBox.height+this.currentBBox.y>=box.y+box.height;};HShapeElement.prototype.renderInnerContent=function(){this._renderShapeFrame();if(!this.hidden&&(this._isFirstFrame||this._mdf)){var tempBoundingBox=this.tempBoundingBox;var max=999999;tempBoundingBox.x=max;tempBoundingBox.xMax=-max;tempBoundingBox.y=max;tempBoundingBox.yMax=-max;this.calculateBoundingBox(this.itemsData,tempBoundingBox);tempBoundingBox.width=tempBoundingBox.xMax<tempBoundingBox.x?0:tempBoundingBox.xMax-tempBoundingBox.x;tempBoundingBox.height=tempBoundingBox.yMax<tempBoundingBox.y?0:tempBoundingBox.yMax-tempBoundingBox.y;// var tempBoundingBox = this.shapeCont.getBBox();
if(this.currentBoxContains(tempBoundingBox)){return;}var changed=false;if(this.currentBBox.w!==tempBoundingBox.width){this.currentBBox.w=tempBoundingBox.width;this.shapeCont.setAttribute('width',tempBoundingBox.width);changed=true;}if(this.currentBBox.h!==tempBoundingBox.height){this.currentBBox.h=tempBoundingBox.height;this.shapeCont.setAttribute('height',tempBoundingBox.height);changed=true;}if(changed||this.currentBBox.x!==tempBoundingBox.x||this.currentBBox.y!==tempBoundingBox.y){this.currentBBox.w=tempBoundingBox.width;this.currentBBox.h=tempBoundingBox.height;this.currentBBox.x=tempBoundingBox.x;this.currentBBox.y=tempBoundingBox.y;this.shapeCont.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);var shapeStyle=this.shapeCont.style;var shapeTransform='translate('+this.currentBBox.x+'px,'+this.currentBBox.y+'px)';shapeStyle.transform=shapeTransform;shapeStyle.webkitTransform=shapeTransform;}}};function HTextElement(data,globalData,comp){this.textSpans=[];this.textPaths=[];this.currentBBox={x:999999,y:-999999,h:0,w:0};this.renderType='svg';this.isMasked=false;this.initElement(data,globalData,comp);}extendPrototype([BaseElement,TransformElement,HBaseElement,HierarchyElement,FrameElement,RenderableDOMElement,ITextElement],HTextElement);HTextElement.prototype.createContent=function(){this.isMasked=this.checkMasks();if(this.isMasked){this.renderType='svg';this.compW=this.comp.data.w;this.compH=this.comp.data.h;this.svgElement.setAttribute('width',this.compW);this.svgElement.setAttribute('height',this.compH);var g=createNS('g');this.maskedElement.appendChild(g);this.innerElem=g;}else {this.renderType='html';this.innerElem=this.layerElement;}this.checkParenting();};HTextElement.prototype.buildNewText=function(){var documentData=this.textProperty.currentData;this.renderedLetters=createSizedArray(documentData.l?documentData.l.length:0);var innerElemStyle=this.innerElem.style;var textColor=documentData.fc?this.buildColor(documentData.fc):'rgba(0,0,0,0)';innerElemStyle.fill=textColor;innerElemStyle.color=textColor;if(documentData.sc){innerElemStyle.stroke=this.buildColor(documentData.sc);innerElemStyle.strokeWidth=documentData.sw+'px';}var fontData=this.globalData.fontManager.getFontByName(documentData.f);if(!this.globalData.fontManager.chars){innerElemStyle.fontSize=documentData.finalSize+'px';innerElemStyle.lineHeight=documentData.finalSize+'px';if(fontData.fClass){this.innerElem.className=fontData.fClass;}else {innerElemStyle.fontFamily=fontData.fFamily;var fWeight=documentData.fWeight;var fStyle=documentData.fStyle;innerElemStyle.fontStyle=fStyle;innerElemStyle.fontWeight=fWeight;}}var i;var len;var letters=documentData.l;len=letters.length;var tSpan;var tParent;var tCont;var matrixHelper=this.mHelper;var shapes;var shapeStr='';var cnt=0;for(i=0;i<len;i+=1){if(this.globalData.fontManager.chars){if(!this.textPaths[cnt]){tSpan=createNS('path');tSpan.setAttribute('stroke-linecap',lineCapEnum[1]);tSpan.setAttribute('stroke-linejoin',lineJoinEnum[2]);tSpan.setAttribute('stroke-miterlimit','4');}else {tSpan=this.textPaths[cnt];}if(!this.isMasked){if(this.textSpans[cnt]){tParent=this.textSpans[cnt];tCont=tParent.children[0];}else {tParent=createTag('div');tParent.style.lineHeight=0;tCont=createNS('svg');tCont.appendChild(tSpan);styleDiv(tParent);}}}else if(!this.isMasked){if(this.textSpans[cnt]){tParent=this.textSpans[cnt];tSpan=this.textPaths[cnt];}else {tParent=createTag('span');styleDiv(tParent);tSpan=createTag('span');styleDiv(tSpan);tParent.appendChild(tSpan);}}else {tSpan=this.textPaths[cnt]?this.textPaths[cnt]:createNS('text');}// tSpan.setAttribute('visibility', 'hidden');
if(this.globalData.fontManager.chars){var charData=this.globalData.fontManager.getCharData(documentData.finalText[i],fontData.fStyle,this.globalData.fontManager.getFontByName(documentData.f).fFamily);var shapeData;if(charData){shapeData=charData.data;}else {shapeData=null;}matrixHelper.reset();if(shapeData&&shapeData.shapes&&shapeData.shapes.length){shapes=shapeData.shapes[0].it;matrixHelper.scale(documentData.finalSize/100,documentData.finalSize/100);shapeStr=this.createPathShape(matrixHelper,shapes);tSpan.setAttribute('d',shapeStr);}if(!this.isMasked){this.innerElem.appendChild(tParent);if(shapeData&&shapeData.shapes){// document.body.appendChild is needed to get exact measure of shape
document.body.appendChild(tCont);var boundingBox=tCont.getBBox();tCont.setAttribute('width',boundingBox.width+2);tCont.setAttribute('height',boundingBox.height+2);tCont.setAttribute('viewBox',boundingBox.x-1+' '+(boundingBox.y-1)+' '+(boundingBox.width+2)+' '+(boundingBox.height+2));var tContStyle=tCont.style;var tContTranslation='translate('+(boundingBox.x-1)+'px,'+(boundingBox.y-1)+'px)';tContStyle.transform=tContTranslation;tContStyle.webkitTransform=tContTranslation;letters[i].yOffset=boundingBox.y-1;}else {tCont.setAttribute('width',1);tCont.setAttribute('height',1);}tParent.appendChild(tCont);}else {this.innerElem.appendChild(tSpan);}}else {tSpan.textContent=letters[i].val;tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace','xml:space','preserve');if(!this.isMasked){this.innerElem.appendChild(tParent);//
var tStyle=tSpan.style;var tSpanTranslation='translate3d(0,'+-documentData.finalSize/1.2+'px,0)';tStyle.transform=tSpanTranslation;tStyle.webkitTransform=tSpanTranslation;}else {this.innerElem.appendChild(tSpan);}}//
if(!this.isMasked){this.textSpans[cnt]=tParent;}else {this.textSpans[cnt]=tSpan;}this.textSpans[cnt].style.display='block';this.textPaths[cnt]=tSpan;cnt+=1;}while(cnt<this.textSpans.length){this.textSpans[cnt].style.display='none';cnt+=1;}};HTextElement.prototype.renderInnerContent=function(){this.validateText();var svgStyle;if(this.data.singleShape){if(!this._isFirstFrame&&!this.lettersChangedFlag){return;}if(this.isMasked&&this.finalTransform._matMdf){// Todo Benchmark if using this is better than getBBox
this.svgElement.setAttribute('viewBox',-this.finalTransform.mProp.p.v[0]+' '+-this.finalTransform.mProp.p.v[1]+' '+this.compW+' '+this.compH);svgStyle=this.svgElement.style;var translation='translate('+-this.finalTransform.mProp.p.v[0]+'px,'+-this.finalTransform.mProp.p.v[1]+'px)';svgStyle.transform=translation;svgStyle.webkitTransform=translation;}}this.textAnimator.getMeasures(this.textProperty.currentData,this.lettersChangedFlag);if(!this.lettersChangedFlag&&!this.textAnimator.lettersChangedFlag){return;}var i;var len;var count=0;var renderedLetters=this.textAnimator.renderedLetters;var letters=this.textProperty.currentData.l;len=letters.length;var renderedLetter;var textSpan;var textPath;for(i=0;i<len;i+=1){if(letters[i].n){count+=1;}else {textSpan=this.textSpans[i];textPath=this.textPaths[i];renderedLetter=renderedLetters[count];count+=1;if(renderedLetter._mdf.m){if(!this.isMasked){textSpan.style.webkitTransform=renderedLetter.m;textSpan.style.transform=renderedLetter.m;}else {textSpan.setAttribute('transform',renderedLetter.m);}}/// /textSpan.setAttribute('opacity',renderedLetter.o);
textSpan.style.opacity=renderedLetter.o;if(renderedLetter.sw&&renderedLetter._mdf.sw){textPath.setAttribute('stroke-width',renderedLetter.sw);}if(renderedLetter.sc&&renderedLetter._mdf.sc){textPath.setAttribute('stroke',renderedLetter.sc);}if(renderedLetter.fc&&renderedLetter._mdf.fc){textPath.setAttribute('fill',renderedLetter.fc);textPath.style.color=renderedLetter.fc;}}}if(this.innerElem.getBBox&&!this.hidden&&(this._isFirstFrame||this._mdf)){var boundingBox=this.innerElem.getBBox();if(this.currentBBox.w!==boundingBox.width){this.currentBBox.w=boundingBox.width;this.svgElement.setAttribute('width',boundingBox.width);}if(this.currentBBox.h!==boundingBox.height){this.currentBBox.h=boundingBox.height;this.svgElement.setAttribute('height',boundingBox.height);}var margin=1;if(this.currentBBox.w!==boundingBox.width+margin*2||this.currentBBox.h!==boundingBox.height+margin*2||this.currentBBox.x!==boundingBox.x-margin||this.currentBBox.y!==boundingBox.y-margin){this.currentBBox.w=boundingBox.width+margin*2;this.currentBBox.h=boundingBox.height+margin*2;this.currentBBox.x=boundingBox.x-margin;this.currentBBox.y=boundingBox.y-margin;this.svgElement.setAttribute('viewBox',this.currentBBox.x+' '+this.currentBBox.y+' '+this.currentBBox.w+' '+this.currentBBox.h);svgStyle=this.svgElement.style;var svgTransform='translate('+this.currentBBox.x+'px,'+this.currentBBox.y+'px)';svgStyle.transform=svgTransform;svgStyle.webkitTransform=svgTransform;}}};function HCameraElement(data,globalData,comp){this.initFrame();this.initBaseData(data,globalData,comp);this.initHierarchy();var getProp=PropertyFactory.getProp;this.pe=getProp(this,data.pe,0,0,this);if(data.ks.p.s){this.px=getProp(this,data.ks.p.x,1,0,this);this.py=getProp(this,data.ks.p.y,1,0,this);this.pz=getProp(this,data.ks.p.z,1,0,this);}else {this.p=getProp(this,data.ks.p,1,0,this);}if(data.ks.a){this.a=getProp(this,data.ks.a,1,0,this);}if(data.ks.or.k.length&&data.ks.or.k[0].to){var i;var len=data.ks.or.k.length;for(i=0;i<len;i+=1){data.ks.or.k[i].to=null;data.ks.or.k[i].ti=null;}}this.or=getProp(this,data.ks.or,1,degToRads,this);this.or.sh=true;this.rx=getProp(this,data.ks.rx,0,degToRads,this);this.ry=getProp(this,data.ks.ry,0,degToRads,this);this.rz=getProp(this,data.ks.rz,0,degToRads,this);this.mat=new Matrix();this._prevMat=new Matrix();this._isFirstFrame=true;// TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.
this.finalTransform={mProp:this};}extendPrototype([BaseElement,FrameElement,HierarchyElement],HCameraElement);HCameraElement.prototype.setup=function(){var i;var len=this.comp.threeDElements.length;var comp;var perspectiveStyle;var containerStyle;for(i=0;i<len;i+=1){// [perspectiveElem,container]
comp=this.comp.threeDElements[i];if(comp.type==='3d'){perspectiveStyle=comp.perspectiveElem.style;containerStyle=comp.container.style;var perspective=this.pe.v+'px';var origin='0px 0px 0px';var matrix='matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';perspectiveStyle.perspective=perspective;perspectiveStyle.webkitPerspective=perspective;containerStyle.transformOrigin=origin;containerStyle.mozTransformOrigin=origin;containerStyle.webkitTransformOrigin=origin;perspectiveStyle.transform=matrix;perspectiveStyle.webkitTransform=matrix;}}};HCameraElement.prototype.createElements=function(){};HCameraElement.prototype.hide=function(){};HCameraElement.prototype.renderFrame=function(){var _mdf=this._isFirstFrame;var i;var len;if(this.hierarchy){len=this.hierarchy.length;for(i=0;i<len;i+=1){_mdf=this.hierarchy[i].finalTransform.mProp._mdf||_mdf;}}if(_mdf||this.pe._mdf||this.p&&this.p._mdf||this.px&&(this.px._mdf||this.py._mdf||this.pz._mdf)||this.rx._mdf||this.ry._mdf||this.rz._mdf||this.or._mdf||this.a&&this.a._mdf){this.mat.reset();if(this.hierarchy){len=this.hierarchy.length-1;for(i=len;i>=0;i-=1){var mTransf=this.hierarchy[i].finalTransform.mProp;this.mat.translate(-mTransf.p.v[0],-mTransf.p.v[1],mTransf.p.v[2]);this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);this.mat.scale(1/mTransf.s.v[0],1/mTransf.s.v[1],1/mTransf.s.v[2]);this.mat.translate(mTransf.a.v[0],mTransf.a.v[1],mTransf.a.v[2]);}}if(this.p){this.mat.translate(-this.p.v[0],-this.p.v[1],this.p.v[2]);}else {this.mat.translate(-this.px.v,-this.py.v,this.pz.v);}if(this.a){var diffVector;if(this.p){diffVector=[this.p.v[0]-this.a.v[0],this.p.v[1]-this.a.v[1],this.p.v[2]-this.a.v[2]];}else {diffVector=[this.px.v-this.a.v[0],this.py.v-this.a.v[1],this.pz.v-this.a.v[2]];}var mag=Math.sqrt(Math.pow(diffVector[0],2)+Math.pow(diffVector[1],2)+Math.pow(diffVector[2],2));// var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));
var lookDir=[diffVector[0]/mag,diffVector[1]/mag,diffVector[2]/mag];var lookLengthOnXZ=Math.sqrt(lookDir[2]*lookDir[2]+lookDir[0]*lookDir[0]);var mRotationX=Math.atan2(lookDir[1],lookLengthOnXZ);var mRotationY=Math.atan2(lookDir[0],-lookDir[2]);this.mat.rotateY(mRotationY).rotateX(-mRotationX);}this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);this.mat.translate(this.globalData.compSize.w/2,this.globalData.compSize.h/2,0);this.mat.translate(0,0,this.pe.v);var hasMatrixChanged=!this._prevMat.equals(this.mat);if((hasMatrixChanged||this.pe._mdf)&&this.comp.threeDElements){len=this.comp.threeDElements.length;var comp;var perspectiveStyle;var containerStyle;for(i=0;i<len;i+=1){comp=this.comp.threeDElements[i];if(comp.type==='3d'){if(hasMatrixChanged){var matValue=this.mat.toCSS();containerStyle=comp.container.style;containerStyle.transform=matValue;containerStyle.webkitTransform=matValue;}if(this.pe._mdf){perspectiveStyle=comp.perspectiveElem.style;perspectiveStyle.perspective=this.pe.v+'px';perspectiveStyle.webkitPerspective=this.pe.v+'px';}}}this.mat.clone(this._prevMat);}}this._isFirstFrame=false;};HCameraElement.prototype.prepareFrame=function(num){this.prepareProperties(num,true);};HCameraElement.prototype.destroy=function(){};HCameraElement.prototype.getBaseElement=function(){return null;};function HImageElement(data,globalData,comp){this.assetData=globalData.getAssetData(data.refId);this.initElement(data,globalData,comp);}extendPrototype([BaseElement,TransformElement,HBaseElement,HSolidElement,HierarchyElement,FrameElement,RenderableElement],HImageElement);HImageElement.prototype.createContent=function(){var assetPath=this.globalData.getAssetsPath(this.assetData);var img=new Image();if(this.data.hasMask){this.imageElem=createNS('image');this.imageElem.setAttribute('width',this.assetData.w+'px');this.imageElem.setAttribute('height',this.assetData.h+'px');this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink','href',assetPath);this.layerElement.appendChild(this.imageElem);this.baseElement.setAttribute('width',this.assetData.w);this.baseElement.setAttribute('height',this.assetData.h);}else {this.layerElement.appendChild(img);}img.crossOrigin='anonymous';img.src=assetPath;if(this.data.ln){this.baseElement.setAttribute('id',this.data.ln);}};function HybridRendererBase(animationItem,config){this.animationItem=animationItem;this.layers=null;this.renderedFrame=-1;this.renderConfig={className:config&&config.className||'',imagePreserveAspectRatio:config&&config.imagePreserveAspectRatio||'xMidYMid slice',hideOnTransparent:!(config&&config.hideOnTransparent===false),filterSize:{width:config&&config.filterSize&&config.filterSize.width||'400%',height:config&&config.filterSize&&config.filterSize.height||'400%',x:config&&config.filterSize&&config.filterSize.x||'-100%',y:config&&config.filterSize&&config.filterSize.y||'-100%'}};this.globalData={_mdf:false,frameNum:-1,renderConfig:this.renderConfig};this.pendingElements=[];this.elements=[];this.threeDElements=[];this.destroyed=false;this.camera=null;this.supports3d=true;this.rendererType='html';}extendPrototype([BaseRenderer],HybridRendererBase);HybridRendererBase.prototype.buildItem=SVGRenderer.prototype.buildItem;HybridRendererBase.prototype.checkPendingElements=function(){while(this.pendingElements.length){var element=this.pendingElements.pop();element.checkParenting();}};HybridRendererBase.prototype.appendElementInPos=function(element,pos){var newDOMElement=element.getBaseElement();if(!newDOMElement){return;}var layer=this.layers[pos];if(!layer.ddd||!this.supports3d){if(this.threeDElements){this.addTo3dContainer(newDOMElement,pos);}else {var i=0;var nextDOMElement;var nextLayer;var tmpDOMElement;while(i<pos){if(this.elements[i]&&this.elements[i]!==true&&this.elements[i].getBaseElement){nextLayer=this.elements[i];tmpDOMElement=this.layers[i].ddd?this.getThreeDContainerByPos(i):nextLayer.getBaseElement();nextDOMElement=tmpDOMElement||nextDOMElement;}i+=1;}if(nextDOMElement){if(!layer.ddd||!this.supports3d){this.layerElement.insertBefore(newDOMElement,nextDOMElement);}}else if(!layer.ddd||!this.supports3d){this.layerElement.appendChild(newDOMElement);}}}else {this.addTo3dContainer(newDOMElement,pos);}};HybridRendererBase.prototype.createShape=function(data){if(!this.supports3d){return new SVGShapeElement(data,this.globalData,this);}return new HShapeElement(data,this.globalData,this);};HybridRendererBase.prototype.createText=function(data){if(!this.supports3d){return new SVGTextLottieElement(data,this.globalData,this);}return new HTextElement(data,this.globalData,this);};HybridRendererBase.prototype.createCamera=function(data){this.camera=new HCameraElement(data,this.globalData,this);return this.camera;};HybridRendererBase.prototype.createImage=function(data){if(!this.supports3d){return new IImageElement(data,this.globalData,this);}return new HImageElement(data,this.globalData,this);};HybridRendererBase.prototype.createSolid=function(data){if(!this.supports3d){return new ISolidElement(data,this.globalData,this);}return new HSolidElement(data,this.globalData,this);};HybridRendererBase.prototype.createNull=SVGRenderer.prototype.createNull;HybridRendererBase.prototype.getThreeDContainerByPos=function(pos){var i=0;var len=this.threeDElements.length;while(i<len){if(this.threeDElements[i].startPos<=pos&&this.threeDElements[i].endPos>=pos){return this.threeDElements[i].perspectiveElem;}i+=1;}return null;};HybridRendererBase.prototype.createThreeDContainer=function(pos,type){var perspectiveElem=createTag('div');var style;var containerStyle;styleDiv(perspectiveElem);var container=createTag('div');styleDiv(container);if(type==='3d'){style=perspectiveElem.style;style.width=this.globalData.compSize.w+'px';style.height=this.globalData.compSize.h+'px';var center='50% 50%';style.webkitTransformOrigin=center;style.mozTransformOrigin=center;style.transformOrigin=center;containerStyle=container.style;var matrix='matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';containerStyle.transform=matrix;containerStyle.webkitTransform=matrix;}perspectiveElem.appendChild(container);// this.resizerElem.appendChild(perspectiveElem);
var threeDContainerData={container:container,perspectiveElem:perspectiveElem,startPos:pos,endPos:pos,type:type};this.threeDElements.push(threeDContainerData);return threeDContainerData;};HybridRendererBase.prototype.build3dContainers=function(){var i;var len=this.layers.length;var lastThreeDContainerData;var currentContainer='';for(i=0;i<len;i+=1){if(this.layers[i].ddd&&this.layers[i].ty!==3){if(currentContainer!=='3d'){currentContainer='3d';lastThreeDContainerData=this.createThreeDContainer(i,'3d');}lastThreeDContainerData.endPos=Math.max(lastThreeDContainerData.endPos,i);}else {if(currentContainer!=='2d'){currentContainer='2d';lastThreeDContainerData=this.createThreeDContainer(i,'2d');}lastThreeDContainerData.endPos=Math.max(lastThreeDContainerData.endPos,i);}}len=this.threeDElements.length;for(i=len-1;i>=0;i-=1){this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);}};HybridRendererBase.prototype.addTo3dContainer=function(elem,pos){var i=0;var len=this.threeDElements.length;while(i<len){if(pos<=this.threeDElements[i].endPos){var j=this.threeDElements[i].startPos;var nextElement;while(j<pos){if(this.elements[j]&&this.elements[j].getBaseElement){nextElement=this.elements[j].getBaseElement();}j+=1;}if(nextElement){this.threeDElements[i].container.insertBefore(elem,nextElement);}else {this.threeDElements[i].container.appendChild(elem);}break;}i+=1;}};HybridRendererBase.prototype.configAnimation=function(animData){var resizerElem=createTag('div');var wrapper=this.animationItem.wrapper;var style=resizerElem.style;style.width=animData.w+'px';style.height=animData.h+'px';this.resizerElem=resizerElem;styleDiv(resizerElem);style.transformStyle='flat';style.mozTransformStyle='flat';style.webkitTransformStyle='flat';if(this.renderConfig.className){resizerElem.setAttribute('class',this.renderConfig.className);}wrapper.appendChild(resizerElem);style.overflow='hidden';var svg=createNS('svg');svg.setAttribute('width','1');svg.setAttribute('height','1');styleDiv(svg);this.resizerElem.appendChild(svg);var defs=createNS('defs');svg.appendChild(defs);this.data=animData;// Mask animation
this.setupGlobalData(animData,svg);this.globalData.defs=defs;this.layers=animData.layers;this.layerElement=this.resizerElem;this.build3dContainers();this.updateContainerSize();};HybridRendererBase.prototype.destroy=function(){if(this.animationItem.wrapper){this.animationItem.wrapper.innerText='';}this.animationItem.container=null;this.globalData.defs=null;var i;var len=this.layers?this.layers.length:0;for(i=0;i<len;i+=1){if(this.elements[i]&&this.elements[i].destroy){this.elements[i].destroy();}}this.elements.length=0;this.destroyed=true;this.animationItem=null;};HybridRendererBase.prototype.updateContainerSize=function(){var elementWidth=this.animationItem.wrapper.offsetWidth;var elementHeight=this.animationItem.wrapper.offsetHeight;var elementRel=elementWidth/elementHeight;var animationRel=this.globalData.compSize.w/this.globalData.compSize.h;var sx;var sy;var tx;var ty;if(animationRel>elementRel){sx=elementWidth/this.globalData.compSize.w;sy=elementWidth/this.globalData.compSize.w;tx=0;ty=(elementHeight-this.globalData.compSize.h*(elementWidth/this.globalData.compSize.w))/2;}else {sx=elementHeight/this.globalData.compSize.h;sy=elementHeight/this.globalData.compSize.h;tx=(elementWidth-this.globalData.compSize.w*(elementHeight/this.globalData.compSize.h))/2;ty=0;}var style=this.resizerElem.style;style.webkitTransform='matrix3d('+sx+',0,0,0,0,'+sy+',0,0,0,0,1,0,'+tx+','+ty+',0,1)';style.transform=style.webkitTransform;};HybridRendererBase.prototype.renderFrame=SVGRenderer.prototype.renderFrame;HybridRendererBase.prototype.hide=function(){this.resizerElem.style.display='none';};HybridRendererBase.prototype.show=function(){this.resizerElem.style.display='block';};HybridRendererBase.prototype.initItems=function(){this.buildAllItems();if(this.camera){this.camera.setup();}else {var cWidth=this.globalData.compSize.w;var cHeight=this.globalData.compSize.h;var i;var len=this.threeDElements.length;for(i=0;i<len;i+=1){var style=this.threeDElements[i].perspectiveElem.style;style.webkitPerspective=Math.sqrt(Math.pow(cWidth,2)+Math.pow(cHeight,2))+'px';style.perspective=style.webkitPerspective;}}};HybridRendererBase.prototype.searchExtraCompositions=function(assets){var i;var len=assets.length;var floatingContainer=createTag('div');for(i=0;i<len;i+=1){if(assets[i].xt){var comp=this.createComp(assets[i],floatingContainer,this.globalData.comp,null);comp.initExpressions();this.globalData.projectInterface.registerComposition(comp);}}};function HCompElement(data,globalData,comp){this.layers=data.layers;this.supports3d=!data.hasMask;this.completeLayers=false;this.pendingElements=[];this.elements=this.layers?createSizedArray(this.layers.length):[];this.initElement(data,globalData,comp);this.tm=data.tm?PropertyFactory.getProp(this,data.tm,0,globalData.frameRate,this):{_placeholder:true};}extendPrototype([HybridRendererBase,ICompElement,HBaseElement],HCompElement);HCompElement.prototype._createBaseContainerElements=HCompElement.prototype.createContainerElements;HCompElement.prototype.createContainerElements=function(){this._createBaseContainerElements();// divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';
if(this.data.hasMask){this.svgElement.setAttribute('width',this.data.w);this.svgElement.setAttribute('height',this.data.h);this.transformedElement=this.baseElement;}else {this.transformedElement=this.layerElement;}};HCompElement.prototype.addTo3dContainer=function(elem,pos){var j=0;var nextElement;while(j<pos){if(this.elements[j]&&this.elements[j].getBaseElement){nextElement=this.elements[j].getBaseElement();}j+=1;}if(nextElement){this.layerElement.insertBefore(elem,nextElement);}else {this.layerElement.appendChild(elem);}};HCompElement.prototype.createComp=function(data){if(!this.supports3d){return new SVGCompElement(data,this.globalData,this);}return new HCompElement(data,this.globalData,this);};function HybridRenderer(animationItem,config){this.animationItem=animationItem;this.layers=null;this.renderedFrame=-1;this.renderConfig={className:config&&config.className||'',imagePreserveAspectRatio:config&&config.imagePreserveAspectRatio||'xMidYMid slice',hideOnTransparent:!(config&&config.hideOnTransparent===false),filterSize:{width:config&&config.filterSize&&config.filterSize.width||'400%',height:config&&config.filterSize&&config.filterSize.height||'400%',x:config&&config.filterSize&&config.filterSize.x||'-100%',y:config&&config.filterSize&&config.filterSize.y||'-100%'},runExpressions:!config||config.runExpressions===undefined||config.runExpressions};this.globalData={_mdf:false,frameNum:-1,renderConfig:this.renderConfig};this.pendingElements=[];this.elements=[];this.threeDElements=[];this.destroyed=false;this.camera=null;this.supports3d=true;this.rendererType='html';}extendPrototype([HybridRendererBase],HybridRenderer);HybridRenderer.prototype.createComp=function(data){if(!this.supports3d){return new SVGCompElement(data,this.globalData,this);}return new HCompElement(data,this.globalData,this);};var CompExpressionInterface=function(){return function(comp){function _thisLayerFunction(name){var i=0;var len=comp.layers.length;while(i<len){if(comp.layers[i].nm===name||comp.layers[i].ind===name){return comp.elements[i].layerInterface;}i+=1;}return null;// return {active:false};
}Object.defineProperty(_thisLayerFunction,'_name',{value:comp.data.nm});_thisLayerFunction.layer=_thisLayerFunction;_thisLayerFunction.pixelAspect=1;_thisLayerFunction.height=comp.data.h||comp.globalData.compSize.h;_thisLayerFunction.width=comp.data.w||comp.globalData.compSize.w;_thisLayerFunction.pixelAspect=1;_thisLayerFunction.frameDuration=1/comp.globalData.frameRate;_thisLayerFunction.displayStartTime=0;_thisLayerFunction.numLayers=comp.layers.length;return _thisLayerFunction;};}();function _typeof$2(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof$2=function _typeof(obj){return typeof obj;};}else {_typeof$2=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof$2(obj);}/* eslint-disable */ /*
	   Copyright 2014 David Bau.

	   Permission is hereby granted, free of charge, to any person obtaining
	   a copy of this software and associated documentation files (the
	   "Software"), to deal in the Software without restriction, including
	   without limitation the rights to use, copy, modify, merge, publish,
	   distribute, sublicense, and/or sell copies of the Software, and to
	   permit persons to whom the Software is furnished to do so, subject to
	   the following conditions:

	   The above copyright notice and this permission notice shall be
	   included in all copies or substantial portions of the Software.

	   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
	   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
	   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
	   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	   */function seedRandom(pool,math){//
// The following constants are related to IEEE 754 limits.
//
var global=this,width=256,// each RC4 output is 0 <= x < 256
chunks=6,// at least six RC4 outputs for each double
digits=52,// there are 52 significant digits in a double
rngname='random',// rngname: name for Math.random and Math.seedrandom
startdenom=math.pow(width,chunks),significance=math.pow(2,digits),overflow=significance*2,mask=width-1,nodecrypto;// node.js crypto module, initialized at the bottom.
//
// seedrandom()
// This is the seedrandom function described above.
//
function seedrandom(seed,options,callback){var key=[];options=options===true?{entropy:true}:options||{};// Flatten the seed string or build one from local entropy if needed.
var shortseed=mixkey(flatten(options.entropy?[seed,tostring(pool)]:seed===null?autoseed():seed,3),key);// Use the seed to initialize an ARC4 generator.
var arc4=new ARC4(key);// This function returns a random double in [0, 1) that contains
// randomness in every bit of the mantissa of the IEEE 754 value.
var prng=function prng(){var n=arc4.g(chunks),// Start with a numerator n < 2 ^ 48
d=startdenom,//   and denominator d = 2 ^ 48.
x=0;//   and no 'extra last byte'.
while(n<significance){// Fill up all significant digits by
n=(n+x)*width;//   shifting numerator and
d*=width;//   denominator and generating a
x=arc4.g(1);//   new least-significant-byte.
}while(n>=overflow){// To avoid rounding up, before adding
n/=2;//   last byte, shift everything
d/=2;//   right using integer math until
x>>>=1;//   we have exactly the desired bits.
}return (n+x)/d;// Form the number within [0, 1).
};prng.int32=function(){return arc4.g(4)|0;};prng.quick=function(){return arc4.g(4)/0x100000000;};prng["double"]=prng;// Mix the randomness into accumulated entropy.
mixkey(tostring(arc4.S),pool);// Calling convention: what to return as a function of prng, seed, is_math.
return (options.pass||callback||function(prng,seed,is_math_call,state){if(state){// Load the arc4 state from the given state if it has an S array.
if(state.S){copy(state,arc4);}// Only provide the .state method if requested via options.state.
prng.state=function(){return copy(arc4,{});};}// If called as a method of Math (Math.seedrandom()), mutate
// Math.random because that is how seedrandom.js has worked since v1.0.
if(is_math_call){math[rngname]=prng;return seed;}// Otherwise, it is a newer calling convention, so return the
// prng directly.
else return prng;})(prng,shortseed,'global'in options?options.global:this==math,options.state);}math['seed'+rngname]=seedrandom;//
// ARC4
//
// An ARC4 implementation.  The constructor takes a key in the form of
// an array of at most (width) integers that should be 0 <= x < (width).
//
// The g(count) method returns a pseudorandom integer that concatenates
// the next (count) outputs from ARC4.  Its return value is a number x
// that is in the range 0 <= x < (width ^ count).
//
function ARC4(key){var t,keylen=key.length,me=this,i=0,j=me.i=me.j=0,s=me.S=[];// The empty key [] is treated as [0].
if(!keylen){key=[keylen++];}// Set up S using the standard key scheduling algorithm.
while(i<width){s[i]=i++;}for(i=0;i<width;i++){s[i]=s[j=mask&j+key[i%keylen]+(t=s[i])];s[j]=t;}// The "g" method returns the next (count) outputs as one number.
me.g=function(count){// Using instance members instead of closure state nearly doubles speed.
var t,r=0,i=me.i,j=me.j,s=me.S;while(count--){t=s[i=mask&i+1];r=r*width+s[mask&(s[i]=s[j=mask&j+t])+(s[j]=t)];}me.i=i;me.j=j;return r;// For robust unpredictability, the function call below automatically
// discards an initial batch of values.  This is called RC4-drop[256].
// See http://google.com/search?q=rsa+fluhrer+response&btnI
};}//
// copy()
// Copies internal state of ARC4 to or from a plain object.
//
function copy(f,t){t.i=f.i;t.j=f.j;t.S=f.S.slice();return t;}//
// flatten()
// Converts an object tree to nested arrays of strings.
//
function flatten(obj,depth){var result=[],typ=_typeof$2(obj),prop;if(depth&&typ=='object'){for(prop in obj){try{result.push(flatten(obj[prop],depth-1));}catch(e){}}}return result.length?result:typ=='string'?obj:obj+'\0';}//
// mixkey()
// Mixes a string seed into a key that is an array of integers, and
// returns a shortened string seed that is equivalent to the result key.
//
function mixkey(seed,key){var stringseed=seed+'',smear,j=0;while(j<stringseed.length){key[mask&j]=mask&(smear^=key[mask&j]*19)+stringseed.charCodeAt(j++);}return tostring(key);}//
// autoseed()
// Returns an object for autoseeding, using window.crypto and Node crypto
// module if available.
//
function autoseed(){try{if(nodecrypto);var out=new Uint8Array(width);(global.crypto||global.msCrypto).getRandomValues(out);return tostring(out);}catch(e){var browser=global.navigator,plugins=browser&&browser.plugins;return [+new Date(),global,plugins,global.screen,tostring(pool)];}}//
// tostring()
// Converts an array of charcodes to a string
//
function tostring(a){return String.fromCharCode.apply(0,a);}//
// When seedrandom.js is loaded, we immediately mix a few bits
// from the built-in RNG into the entropy pool.  Because we do
// not want to interfere with deterministic PRNG state later,
// seedrandom will not call math.random on its own again after
// initialization.
//
mixkey(math.random(),pool);//
// Nodejs and AMD support: export the implementation as a module using
// either convention.
//
// End anonymous scope, and pass initial values.
}function initialize$2(BMMath){seedRandom([],BMMath);}var propTypes={SHAPE:'shape'};function _typeof$1(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof$1=function _typeof(obj){return typeof obj;};}else {_typeof$1=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof$1(obj);}var ExpressionManager=function(){var ob={};var Math=BMMath;var window=null;var document=null;var XMLHttpRequest=null;var fetch=null;var frames=null;var _lottieGlobal={};initialize$2(BMMath);function resetFrame(){_lottieGlobal={};}function $bm_isInstanceOfArray(arr){return arr.constructor===Array||arr.constructor===Float32Array;}function isNumerable(tOfV,v){return tOfV==='number'||v instanceof Number||tOfV==='boolean'||tOfV==='string';}function $bm_neg(a){var tOfA=_typeof$1(a);if(tOfA==='number'||a instanceof Number||tOfA==='boolean'){return -a;}if($bm_isInstanceOfArray(a)){var i;var lenA=a.length;var retArr=[];for(i=0;i<lenA;i+=1){retArr[i]=-a[i];}return retArr;}if(a.propType){return a.v;}return -a;}var easeInBez=BezierFactory.getBezierEasing(0.333,0,0.833,0.833,'easeIn').get;var easeOutBez=BezierFactory.getBezierEasing(0.167,0.167,0.667,1,'easeOut').get;var easeInOutBez=BezierFactory.getBezierEasing(0.33,0,0.667,1,'easeInOut').get;function sum(a,b){var tOfA=_typeof$1(a);var tOfB=_typeof$1(b);if(isNumerable(tOfA,a)&&isNumerable(tOfB,b)||tOfA==='string'||tOfB==='string'){return a+b;}if($bm_isInstanceOfArray(a)&&isNumerable(tOfB,b)){a=a.slice(0);a[0]+=b;return a;}if(isNumerable(tOfA,a)&&$bm_isInstanceOfArray(b)){b=b.slice(0);b[0]=a+b[0];return b;}if($bm_isInstanceOfArray(a)&&$bm_isInstanceOfArray(b)){var i=0;var lenA=a.length;var lenB=b.length;var retArr=[];while(i<lenA||i<lenB){if((typeof a[i]==='number'||a[i]instanceof Number)&&(typeof b[i]==='number'||b[i]instanceof Number)){retArr[i]=a[i]+b[i];}else {retArr[i]=b[i]===undefined?a[i]:a[i]||b[i];}i+=1;}return retArr;}return 0;}var add=sum;function sub(a,b){var tOfA=_typeof$1(a);var tOfB=_typeof$1(b);if(isNumerable(tOfA,a)&&isNumerable(tOfB,b)){if(tOfA==='string'){a=parseInt(a,10);}if(tOfB==='string'){b=parseInt(b,10);}return a-b;}if($bm_isInstanceOfArray(a)&&isNumerable(tOfB,b)){a=a.slice(0);a[0]-=b;return a;}if(isNumerable(tOfA,a)&&$bm_isInstanceOfArray(b)){b=b.slice(0);b[0]=a-b[0];return b;}if($bm_isInstanceOfArray(a)&&$bm_isInstanceOfArray(b)){var i=0;var lenA=a.length;var lenB=b.length;var retArr=[];while(i<lenA||i<lenB){if((typeof a[i]==='number'||a[i]instanceof Number)&&(typeof b[i]==='number'||b[i]instanceof Number)){retArr[i]=a[i]-b[i];}else {retArr[i]=b[i]===undefined?a[i]:a[i]||b[i];}i+=1;}return retArr;}return 0;}function mul(a,b){var tOfA=_typeof$1(a);var tOfB=_typeof$1(b);var arr;if(isNumerable(tOfA,a)&&isNumerable(tOfB,b)){return a*b;}var i;var len;if($bm_isInstanceOfArray(a)&&isNumerable(tOfB,b)){len=a.length;arr=createTypedArray('float32',len);for(i=0;i<len;i+=1){arr[i]=a[i]*b;}return arr;}if(isNumerable(tOfA,a)&&$bm_isInstanceOfArray(b)){len=b.length;arr=createTypedArray('float32',len);for(i=0;i<len;i+=1){arr[i]=a*b[i];}return arr;}return 0;}function div(a,b){var tOfA=_typeof$1(a);var tOfB=_typeof$1(b);var arr;if(isNumerable(tOfA,a)&&isNumerable(tOfB,b)){return a/b;}var i;var len;if($bm_isInstanceOfArray(a)&&isNumerable(tOfB,b)){len=a.length;arr=createTypedArray('float32',len);for(i=0;i<len;i+=1){arr[i]=a[i]/b;}return arr;}if(isNumerable(tOfA,a)&&$bm_isInstanceOfArray(b)){len=b.length;arr=createTypedArray('float32',len);for(i=0;i<len;i+=1){arr[i]=a/b[i];}return arr;}return 0;}function mod(a,b){if(typeof a==='string'){a=parseInt(a,10);}if(typeof b==='string'){b=parseInt(b,10);}return a%b;}var $bm_sum=sum;var $bm_sub=sub;var $bm_mul=mul;var $bm_div=div;var $bm_mod=mod;function clamp(num,min,max){if(min>max){var mm=max;max=min;min=mm;}return Math.min(Math.max(num,min),max);}function radiansToDegrees(val){return val/degToRads;}var radians_to_degrees=radiansToDegrees;function degreesToRadians(val){return val*degToRads;}var degrees_to_radians=radiansToDegrees;var helperLengthArray=[0,0,0,0,0,0];function length(arr1,arr2){if(typeof arr1==='number'||arr1 instanceof Number){arr2=arr2||0;return Math.abs(arr1-arr2);}if(!arr2){arr2=helperLengthArray;}var i;var len=Math.min(arr1.length,arr2.length);var addedLength=0;for(i=0;i<len;i+=1){addedLength+=Math.pow(arr2[i]-arr1[i],2);}return Math.sqrt(addedLength);}function normalize(vec){return div(vec,length(vec));}function rgbToHsl(val){var r=val[0];var g=val[1];var b=val[2];var max=Math.max(r,g,b);var min=Math.min(r,g,b);var h;var s;var l=(max+min)/2;if(max===min){h=0;// achromatic
s=0;// achromatic
}else {var d=max-min;s=l>0.5?d/(2-max-min):d/(max+min);switch(max){case r:h=(g-b)/d+(g<b?6:0);break;case g:h=(b-r)/d+2;break;case b:h=(r-g)/d+4;break;}h/=6;}return [h,s,l,val[3]];}function hue2rgb(p,q,t){if(t<0)t+=1;if(t>1)t-=1;if(t<1/6)return p+(q-p)*6*t;if(t<1/2)return q;if(t<2/3)return p+(q-p)*(2/3-t)*6;return p;}function hslToRgb(val){var h=val[0];var s=val[1];var l=val[2];var r;var g;var b;if(s===0){r=l;// achromatic
b=l;// achromatic
g=l;// achromatic
}else {var q=l<0.5?l*(1+s):l+s-l*s;var p=2*l-q;r=hue2rgb(p,q,h+1/3);g=hue2rgb(p,q,h);b=hue2rgb(p,q,h-1/3);}return [r,g,b,val[3]];}function linear(t,tMin,tMax,value1,value2){if(value1===undefined||value2===undefined){value1=tMin;value2=tMax;tMin=0;tMax=1;}if(tMax<tMin){var _tMin=tMax;tMax=tMin;tMin=_tMin;}if(t<=tMin){return value1;}if(t>=tMax){return value2;}var perc=tMax===tMin?0:(t-tMin)/(tMax-tMin);if(!value1.length){return value1+(value2-value1)*perc;}var i;var len=value1.length;var arr=createTypedArray('float32',len);for(i=0;i<len;i+=1){arr[i]=value1[i]+(value2[i]-value1[i])*perc;}return arr;}function random(min,max){if(max===undefined){if(min===undefined){min=0;max=1;}else {max=min;min=undefined;}}if(max.length){var i;var len=max.length;if(!min){min=createTypedArray('float32',len);}var arr=createTypedArray('float32',len);var rnd=BMMath.random();for(i=0;i<len;i+=1){arr[i]=min[i]+rnd*(max[i]-min[i]);}return arr;}if(min===undefined){min=0;}var rndm=BMMath.random();return min+rndm*(max-min);}function createPath(points,inTangents,outTangents,closed){var i;var len=points.length;var path=shapePool.newElement();path.setPathData(!!closed,len);var arrPlaceholder=[0,0];var inVertexPoint;var outVertexPoint;for(i=0;i<len;i+=1){inVertexPoint=inTangents&&inTangents[i]?inTangents[i]:arrPlaceholder;outVertexPoint=outTangents&&outTangents[i]?outTangents[i]:arrPlaceholder;path.setTripleAt(points[i][0],points[i][1],outVertexPoint[0]+points[i][0],outVertexPoint[1]+points[i][1],inVertexPoint[0]+points[i][0],inVertexPoint[1]+points[i][1],i,true);}return path;}function initiateExpression(elem,data,property){// Bail out if we don't want expressions
function noOp(_value){return _value;}if(!elem.globalData.renderConfig.runExpressions){return noOp;}var val=data.x;var needsVelocity=/velocity(?![\w\d])/.test(val);var _needsRandom=val.indexOf('random')!==-1;var elemType=elem.data.ty;var transform;var $bm_transform;var content;var effect;var thisProperty=property;thisProperty.valueAtTime=thisProperty.getValueAtTime;Object.defineProperty(thisProperty,'value',{get:function get(){return thisProperty.v;}});elem.comp.frameDuration=1/elem.comp.globalData.frameRate;elem.comp.displayStartTime=0;var inPoint=elem.data.ip/elem.comp.globalData.frameRate;var outPoint=elem.data.op/elem.comp.globalData.frameRate;var width=elem.data.sw?elem.data.sw:0;var height=elem.data.sh?elem.data.sh:0;var name=elem.data.nm;var loopIn;var loop_in;var loopOut;var loop_out;var smooth;var toWorld;var fromWorld;var fromComp;var toComp;var fromCompToSurface;var position;var rotation;var anchorPoint;var scale;var thisLayer;var thisComp;var mask;var valueAtTime;var velocityAtTime;var scoped_bm_rt;// val = val.replace(/(\\?"|')((http)(s)?(:\/))?\/.*?(\\?"|')/g, "\"\""); // deter potential network calls
var expression_function=eval('[function _expression_function(){'+val+';scoped_bm_rt=$bm_rt}]')[0];// eslint-disable-line no-eval
var numKeys=property.kf?data.k.length:0;var active=!this.data||this.data.hd!==true;var wiggle=function wiggle(freq,amp){var iWiggle;var j;var lenWiggle=this.pv.length?this.pv.length:1;var addedAmps=createTypedArray('float32',lenWiggle);freq=5;var iterations=Math.floor(time*freq);iWiggle=0;j=0;while(iWiggle<iterations){// var rnd = BMMath.random();
for(j=0;j<lenWiggle;j+=1){addedAmps[j]+=-amp+amp*2*BMMath.random();// addedAmps[j] += -amp + amp*2*rnd;
}iWiggle+=1;}// var rnd2 = BMMath.random();
var periods=time*freq;var perc=periods-Math.floor(periods);var arr=createTypedArray('float32',lenWiggle);if(lenWiggle>1){for(j=0;j<lenWiggle;j+=1){arr[j]=this.pv[j]+addedAmps[j]+(-amp+amp*2*BMMath.random())*perc;// arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;
// arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);
}return arr;}return this.pv+addedAmps[0]+(-amp+amp*2*BMMath.random())*perc;}.bind(this);if(thisProperty.loopIn){loopIn=thisProperty.loopIn.bind(thisProperty);loop_in=loopIn;}if(thisProperty.loopOut){loopOut=thisProperty.loopOut.bind(thisProperty);loop_out=loopOut;}if(thisProperty.smooth){smooth=thisProperty.smooth.bind(thisProperty);}function loopInDuration(type,duration){return loopIn(type,duration,true);}function loopOutDuration(type,duration){return loopOut(type,duration,true);}if(this.getValueAtTime){valueAtTime=this.getValueAtTime.bind(this);}if(this.getVelocityAtTime){velocityAtTime=this.getVelocityAtTime.bind(this);}var comp=elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);function lookAt(elem1,elem2){var fVec=[elem2[0]-elem1[0],elem2[1]-elem1[1],elem2[2]-elem1[2]];var pitch=Math.atan2(fVec[0],Math.sqrt(fVec[1]*fVec[1]+fVec[2]*fVec[2]))/degToRads;var yaw=-Math.atan2(fVec[1],fVec[2])/degToRads;return [yaw,pitch,0];}function easeOut(t,tMin,tMax,val1,val2){return applyEase(easeOutBez,t,tMin,tMax,val1,val2);}function easeIn(t,tMin,tMax,val1,val2){return applyEase(easeInBez,t,tMin,tMax,val1,val2);}function ease(t,tMin,tMax,val1,val2){return applyEase(easeInOutBez,t,tMin,tMax,val1,val2);}function applyEase(fn,t,tMin,tMax,val1,val2){if(val1===undefined){val1=tMin;val2=tMax;}else {t=(t-tMin)/(tMax-tMin);}if(t>1){t=1;}else if(t<0){t=0;}var mult=fn(t);if($bm_isInstanceOfArray(val1)){var iKey;var lenKey=val1.length;var arr=createTypedArray('float32',lenKey);for(iKey=0;iKey<lenKey;iKey+=1){arr[iKey]=(val2[iKey]-val1[iKey])*mult+val1[iKey];}return arr;}return (val2-val1)*mult+val1;}function nearestKey(time){var iKey;var lenKey=data.k.length;var index;var keyTime;if(!data.k.length||typeof data.k[0]==='number'){index=0;keyTime=0;}else {index=-1;time*=elem.comp.globalData.frameRate;if(time<data.k[0].t){index=1;keyTime=data.k[0].t;}else {for(iKey=0;iKey<lenKey-1;iKey+=1){if(time===data.k[iKey].t){index=iKey+1;keyTime=data.k[iKey].t;break;}else if(time>data.k[iKey].t&&time<data.k[iKey+1].t){if(time-data.k[iKey].t>data.k[iKey+1].t-time){index=iKey+2;keyTime=data.k[iKey+1].t;}else {index=iKey+1;keyTime=data.k[iKey].t;}break;}}if(index===-1){index=iKey+1;keyTime=data.k[iKey].t;}}}var obKey={};obKey.index=index;obKey.time=keyTime/elem.comp.globalData.frameRate;return obKey;}function key(ind){var obKey;var iKey;var lenKey;if(!data.k.length||typeof data.k[0]==='number'){throw new Error('The property has no keyframe at index '+ind);}ind-=1;obKey={time:data.k[ind].t/elem.comp.globalData.frameRate,value:[]};var arr=Object.prototype.hasOwnProperty.call(data.k[ind],'s')?data.k[ind].s:data.k[ind-1].e;lenKey=arr.length;for(iKey=0;iKey<lenKey;iKey+=1){obKey[iKey]=arr[iKey];obKey.value[iKey]=arr[iKey];}return obKey;}function framesToTime(fr,fps){if(!fps){fps=elem.comp.globalData.frameRate;}return fr/fps;}function timeToFrames(t,fps){if(!t&&t!==0){t=time;}if(!fps){fps=elem.comp.globalData.frameRate;}return t*fps;}function seedRandom(seed){BMMath.seedrandom(randSeed+seed);}function sourceRectAtTime(){return elem.sourceRectAtTime();}function substring(init,end){if(typeof value==='string'){if(end===undefined){return value.substring(init);}return value.substring(init,end);}return '';}function substr(init,end){if(typeof value==='string'){if(end===undefined){return value.substr(init);}return value.substr(init,end);}return '';}function posterizeTime(framesPerSecond){time=framesPerSecond===0?0:Math.floor(time*framesPerSecond)/framesPerSecond;value=valueAtTime(time);}var time;var velocity;var value;var text;var textIndex;var textTotal;var selectorValue;var index=elem.data.ind;var hasParent=!!(elem.hierarchy&&elem.hierarchy.length);var parent;var randSeed=Math.floor(Math.random()*1000000);var globalData=elem.globalData;function executeExpression(_value){// globalData.pushExpression();
value=_value;if(this.frameExpressionId===elem.globalData.frameId&&this.propType!=='textSelector'){return value;}if(this.propType==='textSelector'){textIndex=this.textIndex;textTotal=this.textTotal;selectorValue=this.selectorValue;}if(!thisLayer){text=elem.layerInterface.text;thisLayer=elem.layerInterface;thisComp=elem.comp.compInterface;toWorld=thisLayer.toWorld.bind(thisLayer);fromWorld=thisLayer.fromWorld.bind(thisLayer);fromComp=thisLayer.fromComp.bind(thisLayer);toComp=thisLayer.toComp.bind(thisLayer);mask=thisLayer.mask?thisLayer.mask.bind(thisLayer):null;fromCompToSurface=fromComp;}if(!transform){transform=elem.layerInterface('ADBE Transform Group');$bm_transform=transform;if(transform){anchorPoint=transform.anchorPoint;/* position = transform.position;
	                      rotation = transform.rotation;
	                      scale = transform.scale; */}}if(elemType===4&&!content){content=thisLayer('ADBE Root Vectors Group');}if(!effect){effect=thisLayer(4);}hasParent=!!(elem.hierarchy&&elem.hierarchy.length);if(hasParent&&!parent){parent=elem.hierarchy[0].layerInterface;}time=this.comp.renderedFrame/this.comp.globalData.frameRate;if(_needsRandom){seedRandom(randSeed+time);}if(needsVelocity){velocity=velocityAtTime(time);}expression_function();this.frameExpressionId=elem.globalData.frameId;// TODO: Check if it's possible to return on ShapeInterface the .v value
// Changed this to a ternary operation because Rollup failed compiling it correctly
scoped_bm_rt=scoped_bm_rt.propType===propTypes.SHAPE?scoped_bm_rt.v:scoped_bm_rt;return scoped_bm_rt;}// Bundlers will see these as dead code and unless we reference them
executeExpression.__preventDeadCodeRemoval=[$bm_transform,anchorPoint,time,velocity,inPoint,outPoint,width,height,name,loop_in,loop_out,smooth,toComp,fromCompToSurface,toWorld,fromWorld,mask,position,rotation,scale,thisComp,numKeys,active,wiggle,loopInDuration,loopOutDuration,comp,lookAt,easeOut,easeIn,ease,nearestKey,key,text,textIndex,textTotal,selectorValue,framesToTime,timeToFrames,sourceRectAtTime,substring,substr,posterizeTime,index,globalData];return executeExpression;}ob.initiateExpression=initiateExpression;ob.__preventDeadCodeRemoval=[window,document,XMLHttpRequest,fetch,frames,$bm_neg,add,$bm_sum,$bm_sub,$bm_mul,$bm_div,$bm_mod,clamp,radians_to_degrees,degreesToRadians,degrees_to_radians,normalize,rgbToHsl,hslToRgb,linear,random,createPath,_lottieGlobal];ob.resetFrame=resetFrame;return ob;}();var Expressions=function(){var ob={};ob.initExpressions=initExpressions;ob.resetFrame=ExpressionManager.resetFrame;function initExpressions(animation){var stackCount=0;var registers=[];function pushExpression(){stackCount+=1;}function popExpression(){stackCount-=1;if(stackCount===0){releaseInstances();}}function registerExpressionProperty(expression){if(registers.indexOf(expression)===-1){registers.push(expression);}}function releaseInstances(){var i;var len=registers.length;for(i=0;i<len;i+=1){registers[i].release();}registers.length=0;}animation.renderer.compInterface=CompExpressionInterface(animation.renderer);animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);animation.renderer.globalData.pushExpression=pushExpression;animation.renderer.globalData.popExpression=popExpression;animation.renderer.globalData.registerExpressionProperty=registerExpressionProperty;}return ob;}();var MaskManagerInterface=function(){function MaskInterface(mask,data){this._mask=mask;this._data=data;}Object.defineProperty(MaskInterface.prototype,'maskPath',{get:function get(){if(this._mask.prop.k){this._mask.prop.getValue();}return this._mask.prop;}});Object.defineProperty(MaskInterface.prototype,'maskOpacity',{get:function get(){if(this._mask.op.k){this._mask.op.getValue();}return this._mask.op.v*100;}});var MaskManager=function MaskManager(maskManager){var _masksInterfaces=createSizedArray(maskManager.viewData.length);var i;var len=maskManager.viewData.length;for(i=0;i<len;i+=1){_masksInterfaces[i]=new MaskInterface(maskManager.viewData[i],maskManager.masksProperties[i]);}var maskFunction=function maskFunction(name){i=0;while(i<len){if(maskManager.masksProperties[i].nm===name){return _masksInterfaces[i];}i+=1;}return null;};return maskFunction;};return MaskManager;}();var ExpressionPropertyInterface=function(){var defaultUnidimensionalValue={pv:0,v:0,mult:1};var defaultMultidimensionalValue={pv:[0,0,0],v:[0,0,0],mult:1};function completeProperty(expressionValue,property,type){Object.defineProperty(expressionValue,'velocity',{get:function get(){return property.getVelocityAtTime(property.comp.currentFrame);}});expressionValue.numKeys=property.keyframes?property.keyframes.length:0;expressionValue.key=function(pos){if(!expressionValue.numKeys){return 0;}var value='';if('s'in property.keyframes[pos-1]){value=property.keyframes[pos-1].s;}else if('e'in property.keyframes[pos-2]){value=property.keyframes[pos-2].e;}else {value=property.keyframes[pos-2].s;}var valueProp=type==='unidimensional'?new Number(value):Object.assign({},value);// eslint-disable-line no-new-wrappers
valueProp.time=property.keyframes[pos-1].t/property.elem.comp.globalData.frameRate;valueProp.value=type==='unidimensional'?value[0]:value;return valueProp;};expressionValue.valueAtTime=property.getValueAtTime;expressionValue.speedAtTime=property.getSpeedAtTime;expressionValue.velocityAtTime=property.getVelocityAtTime;expressionValue.propertyGroup=property.propertyGroup;}function UnidimensionalPropertyInterface(property){if(!property||!('pv'in property)){property=defaultUnidimensionalValue;}var mult=1/property.mult;var val=property.pv*mult;var expressionValue=new Number(val);// eslint-disable-line no-new-wrappers
expressionValue.value=val;completeProperty(expressionValue,property,'unidimensional');return function(){if(property.k){property.getValue();}val=property.v*mult;if(expressionValue.value!==val){expressionValue=new Number(val);// eslint-disable-line no-new-wrappers
expressionValue.value=val;completeProperty(expressionValue,property,'unidimensional');}return expressionValue;};}function MultidimensionalPropertyInterface(property){if(!property||!('pv'in property)){property=defaultMultidimensionalValue;}var mult=1/property.mult;var len=property.data&&property.data.l||property.pv.length;var expressionValue=createTypedArray('float32',len);var arrValue=createTypedArray('float32',len);expressionValue.value=arrValue;completeProperty(expressionValue,property,'multidimensional');return function(){if(property.k){property.getValue();}for(var i=0;i<len;i+=1){arrValue[i]=property.v[i]*mult;expressionValue[i]=arrValue[i];}return expressionValue;};}// TODO: try to avoid using this getter
function defaultGetter(){return defaultUnidimensionalValue;}return function(property){if(!property){return defaultGetter;}if(property.propType==='unidimensional'){return UnidimensionalPropertyInterface(property);}return MultidimensionalPropertyInterface(property);};}();var TransformExpressionInterface=function(){return function(transform){function _thisFunction(name){switch(name){case'scale':case'Scale':case'ADBE Scale':case 6:return _thisFunction.scale;case'rotation':case'Rotation':case'ADBE Rotation':case'ADBE Rotate Z':case 10:return _thisFunction.rotation;case'ADBE Rotate X':return _thisFunction.xRotation;case'ADBE Rotate Y':return _thisFunction.yRotation;case'position':case'Position':case'ADBE Position':case 2:return _thisFunction.position;case'ADBE Position_0':return _thisFunction.xPosition;case'ADBE Position_1':return _thisFunction.yPosition;case'ADBE Position_2':return _thisFunction.zPosition;case'anchorPoint':case'AnchorPoint':case'Anchor Point':case'ADBE AnchorPoint':case 1:return _thisFunction.anchorPoint;case'opacity':case'Opacity':case 11:return _thisFunction.opacity;default:return null;}}Object.defineProperty(_thisFunction,'rotation',{get:ExpressionPropertyInterface(transform.r||transform.rz)});Object.defineProperty(_thisFunction,'zRotation',{get:ExpressionPropertyInterface(transform.rz||transform.r)});Object.defineProperty(_thisFunction,'xRotation',{get:ExpressionPropertyInterface(transform.rx)});Object.defineProperty(_thisFunction,'yRotation',{get:ExpressionPropertyInterface(transform.ry)});Object.defineProperty(_thisFunction,'scale',{get:ExpressionPropertyInterface(transform.s)});var _px;var _py;var _pz;var _transformFactory;if(transform.p){_transformFactory=ExpressionPropertyInterface(transform.p);}else {_px=ExpressionPropertyInterface(transform.px);_py=ExpressionPropertyInterface(transform.py);if(transform.pz){_pz=ExpressionPropertyInterface(transform.pz);}}Object.defineProperty(_thisFunction,'position',{get:function get(){if(transform.p){return _transformFactory();}return [_px(),_py(),_pz?_pz():0];}});Object.defineProperty(_thisFunction,'xPosition',{get:ExpressionPropertyInterface(transform.px)});Object.defineProperty(_thisFunction,'yPosition',{get:ExpressionPropertyInterface(transform.py)});Object.defineProperty(_thisFunction,'zPosition',{get:ExpressionPropertyInterface(transform.pz)});Object.defineProperty(_thisFunction,'anchorPoint',{get:ExpressionPropertyInterface(transform.a)});Object.defineProperty(_thisFunction,'opacity',{get:ExpressionPropertyInterface(transform.o)});Object.defineProperty(_thisFunction,'skew',{get:ExpressionPropertyInterface(transform.sk)});Object.defineProperty(_thisFunction,'skewAxis',{get:ExpressionPropertyInterface(transform.sa)});Object.defineProperty(_thisFunction,'orientation',{get:ExpressionPropertyInterface(transform.or)});return _thisFunction;};}();var LayerExpressionInterface=function(){function getMatrix(time){var toWorldMat=new Matrix();if(time!==undefined){var propMatrix=this._elem.finalTransform.mProp.getValueAtTime(time);propMatrix.clone(toWorldMat);}else {var transformMat=this._elem.finalTransform.mProp;transformMat.applyToMatrix(toWorldMat);}return toWorldMat;}function toWorldVec(arr,time){var toWorldMat=this.getMatrix(time);toWorldMat.props[12]=0;toWorldMat.props[13]=0;toWorldMat.props[14]=0;return this.applyPoint(toWorldMat,arr);}function toWorld(arr,time){var toWorldMat=this.getMatrix(time);return this.applyPoint(toWorldMat,arr);}function fromWorldVec(arr,time){var toWorldMat=this.getMatrix(time);toWorldMat.props[12]=0;toWorldMat.props[13]=0;toWorldMat.props[14]=0;return this.invertPoint(toWorldMat,arr);}function fromWorld(arr,time){var toWorldMat=this.getMatrix(time);return this.invertPoint(toWorldMat,arr);}function applyPoint(matrix,arr){if(this._elem.hierarchy&&this._elem.hierarchy.length){var i;var len=this._elem.hierarchy.length;for(i=0;i<len;i+=1){this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);}}return matrix.applyToPointArray(arr[0],arr[1],arr[2]||0);}function invertPoint(matrix,arr){if(this._elem.hierarchy&&this._elem.hierarchy.length){var i;var len=this._elem.hierarchy.length;for(i=0;i<len;i+=1){this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);}}return matrix.inversePoint(arr);}function fromComp(arr){var toWorldMat=new Matrix();toWorldMat.reset();this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);if(this._elem.hierarchy&&this._elem.hierarchy.length){var i;var len=this._elem.hierarchy.length;for(i=0;i<len;i+=1){this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);}return toWorldMat.inversePoint(arr);}return toWorldMat.inversePoint(arr);}function sampleImage(){return [1,1,1,1];}return function(elem){var transformInterface;function _registerMaskInterface(maskManager){_thisLayerFunction.mask=new MaskManagerInterface(maskManager,elem);}function _registerEffectsInterface(effects){_thisLayerFunction.effect=effects;}function _thisLayerFunction(name){switch(name){case'ADBE Root Vectors Group':case'Contents':case 2:return _thisLayerFunction.shapeInterface;case 1:case 6:case'Transform':case'transform':case'ADBE Transform Group':return transformInterface;case 4:case'ADBE Effect Parade':case'effects':case'Effects':return _thisLayerFunction.effect;case'ADBE Text Properties':return _thisLayerFunction.textInterface;default:return null;}}_thisLayerFunction.getMatrix=getMatrix;_thisLayerFunction.invertPoint=invertPoint;_thisLayerFunction.applyPoint=applyPoint;_thisLayerFunction.toWorld=toWorld;_thisLayerFunction.toWorldVec=toWorldVec;_thisLayerFunction.fromWorld=fromWorld;_thisLayerFunction.fromWorldVec=fromWorldVec;_thisLayerFunction.toComp=toWorld;_thisLayerFunction.fromComp=fromComp;_thisLayerFunction.sampleImage=sampleImage;_thisLayerFunction.sourceRectAtTime=elem.sourceRectAtTime.bind(elem);_thisLayerFunction._elem=elem;transformInterface=TransformExpressionInterface(elem.finalTransform.mProp);var anchorPointDescriptor=getDescriptor(transformInterface,'anchorPoint');Object.defineProperties(_thisLayerFunction,{hasParent:{get:function get(){return elem.hierarchy.length;}},parent:{get:function get(){return elem.hierarchy[0].layerInterface;}},rotation:getDescriptor(transformInterface,'rotation'),scale:getDescriptor(transformInterface,'scale'),position:getDescriptor(transformInterface,'position'),opacity:getDescriptor(transformInterface,'opacity'),anchorPoint:anchorPointDescriptor,anchor_point:anchorPointDescriptor,transform:{get:function get(){return transformInterface;}},active:{get:function get(){return elem.isInRange;}}});_thisLayerFunction.startTime=elem.data.st;_thisLayerFunction.index=elem.data.ind;_thisLayerFunction.source=elem.data.refId;_thisLayerFunction.height=elem.data.ty===0?elem.data.h:100;_thisLayerFunction.width=elem.data.ty===0?elem.data.w:100;_thisLayerFunction.inPoint=elem.data.ip/elem.comp.globalData.frameRate;_thisLayerFunction.outPoint=elem.data.op/elem.comp.globalData.frameRate;_thisLayerFunction._name=elem.data.nm;_thisLayerFunction.registerMaskInterface=_registerMaskInterface;_thisLayerFunction.registerEffectsInterface=_registerEffectsInterface;return _thisLayerFunction;};}();var propertyGroupFactory=function(){return function(interfaceFunction,parentPropertyGroup){return function(val){val=val===undefined?1:val;if(val<=0){return interfaceFunction;}return parentPropertyGroup(val-1);};};}();var PropertyInterface=function(){return function(propertyName,propertyGroup){var interfaceFunction={_name:propertyName};function _propertyGroup(val){val=val===undefined?1:val;if(val<=0){return interfaceFunction;}return propertyGroup(val-1);}return _propertyGroup;};}();var EffectsExpressionInterface=function(){var ob={createEffectsInterface:createEffectsInterface};function createEffectsInterface(elem,propertyGroup){if(elem.effectsManager){var effectElements=[];var effectsData=elem.data.ef;var i;var len=elem.effectsManager.effectElements.length;for(i=0;i<len;i+=1){effectElements.push(createGroupInterface(effectsData[i],elem.effectsManager.effectElements[i],propertyGroup,elem));}var effects=elem.data.ef||[];var groupInterface=function groupInterface(name){i=0;len=effects.length;while(i<len){if(name===effects[i].nm||name===effects[i].mn||name===effects[i].ix){return effectElements[i];}i+=1;}return null;};Object.defineProperty(groupInterface,'numProperties',{get:function get(){return effects.length;}});return groupInterface;}return null;}function createGroupInterface(data,elements,propertyGroup,elem){function groupInterface(name){var effects=data.ef;var i=0;var len=effects.length;while(i<len){if(name===effects[i].nm||name===effects[i].mn||name===effects[i].ix){if(effects[i].ty===5){return effectElements[i];}return effectElements[i]();}i+=1;}throw new Error();}var _propertyGroup=propertyGroupFactory(groupInterface,propertyGroup);var effectElements=[];var i;var len=data.ef.length;for(i=0;i<len;i+=1){if(data.ef[i].ty===5){effectElements.push(createGroupInterface(data.ef[i],elements.effectElements[i],elements.effectElements[i].propertyGroup,elem));}else {effectElements.push(createValueInterface(elements.effectElements[i],data.ef[i].ty,elem,_propertyGroup));}}if(data.mn==='ADBE Color Control'){Object.defineProperty(groupInterface,'color',{get:function get(){return effectElements[0]();}});}Object.defineProperties(groupInterface,{numProperties:{get:function get(){return data.np;}},_name:{value:data.nm},propertyGroup:{value:_propertyGroup}});groupInterface.enabled=data.en!==0;groupInterface.active=groupInterface.enabled;return groupInterface;}function createValueInterface(element,type,elem,propertyGroup){var expressionProperty=ExpressionPropertyInterface(element.p);function interfaceFunction(){if(type===10){return elem.comp.compInterface(element.p.v);}return expressionProperty();}if(element.p.setGroupProperty){element.p.setGroupProperty(PropertyInterface('',propertyGroup));}return interfaceFunction;}return ob;}();var ShapePathInterface=function(){return function pathInterfaceFactory(shape,view,propertyGroup){var prop=view.sh;function interfaceFunction(val){if(val==='Shape'||val==='shape'||val==='Path'||val==='path'||val==='ADBE Vector Shape'||val===2){return interfaceFunction.path;}return null;}var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);prop.setGroupProperty(PropertyInterface('Path',_propertyGroup));Object.defineProperties(interfaceFunction,{path:{get:function get(){if(prop.k){prop.getValue();}return prop;}},shape:{get:function get(){if(prop.k){prop.getValue();}return prop;}},_name:{value:shape.nm},ix:{value:shape.ix},propertyIndex:{value:shape.ix},mn:{value:shape.mn},propertyGroup:{value:propertyGroup}});return interfaceFunction;};}();var ShapeExpressionInterface=function(){function iterateElements(shapes,view,propertyGroup){var arr=[];var i;var len=shapes?shapes.length:0;for(i=0;i<len;i+=1){if(shapes[i].ty==='gr'){arr.push(groupInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='fl'){arr.push(fillInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='st'){arr.push(strokeInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='tm'){arr.push(trimInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='tr');else if(shapes[i].ty==='el'){arr.push(ellipseInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='sr'){arr.push(starInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='sh'){arr.push(ShapePathInterface(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='rc'){arr.push(rectInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='rd'){arr.push(roundedInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='rp'){arr.push(repeaterInterfaceFactory(shapes[i],view[i],propertyGroup));}else if(shapes[i].ty==='gf'){arr.push(gradientFillInterfaceFactory(shapes[i],view[i],propertyGroup));}else {arr.push(defaultInterfaceFactory(shapes[i],view[i]));}}return arr;}function contentsInterfaceFactory(shape,view,propertyGroup){var interfaces;var interfaceFunction=function _interfaceFunction(value){var i=0;var len=interfaces.length;while(i<len){if(interfaces[i]._name===value||interfaces[i].mn===value||interfaces[i].propertyIndex===value||interfaces[i].ix===value||interfaces[i].ind===value){return interfaces[i];}i+=1;}if(typeof value==='number'){return interfaces[value-1];}return null;};interfaceFunction.propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);interfaces=iterateElements(shape.it,view.it,interfaceFunction.propertyGroup);interfaceFunction.numProperties=interfaces.length;var transformInterface=transformInterfaceFactory(shape.it[shape.it.length-1],view.it[view.it.length-1],interfaceFunction.propertyGroup);interfaceFunction.transform=transformInterface;interfaceFunction.propertyIndex=shape.cix;interfaceFunction._name=shape.nm;return interfaceFunction;}function groupInterfaceFactory(shape,view,propertyGroup){var interfaceFunction=function _interfaceFunction(value){switch(value){case'ADBE Vectors Group':case'Contents':case 2:return interfaceFunction.content;// Not necessary for now. Keeping them here in case a new case appears
// case 'ADBE Vector Transform Group':
// case 3:
default:return interfaceFunction.transform;}};interfaceFunction.propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);var content=contentsInterfaceFactory(shape,view,interfaceFunction.propertyGroup);var transformInterface=transformInterfaceFactory(shape.it[shape.it.length-1],view.it[view.it.length-1],interfaceFunction.propertyGroup);interfaceFunction.content=content;interfaceFunction.transform=transformInterface;Object.defineProperty(interfaceFunction,'_name',{get:function get(){return shape.nm;}});// interfaceFunction.content = interfaceFunction;
interfaceFunction.numProperties=shape.np;interfaceFunction.propertyIndex=shape.ix;interfaceFunction.nm=shape.nm;interfaceFunction.mn=shape.mn;return interfaceFunction;}function fillInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(val){if(val==='Color'||val==='color'){return interfaceFunction.color;}if(val==='Opacity'||val==='opacity'){return interfaceFunction.opacity;}return null;}Object.defineProperties(interfaceFunction,{color:{get:ExpressionPropertyInterface(view.c)},opacity:{get:ExpressionPropertyInterface(view.o)},_name:{value:shape.nm},mn:{value:shape.mn}});view.c.setGroupProperty(PropertyInterface('Color',propertyGroup));view.o.setGroupProperty(PropertyInterface('Opacity',propertyGroup));return interfaceFunction;}function gradientFillInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(val){if(val==='Start Point'||val==='start point'){return interfaceFunction.startPoint;}if(val==='End Point'||val==='end point'){return interfaceFunction.endPoint;}if(val==='Opacity'||val==='opacity'){return interfaceFunction.opacity;}return null;}Object.defineProperties(interfaceFunction,{startPoint:{get:ExpressionPropertyInterface(view.s)},endPoint:{get:ExpressionPropertyInterface(view.e)},opacity:{get:ExpressionPropertyInterface(view.o)},type:{get:function get(){return 'a';}},_name:{value:shape.nm},mn:{value:shape.mn}});view.s.setGroupProperty(PropertyInterface('Start Point',propertyGroup));view.e.setGroupProperty(PropertyInterface('End Point',propertyGroup));view.o.setGroupProperty(PropertyInterface('Opacity',propertyGroup));return interfaceFunction;}function defaultInterfaceFactory(){function interfaceFunction(){return null;}return interfaceFunction;}function strokeInterfaceFactory(shape,view,propertyGroup){var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);var _dashPropertyGroup=propertyGroupFactory(dashOb,_propertyGroup);function addPropertyToDashOb(i){Object.defineProperty(dashOb,shape.d[i].nm,{get:ExpressionPropertyInterface(view.d.dataProps[i].p)});}var i;var len=shape.d?shape.d.length:0;var dashOb={};for(i=0;i<len;i+=1){addPropertyToDashOb(i);view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);}function interfaceFunction(val){if(val==='Color'||val==='color'){return interfaceFunction.color;}if(val==='Opacity'||val==='opacity'){return interfaceFunction.opacity;}if(val==='Stroke Width'||val==='stroke width'){return interfaceFunction.strokeWidth;}return null;}Object.defineProperties(interfaceFunction,{color:{get:ExpressionPropertyInterface(view.c)},opacity:{get:ExpressionPropertyInterface(view.o)},strokeWidth:{get:ExpressionPropertyInterface(view.w)},dash:{get:function get(){return dashOb;}},_name:{value:shape.nm},mn:{value:shape.mn}});view.c.setGroupProperty(PropertyInterface('Color',_propertyGroup));view.o.setGroupProperty(PropertyInterface('Opacity',_propertyGroup));view.w.setGroupProperty(PropertyInterface('Stroke Width',_propertyGroup));return interfaceFunction;}function trimInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(val){if(val===shape.e.ix||val==='End'||val==='end'){return interfaceFunction.end;}if(val===shape.s.ix){return interfaceFunction.start;}if(val===shape.o.ix){return interfaceFunction.offset;}return null;}var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);interfaceFunction.propertyIndex=shape.ix;view.s.setGroupProperty(PropertyInterface('Start',_propertyGroup));view.e.setGroupProperty(PropertyInterface('End',_propertyGroup));view.o.setGroupProperty(PropertyInterface('Offset',_propertyGroup));interfaceFunction.propertyIndex=shape.ix;interfaceFunction.propertyGroup=propertyGroup;Object.defineProperties(interfaceFunction,{start:{get:ExpressionPropertyInterface(view.s)},end:{get:ExpressionPropertyInterface(view.e)},offset:{get:ExpressionPropertyInterface(view.o)},_name:{value:shape.nm}});interfaceFunction.mn=shape.mn;return interfaceFunction;}function transformInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(value){if(shape.a.ix===value||value==='Anchor Point'){return interfaceFunction.anchorPoint;}if(shape.o.ix===value||value==='Opacity'){return interfaceFunction.opacity;}if(shape.p.ix===value||value==='Position'){return interfaceFunction.position;}if(shape.r.ix===value||value==='Rotation'||value==='ADBE Vector Rotation'){return interfaceFunction.rotation;}if(shape.s.ix===value||value==='Scale'){return interfaceFunction.scale;}if(shape.sk&&shape.sk.ix===value||value==='Skew'){return interfaceFunction.skew;}if(shape.sa&&shape.sa.ix===value||value==='Skew Axis'){return interfaceFunction.skewAxis;}return null;}var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity',_propertyGroup));view.transform.mProps.p.setGroupProperty(PropertyInterface('Position',_propertyGroup));view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point',_propertyGroup));view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale',_propertyGroup));view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation',_propertyGroup));if(view.transform.mProps.sk){view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew',_propertyGroup));view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle',_propertyGroup));}view.transform.op.setGroupProperty(PropertyInterface('Opacity',_propertyGroup));Object.defineProperties(interfaceFunction,{opacity:{get:ExpressionPropertyInterface(view.transform.mProps.o)},position:{get:ExpressionPropertyInterface(view.transform.mProps.p)},anchorPoint:{get:ExpressionPropertyInterface(view.transform.mProps.a)},scale:{get:ExpressionPropertyInterface(view.transform.mProps.s)},rotation:{get:ExpressionPropertyInterface(view.transform.mProps.r)},skew:{get:ExpressionPropertyInterface(view.transform.mProps.sk)},skewAxis:{get:ExpressionPropertyInterface(view.transform.mProps.sa)},_name:{value:shape.nm}});interfaceFunction.ty='tr';interfaceFunction.mn=shape.mn;interfaceFunction.propertyGroup=propertyGroup;return interfaceFunction;}function ellipseInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(value){if(shape.p.ix===value){return interfaceFunction.position;}if(shape.s.ix===value){return interfaceFunction.size;}return null;}var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);interfaceFunction.propertyIndex=shape.ix;var prop=view.sh.ty==='tm'?view.sh.prop:view.sh;prop.s.setGroupProperty(PropertyInterface('Size',_propertyGroup));prop.p.setGroupProperty(PropertyInterface('Position',_propertyGroup));Object.defineProperties(interfaceFunction,{size:{get:ExpressionPropertyInterface(prop.s)},position:{get:ExpressionPropertyInterface(prop.p)},_name:{value:shape.nm}});interfaceFunction.mn=shape.mn;return interfaceFunction;}function starInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(value){if(shape.p.ix===value){return interfaceFunction.position;}if(shape.r.ix===value){return interfaceFunction.rotation;}if(shape.pt.ix===value){return interfaceFunction.points;}if(shape.or.ix===value||value==='ADBE Vector Star Outer Radius'){return interfaceFunction.outerRadius;}if(shape.os.ix===value){return interfaceFunction.outerRoundness;}if(shape.ir&&(shape.ir.ix===value||value==='ADBE Vector Star Inner Radius')){return interfaceFunction.innerRadius;}if(shape.is&&shape.is.ix===value){return interfaceFunction.innerRoundness;}return null;}var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);var prop=view.sh.ty==='tm'?view.sh.prop:view.sh;interfaceFunction.propertyIndex=shape.ix;prop.or.setGroupProperty(PropertyInterface('Outer Radius',_propertyGroup));prop.os.setGroupProperty(PropertyInterface('Outer Roundness',_propertyGroup));prop.pt.setGroupProperty(PropertyInterface('Points',_propertyGroup));prop.p.setGroupProperty(PropertyInterface('Position',_propertyGroup));prop.r.setGroupProperty(PropertyInterface('Rotation',_propertyGroup));if(shape.ir){prop.ir.setGroupProperty(PropertyInterface('Inner Radius',_propertyGroup));prop.is.setGroupProperty(PropertyInterface('Inner Roundness',_propertyGroup));}Object.defineProperties(interfaceFunction,{position:{get:ExpressionPropertyInterface(prop.p)},rotation:{get:ExpressionPropertyInterface(prop.r)},points:{get:ExpressionPropertyInterface(prop.pt)},outerRadius:{get:ExpressionPropertyInterface(prop.or)},outerRoundness:{get:ExpressionPropertyInterface(prop.os)},innerRadius:{get:ExpressionPropertyInterface(prop.ir)},innerRoundness:{get:ExpressionPropertyInterface(prop.is)},_name:{value:shape.nm}});interfaceFunction.mn=shape.mn;return interfaceFunction;}function rectInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(value){if(shape.p.ix===value){return interfaceFunction.position;}if(shape.r.ix===value){return interfaceFunction.roundness;}if(shape.s.ix===value||value==='Size'||value==='ADBE Vector Rect Size'){return interfaceFunction.size;}return null;}var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);var prop=view.sh.ty==='tm'?view.sh.prop:view.sh;interfaceFunction.propertyIndex=shape.ix;prop.p.setGroupProperty(PropertyInterface('Position',_propertyGroup));prop.s.setGroupProperty(PropertyInterface('Size',_propertyGroup));prop.r.setGroupProperty(PropertyInterface('Rotation',_propertyGroup));Object.defineProperties(interfaceFunction,{position:{get:ExpressionPropertyInterface(prop.p)},roundness:{get:ExpressionPropertyInterface(prop.r)},size:{get:ExpressionPropertyInterface(prop.s)},_name:{value:shape.nm}});interfaceFunction.mn=shape.mn;return interfaceFunction;}function roundedInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(value){if(shape.r.ix===value||value==='Round Corners 1'){return interfaceFunction.radius;}return null;}var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);var prop=view;interfaceFunction.propertyIndex=shape.ix;prop.rd.setGroupProperty(PropertyInterface('Radius',_propertyGroup));Object.defineProperties(interfaceFunction,{radius:{get:ExpressionPropertyInterface(prop.rd)},_name:{value:shape.nm}});interfaceFunction.mn=shape.mn;return interfaceFunction;}function repeaterInterfaceFactory(shape,view,propertyGroup){function interfaceFunction(value){if(shape.c.ix===value||value==='Copies'){return interfaceFunction.copies;}if(shape.o.ix===value||value==='Offset'){return interfaceFunction.offset;}return null;}var _propertyGroup=propertyGroupFactory(interfaceFunction,propertyGroup);var prop=view;interfaceFunction.propertyIndex=shape.ix;prop.c.setGroupProperty(PropertyInterface('Copies',_propertyGroup));prop.o.setGroupProperty(PropertyInterface('Offset',_propertyGroup));Object.defineProperties(interfaceFunction,{copies:{get:ExpressionPropertyInterface(prop.c)},offset:{get:ExpressionPropertyInterface(prop.o)},_name:{value:shape.nm}});interfaceFunction.mn=shape.mn;return interfaceFunction;}return function(shapes,view,propertyGroup){var interfaces;function _interfaceFunction(value){if(typeof value==='number'){value=value===undefined?1:value;if(value===0){return propertyGroup;}return interfaces[value-1];}var i=0;var len=interfaces.length;while(i<len){if(interfaces[i]._name===value){return interfaces[i];}i+=1;}return null;}function parentGroupWrapper(){return propertyGroup;}_interfaceFunction.propertyGroup=propertyGroupFactory(_interfaceFunction,parentGroupWrapper);interfaces=iterateElements(shapes,view,_interfaceFunction.propertyGroup);_interfaceFunction.numProperties=interfaces.length;_interfaceFunction._name='Contents';return _interfaceFunction;};}();var TextExpressionInterface=function(){return function(elem){var _sourceText;function _thisLayerFunction(name){switch(name){case'ADBE Text Document':return _thisLayerFunction.sourceText;default:return null;}}Object.defineProperty(_thisLayerFunction,'sourceText',{get:function get(){elem.textProperty.getValue();var stringValue=elem.textProperty.currentData.t;if(!_sourceText||stringValue!==_sourceText.value){_sourceText=new String(stringValue);// eslint-disable-line no-new-wrappers
// If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive
_sourceText.value=stringValue||new String(stringValue);// eslint-disable-line no-new-wrappers
Object.defineProperty(_sourceText,'style',{get:function get(){return {fillColor:elem.textProperty.currentData.fc};}});}return _sourceText;}});return _thisLayerFunction;};}();function _typeof(obj){"@babel/helpers - typeof";if(typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"){_typeof=function _typeof(obj){return typeof obj;};}else {_typeof=function _typeof(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};}return _typeof(obj);}var FootageInterface=function(){var outlineInterfaceFactory=function outlineInterfaceFactory(elem){var currentPropertyName='';var currentProperty=elem.getFootageData();function init(){currentPropertyName='';currentProperty=elem.getFootageData();return searchProperty;}function searchProperty(value){if(currentProperty[value]){currentPropertyName=value;currentProperty=currentProperty[value];if(_typeof(currentProperty)==='object'){return searchProperty;}return currentProperty;}var propertyNameIndex=value.indexOf(currentPropertyName);if(propertyNameIndex!==-1){var index=parseInt(value.substr(propertyNameIndex+currentPropertyName.length),10);currentProperty=currentProperty[index];if(_typeof(currentProperty)==='object'){return searchProperty;}return currentProperty;}return '';}return init;};var dataInterfaceFactory=function dataInterfaceFactory(elem){function interfaceFunction(value){if(value==='Outline'){return interfaceFunction.outlineInterface();}return null;}interfaceFunction._name='Outline';interfaceFunction.outlineInterface=outlineInterfaceFactory(elem);return interfaceFunction;};return function(elem){function _interfaceFunction(value){if(value==='Data'){return _interfaceFunction.dataInterface;}return null;}_interfaceFunction._name='Data';_interfaceFunction.dataInterface=dataInterfaceFactory(elem);return _interfaceFunction;};}();var interfaces={layer:LayerExpressionInterface,effects:EffectsExpressionInterface,comp:CompExpressionInterface,shape:ShapeExpressionInterface,text:TextExpressionInterface,footage:FootageInterface};function getInterface(type){return interfaces[type]||null;}var expressionHelpers=function(){function searchExpressions(elem,data,prop){if(data.x){prop.k=true;prop.x=true;prop.initiateExpression=ExpressionManager.initiateExpression;prop.effectsSequence.push(prop.initiateExpression(elem,data,prop).bind(prop));}}function getValueAtTime(frameNum){frameNum*=this.elem.globalData.frameRate;frameNum-=this.offsetTime;if(frameNum!==this._cachingAtTime.lastFrame){this._cachingAtTime.lastIndex=this._cachingAtTime.lastFrame<frameNum?this._cachingAtTime.lastIndex:0;this._cachingAtTime.value=this.interpolateValue(frameNum,this._cachingAtTime);this._cachingAtTime.lastFrame=frameNum;}return this._cachingAtTime.value;}function getSpeedAtTime(frameNum){var delta=-0.01;var v1=this.getValueAtTime(frameNum);var v2=this.getValueAtTime(frameNum+delta);var speed=0;if(v1.length){var i;for(i=0;i<v1.length;i+=1){speed+=Math.pow(v2[i]-v1[i],2);}speed=Math.sqrt(speed)*100;}else {speed=0;}return speed;}function getVelocityAtTime(frameNum){if(this.vel!==undefined){return this.vel;}var delta=-0.001;// frameNum += this.elem.data.st;
var v1=this.getValueAtTime(frameNum);var v2=this.getValueAtTime(frameNum+delta);var velocity;if(v1.length){velocity=createTypedArray('float32',v1.length);var i;for(i=0;i<v1.length;i+=1){// removing frameRate
// if needed, don't add it here
// velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);
velocity[i]=(v2[i]-v1[i])/delta;}}else {velocity=(v2-v1)/delta;}return velocity;}function getStaticValueAtTime(){return this.pv;}function setGroupProperty(propertyGroup){this.propertyGroup=propertyGroup;}return {searchExpressions:searchExpressions,getSpeedAtTime:getSpeedAtTime,getVelocityAtTime:getVelocityAtTime,getValueAtTime:getValueAtTime,getStaticValueAtTime:getStaticValueAtTime,setGroupProperty:setGroupProperty};}();function addPropertyDecorator(){function loopOut(type,duration,durationFlag){if(!this.k||!this.keyframes){return this.pv;}type=type?type.toLowerCase():'';var currentFrame=this.comp.renderedFrame;var keyframes=this.keyframes;var lastKeyFrame=keyframes[keyframes.length-1].t;if(currentFrame<=lastKeyFrame){return this.pv;}var cycleDuration;var firstKeyFrame;if(!durationFlag){if(!duration||duration>keyframes.length-1){duration=keyframes.length-1;}firstKeyFrame=keyframes[keyframes.length-1-duration].t;cycleDuration=lastKeyFrame-firstKeyFrame;}else {if(!duration){cycleDuration=Math.max(0,lastKeyFrame-this.elem.data.ip);}else {cycleDuration=Math.abs(lastKeyFrame-this.elem.comp.globalData.frameRate*duration);}firstKeyFrame=lastKeyFrame-cycleDuration;}var i;var len;var ret;if(type==='pingpong'){var iterations=Math.floor((currentFrame-firstKeyFrame)/cycleDuration);if(iterations%2!==0){return this.getValueAtTime((cycleDuration-(currentFrame-firstKeyFrame)%cycleDuration+firstKeyFrame)/this.comp.globalData.frameRate,0);// eslint-disable-line
}}else if(type==='offset'){var initV=this.getValueAtTime(firstKeyFrame/this.comp.globalData.frameRate,0);var endV=this.getValueAtTime(lastKeyFrame/this.comp.globalData.frameRate,0);var current=this.getValueAtTime(((currentFrame-firstKeyFrame)%cycleDuration+firstKeyFrame)/this.comp.globalData.frameRate,0);// eslint-disable-line
var repeats=Math.floor((currentFrame-firstKeyFrame)/cycleDuration);if(this.pv.length){ret=new Array(initV.length);len=ret.length;for(i=0;i<len;i+=1){ret[i]=(endV[i]-initV[i])*repeats+current[i];}return ret;}return (endV-initV)*repeats+current;}else if(type==='continue'){var lastValue=this.getValueAtTime(lastKeyFrame/this.comp.globalData.frameRate,0);var nextLastValue=this.getValueAtTime((lastKeyFrame-0.001)/this.comp.globalData.frameRate,0);if(this.pv.length){ret=new Array(lastValue.length);len=ret.length;for(i=0;i<len;i+=1){ret[i]=lastValue[i]+(lastValue[i]-nextLastValue[i])*((currentFrame-lastKeyFrame)/this.comp.globalData.frameRate)/0.0005;// eslint-disable-line
}return ret;}return lastValue+(lastValue-nextLastValue)*((currentFrame-lastKeyFrame)/0.001);}return this.getValueAtTime(((currentFrame-firstKeyFrame)%cycleDuration+firstKeyFrame)/this.comp.globalData.frameRate,0);// eslint-disable-line
}function loopIn(type,duration,durationFlag){if(!this.k){return this.pv;}type=type?type.toLowerCase():'';var currentFrame=this.comp.renderedFrame;var keyframes=this.keyframes;var firstKeyFrame=keyframes[0].t;if(currentFrame>=firstKeyFrame){return this.pv;}var cycleDuration;var lastKeyFrame;if(!durationFlag){if(!duration||duration>keyframes.length-1){duration=keyframes.length-1;}lastKeyFrame=keyframes[duration].t;cycleDuration=lastKeyFrame-firstKeyFrame;}else {if(!duration){cycleDuration=Math.max(0,this.elem.data.op-firstKeyFrame);}else {cycleDuration=Math.abs(this.elem.comp.globalData.frameRate*duration);}lastKeyFrame=firstKeyFrame+cycleDuration;}var i;var len;var ret;if(type==='pingpong'){var iterations=Math.floor((firstKeyFrame-currentFrame)/cycleDuration);if(iterations%2===0){return this.getValueAtTime(((firstKeyFrame-currentFrame)%cycleDuration+firstKeyFrame)/this.comp.globalData.frameRate,0);// eslint-disable-line
}}else if(type==='offset'){var initV=this.getValueAtTime(firstKeyFrame/this.comp.globalData.frameRate,0);var endV=this.getValueAtTime(lastKeyFrame/this.comp.globalData.frameRate,0);var current=this.getValueAtTime((cycleDuration-(firstKeyFrame-currentFrame)%cycleDuration+firstKeyFrame)/this.comp.globalData.frameRate,0);var repeats=Math.floor((firstKeyFrame-currentFrame)/cycleDuration)+1;if(this.pv.length){ret=new Array(initV.length);len=ret.length;for(i=0;i<len;i+=1){ret[i]=current[i]-(endV[i]-initV[i])*repeats;}return ret;}return current-(endV-initV)*repeats;}else if(type==='continue'){var firstValue=this.getValueAtTime(firstKeyFrame/this.comp.globalData.frameRate,0);var nextFirstValue=this.getValueAtTime((firstKeyFrame+0.001)/this.comp.globalData.frameRate,0);if(this.pv.length){ret=new Array(firstValue.length);len=ret.length;for(i=0;i<len;i+=1){ret[i]=firstValue[i]+(firstValue[i]-nextFirstValue[i])*(firstKeyFrame-currentFrame)/0.001;}return ret;}return firstValue+(firstValue-nextFirstValue)*(firstKeyFrame-currentFrame)/0.001;}return this.getValueAtTime((cycleDuration-((firstKeyFrame-currentFrame)%cycleDuration+firstKeyFrame))/this.comp.globalData.frameRate,0);// eslint-disable-line
}function smooth(width,samples){if(!this.k){return this.pv;}width=(width||0.4)*0.5;samples=Math.floor(samples||5);if(samples<=1){return this.pv;}var currentTime=this.comp.renderedFrame/this.comp.globalData.frameRate;var initFrame=currentTime-width;var endFrame=currentTime+width;var sampleFrequency=samples>1?(endFrame-initFrame)/(samples-1):1;var i=0;var j=0;var value;if(this.pv.length){value=createTypedArray('float32',this.pv.length);}else {value=0;}var sampleValue;while(i<samples){sampleValue=this.getValueAtTime(initFrame+i*sampleFrequency);if(this.pv.length){for(j=0;j<this.pv.length;j+=1){value[j]+=sampleValue[j];}}else {value+=sampleValue;}i+=1;}if(this.pv.length){for(j=0;j<this.pv.length;j+=1){value[j]/=samples;}}else {value/=samples;}return value;}function getTransformValueAtTime(time){if(!this._transformCachingAtTime){this._transformCachingAtTime={v:new Matrix()};}/// /
var matrix=this._transformCachingAtTime.v;matrix.cloneFromProps(this.pre.props);if(this.appliedTransformations<1){var anchor=this.a.getValueAtTime(time);matrix.translate(-anchor[0]*this.a.mult,-anchor[1]*this.a.mult,anchor[2]*this.a.mult);}if(this.appliedTransformations<2){var scale=this.s.getValueAtTime(time);matrix.scale(scale[0]*this.s.mult,scale[1]*this.s.mult,scale[2]*this.s.mult);}if(this.sk&&this.appliedTransformations<3){var skew=this.sk.getValueAtTime(time);var skewAxis=this.sa.getValueAtTime(time);matrix.skewFromAxis(-skew*this.sk.mult,skewAxis*this.sa.mult);}if(this.r&&this.appliedTransformations<4){var rotation=this.r.getValueAtTime(time);matrix.rotate(-rotation*this.r.mult);}else if(!this.r&&this.appliedTransformations<4){var rotationZ=this.rz.getValueAtTime(time);var rotationY=this.ry.getValueAtTime(time);var rotationX=this.rx.getValueAtTime(time);var orientation=this.or.getValueAtTime(time);matrix.rotateZ(-rotationZ*this.rz.mult).rotateY(rotationY*this.ry.mult).rotateX(rotationX*this.rx.mult).rotateZ(-orientation[2]*this.or.mult).rotateY(orientation[1]*this.or.mult).rotateX(orientation[0]*this.or.mult);}if(this.data.p&&this.data.p.s){var positionX=this.px.getValueAtTime(time);var positionY=this.py.getValueAtTime(time);if(this.data.p.z){var positionZ=this.pz.getValueAtTime(time);matrix.translate(positionX*this.px.mult,positionY*this.py.mult,-positionZ*this.pz.mult);}else {matrix.translate(positionX*this.px.mult,positionY*this.py.mult,0);}}else {var position=this.p.getValueAtTime(time);matrix.translate(position[0]*this.p.mult,position[1]*this.p.mult,-position[2]*this.p.mult);}return matrix;/// /
}function getTransformStaticValueAtTime(){return this.v.clone(new Matrix());}var getTransformProperty=TransformPropertyFactory.getTransformProperty;TransformPropertyFactory.getTransformProperty=function(elem,data,container){var prop=getTransformProperty(elem,data,container);if(prop.dynamicProperties.length){prop.getValueAtTime=getTransformValueAtTime.bind(prop);}else {prop.getValueAtTime=getTransformStaticValueAtTime.bind(prop);}prop.setGroupProperty=expressionHelpers.setGroupProperty;return prop;};var propertyGetProp=PropertyFactory.getProp;PropertyFactory.getProp=function(elem,data,type,mult,container){var prop=propertyGetProp(elem,data,type,mult,container);// prop.getVelocityAtTime = getVelocityAtTime;
// prop.loopOut = loopOut;
// prop.loopIn = loopIn;
if(prop.kf){prop.getValueAtTime=expressionHelpers.getValueAtTime.bind(prop);}else {prop.getValueAtTime=expressionHelpers.getStaticValueAtTime.bind(prop);}prop.setGroupProperty=expressionHelpers.setGroupProperty;prop.loopOut=loopOut;prop.loopIn=loopIn;prop.smooth=smooth;prop.getVelocityAtTime=expressionHelpers.getVelocityAtTime.bind(prop);prop.getSpeedAtTime=expressionHelpers.getSpeedAtTime.bind(prop);prop.numKeys=data.a===1?data.k.length:0;prop.propertyIndex=data.ix;var value=0;if(type!==0){value=createTypedArray('float32',data.a===1?data.k[0].s.length:data.k.length);}prop._cachingAtTime={lastFrame:initialDefaultFrame,lastIndex:0,value:value};expressionHelpers.searchExpressions(elem,data,prop);if(prop.k){container.addDynamicProperty(prop);}return prop;};function getShapeValueAtTime(frameNum){// For now this caching object is created only when needed instead of creating it when the shape is initialized.
if(!this._cachingAtTime){this._cachingAtTime={shapeValue:shapePool.clone(this.pv),lastIndex:0,lastTime:initialDefaultFrame};}frameNum*=this.elem.globalData.frameRate;frameNum-=this.offsetTime;if(frameNum!==this._cachingAtTime.lastTime){this._cachingAtTime.lastIndex=this._cachingAtTime.lastTime<frameNum?this._caching.lastIndex:0;this._cachingAtTime.lastTime=frameNum;this.interpolateShape(frameNum,this._cachingAtTime.shapeValue,this._cachingAtTime);}return this._cachingAtTime.shapeValue;}var ShapePropertyConstructorFunction=ShapePropertyFactory.getConstructorFunction();var KeyframedShapePropertyConstructorFunction=ShapePropertyFactory.getKeyframedConstructorFunction();function ShapeExpressions(){}ShapeExpressions.prototype={vertices:function vertices(prop,time){if(this.k){this.getValue();}var shapePath=this.v;if(time!==undefined){shapePath=this.getValueAtTime(time,0);}var i;var len=shapePath._length;var vertices=shapePath[prop];var points=shapePath.v;var arr=createSizedArray(len);for(i=0;i<len;i+=1){if(prop==='i'||prop==='o'){arr[i]=[vertices[i][0]-points[i][0],vertices[i][1]-points[i][1]];}else {arr[i]=[vertices[i][0],vertices[i][1]];}}return arr;},points:function points(time){return this.vertices('v',time);},inTangents:function inTangents(time){return this.vertices('i',time);},outTangents:function outTangents(time){return this.vertices('o',time);},isClosed:function isClosed(){return this.v.c;},pointOnPath:function pointOnPath(perc,time){var shapePath=this.v;if(time!==undefined){shapePath=this.getValueAtTime(time,0);}if(!this._segmentsLength){this._segmentsLength=bez.getSegmentsLength(shapePath);}var segmentsLength=this._segmentsLength;var lengths=segmentsLength.lengths;var lengthPos=segmentsLength.totalLength*perc;var i=0;var len=lengths.length;var accumulatedLength=0;var pt;while(i<len){if(accumulatedLength+lengths[i].addedLength>lengthPos){var initIndex=i;var endIndex=shapePath.c&&i===len-1?0:i+1;var segmentPerc=(lengthPos-accumulatedLength)/lengths[i].addedLength;pt=bez.getPointInSegment(shapePath.v[initIndex],shapePath.v[endIndex],shapePath.o[initIndex],shapePath.i[endIndex],segmentPerc,lengths[i]);break;}else {accumulatedLength+=lengths[i].addedLength;}i+=1;}if(!pt){pt=shapePath.c?[shapePath.v[0][0],shapePath.v[0][1]]:[shapePath.v[shapePath._length-1][0],shapePath.v[shapePath._length-1][1]];}return pt;},vectorOnPath:function vectorOnPath(perc,time,vectorType){// perc doesn't use triple equality because it can be a Number object as well as a primitive.
if(perc==1){// eslint-disable-line eqeqeq
perc=this.v.c;}else if(perc==0){// eslint-disable-line eqeqeq
perc=0.999;}var pt1=this.pointOnPath(perc,time);var pt2=this.pointOnPath(perc+0.001,time);var xLength=pt2[0]-pt1[0];var yLength=pt2[1]-pt1[1];var magnitude=Math.sqrt(Math.pow(xLength,2)+Math.pow(yLength,2));if(magnitude===0){return [0,0];}var unitVector=vectorType==='tangent'?[xLength/magnitude,yLength/magnitude]:[-yLength/magnitude,xLength/magnitude];return unitVector;},tangentOnPath:function tangentOnPath(perc,time){return this.vectorOnPath(perc,time,'tangent');},normalOnPath:function normalOnPath(perc,time){return this.vectorOnPath(perc,time,'normal');},setGroupProperty:expressionHelpers.setGroupProperty,getValueAtTime:expressionHelpers.getStaticValueAtTime};extendPrototype([ShapeExpressions],ShapePropertyConstructorFunction);extendPrototype([ShapeExpressions],KeyframedShapePropertyConstructorFunction);KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime=getShapeValueAtTime;KeyframedShapePropertyConstructorFunction.prototype.initiateExpression=ExpressionManager.initiateExpression;var propertyGetShapeProp=ShapePropertyFactory.getShapeProp;ShapePropertyFactory.getShapeProp=function(elem,data,type,arr,trims){var prop=propertyGetShapeProp(elem,data,type,arr,trims);prop.propertyIndex=data.ix;prop.lock=false;if(type===3){expressionHelpers.searchExpressions(elem,data.pt,prop);}else if(type===4){expressionHelpers.searchExpressions(elem,data.ks,prop);}if(prop.k){elem.addDynamicProperty(prop);}return prop;};}function initialize$1(){addPropertyDecorator();}function addDecorator(){function searchExpressions(){if(this.data.d.x){this.calculateExpression=ExpressionManager.initiateExpression.bind(this)(this.elem,this.data.d,this);this.addEffect(this.getExpressionValue.bind(this));return true;}return null;}TextProperty.prototype.getExpressionValue=function(currentValue,text){var newValue=this.calculateExpression(text);if(currentValue.t!==newValue){var newData={};this.copyData(newData,currentValue);newData.t=newValue.toString();newData.__complete=false;return newData;}return currentValue;};TextProperty.prototype.searchProperty=function(){var isKeyframed=this.searchKeyframes();var hasExpressions=this.searchExpressions();this.kf=isKeyframed||hasExpressions;return this.kf;};TextProperty.prototype.searchExpressions=searchExpressions;}function initialize(){addDecorator();}function SVGComposableEffect(){}SVGComposableEffect.prototype={createMergeNode:function createMergeNode(resultId,ins){var feMerge=createNS('feMerge');feMerge.setAttribute('result',resultId);var feMergeNode;var i;for(i=0;i<ins.length;i+=1){feMergeNode=createNS('feMergeNode');feMergeNode.setAttribute('in',ins[i]);feMerge.appendChild(feMergeNode);feMerge.appendChild(feMergeNode);}return feMerge;}};var linearFilterValue='0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';function SVGTintFilter(filter,filterManager,elem,id,source){this.filterManager=filterManager;var feColorMatrix=createNS('feColorMatrix');feColorMatrix.setAttribute('type','matrix');feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');feColorMatrix.setAttribute('values',linearFilterValue+' 1 0');this.linearFilter=feColorMatrix;feColorMatrix.setAttribute('result',id+'_tint_1');filter.appendChild(feColorMatrix);feColorMatrix=createNS('feColorMatrix');feColorMatrix.setAttribute('type','matrix');feColorMatrix.setAttribute('color-interpolation-filters','sRGB');feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');feColorMatrix.setAttribute('result',id+'_tint_2');filter.appendChild(feColorMatrix);this.matrixFilter=feColorMatrix;var feMerge=this.createMergeNode(id,[source,id+'_tint_1',id+'_tint_2']);filter.appendChild(feMerge);}extendPrototype([SVGComposableEffect],SVGTintFilter);SVGTintFilter.prototype.renderFrame=function(forceRender){if(forceRender||this.filterManager._mdf){var colorBlack=this.filterManager.effectElements[0].p.v;var colorWhite=this.filterManager.effectElements[1].p.v;var opacity=this.filterManager.effectElements[2].p.v/100;this.linearFilter.setAttribute('values',linearFilterValue+' '+opacity+' 0');this.matrixFilter.setAttribute('values',colorWhite[0]-colorBlack[0]+' 0 0 0 '+colorBlack[0]+' '+(colorWhite[1]-colorBlack[1])+' 0 0 0 '+colorBlack[1]+' '+(colorWhite[2]-colorBlack[2])+' 0 0 0 '+colorBlack[2]+' 0 0 0 1 0');}};function SVGFillFilter(filter,filterManager,elem,id){this.filterManager=filterManager;var feColorMatrix=createNS('feColorMatrix');feColorMatrix.setAttribute('type','matrix');feColorMatrix.setAttribute('color-interpolation-filters','sRGB');feColorMatrix.setAttribute('values','1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');feColorMatrix.setAttribute('result',id);filter.appendChild(feColorMatrix);this.matrixFilter=feColorMatrix;}SVGFillFilter.prototype.renderFrame=function(forceRender){if(forceRender||this.filterManager._mdf){var color=this.filterManager.effectElements[2].p.v;var opacity=this.filterManager.effectElements[6].p.v;this.matrixFilter.setAttribute('values','0 0 0 0 '+color[0]+' 0 0 0 0 '+color[1]+' 0 0 0 0 '+color[2]+' 0 0 0 '+opacity+' 0');}};function SVGStrokeEffect(fil,filterManager,elem){this.initialized=false;this.filterManager=filterManager;this.elem=elem;this.paths=[];}SVGStrokeEffect.prototype.initialize=function(){var elemChildren=this.elem.layerElement.children||this.elem.layerElement.childNodes;var path;var groupPath;var i;var len;if(this.filterManager.effectElements[1].p.v===1){len=this.elem.maskManager.masksProperties.length;i=0;}else {i=this.filterManager.effectElements[0].p.v-1;len=i+1;}groupPath=createNS('g');groupPath.setAttribute('fill','none');groupPath.setAttribute('stroke-linecap','round');groupPath.setAttribute('stroke-dashoffset',1);for(i;i<len;i+=1){path=createNS('path');groupPath.appendChild(path);this.paths.push({p:path,m:i});}if(this.filterManager.effectElements[10].p.v===3){var mask=createNS('mask');var id=createElementID();mask.setAttribute('id',id);mask.setAttribute('mask-type','alpha');mask.appendChild(groupPath);this.elem.globalData.defs.appendChild(mask);var g=createNS('g');g.setAttribute('mask','url('+getLocationHref()+'#'+id+')');while(elemChildren[0]){g.appendChild(elemChildren[0]);}this.elem.layerElement.appendChild(g);this.masker=mask;groupPath.setAttribute('stroke','#fff');}else if(this.filterManager.effectElements[10].p.v===1||this.filterManager.effectElements[10].p.v===2){if(this.filterManager.effectElements[10].p.v===2){elemChildren=this.elem.layerElement.children||this.elem.layerElement.childNodes;while(elemChildren.length){this.elem.layerElement.removeChild(elemChildren[0]);}}this.elem.layerElement.appendChild(groupPath);this.elem.layerElement.removeAttribute('mask');groupPath.setAttribute('stroke','#fff');}this.initialized=true;this.pathMasker=groupPath;};SVGStrokeEffect.prototype.renderFrame=function(forceRender){if(!this.initialized){this.initialize();}var i;var len=this.paths.length;var mask;var path;for(i=0;i<len;i+=1){if(this.paths[i].m!==-1){mask=this.elem.maskManager.viewData[this.paths[i].m];path=this.paths[i].p;if(forceRender||this.filterManager._mdf||mask.prop._mdf){path.setAttribute('d',mask.lastPath);}if(forceRender||this.filterManager.effectElements[9].p._mdf||this.filterManager.effectElements[4].p._mdf||this.filterManager.effectElements[7].p._mdf||this.filterManager.effectElements[8].p._mdf||mask.prop._mdf){var dasharrayValue;if(this.filterManager.effectElements[7].p.v!==0||this.filterManager.effectElements[8].p.v!==100){var s=Math.min(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)*0.01;var e=Math.max(this.filterManager.effectElements[7].p.v,this.filterManager.effectElements[8].p.v)*0.01;var l=path.getTotalLength();dasharrayValue='0 0 0 '+l*s+' ';var lineLength=l*(e-s);var segment=1+this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v*0.01;var units=Math.floor(lineLength/segment);var j;for(j=0;j<units;j+=1){dasharrayValue+='1 '+this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v*0.01+' ';}dasharrayValue+='0 '+l*10+' 0 0';}else {dasharrayValue='1 '+this.filterManager.effectElements[4].p.v*2*this.filterManager.effectElements[9].p.v*0.01;}path.setAttribute('stroke-dasharray',dasharrayValue);}}}if(forceRender||this.filterManager.effectElements[4].p._mdf){this.pathMasker.setAttribute('stroke-width',this.filterManager.effectElements[4].p.v*2);}if(forceRender||this.filterManager.effectElements[6].p._mdf){this.pathMasker.setAttribute('opacity',this.filterManager.effectElements[6].p.v);}if(this.filterManager.effectElements[10].p.v===1||this.filterManager.effectElements[10].p.v===2){if(forceRender||this.filterManager.effectElements[3].p._mdf){var color=this.filterManager.effectElements[3].p.v;this.pathMasker.setAttribute('stroke','rgb('+bmFloor(color[0]*255)+','+bmFloor(color[1]*255)+','+bmFloor(color[2]*255)+')');}}};function SVGTritoneFilter(filter,filterManager,elem,id){this.filterManager=filterManager;var feColorMatrix=createNS('feColorMatrix');feColorMatrix.setAttribute('type','matrix');feColorMatrix.setAttribute('color-interpolation-filters','linearRGB');feColorMatrix.setAttribute('values','0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');filter.appendChild(feColorMatrix);var feComponentTransfer=createNS('feComponentTransfer');feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');feComponentTransfer.setAttribute('result',id);this.matrixFilter=feComponentTransfer;var feFuncR=createNS('feFuncR');feFuncR.setAttribute('type','table');feComponentTransfer.appendChild(feFuncR);this.feFuncR=feFuncR;var feFuncG=createNS('feFuncG');feFuncG.setAttribute('type','table');feComponentTransfer.appendChild(feFuncG);this.feFuncG=feFuncG;var feFuncB=createNS('feFuncB');feFuncB.setAttribute('type','table');feComponentTransfer.appendChild(feFuncB);this.feFuncB=feFuncB;filter.appendChild(feComponentTransfer);}SVGTritoneFilter.prototype.renderFrame=function(forceRender){if(forceRender||this.filterManager._mdf){var color1=this.filterManager.effectElements[0].p.v;var color2=this.filterManager.effectElements[1].p.v;var color3=this.filterManager.effectElements[2].p.v;var tableR=color3[0]+' '+color2[0]+' '+color1[0];var tableG=color3[1]+' '+color2[1]+' '+color1[1];var tableB=color3[2]+' '+color2[2]+' '+color1[2];this.feFuncR.setAttribute('tableValues',tableR);this.feFuncG.setAttribute('tableValues',tableG);this.feFuncB.setAttribute('tableValues',tableB);}};function SVGProLevelsFilter(filter,filterManager,elem,id){this.filterManager=filterManager;var effectElements=this.filterManager.effectElements;var feComponentTransfer=createNS('feComponentTransfer');// Red
if(effectElements[10].p.k||effectElements[10].p.v!==0||effectElements[11].p.k||effectElements[11].p.v!==1||effectElements[12].p.k||effectElements[12].p.v!==1||effectElements[13].p.k||effectElements[13].p.v!==0||effectElements[14].p.k||effectElements[14].p.v!==1){this.feFuncR=this.createFeFunc('feFuncR',feComponentTransfer);}// Green
if(effectElements[17].p.k||effectElements[17].p.v!==0||effectElements[18].p.k||effectElements[18].p.v!==1||effectElements[19].p.k||effectElements[19].p.v!==1||effectElements[20].p.k||effectElements[20].p.v!==0||effectElements[21].p.k||effectElements[21].p.v!==1){this.feFuncG=this.createFeFunc('feFuncG',feComponentTransfer);}// Blue
if(effectElements[24].p.k||effectElements[24].p.v!==0||effectElements[25].p.k||effectElements[25].p.v!==1||effectElements[26].p.k||effectElements[26].p.v!==1||effectElements[27].p.k||effectElements[27].p.v!==0||effectElements[28].p.k||effectElements[28].p.v!==1){this.feFuncB=this.createFeFunc('feFuncB',feComponentTransfer);}// Alpha
if(effectElements[31].p.k||effectElements[31].p.v!==0||effectElements[32].p.k||effectElements[32].p.v!==1||effectElements[33].p.k||effectElements[33].p.v!==1||effectElements[34].p.k||effectElements[34].p.v!==0||effectElements[35].p.k||effectElements[35].p.v!==1){this.feFuncA=this.createFeFunc('feFuncA',feComponentTransfer);}// RGB
if(this.feFuncR||this.feFuncG||this.feFuncB||this.feFuncA){feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');filter.appendChild(feComponentTransfer);}if(effectElements[3].p.k||effectElements[3].p.v!==0||effectElements[4].p.k||effectElements[4].p.v!==1||effectElements[5].p.k||effectElements[5].p.v!==1||effectElements[6].p.k||effectElements[6].p.v!==0||effectElements[7].p.k||effectElements[7].p.v!==1){feComponentTransfer=createNS('feComponentTransfer');feComponentTransfer.setAttribute('color-interpolation-filters','sRGB');feComponentTransfer.setAttribute('result',id);filter.appendChild(feComponentTransfer);this.feFuncRComposed=this.createFeFunc('feFuncR',feComponentTransfer);this.feFuncGComposed=this.createFeFunc('feFuncG',feComponentTransfer);this.feFuncBComposed=this.createFeFunc('feFuncB',feComponentTransfer);}}SVGProLevelsFilter.prototype.createFeFunc=function(type,feComponentTransfer){var feFunc=createNS(type);feFunc.setAttribute('type','table');feComponentTransfer.appendChild(feFunc);return feFunc;};SVGProLevelsFilter.prototype.getTableValue=function(inputBlack,inputWhite,gamma,outputBlack,outputWhite){var cnt=0;var segments=256;var perc;var min=Math.min(inputBlack,inputWhite);var max=Math.max(inputBlack,inputWhite);var table=Array.call(null,{length:segments});var colorValue;var pos=0;var outputDelta=outputWhite-outputBlack;var inputDelta=inputWhite-inputBlack;while(cnt<=256){perc=cnt/256;if(perc<=min){colorValue=inputDelta<0?outputWhite:outputBlack;}else if(perc>=max){colorValue=inputDelta<0?outputBlack:outputWhite;}else {colorValue=outputBlack+outputDelta*Math.pow((perc-inputBlack)/inputDelta,1/gamma);}table[pos]=colorValue;pos+=1;cnt+=256/(segments-1);}return table.join(' ');};SVGProLevelsFilter.prototype.renderFrame=function(forceRender){if(forceRender||this.filterManager._mdf){var val;var effectElements=this.filterManager.effectElements;if(this.feFuncRComposed&&(forceRender||effectElements[3].p._mdf||effectElements[4].p._mdf||effectElements[5].p._mdf||effectElements[6].p._mdf||effectElements[7].p._mdf)){val=this.getTableValue(effectElements[3].p.v,effectElements[4].p.v,effectElements[5].p.v,effectElements[6].p.v,effectElements[7].p.v);this.feFuncRComposed.setAttribute('tableValues',val);this.feFuncGComposed.setAttribute('tableValues',val);this.feFuncBComposed.setAttribute('tableValues',val);}if(this.feFuncR&&(forceRender||effectElements[10].p._mdf||effectElements[11].p._mdf||effectElements[12].p._mdf||effectElements[13].p._mdf||effectElements[14].p._mdf)){val=this.getTableValue(effectElements[10].p.v,effectElements[11].p.v,effectElements[12].p.v,effectElements[13].p.v,effectElements[14].p.v);this.feFuncR.setAttribute('tableValues',val);}if(this.feFuncG&&(forceRender||effectElements[17].p._mdf||effectElements[18].p._mdf||effectElements[19].p._mdf||effectElements[20].p._mdf||effectElements[21].p._mdf)){val=this.getTableValue(effectElements[17].p.v,effectElements[18].p.v,effectElements[19].p.v,effectElements[20].p.v,effectElements[21].p.v);this.feFuncG.setAttribute('tableValues',val);}if(this.feFuncB&&(forceRender||effectElements[24].p._mdf||effectElements[25].p._mdf||effectElements[26].p._mdf||effectElements[27].p._mdf||effectElements[28].p._mdf)){val=this.getTableValue(effectElements[24].p.v,effectElements[25].p.v,effectElements[26].p.v,effectElements[27].p.v,effectElements[28].p.v);this.feFuncB.setAttribute('tableValues',val);}if(this.feFuncA&&(forceRender||effectElements[31].p._mdf||effectElements[32].p._mdf||effectElements[33].p._mdf||effectElements[34].p._mdf||effectElements[35].p._mdf)){val=this.getTableValue(effectElements[31].p.v,effectElements[32].p.v,effectElements[33].p.v,effectElements[34].p.v,effectElements[35].p.v);this.feFuncA.setAttribute('tableValues',val);}}};function SVGDropShadowEffect(filter,filterManager,elem,id,source){var globalFilterSize=filterManager.container.globalData.renderConfig.filterSize;var filterSize=filterManager.data.fs||globalFilterSize;filter.setAttribute('x',filterSize.x||globalFilterSize.x);filter.setAttribute('y',filterSize.y||globalFilterSize.y);filter.setAttribute('width',filterSize.width||globalFilterSize.width);filter.setAttribute('height',filterSize.height||globalFilterSize.height);this.filterManager=filterManager;var feGaussianBlur=createNS('feGaussianBlur');feGaussianBlur.setAttribute('in','SourceAlpha');feGaussianBlur.setAttribute('result',id+'_drop_shadow_1');feGaussianBlur.setAttribute('stdDeviation','0');this.feGaussianBlur=feGaussianBlur;filter.appendChild(feGaussianBlur);var feOffset=createNS('feOffset');feOffset.setAttribute('dx','25');feOffset.setAttribute('dy','0');feOffset.setAttribute('in',id+'_drop_shadow_1');feOffset.setAttribute('result',id+'_drop_shadow_2');this.feOffset=feOffset;filter.appendChild(feOffset);var feFlood=createNS('feFlood');feFlood.setAttribute('flood-color','#00ff00');feFlood.setAttribute('flood-opacity','1');feFlood.setAttribute('result',id+'_drop_shadow_3');this.feFlood=feFlood;filter.appendChild(feFlood);var feComposite=createNS('feComposite');feComposite.setAttribute('in',id+'_drop_shadow_3');feComposite.setAttribute('in2',id+'_drop_shadow_2');feComposite.setAttribute('operator','in');feComposite.setAttribute('result',id+'_drop_shadow_4');filter.appendChild(feComposite);var feMerge=this.createMergeNode(id,[id+'_drop_shadow_4',source]);filter.appendChild(feMerge);//
}extendPrototype([SVGComposableEffect],SVGDropShadowEffect);SVGDropShadowEffect.prototype.renderFrame=function(forceRender){if(forceRender||this.filterManager._mdf){if(forceRender||this.filterManager.effectElements[4].p._mdf){this.feGaussianBlur.setAttribute('stdDeviation',this.filterManager.effectElements[4].p.v/4);}if(forceRender||this.filterManager.effectElements[0].p._mdf){var col=this.filterManager.effectElements[0].p.v;this.feFlood.setAttribute('flood-color',rgbToHex(Math.round(col[0]*255),Math.round(col[1]*255),Math.round(col[2]*255)));}if(forceRender||this.filterManager.effectElements[1].p._mdf){this.feFlood.setAttribute('flood-opacity',this.filterManager.effectElements[1].p.v/255);}if(forceRender||this.filterManager.effectElements[2].p._mdf||this.filterManager.effectElements[3].p._mdf){var distance=this.filterManager.effectElements[3].p.v;var angle=(this.filterManager.effectElements[2].p.v-90)*degToRads;var x=distance*Math.cos(angle);var y=distance*Math.sin(angle);this.feOffset.setAttribute('dx',x);this.feOffset.setAttribute('dy',y);}}};var _svgMatteSymbols=[];function SVGMatte3Effect(filterElem,filterManager,elem){this.initialized=false;this.filterManager=filterManager;this.filterElem=filterElem;this.elem=elem;elem.matteElement=createNS('g');elem.matteElement.appendChild(elem.layerElement);elem.matteElement.appendChild(elem.transformedElement);elem.baseElement=elem.matteElement;}SVGMatte3Effect.prototype.findSymbol=function(mask){var i=0;var len=_svgMatteSymbols.length;while(i<len){if(_svgMatteSymbols[i]===mask){return _svgMatteSymbols[i];}i+=1;}return null;};SVGMatte3Effect.prototype.replaceInParent=function(mask,symbolId){var parentNode=mask.layerElement.parentNode;if(!parentNode){return;}var children=parentNode.children;var i=0;var len=children.length;while(i<len){if(children[i]===mask.layerElement){break;}i+=1;}var nextChild;if(i<=len-2){nextChild=children[i+1];}var useElem=createNS('use');useElem.setAttribute('href','#'+symbolId);if(nextChild){parentNode.insertBefore(useElem,nextChild);}else {parentNode.appendChild(useElem);}};SVGMatte3Effect.prototype.setElementAsMask=function(elem,mask){if(!this.findSymbol(mask)){var symbolId=createElementID();var masker=createNS('mask');masker.setAttribute('id',mask.layerId);masker.setAttribute('mask-type','alpha');_svgMatteSymbols.push(mask);var defs=elem.globalData.defs;defs.appendChild(masker);var symbol=createNS('symbol');symbol.setAttribute('id',symbolId);this.replaceInParent(mask,symbolId);symbol.appendChild(mask.layerElement);defs.appendChild(symbol);var useElem=createNS('use');useElem.setAttribute('href','#'+symbolId);masker.appendChild(useElem);mask.data.hd=false;mask.show();}elem.setMatte(mask.layerId);};SVGMatte3Effect.prototype.initialize=function(){var ind=this.filterManager.effectElements[0].p.v;var elements=this.elem.comp.elements;var i=0;var len=elements.length;while(i<len){if(elements[i]&&elements[i].data.ind===ind){this.setElementAsMask(this.elem,elements[i]);}i+=1;}this.initialized=true;};SVGMatte3Effect.prototype.renderFrame=function(){if(!this.initialized){this.initialize();}};function SVGGaussianBlurEffect(filter,filterManager,elem,id){// Outset the filter region by 100% on all sides to accommodate blur expansion.
filter.setAttribute('x','-100%');filter.setAttribute('y','-100%');filter.setAttribute('width','300%');filter.setAttribute('height','300%');this.filterManager=filterManager;var feGaussianBlur=createNS('feGaussianBlur');feGaussianBlur.setAttribute('result',id);filter.appendChild(feGaussianBlur);this.feGaussianBlur=feGaussianBlur;}SVGGaussianBlurEffect.prototype.renderFrame=function(forceRender){if(forceRender||this.filterManager._mdf){// Empirical value, matching AE's blur appearance.
var kBlurrinessToSigma=0.3;var sigma=this.filterManager.effectElements[0].p.v*kBlurrinessToSigma;// Dimensions mapping:
//
//   1 -> horizontal & vertical
//   2 -> horizontal only
//   3 -> vertical only
//
var dimensions=this.filterManager.effectElements[1].p.v;var sigmaX=dimensions==3?0:sigma;// eslint-disable-line eqeqeq
var sigmaY=dimensions==2?0:sigma;// eslint-disable-line eqeqeq
this.feGaussianBlur.setAttribute('stdDeviation',sigmaX+' '+sigmaY);// Repeat edges mapping:
//
//   0 -> off -> duplicate
//   1 -> on  -> wrap
var edgeMode=this.filterManager.effectElements[2].p.v==1?'wrap':'duplicate';// eslint-disable-line eqeqeq
this.feGaussianBlur.setAttribute('edgeMode',edgeMode);}};function TransformEffect(){}TransformEffect.prototype.init=function(effectsManager){this.effectsManager=effectsManager;this.type=effectTypes.TRANSFORM_EFFECT;this.matrix=new Matrix();this.opacity=-1;this._mdf=false;this._opMdf=false;};TransformEffect.prototype.renderFrame=function(forceFrame){this._opMdf=false;this._mdf=false;if(forceFrame||this.effectsManager._mdf){var effectElements=this.effectsManager.effectElements;var anchor=effectElements[0].p.v;var position=effectElements[1].p.v;var isUniformScale=effectElements[2].p.v===1;var scaleHeight=effectElements[3].p.v;var scaleWidth=isUniformScale?scaleHeight:effectElements[4].p.v;var skew=effectElements[5].p.v;var skewAxis=effectElements[6].p.v;var rotation=effectElements[7].p.v;this.matrix.reset();this.matrix.translate(-anchor[0],-anchor[1],anchor[2]);this.matrix.scale(scaleWidth*0.01,scaleHeight*0.01,1);this.matrix.rotate(-rotation*degToRads);this.matrix.skewFromAxis(-skew*degToRads,(skewAxis+90)*degToRads);this.matrix.translate(position[0],position[1],0);this._mdf=true;if(this.opacity!==effectElements[8].p.v){this.opacity=effectElements[8].p.v;this._opMdf=true;}}};function SVGTransformEffect(_,filterManager){this.init(filterManager);}extendPrototype([TransformEffect],SVGTransformEffect);function CVTransformEffect(effectsManager){this.init(effectsManager);}extendPrototype([TransformEffect],CVTransformEffect);registerRenderer('canvas',CanvasRenderer);registerRenderer('html',HybridRenderer);registerRenderer('svg',SVGRenderer);// Registering shape modifiers
ShapeModifiers.registerModifier('tm',TrimModifier);ShapeModifiers.registerModifier('pb',PuckerAndBloatModifier);ShapeModifiers.registerModifier('rp',RepeaterModifier);ShapeModifiers.registerModifier('rd',RoundCornersModifier);ShapeModifiers.registerModifier('zz',ZigZagModifier);ShapeModifiers.registerModifier('op',OffsetPathModifier);// Registering expression plugin
setExpressionsPlugin(Expressions);setExpressionInterfaces(getInterface);initialize$1();initialize();// Registering svg effects
registerEffect$1(20,SVGTintFilter,true);registerEffect$1(21,SVGFillFilter,true);registerEffect$1(22,SVGStrokeEffect,false);registerEffect$1(23,SVGTritoneFilter,true);registerEffect$1(24,SVGProLevelsFilter,true);registerEffect$1(25,SVGDropShadowEffect,true);registerEffect$1(28,SVGMatte3Effect,false);registerEffect$1(29,SVGGaussianBlurEffect,true);registerEffect$1(35,SVGTransformEffect,false);registerEffect(35,CVTransformEffect);return lottie;});})(lottie,lottie.exports);var lottieExports=lottie.exports;var bodymovin = /*@__PURE__*/getDefaultExportFromCjs(lottieExports);

class Lottie extends Rect {
  constructor(params) {
    super(params), this.type = "lottie", this.renderNextFrame = () => {
      this.stage.renderNextFrame();
    }, this.numberType = LOTTIE_NUMBER_TYPE, this.initLottieWeb(this.attribute.data);
  }
  setAttributes(params, forceUpdateTag, context) {
    return params.data && this.initLottieWeb(params.data), super.setAttributes(params, forceUpdateTag, context);
  }
  setAttribute(key, value, forceUpdateTag, context) {
    return "data" === key && this.initLottieWeb(value), super.setAttribute(key, value, forceUpdateTag, context);
  }
  getGraphicTheme() {
    return getTheme(this).rect;
  }
  initLottieWeb(data) {
    if ("browser" !== vglobal.env) return;
    this.lottieInstance && this.releaseLottieInstance();
    const theme = this.getGraphicTheme(),
      {
        width = theme.width,
        height = theme.height
      } = this.attribute,
      canvas = vglobal.createCanvas({
        width: width,
        height: height,
        dpr: vglobal.devicePixelRatio
      }),
      params = {
        rendererSettings: {
          context: canvas.getContext("2d")
        },
        animType: "canvas",
        loop: !0
      };
    "string" == typeof data ? params.path = data : params.animationData = data, this.lottieInstance = bodymovin.loadAnimation(params), this.canvas = canvas, this.lottieInstance.addEventListener("drawnFrame", this.renderNextFrame);
  }
  release() {
    super.release(), this.releaseLottieInstance();
  }
  releaseLottieInstance() {
    this.lottieInstance.removeEventListener("drawnFrame", this.renderNextFrame), this.lottieInstance.destroy(), this.lottieInstance = null;
  }
}
Lottie.NOWORK_ANIMATE_ATTR = NOWORK_ANIMATE_ATTR;
function createLottie(attributes) {
  return new Lottie(attributes);
}

var __decorate$1 = undefined && undefined.__decorate || function (decorators, target, key, desc) {
    var d,
      c = arguments.length,
      r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
    if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  },
  __metadata = undefined && undefined.__metadata || function (k, v) {
    if ("object" == typeof Reflect && "function" == typeof Reflect.metadata) return Reflect.metadata(k, v);
  },
  __param = undefined && undefined.__param || function (paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  };
let DefaultCanvasLottiePicker = class extends RectPickerBase {
  constructor(canvasRenderer) {
    super(), this.canvasRenderer = canvasRenderer;
  }
};
DefaultCanvasLottiePicker = __decorate$1([injectable(), __param(0, inject(RectRender)), __metadata("design:paramtypes", [Object])], DefaultCanvasLottiePicker);

let loadLottiePick = !1;
const lottieCanvasPickModule = new ContainerModule((bind, unbind, isBound, rebind) => {
  loadLottiePick || (loadLottiePick = !0, bind(CanvasLottiePicker).to(DefaultCanvasLottiePicker).inSingletonScope(), bind(CanvasPickerContribution).toService(CanvasLottiePicker));
});

var __decorate = undefined && undefined.__decorate || function (decorators, target, key, desc) {
  var d,
    c = arguments.length,
    r = c < 3 ? target : null === desc ? desc = Object.getOwnPropertyDescriptor(target, key) : desc;
  if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) (d = decorators[i]) && (r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r);
  return c > 3 && r && Object.defineProperty(target, key, r), r;
};
let DefaultCanvasLottieRender = class extends DefaultCanvasRectRender {
  constructor() {
    super(...arguments), this.numberType = LOTTIE_NUMBER_TYPE;
  }
  drawShape(lottie, context, x, y, drawContext, params, fillCb, strokeCb) {
    const _fillCb = fillCb || (() => this._drawShape.call(this, lottie, context, x, y, drawContext, params));
    super.drawShape(lottie, context, x, y, drawContext, params, _fillCb, strokeCb);
  }
  _drawShape(lottie, context, x, y, drawContext, params) {
    var _a;
    const lottieAttribute = null !== (_a = this.tempTheme) && void 0 !== _a ? _a : getTheme(lottie, null == params ? void 0 : params.theme).rect,
      {
        x: originX = lottieAttribute.x,
        y: originY = lottieAttribute.y
      } = lottie.attribute;
    context.setCommonStyle(lottie, lottie.attribute, originX - x, originY - y, lottieAttribute);
    const canvas = lottie.canvas;
    if (canvas) {
      const pattern = context.createPattern(canvas, "no-repeat"),
        dpr = context.dpr;
      pattern.setTransform && pattern.setTransform(new DOMMatrix([1 / dpr, 0, 0, 1 / dpr, x, y])), context.fillStyle = pattern;
    }
    context.fill();
  }
};
DefaultCanvasLottieRender = __decorate([injectable()], DefaultCanvasLottieRender);

let loadLottieModule = !1;
const lottieModule = new ContainerModule(bind => {
  loadLottieModule || (loadLottieModule = !0, bind(DefaultCanvasLottieRender).toSelf().inSingletonScope(), bind(GraphicRender).toService(DefaultCanvasLottieRender));
});

const browser = isBrowserEnv();

function _registerArc() {
  _registerArc.__loaded || (_registerArc.__loaded = !0, registerArcGraphic(), container.load(arcModule), container.load(browser ? arcCanvasPickModule : arcMathPickModule));
}
_registerArc.__loaded = !1;
const registerArc = _registerArc;

function _registerArc3d() {
  _registerArc3d.__loaded || (_registerArc3d.__loaded = !0, registerArc3dGraphic(), registerDirectionalLight(), registerOrthoCamera(), container.load(arc3dModule), container.load(arc3dCanvasPickModule));
}
_registerArc3d.__loaded = !1;
const registerArc3d = _registerArc3d;

function _registerArea() {
  _registerArea.__loaded || (_registerArea.__loaded = !0, registerAreaGraphic(), container.load(areaModule), container.load(browser ? areaCanvasPickModule : areaMathPickModule));
}
_registerArea.__loaded = !1;
const registerArea = _registerArea;

function _registerCircle() {
  _registerCircle.__loaded || (_registerCircle.__loaded = !0, registerCircleGraphic(), container.load(circleModule), container.load(browser ? circleCanvasPickModule : circleMathPickModule));
}
_registerCircle.__loaded = !1;
const registerCircle = _registerCircle;

function _registerGlyph() {
  _registerGlyph.__loaded || (_registerGlyph.__loaded = !0, registerGlyphGraphic(), container.load(glyphModule), container.load(browser ? glyphCanvasPickModule : glyphMathPickModule));
}
_registerGlyph.__loaded = !1;
const registerGlyph = _registerGlyph;

function _registerGroup() {
  _registerGroup.__loaded || (_registerGroup.__loaded = !0, registerGroupGraphic());
}
_registerGroup.__loaded = !1;
const registerGroup = _registerGroup;

function _registerImage() {
  _registerImage.__loaded || (_registerImage.__loaded = !0, registerImageGraphic(), container.load(imageModule), container.load(browser ? imageCanvasPickModule : imageMathPickModule));
}
_registerImage.__loaded = !1;
const registerImage = _registerImage;

function _registerLine() {
  _registerLine.__loaded || (_registerLine.__loaded = !0, registerLineGraphic(), container.load(lineModule), container.load(browser ? lineCanvasPickModule : lineMathPickModule));
}
_registerLine.__loaded = !1;
const registerLine = _registerLine;

function _registerPath() {
  _registerPath.__loaded || (_registerPath.__loaded = !0, registerPathGraphic(), container.load(pathModule), container.load(browser ? pathCanvasPickModule : pathMathPickModule));
}
_registerPath.__loaded = !1;
const registerPath = _registerPath;

function _registerPolygon() {
  _registerPolygon.__loaded || (_registerPolygon.__loaded = !0, registerPolygonGraphic(), container.load(polygonModule), container.load(browser ? polygonCanvasPickModule : polygonMathPickModule));
}
_registerPolygon.__loaded = !1;
const registerPolygon = _registerPolygon;

function _registerPyramid3d() {
  _registerPyramid3d.__loaded || (_registerPyramid3d.__loaded = !0, registerPyramid3dGraphic(), registerDirectionalLight(), registerOrthoCamera(), container.load(pyramid3dModule), container.load(pyramid3dCanvasPickModule));
}
_registerPyramid3d.__loaded = !1;
const registerPyramid3d = _registerPyramid3d;

function _registerRect() {
  _registerRect.__loaded || (_registerRect.__loaded = !0, registerRectGraphic(), container.load(rectModule), container.load(browser ? rectCanvasPickModule : rectMathPickModule));
}
_registerRect.__loaded = !1;
const registerRect = _registerRect;

function _registerRect3d() {
  _registerRect3d.__loaded || (_registerRect3d.__loaded = !0, registerRect3dGraphic(), container.load(rect3dModule), container.load(rect3dCanvasPickModule));
}
_registerRect3d.__loaded = !1;
const registerRect3d = _registerRect3d;

function _registerRichtext() {
  _registerRichtext.__loaded || (_registerRichtext.__loaded = !0, registerRichtextGraphic(), container.load(richtextModule), container.load(browser ? richtextCanvasPickModule : richTextMathPickModule));
}
_registerRichtext.__loaded = !1;
const registerRichtext = _registerRichtext;

function _registerShadowRoot() {
  _registerShadowRoot.__loaded || (_registerShadowRoot.__loaded = !0, registerShadowRootGraphic());
}
_registerShadowRoot.__loaded = !1;
const registerShadowRoot = _registerShadowRoot;

function _registerSymbol() {
  _registerSymbol.__loaded || (_registerSymbol.__loaded = !0, registerSymbolGraphic(), container.load(symbolModule), container.load(browser ? symbolCanvasPickModule : symbolMathPickModule));
}
_registerSymbol.__loaded = !1;
const registerSymbol = _registerSymbol;

function _registerText() {
  _registerText.__loaded || (_registerText.__loaded = !0, registerTextGraphic(), container.load(textModule), container.load(browser ? textCanvasPickModule : textMathPickModule));
}
_registerText.__loaded = !1;
const registerText = _registerText;

function _registerWrapText() {
  _registerWrapText.__loaded || (_registerWrapText.__loaded = !0, registerWrapTextGraphic());
}
_registerWrapText.__loaded = !1;
const registerWrapText = _registerWrapText;

function pseudoRandom(n) {
  let seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  let hash = 3735928559 ^ seed;
  return hash = (2654435769 ^ hash) + (hash << 6) + (hash >> 2), hash = 3432918353 * (hash ^ n), hash = hash << 15 | hash >>> 17, hash ^= hash << 25, hash += hash << 9, hash ^= hash >> 4, hash ^= hash << 18, hash |= 1, (hash >>> 0) % 2147483647 / 2147483647;
}
function randomOpacity(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const targetRandomValue = 2 * pseudoRandom(row * columnCount + column) * Math.PI,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI + targetRandomValue) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function columnLeftToRight(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const delay = column / columnCount,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function columnRightToLeft(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const delay = (columnCount - 1 - column) / columnCount,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rowTopToBottom(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const delay = row / rowCount,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rowBottomToTop(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const delay = (rowCount - 1 - row) / rowCount,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function diagonalCenterToEdge(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    centerCol = columnCount / 2,
    distance = Math.sqrt(Math.pow((row - centerRow) / rowCount, 2) + Math.pow((column - centerCol) / columnCount, 2)),
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function diagonalTopLeftToBottomRight(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const delay = (row / rowCount + column / columnCount) / 2,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rotationScan(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    centerCol = columnCount / 2,
    angle = Math.atan2(row - centerRow, column - centerCol),
    delay = (angle < 0 ? angle + 2 * Math.PI : angle) / (2 * Math.PI),
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rippleEffect(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    centerCol = columnCount / 2,
    normalizedDistance = Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(column - centerCol, 2)) / Math.sqrt(Math.pow(rowCount / 2, 2) + Math.pow(columnCount / 2, 2)),
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI * 3 - 2 * normalizedDistance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function snakeWave(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const delay = (row + column) % (rowCount + columnCount) / (rowCount + columnCount),
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 4 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function alternatingWave(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const rowPhase = row / rowCount,
    colPhase = column / columnCount,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * rowPhase * Math.PI) * Math.sin(2 * ratio * Math.PI - 2 * colPhase * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function spiralEffect(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    centerCol = columnCount / 2,
    distance = Math.sqrt(Math.pow(row - centerRow, 2) + Math.pow(column - centerCol, 2)),
    angle = Math.atan2(row - centerRow, column - centerCol),
    delay = (distance / Math.sqrt(Math.pow(rowCount / 2, 2) + Math.pow(columnCount / 2, 2)) + angle / (2 * Math.PI)) / 2,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 4 * delay * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function columnCenterToEdge(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerCol = columnCount / 2,
    distance = Math.abs(column - centerCol) / centerCol,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function columnEdgeToCenter(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerCol = columnCount / 2,
    distance = 1 - Math.abs(column - centerCol) / centerCol,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rowCenterToEdge(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    distance = Math.abs(row - centerRow) / centerRow,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function rowEdgeToCenter(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    distance = 1 - Math.abs(row - centerRow) / centerRow,
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * distance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function cornerToCenter(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    centerCol = columnCount / 2,
    distance = Math.sqrt(Math.pow((row - centerRow) / centerRow, 2) + Math.pow((column - centerCol) / centerCol, 2)),
    normalizedDistance = Math.min(distance, 1),
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * normalizedDistance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function centerToCorner(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    centerCol = columnCount / 2,
    distance = Math.sqrt(Math.pow((row - centerRow) / centerRow, 2) + Math.pow((column - centerCol) / centerCol, 2)),
    normalizedDistance = 1 - Math.min(distance, 1),
    _r = minRatio + amplitude * (Math.sin(2 * ratio * Math.PI - 2 * normalizedDistance * Math.PI) + 1) / 2;
  return Math.min(1, Math.max(0, _r));
}
function pulseWave(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const centerRow = rowCount / 2,
    centerCol = columnCount / 2,
    distance = Math.sqrt(Math.pow((row - centerRow) / centerRow, 2) + Math.pow((column - centerCol) / centerCol, 2)),
    normalizedDistance = Math.min(distance, 1),
    wavePhase = 2 * ratio * Math.PI * 3,
    decay = Math.max(0, 1 - normalizedDistance),
    _r = minRatio + amplitude * ((Math.sin(wavePhase - 4 * normalizedDistance * Math.PI) + 1) / 2) * (.7 * decay + .3);
  return Math.min(1, Math.max(0, _r));
}
function particleEffect(ctx, row, column, rowCount, columnCount, ratio, graphic) {
  let minRatio = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
  let amplitude = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 1;
  const index = row * columnCount + column,
    phase = 2 * pseudoRandom(index, 0) * Math.PI,
    speed = .5 * pseudoRandom(index, 1) + .5,
    direction = 2 * pseudoRandom(index, 2) * Math.PI,
    centerRow = rowCount / 2,
    centerCol = columnCount / 2,
    distance = Math.sqrt(Math.pow((row - centerRow) / centerRow, 2) + Math.pow((column - centerCol) / centerCol, 2)),
    normalizedDistance = Math.min(distance, 1),
    scatterRatio = (ratio - .4) / .6,
    movement = Math.sin(scatterRatio * speed * 8 * Math.PI + phase + direction * scatterRatio),
    distanceEffect = Math.cos(normalizedDistance * Math.PI + scatterRatio * Math.PI),
    _r = minRatio + amplitude * ((movement + 1) / 2 * Math.max(0, 1 - 1.2 * scatterRatio) * (.3 + .7 * distanceEffect));
  return Math.min(1, Math.max(0, _r));
}

const roughModule = _roughModule;

const version = "0.22.6";
preLoadAllModule();
if (isBrowserEnv()) {
    loadBrowserEnv(container);
}
else if (isNodeEnv()) {
    loadNodeEnv(container);
}
registerArc();
registerArc3d();
registerArea();
registerCircle();
registerGlyph();
registerGroup();
registerImage();
registerLine();
registerPath();
registerPolygon();
registerPyramid3d();
registerRect();
registerRect3d();
registerRichtext();
registerShadowRoot();
registerSymbol();
registerText();
registerWrapText();
registerFlexLayoutPlugin();
registerViewTransform3dPlugin();
registerHtmlAttributePlugin();
registerReactAttributePlugin();
registerDirectionalLight();
registerOrthoCamera();

export { ACustomAnimate, ARC3D_NUMBER_TYPE, ARC_NUMBER_TYPE, AREA_NUMBER_TYPE, AbstractGraphicRender, Animate, AnimateGroup, AnimateGroup1, AnimateMode, AnimateStatus, AnimateStepType, Application, Arc, Arc3d, Arc3dRender, ArcRender, ArcRenderContribution, Area, AreaRender, AreaRenderContribution, AttributeAnimate, AttributeUpdateType, AutoEnablePlugins, BaseCanvas, BaseEnvContribution, BaseRender, BaseRenderContributionTime, BaseWindowHandlerContribution, Basis, BeforeRenderConstribution, BoundsContext, BoundsPicker, BrowserEnvContribution, CIRCLE_NUMBER_TYPE, Canvas3DDrawItemInterceptor, Canvas3DPickItemInterceptor, CanvasArc3dPicker, CanvasArcPicker, CanvasAreaPicker, CanvasCirclePicker, CanvasFactory, CanvasGifImagePicker, CanvasGlyphPicker, CanvasGroupPicker, CanvasImagePicker, CanvasLinePicker, CanvasLottiePicker, CanvasPathPicker, CanvasPickerContribution, CanvasPolygonPicker, CanvasPyramid3dPicker, CanvasRect3dPicker, CanvasRectPicker, CanvasRichTextPicker, CanvasSymbolPicker, CanvasTextLayout, CanvasTextPicker, CbAnimate, Circle, CircleRender, CircleRenderContribution, ClipAngleAnimate, ClipDirectionAnimate, ClipGraphicAnimate, ClipRadiusAnimate, ColorInterpolate, ColorStore, ColorType, CommonDrawItemInterceptorContribution, CommonRenderContribution, Container, ContainerModule, Context2dFactory, ContributionProvider, CurveContext, CurveTypeEnum, CustomEvent, CustomPath2D, CustomSymbolClass, DEFAULT_TEXT_FONT_FAMILY, DebugDrawItemInterceptorContribution, DefaultArcAllocate, DefaultArcAttribute, DefaultArcRenderContribution, DefaultAreaAllocate, DefaultAreaAttribute, DefaultAreaTextureRenderContribution, DefaultAttribute, DefaultBaseBackgroundRenderContribution, DefaultBaseClipRenderAfterContribution, DefaultBaseClipRenderBeforeContribution, DefaultBaseInteractiveRenderContribution, DefaultBaseTextureRenderContribution, DefaultCanvasAllocate, DefaultCanvasArcRender, DefaultCanvasAreaRender, DefaultCanvasCircleRender, DefaultCanvasGroupRender, DefaultCanvasImageRender, DefaultCanvasLineRender, DefaultCanvasPathRender, DefaultCanvasPolygonRender, DefaultCanvasRectRender, DefaultCanvasSymbolRender, DefaultCanvasTextRender, DefaultCircleAllocate, DefaultCircleAttribute, DefaultCircleRenderContribution, DefaultConnectAttribute, DefaultDebugAttribute, DefaultFillStyle, DefaultGlobal, DefaultGlobalPickerService, DefaultGlyphAttribute, DefaultGraphicAllocate, DefaultGraphicMemoryManager, DefaultGraphicService, DefaultGraphicUtil, DefaultGroupAttribute, DefaultGroupBackgroundRenderContribution, DefaultImageAttribute, DefaultImageRenderContribution, DefaultLayerService, DefaultLayout, DefaultLineAllocate, DefaultLineAttribute, DefaultMat4Allocate, DefaultMatrixAllocate, DefaultMorphingAnimateConfig, DefaultPathAllocate, DefaultPathAttribute, DefaultPickService, DefaultPickStyle, DefaultPolygonAttribute, DefaultRect3dAttribute, DefaultRectAllocate, DefaultRectAttribute, DefaultRectRenderContribution, DefaultRenderService, DefaultRichTextAttribute, DefaultRichTextIconAttribute, DefaultStateAnimateConfig, DefaultStrokeStyle, DefaultStyle, DefaultSymbolAllocate, DefaultSymbolAttribute, DefaultSymbolClipRangeStrokeRenderContribution, DefaultSymbolRenderContribution, DefaultTextAllocate, DefaultTextAttribute, DefaultTextMeasureContribution, DefaultTextStyle, DefaultTicker, DefaultTimeline, DefaultTransform, DefaultTransformUtil, DefaultWindow, Direction$1 as Direction, DirectionalLight, DragNDrop, DrawContribution, DrawItemInterceptor, DynamicLayerHandlerContribution, Easing, Edge, EditModule, EmptyContext2d, EnvContribution, EventManager, EventSystem, EventTarget, FORMAT_ALL_TEXT_COMMAND, FORMAT_ELEMENT_COMMAND, FORMAT_TEXT_COMMAND, Factory, FadeInPlus, FederatedEvent, FederatedMouseEvent, FederatedPointerEvent, FederatedWheelEvent, FlexLayoutPlugin, Fragment, GLYPH_NUMBER_TYPE, GRAPHIC_UPDATE_TAG_KEY, GROUP_NUMBER_TYPE, Generator, Gesture, GifImage, GlobalPickerService, Glyph, GlyphRender, Graphic, GraphicAnimate, GraphicCreator$1 as GraphicCreator, GraphicPicker, GraphicRender, GraphicService, GraphicUtil, Group, GroupFadeIn, GroupFadeOut, GroupRender, GroupRenderContribution, GroupUpdateAABBBoundsMode, HtmlAttributePlugin, IContainPointMode, IMAGE_NUMBER_TYPE, Image$1 as Image, ImageRender, ImageRenderContribution, IncreaseCount, IncrementalDrawContribution, InputText, InteractiveDrawItemInterceptorContribution, InteractivePickItemInterceptorContribution, InteractiveSubRenderContribution, LINE_NUMBER_TYPE, Layer, LayerService, Line$1 as Line, LineRender, Linear, LinearClosed, Lottie, ManualTickHandler, ManualTicker, Mat4Allocate, MathArcPicker, MathAreaPicker, MathCirclePicker, MathGlyphPicker, MathImagePicker, MathLinePicker, MathPathPicker, MathPickerContribution, MathPolygonPicker, MathRectPicker, MathSymbolPicker, MathTextPicker, MatrixAllocate, MeasureModeEnum, Meteor, MonotoneX, MonotoneY, MorphingPath, MotionPath, MultiToOneMorphingPath, NOWORK_ANIMATE_ATTR, Node, OrthoCamera, PATH_NUMBER_TYPE, POLYGON_NUMBER_TYPE, PURE_STYLE_KEY, PYRAMID3D_NUMBER_TYPE, Path, PathRender, PathRenderContribution, PickItemInterceptor, PickServiceInterceptor, PickerService, PluginService, Polygon, PolygonRender, PolygonRenderContribution, Pyramid3d, Pyramid3dRender, RAFTickHandler, REACT_TO_CANOPUS_EVENTS, REACT_TO_CANOPUS_EVENTS_LIST, RECT3D_NUMBER_TYPE, RECT_NUMBER_TYPE, RICHTEXT_NUMBER_TYPE, RafBasedSTO, ReactAttributePlugin, Rect, Rect3DRender, Rect3d, RectRender, RectRenderContribution, ReflectSegContext, RenderSelector, RenderService, ResourceLoader, RichText, RichTextEditPlugin, RichTextRender, RotateBySphereAnimate, SVG_ATTRIBUTE_MAP, SVG_ATTRIBUTE_MAP_KEYS, SVG_PARSE_ATTRIBUTE_MAP, SVG_PARSE_ATTRIBUTE_MAP_KEYS, SYMBOL_NUMBER_TYPE, SegContext, ShadowPickServiceInterceptorContribution, ShadowRoot, ShadowRootDrawItemInterceptorContribution, ShadowRootPickItemInterceptorContribution, SplitRectAfterRenderContribution, SplitRectBeforeRenderContribution, Stage, StaticLayerHandlerContribution, Step$1 as Step, StreamLight, SubAnimate, Symbol$1 as Symbol, SymbolRender, SymbolRenderContribution, TEXT_NUMBER_TYPE, TagPointsUpdate, Text, TextDirection, TextMeasureContribution, TextRender, TextRenderContribution, Theme, TimeOutTickHandler, TransformUtil, UpdateTag, VArc, VArc3d, VArea, VCircle, VGlobal, VGlyph, VGroup, VImage, VLine, VPath, VPolygon, VPyramid3d, VRect, VRect3d, VRichText, VSymbol, VText, VWindow, ViewTransform3dPlugin, VirtualLayerHandlerContribution, WILDCARD, WindowHandlerContribution, WrapText, XMLParser, _calculateLineHeight, _interpolateColor, _registerArc, addArcToBezierPath$1 as addArcToBezierPath, addAttributeToPrototype, alignBezierCurves, alignSubpath, alternatingWave, application, applyTransformOnBezierCurves, arc3dCanvasPickModule, arc3dModule, arcCanvasPickModule, arcMathPickModule, arcModule, areaCanvasPickModule, areaMathPickModule, areaModule, bezier, bezierCurversToPath, binarySplitPolygon, bindContributionProvider, bindContributionProviderNoSingletonScope, boundStroke, browserEnvModule, builtInSymbolStrMap, builtinSymbols, builtinSymbolsMap, calcLineCache, calculateArcCornerRadius, calculateLineHeight, canvasAllocate, centerToCorner, centroidOfSubpath, circleBounds, circleCanvasPickModule, circleMathPickModule, circleModule, clock, cloneGraphic, colorEqual, colorStringInterpolationToStr, columnCenterToEdge, columnEdgeToCenter, columnLeftToRight, columnRightToLeft, container, cornerTangents, cornerToCenter, createArc, createArc3d, createArea, createCircle, createColor, createConicalGradient, createGifImage, createGlyph, createGroup, createImage, createImageElement$1 as createImageElement, createLine, createLottie, createMat4, createPath, createPolygon, createPyramid3d, createRect, createRect3d, createRectPath, createRichText, createShadowRoot, createStage, createSymbol, createText, createWrapText, cubicCalc, cubicLength, cubicPointAt, cubicSubdivide, decodeReactDom, defaultArcAllocate, defaultArcBackgroundRenderContribution, defaultArcRenderContribution, defaultArcTextureRenderContribution, defaultAreaAllocate, defaultBaseBackgroundRenderContribution, defaultBaseClipRenderAfterContribution, defaultBaseClipRenderBeforeContribution, defaultBaseTextureRenderContribution, defaultCircleAllocate, defaultCircleBackgroundRenderContribution, defaultCircleRenderContribution, defaultCircleTextureRenderContribution, defaultGraphicMemoryManager, defaultGroupBackgroundRenderContribution, defaultImageBackgroundRenderContribution, defaultImageRenderContribution, defaultLineAllocate, defaultPathAllocate, defaultRectAllocate, defaultRectBackgroundRenderContribution, defaultRectRenderContribution, defaultRectTextureRenderContribution, defaultSymbolAllocate, defaultSymbolBackgroundRenderContribution, defaultSymbolClipRangeStrokeRenderContribution, defaultSymbolRenderContribution, defaultSymbolTextureRenderContribution, defaultTextAllocate, defaultTicker, defaultTimeline, diagonalCenterToEdge, diagonalTopLeftToBottomRight, drawArc, drawArcPath$1 as drawArcPath, drawAreaSegments, drawIncrementalAreaSegments, drawIncrementalSegments, drawSegments, enumCommandMap, feishuEnvModule, fillVisible, findBestMorphingRotation, findConfigIndexByCursorIdx, findCursorIdxByConfigIndex, findNextGraphic, flatten_simplify, foreach, foreachAsync, genBasisSegments, genBasisTypeSegments, genLinearClosedSegments, genLinearClosedTypeSegments, genLinearSegments, genLinearTypeSegments, genMonotoneXSegments, genMonotoneXTypeSegments, genMonotoneYSegments, genMonotoneYTypeSegments, genNumberType, genStepSegments, genStepTypeSegments, generatorPathEasingFunc, getAttributeFromDefaultAttrList, getConicGradientAt, getCurrentEnv, getDefaultCharacterConfig, getExtraModelMatrix, getModelMatrix, getRichTextBounds, getScaledStroke, getTextBounds, getTheme, getThemeFromGroup, gifImageCanvasPickModule, gifImageModule, globalTheme, glyphCanvasPickModule, glyphMathPickModule, glyphModule, graphicCreator, graphicService, graphicUtil, harmonyEnvModule, identityMat4, imageCanvasPickModule, imageMathPickModule, imageModule, incrementalAddTo, initAllEnv, initBrowserEnv, initFeishuEnv, initHarmonyEnv, initLynxEnv, initNodeEnv, initTTEnv, initTaroEnv, initWxEnv, inject, injectable, interpolateColor, interpolateGradientConicalColor, interpolateGradientLinearColor, interpolateGradientRadialColor, interpolatePureColorArray, intersect, isBrowserEnv, isNodeEnv, isSvg, isTransformKey, isXML, jsx, layerService, lineCanvasPickModule, lineMathPickModule, lineModule, loadAllEnv, loadAllModule, loadBrowserEnv, loadFeishuEnv, loadHarmonyEnv, loadLynxEnv, loadNodeEnv, loadTTEnv, loadTaroEnv, loadWxEnv, lookAt, lottieCanvasPickModule, lottieModule, lynxEnvModule, mat3Tomat4, mat4Allocate, matrixAllocate, morphPath, multiInject, multiToOneMorph, multiplyMat4Mat3, multiplyMat4Mat4, named, newThemeObj, nodeEnvModule, oneToMultiMorph, ortho, parsePadding, parseStroke, parseSvgPath, particleEffect, pathCanvasPickModule, pathMathPickModule, pathModule, pathToBezierCurves, point$3 as point, pointEqual, pointInterpolation, pointInterpolationHighPerformance, pointsEqual, pointsInterpolation, polygonCanvasPickModule, polygonMathPickModule, polygonModule, preLoadAllModule, pulseWave, pyramid3dCanvasPickModule, pyramid3dModule, quadCalc, quadLength, quadPointAt, rafBasedSto, randomOpacity, rect3dCanvasPickModule, rect3dModule, rectCanvasPickModule, rectFillVisible, rectMathPickModule, rectModule, rectStrokeVisible, recursiveCallBinarySplit, registerArc, registerArc3d, registerArc3dGraphic, registerArcGraphic, registerArea, registerAreaGraphic, registerCircle, registerCircleGraphic, registerDirectionalLight, registerFlexLayoutPlugin, registerGlyph, registerGlyphGraphic, registerGroup, registerGroupGraphic, registerHtmlAttributePlugin, registerImage, registerImageGraphic, registerLine, registerLineGraphic, registerOrthoCamera, registerPath, registerPathGraphic, registerPolygon, registerPolygonGraphic, registerPyramid3d, registerPyramid3dGraphic, registerReactAttributePlugin, registerRect, registerRect3d, registerRect3dGraphic, registerRectGraphic, registerRichtext, registerRichtextGraphic, registerShadowRoot, registerShadowRootGraphic, registerSymbol, registerSymbolGraphic, registerText, registerTextGraphic, registerViewTransform3dPlugin, registerWrapText, registerWrapTextGraphic, renderCommandList, rewriteProto, richTextMathPickModule, richtextCanvasPickModule, richtextModule, rippleEffect, rotateX, rotateY, rotateZ, rotationScan, roughModule, rowBottomToTop, rowCenterToEdge, rowEdgeToCenter, rowTopToBottom, runFill, runStroke, scaleMat4, segments, shouldUseMat4, snakeWave, snapLength, spiralEffect, splitArc, splitArea, splitCircle, splitGraphic, splitLine, splitPath, splitPolygon, splitRect, splitToGrids, strCommandMap, strokeVisible, symbolCanvasPickModule, symbolMathPickModule, symbolModule, taroEnvModule, textAttributesToStyle, textCanvasPickModule, textDrawOffsetX, textDrawOffsetY, textLayoutOffsetY, textMathPickModule, textModule, transformKeys, transformMat4, transformUtil, translate, ttEnvModule, version, verticalLayout, vglobal, waitForAllSubLayers, wrapCanvas, wrapContext, wxEnvModule, xul };
